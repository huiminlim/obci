
obc.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000208  00800200  00005f3a  00005fce  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00005f3a  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00001c3c  00800408  00800408  000061d6  2**0
                  ALLOC
  3 .comment      0000005c  00000000  00000000  000061d6  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00006234  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000a40  00000000  00000000  00006274  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000ceba  00000000  00000000  00006cb4  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00003fc7  00000000  00000000  00013b6e  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00007212  00000000  00000000  00017b35  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000027ec  00000000  00000000  0001ed48  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    0000315e  00000000  00000000  00021534  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000bcb0  00000000  00000000  00024692  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000990  00000000  00000000  00030342  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	56 c7       	rjmp	.+3756   	; 0xeae <__ctors_end>
       2:	00 00       	nop
       4:	75 c7       	rjmp	.+3818   	; 0xef0 <__bad_interrupt>
       6:	00 00       	nop
       8:	73 c7       	rjmp	.+3814   	; 0xef0 <__bad_interrupt>
       a:	00 00       	nop
       c:	71 c7       	rjmp	.+3810   	; 0xef0 <__bad_interrupt>
       e:	00 00       	nop
      10:	6f c7       	rjmp	.+3806   	; 0xef0 <__bad_interrupt>
      12:	00 00       	nop
      14:	6d c7       	rjmp	.+3802   	; 0xef0 <__bad_interrupt>
      16:	00 00       	nop
      18:	6b c7       	rjmp	.+3798   	; 0xef0 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	69 c7       	rjmp	.+3794   	; 0xef0 <__bad_interrupt>
      1e:	00 00       	nop
      20:	67 c7       	rjmp	.+3790   	; 0xef0 <__bad_interrupt>
      22:	00 00       	nop
      24:	65 c7       	rjmp	.+3786   	; 0xef0 <__bad_interrupt>
      26:	00 00       	nop
      28:	63 c7       	rjmp	.+3782   	; 0xef0 <__bad_interrupt>
      2a:	00 00       	nop
      2c:	61 c7       	rjmp	.+3778   	; 0xef0 <__bad_interrupt>
      2e:	00 00       	nop
      30:	5f c7       	rjmp	.+3774   	; 0xef0 <__bad_interrupt>
      32:	00 00       	nop
      34:	5d c7       	rjmp	.+3770   	; 0xef0 <__bad_interrupt>
      36:	00 00       	nop
      38:	5b c7       	rjmp	.+3766   	; 0xef0 <__bad_interrupt>
      3a:	00 00       	nop
      3c:	59 c7       	rjmp	.+3762   	; 0xef0 <__bad_interrupt>
      3e:	00 00       	nop
      40:	57 c7       	rjmp	.+3758   	; 0xef0 <__bad_interrupt>
      42:	00 00       	nop
      44:	0c 94 c6 0a 	jmp	0x158c	; 0x158c <__vector_17>
      48:	53 c7       	rjmp	.+3750   	; 0xef0 <__bad_interrupt>
      4a:	00 00       	nop
      4c:	51 c7       	rjmp	.+3746   	; 0xef0 <__bad_interrupt>
      4e:	00 00       	nop
      50:	4f c7       	rjmp	.+3742   	; 0xef0 <__bad_interrupt>
      52:	00 00       	nop
      54:	4d c7       	rjmp	.+3738   	; 0xef0 <__bad_interrupt>
      56:	00 00       	nop
      58:	4b c7       	rjmp	.+3734   	; 0xef0 <__bad_interrupt>
      5a:	00 00       	nop
      5c:	49 c7       	rjmp	.+3730   	; 0xef0 <__bad_interrupt>
      5e:	00 00       	nop
      60:	47 c7       	rjmp	.+3726   	; 0xef0 <__bad_interrupt>
      62:	00 00       	nop
      64:	45 c7       	rjmp	.+3722   	; 0xef0 <__bad_interrupt>
      66:	00 00       	nop
      68:	43 c7       	rjmp	.+3718   	; 0xef0 <__bad_interrupt>
      6a:	00 00       	nop
      6c:	41 c7       	rjmp	.+3714   	; 0xef0 <__bad_interrupt>
      6e:	00 00       	nop
      70:	3f c7       	rjmp	.+3710   	; 0xef0 <__bad_interrupt>
      72:	00 00       	nop
      74:	3d c7       	rjmp	.+3706   	; 0xef0 <__bad_interrupt>
      76:	00 00       	nop
      78:	3b c7       	rjmp	.+3702   	; 0xef0 <__bad_interrupt>
      7a:	00 00       	nop
      7c:	39 c7       	rjmp	.+3698   	; 0xef0 <__bad_interrupt>
      7e:	00 00       	nop
      80:	37 c7       	rjmp	.+3694   	; 0xef0 <__bad_interrupt>
      82:	00 00       	nop
      84:	35 c7       	rjmp	.+3690   	; 0xef0 <__bad_interrupt>
      86:	00 00       	nop
      88:	33 c7       	rjmp	.+3686   	; 0xef0 <__bad_interrupt>
      8a:	00 00       	nop
      8c:	31 c7       	rjmp	.+3682   	; 0xef0 <__bad_interrupt>
      8e:	00 00       	nop
      90:	2f c7       	rjmp	.+3678   	; 0xef0 <__bad_interrupt>
      92:	00 00       	nop
      94:	2d c7       	rjmp	.+3674   	; 0xef0 <__bad_interrupt>
      96:	00 00       	nop
      98:	2b c7       	rjmp	.+3670   	; 0xef0 <__bad_interrupt>
      9a:	00 00       	nop
      9c:	0c 94 40 27 	jmp	0x4e80	; 0x4e80 <__vector_39>
      a0:	27 c7       	rjmp	.+3662   	; 0xef0 <__bad_interrupt>
      a2:	00 00       	nop
      a4:	25 c7       	rjmp	.+3658   	; 0xef0 <__bad_interrupt>
      a6:	00 00       	nop
      a8:	23 c7       	rjmp	.+3654   	; 0xef0 <__bad_interrupt>
      aa:	00 00       	nop
      ac:	21 c7       	rjmp	.+3650   	; 0xef0 <__bad_interrupt>
      ae:	00 00       	nop
      b0:	1f c7       	rjmp	.+3646   	; 0xef0 <__bad_interrupt>
      b2:	00 00       	nop
      b4:	1d c7       	rjmp	.+3642   	; 0xef0 <__bad_interrupt>
      b6:	00 00       	nop
      b8:	1b c7       	rjmp	.+3638   	; 0xef0 <__bad_interrupt>
      ba:	00 00       	nop
      bc:	19 c7       	rjmp	.+3634   	; 0xef0 <__bad_interrupt>
      be:	00 00       	nop
      c0:	17 c7       	rjmp	.+3630   	; 0xef0 <__bad_interrupt>
      c2:	00 00       	nop
      c4:	15 c7       	rjmp	.+3626   	; 0xef0 <__bad_interrupt>
      c6:	00 00       	nop
      c8:	13 c7       	rjmp	.+3622   	; 0xef0 <__bad_interrupt>
      ca:	00 00       	nop
      cc:	11 c7       	rjmp	.+3618   	; 0xef0 <__bad_interrupt>
      ce:	00 00       	nop
      d0:	0f c7       	rjmp	.+3614   	; 0xef0 <__bad_interrupt>
      d2:	00 00       	nop
      d4:	0d c7       	rjmp	.+3610   	; 0xef0 <__bad_interrupt>
      d6:	00 00       	nop
      d8:	0b c7       	rjmp	.+3606   	; 0xef0 <__bad_interrupt>
      da:	00 00       	nop
      dc:	09 c7       	rjmp	.+3602   	; 0xef0 <__bad_interrupt>
      de:	00 00       	nop
      e0:	07 c7       	rjmp	.+3598   	; 0xef0 <__bad_interrupt>
      e2:	00 00       	nop
      e4:	94 14       	cp	r9, r4
      e6:	7c 14       	cp	r7, r12
      e8:	7f 14       	cp	r7, r15
      ea:	82 14       	cp	r8, r2
      ec:	85 14       	cp	r8, r5
      ee:	88 14       	cp	r8, r8
      f0:	8b 14       	cp	r8, r11
      f2:	8e 14       	cp	r8, r14
      f4:	a1 1b       	sub	r26, r17
      f6:	a3 1b       	sub	r26, r19
      f8:	ad 1b       	sub	r26, r29
      fa:	a5 1b       	sub	r26, r21
      fc:	a7 1b       	sub	r26, r23
      fe:	a9 1b       	sub	r26, r25
     100:	ab 1b       	sub	r26, r27
     102:	88 28       	or	r8, r8
     104:	75 29       	or	r23, r5
     106:	75 29       	or	r23, r5
     108:	75 29       	or	r23, r5
     10a:	75 29       	or	r23, r5
     10c:	75 29       	or	r23, r5
     10e:	75 29       	or	r23, r5
     110:	75 29       	or	r23, r5
     112:	88 28       	or	r8, r8
     114:	75 29       	or	r23, r5
     116:	75 29       	or	r23, r5
     118:	75 29       	or	r23, r5
     11a:	75 29       	or	r23, r5
     11c:	75 29       	or	r23, r5
     11e:	75 29       	or	r23, r5
     120:	75 29       	or	r23, r5
     122:	b6 28       	or	r11, r6
     124:	75 29       	or	r23, r5
     126:	75 29       	or	r23, r5
     128:	75 29       	or	r23, r5
     12a:	75 29       	or	r23, r5
     12c:	75 29       	or	r23, r5
     12e:	75 29       	or	r23, r5
     130:	75 29       	or	r23, r5
     132:	e2 28       	or	r14, r2
     134:	75 29       	or	r23, r5
     136:	75 29       	or	r23, r5
     138:	75 29       	or	r23, r5
     13a:	75 29       	or	r23, r5
     13c:	75 29       	or	r23, r5
     13e:	75 29       	or	r23, r5
     140:	75 29       	or	r23, r5
     142:	b6 28       	or	r11, r6
     144:	75 29       	or	r23, r5
     146:	75 29       	or	r23, r5
     148:	75 29       	or	r23, r5
     14a:	75 29       	or	r23, r5
     14c:	75 29       	or	r23, r5
     14e:	75 29       	or	r23, r5
     150:	75 29       	or	r23, r5
     152:	e2 28       	or	r14, r2
     154:	75 29       	or	r23, r5
     156:	75 29       	or	r23, r5
     158:	75 29       	or	r23, r5
     15a:	75 29       	or	r23, r5
     15c:	75 29       	or	r23, r5
     15e:	75 29       	or	r23, r5
     160:	75 29       	or	r23, r5
     162:	0f 29       	or	r16, r15
     164:	75 29       	or	r23, r5
     166:	75 29       	or	r23, r5
     168:	75 29       	or	r23, r5
     16a:	75 29       	or	r23, r5
     16c:	75 29       	or	r23, r5
     16e:	75 29       	or	r23, r5
     170:	75 29       	or	r23, r5
     172:	20 29       	or	r18, r0
     174:	75 29       	or	r23, r5
     176:	75 29       	or	r23, r5
     178:	75 29       	or	r23, r5
     17a:	75 29       	or	r23, r5
     17c:	75 29       	or	r23, r5
     17e:	75 29       	or	r23, r5
     180:	75 29       	or	r23, r5
     182:	55 29       	or	r21, r5
     184:	75 29       	or	r23, r5
     186:	75 29       	or	r23, r5
     188:	75 29       	or	r23, r5
     18a:	75 29       	or	r23, r5
     18c:	75 29       	or	r23, r5
     18e:	75 29       	or	r23, r5
     190:	75 29       	or	r23, r5
     192:	2a 29       	or	r18, r10
     194:	75 29       	or	r23, r5
     196:	75 29       	or	r23, r5
     198:	75 29       	or	r23, r5
     19a:	75 29       	or	r23, r5
     19c:	75 29       	or	r23, r5
     19e:	75 29       	or	r23, r5
     1a0:	75 29       	or	r23, r5
     1a2:	5c 29       	or	r21, r12
     1a4:	75 29       	or	r23, r5
     1a6:	75 29       	or	r23, r5
     1a8:	75 29       	or	r23, r5
     1aa:	75 29       	or	r23, r5
     1ac:	75 29       	or	r23, r5
     1ae:	75 29       	or	r23, r5
     1b0:	75 29       	or	r23, r5
     1b2:	be 27       	eor	r27, r30
     1b4:	75 29       	or	r23, r5
     1b6:	75 29       	or	r23, r5
     1b8:	75 29       	or	r23, r5
     1ba:	75 29       	or	r23, r5
     1bc:	75 29       	or	r23, r5
     1be:	75 29       	or	r23, r5
     1c0:	75 29       	or	r23, r5
     1c2:	be 27       	eor	r27, r30
     1c4:	75 29       	or	r23, r5
     1c6:	75 29       	or	r23, r5
     1c8:	75 29       	or	r23, r5
     1ca:	75 29       	or	r23, r5
     1cc:	75 29       	or	r23, r5
     1ce:	75 29       	or	r23, r5
     1d0:	75 29       	or	r23, r5
     1d2:	75 29       	or	r23, r5
     1d4:	75 29       	or	r23, r5
     1d6:	75 29       	or	r23, r5
     1d8:	75 29       	or	r23, r5
     1da:	75 29       	or	r23, r5
     1dc:	75 29       	or	r23, r5
     1de:	75 29       	or	r23, r5
     1e0:	75 29       	or	r23, r5
     1e2:	75 29       	or	r23, r5
     1e4:	75 29       	or	r23, r5
     1e6:	75 29       	or	r23, r5
     1e8:	75 29       	or	r23, r5
     1ea:	75 29       	or	r23, r5
     1ec:	75 29       	or	r23, r5
     1ee:	75 29       	or	r23, r5
     1f0:	75 29       	or	r23, r5
     1f2:	c8 27       	eor	r28, r24
     1f4:	75 29       	or	r23, r5
     1f6:	75 29       	or	r23, r5
     1f8:	75 29       	or	r23, r5
     1fa:	75 29       	or	r23, r5
     1fc:	75 29       	or	r23, r5
     1fe:	75 29       	or	r23, r5
     200:	75 29       	or	r23, r5
     202:	c8 27       	eor	r28, r24
     204:	75 29       	or	r23, r5
     206:	75 29       	or	r23, r5
     208:	75 29       	or	r23, r5
     20a:	75 29       	or	r23, r5
     20c:	75 29       	or	r23, r5
     20e:	75 29       	or	r23, r5
     210:	75 29       	or	r23, r5
     212:	75 29       	or	r23, r5
     214:	75 29       	or	r23, r5
     216:	75 29       	or	r23, r5
     218:	75 29       	or	r23, r5
     21a:	75 29       	or	r23, r5
     21c:	75 29       	or	r23, r5
     21e:	75 29       	or	r23, r5
     220:	75 29       	or	r23, r5
     222:	75 29       	or	r23, r5
     224:	75 29       	or	r23, r5
     226:	75 29       	or	r23, r5
     228:	75 29       	or	r23, r5
     22a:	75 29       	or	r23, r5
     22c:	75 29       	or	r23, r5
     22e:	75 29       	or	r23, r5
     230:	75 29       	or	r23, r5
     232:	fd 27       	eor	r31, r29
     234:	75 29       	or	r23, r5
     236:	75 29       	or	r23, r5
     238:	75 29       	or	r23, r5
     23a:	75 29       	or	r23, r5
     23c:	75 29       	or	r23, r5
     23e:	75 29       	or	r23, r5
     240:	75 29       	or	r23, r5
     242:	6b 27       	eor	r22, r27
     244:	75 29       	or	r23, r5
     246:	75 29       	or	r23, r5
     248:	75 29       	or	r23, r5
     24a:	75 29       	or	r23, r5
     24c:	75 29       	or	r23, r5
     24e:	75 29       	or	r23, r5
     250:	75 29       	or	r23, r5
     252:	6b 27       	eor	r22, r27
     254:	75 29       	or	r23, r5
     256:	75 29       	or	r23, r5
     258:	75 29       	or	r23, r5
     25a:	75 29       	or	r23, r5
     25c:	75 29       	or	r23, r5
     25e:	75 29       	or	r23, r5
     260:	75 29       	or	r23, r5
     262:	6b 27       	eor	r22, r27
     264:	75 29       	or	r23, r5
     266:	75 29       	or	r23, r5
     268:	75 29       	or	r23, r5
     26a:	75 29       	or	r23, r5
     26c:	75 29       	or	r23, r5
     26e:	75 29       	or	r23, r5
     270:	75 29       	or	r23, r5
     272:	b0 27       	eor	r27, r16
     274:	75 29       	or	r23, r5
     276:	75 29       	or	r23, r5
     278:	75 29       	or	r23, r5
     27a:	75 29       	or	r23, r5
     27c:	75 29       	or	r23, r5
     27e:	75 29       	or	r23, r5
     280:	75 29       	or	r23, r5
     282:	b0 27       	eor	r27, r16

00000284 <__trampolines_end>:
     284:	5b 25       	eor	r21, r11
     286:	30 32       	cpi	r19, 0x20	; 32
     288:	75 5d       	subi	r23, 0xD5	; 213
     28a:	20 25       	eor	r18, r0
     28c:	73 3a       	cpi	r23, 0xA3	; 163
     28e:	25 64       	ori	r18, 0x45	; 69
     290:	20 50       	subi	r18, 0x00	; 0
     292:	6f 73       	andi	r22, 0x3F	; 63
     294:	74 3a       	cpi	r23, 0xA4	; 164
     296:	20 25       	eor	r18, r0
     298:	70 00       	.word	0x0070	; ????

0000029a <__c.2849>:
     29a:	5b 25 30 32 75 5d 20 25 73 3a 25 64 20 57 61 69     [%02u] %s:%d Wai
     2aa:	74 3a 20 25 70 00                                   t: %p.

000002b0 <__c.2821>:
     2b0:	1b 5b 25 75 3b 25 75 6d 00                          .[%u;%um.

000002b9 <__c.2885>:
     2b9:	5b 25 30 32 75 5d 20 25 73 3a 25 64 20 46 52 45     [%02u] %s:%d FRE
     2c9:	45 3a 20 25 70 00                                   E: %p.

000002cf <__c.2883>:
     2cf:	5b 25 30 32 75 5d 20 25 73 3a 25 64 20 46 52 45     [%02u] %s:%d FRE
     2df:	45 3a 20 42 75 66 66 65 72 20 25 70 20 69 6e 20     E: Buffer %p in 
     2ef:	75 73 65 20 62 79 20 25 75 20 75 73 65 72 73 00     use by %u users.

000002ff <__c.2881>:
     2ff:	5b 25 30 32 75 5d 20 25 73 3a 25 64 20 46 52 45     [%02u] %s:%d FRE
     30f:	45 3a 20 42 75 66 66 65 72 20 61 6c 72 65 61 64     E: Buffer alread
     31f:	79 20 66 72 65 65 20 25 70 00                       y free %p.

00000329 <__c.2879>:
     329:	5b 25 30 32 75 5d 20 25 73 3a 25 64 20 46 52 45     [%02u] %s:%d FRE
     339:	45 3a 20 49 6e 76 61 6c 69 64 20 43 53 50 20 62     E: Invalid CSP b
     349:	75 66 66 65 72 20 70 6f 69 6e 74 65 72 20 25 70     uffer pointer %p
	...

0000035a <__c.2877>:
     35a:	5b 25 30 32 75 5d 20 25 73 3a 25 64 20 46 52 45     [%02u] %s:%d FRE
     36a:	45 3a 20 55 6e 61 6c 69 67 6e 65 64 20 43 53 50     E: Unaligned CSP
     37a:	20 62 75 66 66 65 72 20 70 6f 69 6e 74 65 72 20      buffer pointer 
     38a:	25 70 00                                            %p.

0000038d <__c.2874>:
     38d:	5b 25 30 32 75 5d 20 25 73 3a 25 64 20 41 74 74     [%02u] %s:%d Att
     39d:	65 6d 70 74 20 74 6f 20 66 72 65 65 20 6e 75 6c     empt to free nul
     3ad:	6c 20 70 6f 69 6e 74 65 72 00                       l pointer.

000003b7 <__c.2864>:
     3b7:	5b 25 30 32 75 5d 20 25 73 3a 25 64 20 43 6f 72     [%02u] %s:%d Cor
     3c7:	72 75 70 74 20 43 53 50 20 62 75 66 66 65 72 00     rupt CSP buffer.

000003d7 <__c.2862>:
     3d7:	5b 25 30 32 75 5d 20 25 73 3a 25 64 20 47 45 54     [%02u] %s:%d GET
     3e7:	3a 20 25 70 20 25 70 00                             : %p %p.

000003ef <__c.2860>:
     3ef:	5b 25 30 32 75 5d 20 25 73 3a 25 64 20 4f 75 74     [%02u] %s:%d Out
     3ff:	20 6f 66 20 62 75 66 66 65 72 73 00                  of buffers.

0000040b <__c.2858>:
     40b:	5b 25 30 32 75 5d 20 25 73 3a 25 64 20 41 74 74     [%02u] %s:%d Att
     41b:	65 6d 70 74 20 74 6f 20 61 6c 6c 6f 63 61 74 65     empt to allocate
     42b:	20 74 6f 6f 20 6c 61 72 67 65 20 62 6c 6f 63 6b      too large block
     43b:	20 25 75 00                                          %u.

0000043f <__c.3263>:
     43f:	5b 25 30 32 75 5d 20 25 73 3a 25 64 20 41 74 74     [%02u] %s:%d Att
     44f:	65 6d 70 74 20 74 6f 20 63 72 65 61 74 65 20 43     empt to create C
     45f:	52 43 33 32 20 76 61 6c 69 64 61 74 65 64 20 63     RC32 validated c
     46f:	6f 6e 6e 65 63 74 69 6f 6e 2c 20 62 75 74 20 43     onnection, but C
     47f:	53 50 20 77 61 73 20 63 6f 6d 70 69 6c 65 64 20     SP was compiled 
     48f:	77 69 74 68 6f 75 74 20 43 52 43 33 32 20 73 75     without CRC32 su
     49f:	70 70 6f 72 74 00                                   pport.

000004a5 <__c.3261>:
     4a5:	5b 25 30 32 75 5d 20 25 73 3a 25 64 20 41 74 74     [%02u] %s:%d Att
     4b5:	65 6d 70 74 20 74 6f 20 63 72 65 61 74 65 20 58     empt to create X
     4c5:	54 45 41 20 65 6e 63 72 79 70 74 65 64 20 63 6f     TEA encrypted co
     4d5:	6e 6e 65 63 74 69 6f 6e 2c 20 62 75 74 20 43 53     nnection, but CS
     4e5:	50 20 77 61 73 20 63 6f 6d 70 69 6c 65 64 20 77     P was compiled w
     4f5:	69 74 68 6f 75 74 20 58 54 45 41 20 73 75 70 70     ithout XTEA supp
     505:	6f 72 74 00                                         ort.

00000509 <__c.3259>:
     509:	5b 25 30 32 75 5d 20 25 73 3a 25 64 20 41 74 74     [%02u] %s:%d Att
     519:	65 6d 70 74 20 74 6f 20 63 72 65 61 74 65 20 48     empt to create H
     529:	4d 41 43 20 61 75 74 68 65 6e 74 69 63 61 74 65     MAC authenticate
     539:	64 20 63 6f 6e 6e 65 63 74 69 6f 6e 2c 20 62 75     d connection, bu
     549:	74 20 43 53 50 20 77 61 73 20 63 6f 6d 70 69 6c     t CSP was compil
     559:	65 64 20 77 69 74 68 6f 75 74 20 48 4d 41 43 20     ed without HMAC 
     569:	73 75 70 70 6f 72 74 00                             support.

00000571 <__c.3257>:
     571:	5b 25 30 32 75 5d 20 25 73 3a 25 64 20 41 74 74     [%02u] %s:%d Att
     581:	65 6d 70 74 20 74 6f 20 63 72 65 61 74 65 20 52     empt to create R
     591:	44 50 20 63 6f 6e 6e 65 63 74 69 6f 6e 2c 20 62     DP connection, b
     5a1:	75 74 20 43 53 50 20 77 61 73 20 63 6f 6d 70 69     ut CSP was compi
     5b1:	6c 65 64 20 77 69 74 68 6f 75 74 20 52 44 50 20     led without RDP 
     5c1:	73 75 70 70 6f 72 74 00                             support.

000005c9 <__c.3246>:
     5c9:	5b 25 30 32 75 5d 20 25 73 3a 25 64 20 46 61 69     [%02u] %s:%d Fai
     5d9:	6c 65 64 20 74 6f 20 6c 6f 63 6b 20 63 6f 6e 6e     led to lock conn
     5e9:	20 61 72 72 61 79 00                                 array.

000005f0 <__c.3244>:
     5f0:	5b 25 30 32 75 5d 20 25 73 3a 25 64 20 43 6f 6e     [%02u] %s:%d Con
     600:	6e 20 61 6c 72 65 61 64 79 20 63 6c 6f 73 65 64     n already closed
	...

00000611 <__c.3242>:
     611:	5b 25 30 32 75 5d 20 25 73 3a 25 64 20 4e 55 4c     [%02u] %s:%d NUL
     621:	4c 20 50 6f 69 6e 74 65 72 20 67 69 76 65 6e 20     L Pointer given 
     631:	74 6f 20 63 73 70 5f 63 6c 6f 73 65 00              to csp_close.

0000063e <__c.3232>:
     63e:	5b 25 30 32 75 5d 20 25 73 3a 25 64 20 4e 6f 20     [%02u] %s:%d No 
     64e:	6d 6f 72 65 20 66 72 65 65 20 63 6f 6e 6e 65 63     more free connec
     65e:	74 69 6f 6e 73 00                                   tions.

00000664 <__c.3227>:
     664:	5b 25 30 32 75 5d 20 25 73 3a 25 64 20 46 61 69     [%02u] %s:%d Fai
     674:	6c 65 64 20 74 6f 20 6c 6f 63 6b 20 63 6f 6e 6e     led to lock conn
     684:	20 61 72 72 61 79 00                                 array.

0000068b <__c.3198>:
     68b:	5b 25 30 32 75 5d 20 25 73 3a 25 64 20 4e 6f 20     [%02u] %s:%d No 
     69b:	6d 6f 72 65 20 6d 65 6d 6f 72 79 20 66 6f 72 20     more memory for 
     6ab:	63 6f 6e 6e 20 73 65 6d 61 70 68 6f 72 65 00        conn semaphore.

000006ba <__c.3193>:
     6ba:	5b 25 30 32 75 5d 20 25 73 3a 25 64 20 46 61 69     [%02u] %s:%d Fai
     6ca:	6c 65 64 20 74 6f 20 63 72 65 61 74 65 20 63 6f     led to create co
     6da:	6e 6e 65 63 74 69 6f 6e 20 6c 6f 63 6b 00           nnection lock.

000006e8 <__c.3186>:
     6e8:	5b 25 30 32 75 5d 20 25 73 3a 25 64 20 4e 6f 20     [%02u] %s:%d No 
     6f8:	6d 6f 72 65 20 6d 65 6d 6f 72 79 20 66 6f 72 20     more memory for 
     708:	73 70 6f 72 74 20 73 65 6d 61 70 68 6f 72 65 00     sport semaphore.

00000718 <__c.3181>:
     718:	5b 25 30 32 75 5d 20 25 73 3a 25 64 20 52 58 20     [%02u] %s:%d RX 
     728:	71 75 65 75 65 20 25 70 20 66 75 6c 6c 20 77 69     queue %p full wi
     738:	74 68 20 25 75 20 69 74 65 6d 73 00                 th %u items.

00000744 <__c.2557>:
     744:	0d 0a 00                                            ...

00000747 <__c.3371>:
     747:	5b 25 30 32 75 5d 20 25 73 3a 25 64 20 52 65 70     [%02u] %s:%d Rep
     757:	6c 79 20 6c 65 6e 67 74 68 20 25 75 20 65 78 70     ly length %u exp
     767:	65 63 74 65 64 20 25 75 00                          ected %u.

00000770 <__c.3352>:
     770:	5b 25 30 32 75 5d 20 25 73 3a 25 64 20 49 6e 76     [%02u] %s:%d Inv
     780:	61 6c 69 64 20 63 61 6c 6c 20 74 6f 20 63 73 70     alid call to csp
     790:	5f 73 65 6e 64 00                                   _send.

00000796 <__c.3342>:
     796:	5b 25 30 32 75 5d 20 25 73 3a 25 64 20 41 74 74     [%02u] %s:%d Att
     7a6:	65 6d 70 74 20 74 6f 20 73 65 6e 64 20 58 54 45     empt to send XTE
     7b6:	41 20 65 6e 63 72 79 70 74 65 64 20 70 61 63 6b     A encrypted pack
     7c6:	65 74 2c 20 62 75 74 20 43 53 50 20 77 61 73 20     et, but CSP was 
     7d6:	63 6f 6d 70 69 6c 65 64 20 77 69 74 68 6f 75 74     compiled without
     7e6:	20 58 54 45 41 20 73 75 70 70 6f 72 74 2e 20 44      XTEA support. D
     7f6:	69 73 63 61 72 64 69 6e 67 20 70 61 63 6b 65 74     iscarding packet
	...

00000807 <__c.3340>:
     807:	5b 25 30 32 75 5d 20 25 73 3a 25 64 20 41 74 74     [%02u] %s:%d Att
     817:	65 6d 70 74 20 74 6f 20 73 65 6e 64 20 70 61 63     empt to send pac
     827:	6b 65 74 20 77 69 74 68 20 43 52 43 33 32 2c 20     ket with CRC32, 
     837:	62 75 74 20 43 53 50 20 77 61 73 20 63 6f 6d 70     but CSP was comp
     847:	69 6c 65 64 20 77 69 74 68 6f 75 74 20 43 52 43     iled without CRC
     857:	33 32 20 73 75 70 70 6f 72 74 2e 20 53 65 6e 64     32 support. Send
     867:	69 6e 67 20 77 69 74 68 6f 75 74 20 43 52 43 33     ing without CRC3
     877:	32 72 00                                            2r.

0000087a <__c.3337>:
     87a:	5b 25 30 32 75 5d 20 25 73 3a 25 64 20 41 74 74     [%02u] %s:%d Att
     88a:	65 6d 70 74 20 74 6f 20 73 65 6e 64 20 70 61 63     empt to send pac
     89a:	6b 65 74 20 77 69 74 68 20 48 4d 41 43 2c 20 62     ket with HMAC, b
     8aa:	75 74 20 43 53 50 20 77 61 73 20 63 6f 6d 70 69     ut CSP was compi
     8ba:	6c 65 64 20 77 69 74 68 6f 75 74 20 48 4d 41 43     led without HMAC
     8ca:	20 73 75 70 70 6f 72 74 2e 20 44 69 73 63 61 72      support. Discar
     8da:	64 69 6e 67 20 70 61 63 6b 65 74 00                 ding packet.

000008e6 <__c.3335>:
     8e6:	5b 25 30 32 75 5d 20 25 73 3a 25 64 20 4f 55 54     [%02u] %s:%d OUT
     8f6:	3a 20 53 20 25 75 2c 20 44 20 25 75 2c 20 44 70     : S %u, D %u, Dp
     906:	20 25 75 2c 20 53 70 20 25 75 2c 20 50 72 20 25      %u, Sp %u, Pr %
     916:	75 2c 20 46 6c 20 30 78 25 30 32 58 2c 20 53 7a     u, Fl 0x%02X, Sz
     926:	20 25 75 20 56 49 41 3a 20 25 73 00                  %u VIA: %s.

00000932 <__c.3333>:
     932:	5b 25 30 32 75 5d 20 25 73 3a 25 64 20 4e 6f 20     [%02u] %s:%d No 
     942:	72 6f 75 74 65 20 74 6f 20 68 6f 73 74 3a 20 25     route to host: %
     952:	23 30 38 78 00                                      #08x.

00000957 <__c.3330>:
     957:	5b 25 30 32 75 5d 20 25 73 3a 25 64 20 63 73 70     [%02u] %s:%d csp
     967:	5f 73 65 6e 64 5f 64 69 72 65 63 74 20 63 61 6c     _send_direct cal
     977:	6c 65 64 20 77 69 74 68 20 4e 55 4c 4c 20 70 61     led with NULL pa
     987:	63 6b 65 74 00                                      cket.

0000098c <__c.2723>:
     98c:	5b 25 30 32 75 5d 20 25 73 3a 25 64 20 45 52 52     [%02u] %s:%d ERR
     99c:	4f 52 3a 20 52 6f 75 74 69 6e 67 20 69 6e 70 75     OR: Routing inpu
     9ac:	74 20 46 49 46 4f 20 69 73 20 46 55 4c 4c 2e 20     t FIFO is FULL. 
     9bc:	44 72 6f 70 70 69 6e 67 20 70 61 63 6b 65 74 2e     Dropping packet.
	...

000009cd <__c.2719>:
     9cd:	5b 25 30 32 75 5d 20 25 73 3a 25 64 20 63 73 70     [%02u] %s:%d csp
     9dd:	5f 6e 65 77 20 70 61 63 6b 65 74 20 63 61 6c 6c     _new packet call
     9ed:	65 64 20 77 69 74 68 20 4e 55 4c 4c 20 69 6e 74     ed with NULL int
     9fd:	65 72 66 61 63 65 00                                erface.

00000a04 <__c.2717>:
     a04:	5b 25 30 32 75 5d 20 25 73 3a 25 64 20 63 73 70     [%02u] %s:%d csp
     a14:	5f 6e 65 77 20 70 61 63 6b 65 74 20 63 61 6c 6c     _new packet call
     a24:	65 64 20 77 69 74 68 20 4e 55 4c 4c 20 70 61 63     ed with NULL pac
     a34:	6b 65 74 00                                         ket.

00000a38 <__c.3089>:
     a38:	5b 25 30 32 75 5d 20 25 73 3a 25 64 20 46 61 69     [%02u] %s:%d Fai
     a48:	6c 65 64 20 74 6f 20 73 74 61 72 74 20 72 6f 75     led to start rou
     a58:	74 65 72 20 74 61 73 6b 00                          ter task.

00000a61 <__c.3060>:
     a61:	5b 25 30 32 75 5d 20 25 73 3a 25 64 20 52 65 63     [%02u] %s:%d Rec
     a71:	65 69 76 65 64 20 70 61 63 6b 65 74 20 77 69 74     eived packet wit
     a81:	68 20 43 52 43 33 32 2c 20 62 75 74 20 43 53 50     h CRC32, but CSP
     a91:	20 77 61 73 20 63 6f 6d 70 69 6c 65 64 20 77 69      was compiled wi
     aa1:	74 68 6f 75 74 20 43 52 43 33 32 20 73 75 70 70     thout CRC32 supp
     ab1:	6f 72 74 2e 20 41 63 63 65 70 74 69 6e 67 20 70     ort. Accepting p
     ac1:	61 63 6b 65 74 00                                   acket.

00000ac7 <__c.3053>:
     ac7:	5b 25 30 32 75 5d 20 25 73 3a 25 64 20 52 65 63     [%02u] %s:%d Rec
     ad7:	65 69 76 65 64 20 52 44 50 20 70 61 63 6b 65 74     eived RDP packet
     ae7:	2c 20 62 75 74 20 43 53 50 20 77 61 73 20 63 6f     , but CSP was co
     af7:	6d 70 69 6c 65 64 20 77 69 74 68 6f 75 74 20 52     mpiled without R
     b07:	44 50 20 73 75 70 70 6f 72 74 2e 20 44 69 73 63     DP support. Disc
     b17:	61 72 64 69 6e 67 20 70 61 63 6b 65 74 00           arding packet.

00000b25 <__c.3051>:
     b25:	5b 25 30 32 75 5d 20 25 73 3a 25 64 20 52 65 63     [%02u] %s:%d Rec
     b35:	65 69 76 65 64 20 70 61 63 6b 65 74 20 77 69 74     eived packet wit
     b45:	68 20 48 4d 41 43 2c 20 62 75 74 20 43 53 50 20     h HMAC, but CSP 
     b55:	77 61 73 20 63 6f 6d 70 69 6c 65 64 20 77 69 74     was compiled wit
     b65:	68 6f 75 74 20 48 4d 41 43 20 73 75 70 70 6f 72     hout HMAC suppor
     b75:	74 2e 20 44 69 73 63 61 72 64 69 6e 67 20 70 61     t. Discarding pa
     b85:	63 6b 65 74 00                                      cket.

00000b8a <__c.3049>:
     b8a:	5b 25 30 32 75 5d 20 25 73 3a 25 64 20 52 65 63     [%02u] %s:%d Rec
     b9a:	65 69 76 65 64 20 58 54 45 41 20 65 6e 63 72 79     eived XTEA encry
     baa:	70 74 65 64 20 70 61 63 6b 65 74 2c 20 62 75 74     pted packet, but
     bba:	20 43 53 50 20 77 61 73 20 63 6f 6d 70 69 6c 65      CSP was compile
     bca:	64 20 77 69 74 68 6f 75 74 20 58 54 45 41 20 73     d without XTEA s
     bda:	75 70 70 6f 72 74 2e 20 44 69 73 63 61 72 64 69     upport. Discardi
     bea:	6e 67 20 70 61 63 6b 65 74 00                       ng packet.

00000bf4 <__c.3077>:
     bf4:	5b 25 30 32 75 5d 20 25 73 3a 25 64 20 4e 6f 20     [%02u] %s:%d No 
     c04:	6d 6f 72 65 20 63 6f 6e 6e 65 63 74 69 6f 6e 73     more connections
     c14:	20 61 76 61 69 6c 61 62 6c 65 00                     available.

00000c1f <__c.3074>:
     c1f:	5b 25 30 32 75 5d 20 25 73 3a 25 64 20 43 6f 6e     [%02u] %s:%d Con
     c2f:	6e 2d 6c 65 73 73 20 73 6f 63 6b 65 74 20 71 75     n-less socket qu
     c3f:	65 75 65 20 66 75 6c 6c 00                          eue full.

00000c48 <__c.3072>:
     c48:	5b 25 30 32 75 5d 20 25 73 3a 25 64 20 52 6f 75     [%02u] %s:%d Rou
     c58:	74 65 72 20 66 61 69 6c 65 64 20 74 6f 20 73 65     ter failed to se
     c68:	6e 64 00                                            nd.

00000c6b <__c.3069>:
     c6b:	5b 25 30 32 75 5d 20 25 73 3a 25 64 20 49 4e 50     [%02u] %s:%d INP
     c7b:	3a 20 53 20 25 75 2c 20 44 20 25 75 2c 20 44 70     : S %u, D %u, Dp
     c8b:	20 25 75 2c 20 53 70 20 25 75 2c 20 50 72 20 25      %u, Sp %u, Pr %
     c9b:	75 2c 20 46 6c 20 30 78 25 30 32 58 2c 20 53 7a     u, Fl 0x%02X, Sz
     cab:	20 25 75 20 56 49 41 3a 20 25 73 00                  %u VIA: %s.

00000cb7 <__c.2553>:
     cb7:	20 20 20 2a 20 20 25 2d 39 73 20 20 25 75 0d 0a        *  %-9s  %u..
	...

00000cc8 <__c.2548>:
     cc8:	25 34 75 20 20 25 2d 39 73 20 20 25 75 0d 0a 00     %4u  %-9s  %u...

00000cd8 <__c.2546>:
     cd8:	4e 6f 64 65 20 20 49 6e 74 65 72 66 61 63 65 20     Node  Interface 
     ce8:	20 41 64 64 72 65 73 73 0d 0a 00                     Address...

00000cf3 <__c.2540>:
     cf3:	5b 25 30 32 75 5d 20 25 73 3a 25 64 20 46 61 69     [%02u] %s:%d Fai
     d03:	6c 65 64 20 74 6f 20 73 65 74 20 72 6f 75 74 65     led to set route
     d13:	3a 20 69 6e 76 61 6c 69 64 20 6e 6f 64 65 20 69     : invalid node i
     d23:	64 20 25 75 00                                      d %u.

00000d28 <__c.2548>:
     d28:	5b 25 30 32 75 5d 20 25 73 3a 25 64 20 57 61 72     [%02u] %s:%d War
     d38:	6e 69 6e 67 20 73 6f 63 6b 65 74 20 63 6f 6e 6e     ning socket conn
     d48:	65 63 74 69 6f 6e 20 71 75 65 75 65 20 66 75 6c     ection queue ful
     d58:	6c 00                                               l.

00000d5a <__c.2546>:
     d5a:	5b 25 30 32 75 5d 20 25 73 3a 25 64 20 43 6f 6e     [%02u] %s:%d Con
     d6a:	6e 65 63 74 69 6f 6e 20 62 75 66 66 65 72 20 71     nection buffer q
     d7a:	75 65 75 65 20 66 75 6c 6c 21 00                    ueue full!.

00000d85 <__c.3455>:
     d85:	50 69 6e 67 20 2d 2d 20 46 61 69 6c 65 64 0d 0a     Ping -- Failed..
     d95:	0d 0a 00                                            ...

00000d98 <__c.3453>:
     d98:	50 69 6e 67 20 2d 2d 20 54 69 6d 65 6f 75 74 0d     Ping -- Timeout.
     da8:	0a 0d 0a 00                                         ....

00000dac <__c.3451>:
     dac:	52 65 63 65 69 76 65 64 20 74 65 6d 70 65 72 61     Received tempera
     dbc:	74 75 72 65 3a 20 25 73 20 20 2a 43 0d 0a 0d 0a     ture: %s  *C....
	...

00000dcd <__c.3449>:
     dcd:	52 65 63 65 69 76 65 64 20 70 61 63 6b 65 74 20     Received packet 
     ddd:	23 25 64 0d 0a 00                                   #%d...

00000de3 <__c.3144>:
     de3:	0a 68 00                                            .h.

00000de6 <__c.3122>:
     de6:	45 72 72 6f 72 3a 20 69 32 63 20 74 6f 6f 20 6c     Error: i2c too l
     df6:	6f 6e 67 20 0d 0a 00                                ong ...

00000dfd <__c.3082>:
     dfd:	51 55 45 55 45 20 73 65 6e 64 20 66 61 69 6c 0d     QUEUE send fail.
     e0d:	0a 00                                               ..

00000e0f <__c.3080>:
     e0f:	44 65 76 69 63 65 20 69 73 20 49 32 43 20 73 6c     Device is I2C sl
     e1f:	61 76 65 2c 20 73 6f 20 69 74 20 63 61 6e 6e 6f     ave, so it canno
     e2f:	74 20 69 6e 69 74 69 61 74 65 20 61 20 49 32 43     t initiate a I2C
     e3f:	20 66 72 61 6d 65 0d 0a 00                           frame...

00000e48 <__c.3436>:
     e48:	2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 20 4f 42 43 3a     ----------- OBC:
     e58:	20 41 75 74 6f 6e 6f 6d 6f 75 73 20 4d 6f 64 65      Autonomous Mode
     e68:	20 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 0d 0a 00         -----------...

00000e77 <__c.3430>:
     e77:	0d 0a 00                                            ...

00000e7a <__c.3428>:
     e7a:	2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 20 4f 42 43 3a     ----------- OBC:
     e8a:	20 49 6e 69 74 69 61 6c 69 7a 61 74 69 6f 6e 20      Initialization 
     e9a:	4d 6f 64 65 20 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d     Mode -----------
     eaa:	0d 0a 00 00                                         ....

00000eae <__ctors_end>:
     eae:	11 24       	eor	r1, r1
     eb0:	1f be       	out	0x3f, r1	; 63
     eb2:	cf ef       	ldi	r28, 0xFF	; 255
     eb4:	d1 e2       	ldi	r29, 0x21	; 33
     eb6:	de bf       	out	0x3e, r29	; 62
     eb8:	cd bf       	out	0x3d, r28	; 61
     eba:	00 e0       	ldi	r16, 0x00	; 0
     ebc:	0c bf       	out	0x3c, r16	; 60

00000ebe <__do_copy_data>:
     ebe:	14 e0       	ldi	r17, 0x04	; 4
     ec0:	a0 e0       	ldi	r26, 0x00	; 0
     ec2:	b2 e0       	ldi	r27, 0x02	; 2
     ec4:	ea e3       	ldi	r30, 0x3A	; 58
     ec6:	ff e5       	ldi	r31, 0x5F	; 95
     ec8:	00 e0       	ldi	r16, 0x00	; 0
     eca:	0b bf       	out	0x3b, r16	; 59
     ecc:	02 c0       	rjmp	.+4      	; 0xed2 <__do_copy_data+0x14>
     ece:	07 90       	elpm	r0, Z+
     ed0:	0d 92       	st	X+, r0
     ed2:	a8 30       	cpi	r26, 0x08	; 8
     ed4:	b1 07       	cpc	r27, r17
     ed6:	d9 f7       	brne	.-10     	; 0xece <__do_copy_data+0x10>

00000ed8 <__do_clear_bss>:
     ed8:	20 e2       	ldi	r18, 0x20	; 32
     eda:	a8 e0       	ldi	r26, 0x08	; 8
     edc:	b4 e0       	ldi	r27, 0x04	; 4
     ede:	01 c0       	rjmp	.+2      	; 0xee2 <.do_clear_bss_start>

00000ee0 <.do_clear_bss_loop>:
     ee0:	1d 92       	st	X+, r1

00000ee2 <.do_clear_bss_start>:
     ee2:	a4 34       	cpi	r26, 0x44	; 68
     ee4:	b2 07       	cpc	r27, r18
     ee6:	e1 f7       	brne	.-8      	; 0xee0 <.do_clear_bss_loop>
     ee8:	0e 94 32 2b 	call	0x5664	; 0x5664 <main>
     eec:	0c 94 9b 2f 	jmp	0x5f36	; 0x5f36 <_exit>

00000ef0 <__bad_interrupt>:
     ef0:	87 c8       	rjmp	.-3826   	; 0x0 <__vectors>

00000ef2 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     ef2:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     ef4:	03 96       	adiw	r24, 0x03	; 3
     ef6:	92 83       	std	Z+2, r25	; 0x02
     ef8:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     efa:	4f ef       	ldi	r20, 0xFF	; 255
     efc:	5f ef       	ldi	r21, 0xFF	; 255
     efe:	ba 01       	movw	r22, r20
     f00:	43 83       	std	Z+3, r20	; 0x03
     f02:	54 83       	std	Z+4, r21	; 0x04
     f04:	65 83       	std	Z+5, r22	; 0x05
     f06:	76 83       	std	Z+6, r23	; 0x06

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     f08:	90 87       	std	Z+8, r25	; 0x08
     f0a:	87 83       	std	Z+7, r24	; 0x07
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     f0c:	92 87       	std	Z+10, r25	; 0x0a
     f0e:	81 87       	std	Z+9, r24	; 0x09

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     f10:	10 82       	st	Z, r1
     f12:	08 95       	ret

00000f14 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     f14:	fc 01       	movw	r30, r24
     f16:	13 86       	std	Z+11, r1	; 0x0b
     f18:	12 86       	std	Z+10, r1	; 0x0a
     f1a:	08 95       	ret

00000f1c <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     f1c:	cf 93       	push	r28
     f1e:	df 93       	push	r29
     f20:	9c 01       	movw	r18, r24
     f22:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
     f24:	dc 01       	movw	r26, r24
     f26:	11 96       	adiw	r26, 0x01	; 1
     f28:	cd 91       	ld	r28, X+
     f2a:	dc 91       	ld	r29, X
     f2c:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     f2e:	d5 83       	std	Z+5, r29	; 0x05
     f30:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     f32:	8e 81       	ldd	r24, Y+6	; 0x06
     f34:	9f 81       	ldd	r25, Y+7	; 0x07
     f36:	97 83       	std	Z+7, r25	; 0x07
     f38:	86 83       	std	Z+6, r24	; 0x06

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
     f3a:	8e 81       	ldd	r24, Y+6	; 0x06
     f3c:	9f 81       	ldd	r25, Y+7	; 0x07
     f3e:	dc 01       	movw	r26, r24
     f40:	15 96       	adiw	r26, 0x05	; 5
     f42:	7c 93       	st	X, r23
     f44:	6e 93       	st	-X, r22
     f46:	14 97       	sbiw	r26, 0x04	; 4
	pxIndex->pxPrevious = pxNewListItem;
     f48:	7f 83       	std	Y+7, r23	; 0x07
     f4a:	6e 83       	std	Y+6, r22	; 0x06

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     f4c:	33 87       	std	Z+11, r19	; 0x0b
     f4e:	22 87       	std	Z+10, r18	; 0x0a

	( pxList->uxNumberOfItems )++;
     f50:	f9 01       	movw	r30, r18
     f52:	80 81       	ld	r24, Z
     f54:	8f 5f       	subi	r24, 0xFF	; 255
     f56:	80 83       	st	Z, r24
}
     f58:	df 91       	pop	r29
     f5a:	cf 91       	pop	r28
     f5c:	08 95       	ret

00000f5e <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     f5e:	0f 93       	push	r16
     f60:	1f 93       	push	r17
     f62:	cf 93       	push	r28
     f64:	df 93       	push	r29
     f66:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     f68:	08 81       	ld	r16, Y
     f6a:	19 81       	ldd	r17, Y+1	; 0x01
     f6c:	2a 81       	ldd	r18, Y+2	; 0x02
     f6e:	3b 81       	ldd	r19, Y+3	; 0x03
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     f70:	0f 3f       	cpi	r16, 0xFF	; 255
     f72:	4f ef       	ldi	r20, 0xFF	; 255
     f74:	14 07       	cpc	r17, r20
     f76:	24 07       	cpc	r18, r20
     f78:	34 07       	cpc	r19, r20
     f7a:	21 f4       	brne	.+8      	; 0xf84 <vListInsert+0x26>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     f7c:	fc 01       	movw	r30, r24
     f7e:	a1 85       	ldd	r26, Z+9	; 0x09
     f80:	b2 85       	ldd	r27, Z+10	; 0x0a
     f82:	11 c0       	rjmp	.+34     	; 0xfa6 <vListInsert+0x48>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     f84:	dc 01       	movw	r26, r24
     f86:	13 96       	adiw	r26, 0x03	; 3
     f88:	01 c0       	rjmp	.+2      	; 0xf8c <vListInsert+0x2e>
     f8a:	df 01       	movw	r26, r30
     f8c:	14 96       	adiw	r26, 0x04	; 4
     f8e:	ed 91       	ld	r30, X+
     f90:	fc 91       	ld	r31, X
     f92:	15 97       	sbiw	r26, 0x05	; 5
     f94:	40 81       	ld	r20, Z
     f96:	51 81       	ldd	r21, Z+1	; 0x01
     f98:	62 81       	ldd	r22, Z+2	; 0x02
     f9a:	73 81       	ldd	r23, Z+3	; 0x03
     f9c:	04 17       	cp	r16, r20
     f9e:	15 07       	cpc	r17, r21
     fa0:	26 07       	cpc	r18, r22
     fa2:	37 07       	cpc	r19, r23
     fa4:	90 f7       	brcc	.-28     	; 0xf8a <vListInsert+0x2c>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     fa6:	14 96       	adiw	r26, 0x04	; 4
     fa8:	ed 91       	ld	r30, X+
     faa:	fc 91       	ld	r31, X
     fac:	15 97       	sbiw	r26, 0x05	; 5
     fae:	fd 83       	std	Y+5, r31	; 0x05
     fb0:	ec 83       	std	Y+4, r30	; 0x04
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     fb2:	d7 83       	std	Z+7, r29	; 0x07
     fb4:	c6 83       	std	Z+6, r28	; 0x06
	pxNewListItem->pxPrevious = pxIterator;
     fb6:	bf 83       	std	Y+7, r27	; 0x07
     fb8:	ae 83       	std	Y+6, r26	; 0x06
	pxIterator->pxNext = pxNewListItem;
     fba:	15 96       	adiw	r26, 0x05	; 5
     fbc:	dc 93       	st	X, r29
     fbe:	ce 93       	st	-X, r28
     fc0:	14 97       	sbiw	r26, 0x04	; 4

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     fc2:	9b 87       	std	Y+11, r25	; 0x0b
     fc4:	8a 87       	std	Y+10, r24	; 0x0a

	( pxList->uxNumberOfItems )++;
     fc6:	fc 01       	movw	r30, r24
     fc8:	20 81       	ld	r18, Z
     fca:	2f 5f       	subi	r18, 0xFF	; 255
     fcc:	20 83       	st	Z, r18
}
     fce:	df 91       	pop	r29
     fd0:	cf 91       	pop	r28
     fd2:	1f 91       	pop	r17
     fd4:	0f 91       	pop	r16
     fd6:	08 95       	ret

00000fd8 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     fd8:	cf 93       	push	r28
     fda:	df 93       	push	r29
     fdc:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     fde:	a2 85       	ldd	r26, Z+10	; 0x0a
     fe0:	b3 85       	ldd	r27, Z+11	; 0x0b

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     fe2:	c4 81       	ldd	r28, Z+4	; 0x04
     fe4:	d5 81       	ldd	r29, Z+5	; 0x05
     fe6:	86 81       	ldd	r24, Z+6	; 0x06
     fe8:	97 81       	ldd	r25, Z+7	; 0x07
     fea:	9f 83       	std	Y+7, r25	; 0x07
     fec:	8e 83       	std	Y+6, r24	; 0x06
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     fee:	c6 81       	ldd	r28, Z+6	; 0x06
     ff0:	d7 81       	ldd	r29, Z+7	; 0x07
     ff2:	84 81       	ldd	r24, Z+4	; 0x04
     ff4:	95 81       	ldd	r25, Z+5	; 0x05
     ff6:	9d 83       	std	Y+5, r25	; 0x05
     ff8:	8c 83       	std	Y+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     ffa:	11 96       	adiw	r26, 0x01	; 1
     ffc:	8d 91       	ld	r24, X+
     ffe:	9c 91       	ld	r25, X
    1000:	12 97       	sbiw	r26, 0x02	; 2
    1002:	e8 17       	cp	r30, r24
    1004:	f9 07       	cpc	r31, r25
    1006:	31 f4       	brne	.+12     	; 0x1014 <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    1008:	86 81       	ldd	r24, Z+6	; 0x06
    100a:	97 81       	ldd	r25, Z+7	; 0x07
    100c:	12 96       	adiw	r26, 0x02	; 2
    100e:	9c 93       	st	X, r25
    1010:	8e 93       	st	-X, r24
    1012:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
    1014:	13 86       	std	Z+11, r1	; 0x0b
    1016:	12 86       	std	Z+10, r1	; 0x0a
	( pxList->uxNumberOfItems )--;
    1018:	8c 91       	ld	r24, X
    101a:	81 50       	subi	r24, 0x01	; 1
    101c:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
    101e:	df 91       	pop	r29
    1020:	cf 91       	pop	r28
    1022:	08 95       	ret

00001024 <prvInsertBlockIntoFreeList>:
	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
}
/*-----------------------------------------------------------*/

static void prvInsertBlockIntoFreeList( BlockLink_t *pxBlockToInsert )
{
    1024:	cf 93       	push	r28
    1026:	df 93       	push	r29
    1028:	dc 01       	movw	r26, r24
BlockLink_t *pxIterator;
uint8_t *puc;

	/* Iterate through the list until a block is found that has a higher address
	than the block being inserted. */
	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
    102a:	e0 e1       	ldi	r30, 0x10	; 16
    102c:	f4 e0       	ldi	r31, 0x04	; 4
    102e:	01 c0       	rjmp	.+2      	; 0x1032 <prvInsertBlockIntoFreeList+0xe>
    1030:	f9 01       	movw	r30, r18
    1032:	20 81       	ld	r18, Z
    1034:	31 81       	ldd	r19, Z+1	; 0x01
    1036:	2a 17       	cp	r18, r26
    1038:	3b 07       	cpc	r19, r27
    103a:	d0 f3       	brcs	.-12     	; 0x1030 <prvInsertBlockIntoFreeList+0xc>
	}

	/* Do the block being inserted, and the block it is being inserted after
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxIterator;
	if( ( puc + pxIterator->xBlockSize ) == ( uint8_t * ) pxBlockToInsert )
    103c:	82 81       	ldd	r24, Z+2	; 0x02
    103e:	93 81       	ldd	r25, Z+3	; 0x03
    1040:	af 01       	movw	r20, r30
    1042:	48 0f       	add	r20, r24
    1044:	59 1f       	adc	r21, r25
    1046:	a4 17       	cp	r26, r20
    1048:	b5 07       	cpc	r27, r21
    104a:	49 f4       	brne	.+18     	; 0x105e <prvInsertBlockIntoFreeList+0x3a>
	{
		pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
    104c:	12 96       	adiw	r26, 0x02	; 2
    104e:	4d 91       	ld	r20, X+
    1050:	5c 91       	ld	r21, X
    1052:	13 97       	sbiw	r26, 0x03	; 3
    1054:	84 0f       	add	r24, r20
    1056:	95 1f       	adc	r25, r21
    1058:	93 83       	std	Z+3, r25	; 0x03
    105a:	82 83       	std	Z+2, r24	; 0x02
    105c:	df 01       	movw	r26, r30
	}

	/* Do the block being inserted, and the block it is being inserted before
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxBlockToInsert;
	if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) pxIterator->pxNextFreeBlock )
    105e:	12 96       	adiw	r26, 0x02	; 2
    1060:	8d 91       	ld	r24, X+
    1062:	9c 91       	ld	r25, X
    1064:	13 97       	sbiw	r26, 0x03	; 3
    1066:	ed 01       	movw	r28, r26
    1068:	c8 0f       	add	r28, r24
    106a:	d9 1f       	adc	r29, r25
    106c:	2c 17       	cp	r18, r28
    106e:	3d 07       	cpc	r19, r29
    1070:	d9 f4       	brne	.+54     	; 0x10a8 <prvInsertBlockIntoFreeList+0x84>
	{
		if( pxIterator->pxNextFreeBlock != pxEnd )
    1072:	20 91 0e 04 	lds	r18, 0x040E	; 0x80040e <pxEnd>
    1076:	30 91 0f 04 	lds	r19, 0x040F	; 0x80040f <pxEnd+0x1>
    107a:	c2 17       	cp	r28, r18
    107c:	d3 07       	cpc	r29, r19
    107e:	81 f0       	breq	.+32     	; 0x10a0 <prvInsertBlockIntoFreeList+0x7c>
		{
			/* Form one big block from the two blocks. */
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
    1080:	2a 81       	ldd	r18, Y+2	; 0x02
    1082:	3b 81       	ldd	r19, Y+3	; 0x03
    1084:	82 0f       	add	r24, r18
    1086:	93 1f       	adc	r25, r19
    1088:	13 96       	adiw	r26, 0x03	; 3
    108a:	9c 93       	st	X, r25
    108c:	8e 93       	st	-X, r24
    108e:	12 97       	sbiw	r26, 0x02	; 2
			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
    1090:	c0 81       	ld	r28, Z
    1092:	d1 81       	ldd	r29, Z+1	; 0x01
    1094:	88 81       	ld	r24, Y
    1096:	99 81       	ldd	r25, Y+1	; 0x01
    1098:	11 96       	adiw	r26, 0x01	; 1
    109a:	9c 93       	st	X, r25
    109c:	8e 93       	st	-X, r24
    109e:	07 c0       	rjmp	.+14     	; 0x10ae <prvInsertBlockIntoFreeList+0x8a>
		}
		else
		{
			pxBlockToInsert->pxNextFreeBlock = pxEnd;
    10a0:	11 96       	adiw	r26, 0x01	; 1
    10a2:	dc 93       	st	X, r29
    10a4:	ce 93       	st	-X, r28
    10a6:	03 c0       	rjmp	.+6      	; 0x10ae <prvInsertBlockIntoFreeList+0x8a>
		}
	}
	else
	{
		pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;
    10a8:	11 96       	adiw	r26, 0x01	; 1
    10aa:	3c 93       	st	X, r19
    10ac:	2e 93       	st	-X, r18

	/* If the block being inserted plugged a gab, so was merged with the block
	before and the block after, then it's pxNextFreeBlock pointer will have
	already been set, and should not be set here as that would make it point
	to itself. */
	if( pxIterator != pxBlockToInsert )
    10ae:	ae 17       	cp	r26, r30
    10b0:	bf 07       	cpc	r27, r31
    10b2:	11 f0       	breq	.+4      	; 0x10b8 <prvInsertBlockIntoFreeList+0x94>
	{
		pxIterator->pxNextFreeBlock = pxBlockToInsert;
    10b4:	b1 83       	std	Z+1, r27	; 0x01
    10b6:	a0 83       	st	Z, r26
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
    10b8:	df 91       	pop	r29
    10ba:	cf 91       	pop	r28
    10bc:	08 95       	ret

000010be <pvPortMalloc>:
static size_t xBlockAllocatedBit = 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    10be:	cf 92       	push	r12
    10c0:	df 92       	push	r13
    10c2:	ef 92       	push	r14
    10c4:	ff 92       	push	r15
    10c6:	0f 93       	push	r16
    10c8:	1f 93       	push	r17
    10ca:	cf 93       	push	r28
    10cc:	df 93       	push	r29
    10ce:	ec 01       	movw	r28, r24
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
void *pvReturn = NULL;

	vTaskSuspendAll();
    10d0:	a6 d7       	rcall	.+3916   	; 0x201e <vTaskSuspendAll>
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( pxEnd == NULL )
    10d2:	80 91 0e 04 	lds	r24, 0x040E	; 0x80040e <pxEnd>
    10d6:	90 91 0f 04 	lds	r25, 0x040F	; 0x80040f <pxEnd+0x1>
    10da:	89 2b       	or	r24, r25
    10dc:	99 f5       	brne	.+102    	; 0x1144 <pvPortMalloc+0x86>

	pucAlignedHeap = ( uint8_t * ) ulAddress;

	/* xStart is used to hold a pointer to the first item in the list of free
	blocks.  The void cast is used to prevent compiler warnings. */
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
    10de:	a0 e1       	ldi	r26, 0x10	; 16
    10e0:	b4 e0       	ldi	r27, 0x04	; 4
    10e2:	44 e1       	ldi	r20, 0x14	; 20
    10e4:	54 e0       	ldi	r21, 0x04	; 4
    10e6:	11 96       	adiw	r26, 0x01	; 1
    10e8:	5c 93       	st	X, r21
    10ea:	4e 93       	st	-X, r20
	xStart.xBlockSize = ( size_t ) 0;
    10ec:	13 96       	adiw	r26, 0x03	; 3
    10ee:	1c 92       	st	X, r1
    10f0:	1e 92       	st	-X, r1
    10f2:	12 97       	sbiw	r26, 0x02	; 2

	/* pxEnd is used to mark the end of the list of free blocks and is inserted
	at the end of the heap space. */
	ulAddress = ( ( uint32_t ) pucAlignedHeap ) + xTotalHeapSize;
	ulAddress -= xHeapStructSize;
    10f4:	ca 01       	movw	r24, r20
    10f6:	05 2e       	mov	r0, r21
    10f8:	00 0c       	add	r0, r0
    10fa:	aa 0b       	sbc	r26, r26
    10fc:	bb 0b       	sbc	r27, r27
    10fe:	80 5a       	subi	r24, 0xA0	; 160
    1100:	96 4e       	sbci	r25, 0xE6	; 230
    1102:	af 4f       	sbci	r26, 0xFF	; 255
    1104:	bf 4f       	sbci	r27, 0xFF	; 255
	ulAddress &= ~portBYTE_ALIGNMENT_MASK;
	pxEnd = ( void * ) ulAddress;
    1106:	9c 01       	movw	r18, r24
    1108:	90 93 0f 04 	sts	0x040F, r25	; 0x80040f <pxEnd+0x1>
    110c:	80 93 0e 04 	sts	0x040E, r24	; 0x80040e <pxEnd>
	pxEnd->xBlockSize = 0;
    1110:	fc 01       	movw	r30, r24
    1112:	13 82       	std	Z+3, r1	; 0x03
    1114:	12 82       	std	Z+2, r1	; 0x02
	pxEnd->pxNextFreeBlock = NULL;
    1116:	11 82       	std	Z+1, r1	; 0x01
    1118:	10 82       	st	Z, r1

	/* To start with there is a single free block that is sized to take up the
	entire heap space, minus the space taken by pxEnd. */
	pxFirstFreeBlock = ( void * ) pucAlignedHeap;
	pxFirstFreeBlock->xBlockSize = ulAddress - ( uint32_t ) pxFirstFreeBlock;
    111a:	24 51       	subi	r18, 0x14	; 20
    111c:	34 40       	sbci	r19, 0x04	; 4
    111e:	fa 01       	movw	r30, r20
    1120:	33 83       	std	Z+3, r19	; 0x03
    1122:	22 83       	std	Z+2, r18	; 0x02
	pxFirstFreeBlock->pxNextFreeBlock = pxEnd;
    1124:	91 83       	std	Z+1, r25	; 0x01
    1126:	80 83       	st	Z, r24

	/* Only one block exists - and it covers the entire usable heap space. */
	xMinimumEverFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
    1128:	30 93 0b 04 	sts	0x040B, r19	; 0x80040b <xMinimumEverFreeBytesRemaining+0x1>
    112c:	20 93 0a 04 	sts	0x040A, r18	; 0x80040a <xMinimumEverFreeBytesRemaining>
	xFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
    1130:	30 93 0d 04 	sts	0x040D, r19	; 0x80040d <xFreeBytesRemaining+0x1>
    1134:	20 93 0c 04 	sts	0x040C, r18	; 0x80040c <xFreeBytesRemaining>

	/* Work out the position of the top bit in a size_t variable. */
	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
    1138:	80 e0       	ldi	r24, 0x00	; 0
    113a:	90 e8       	ldi	r25, 0x80	; 128
    113c:	90 93 09 04 	sts	0x0409, r25	; 0x800409 <__data_end+0x1>
    1140:	80 93 08 04 	sts	0x0408, r24	; 0x800408 <__data_end>

		/* Check the requested block size is not so large that the top bit is
		set.  The top bit of the block size member of the BlockLink_t structure
		is used to determine who owns the block - the application or the
		kernel, so it must be free. */
		if( ( xWantedSize & xBlockAllocatedBit ) == 0 )
    1144:	e0 90 08 04 	lds	r14, 0x0408	; 0x800408 <__data_end>
    1148:	f0 90 09 04 	lds	r15, 0x0409	; 0x800409 <__data_end+0x1>
    114c:	c7 01       	movw	r24, r14
    114e:	8c 23       	and	r24, r28
    1150:	9d 23       	and	r25, r29
    1152:	89 2b       	or	r24, r25
    1154:	09 f0       	breq	.+2      	; 0x1158 <pvPortMalloc+0x9a>
    1156:	5e c0       	rjmp	.+188    	; 0x1214 <pvPortMalloc+0x156>
		{
			/* The wanted size is increased so it can contain a BlockLink_t
			structure in addition to the requested amount of bytes. */
			if( xWantedSize > 0 )
    1158:	20 97       	sbiw	r28, 0x00	; 0
    115a:	09 f4       	brne	.+2      	; 0x115e <pvPortMalloc+0xa0>
    115c:	5e c0       	rjmp	.+188    	; 0x121a <pvPortMalloc+0x15c>
			{
				xWantedSize += xHeapStructSize;
    115e:	ae 01       	movw	r20, r28
    1160:	4c 5f       	subi	r20, 0xFC	; 252
    1162:	5f 4f       	sbci	r21, 0xFF	; 255
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
    1164:	09 f4       	brne	.+2      	; 0x1168 <pvPortMalloc+0xaa>
    1166:	5c c0       	rjmp	.+184    	; 0x1220 <pvPortMalloc+0x162>
    1168:	00 91 0c 04 	lds	r16, 0x040C	; 0x80040c <xFreeBytesRemaining>
    116c:	10 91 0d 04 	lds	r17, 0x040D	; 0x80040d <xFreeBytesRemaining+0x1>
    1170:	04 17       	cp	r16, r20
    1172:	15 07       	cpc	r17, r21
    1174:	08 f4       	brcc	.+2      	; 0x1178 <pvPortMalloc+0xba>
    1176:	57 c0       	rjmp	.+174    	; 0x1226 <pvPortMalloc+0x168>
			{
				/* Traverse the list from the start	(lowest address) block until
				one	of adequate size is found. */
				pxPreviousBlock = &xStart;
				pxBlock = xStart.pxNextFreeBlock;
    1178:	c0 91 10 04 	lds	r28, 0x0410	; 0x800410 <xStart>
    117c:	d0 91 11 04 	lds	r29, 0x0411	; 0x800411 <xStart+0x1>

			if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
			{
				/* Traverse the list from the start	(lowest address) block until
				one	of adequate size is found. */
				pxPreviousBlock = &xStart;
    1180:	e0 e1       	ldi	r30, 0x10	; 16
    1182:	f4 e0       	ldi	r31, 0x04	; 4
				pxBlock = xStart.pxNextFreeBlock;
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
    1184:	02 c0       	rjmp	.+4      	; 0x118a <pvPortMalloc+0xcc>
    1186:	fe 01       	movw	r30, r28
				{
					pxPreviousBlock = pxBlock;
					pxBlock = pxBlock->pxNextFreeBlock;
    1188:	e9 01       	movw	r28, r18
			{
				/* Traverse the list from the start	(lowest address) block until
				one	of adequate size is found. */
				pxPreviousBlock = &xStart;
				pxBlock = xStart.pxNextFreeBlock;
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
    118a:	2a 81       	ldd	r18, Y+2	; 0x02
    118c:	3b 81       	ldd	r19, Y+3	; 0x03
    118e:	24 17       	cp	r18, r20
    1190:	35 07       	cpc	r19, r21
    1192:	28 f4       	brcc	.+10     	; 0x119e <pvPortMalloc+0xe0>
    1194:	28 81       	ld	r18, Y
    1196:	39 81       	ldd	r19, Y+1	; 0x01
    1198:	21 15       	cp	r18, r1
    119a:	31 05       	cpc	r19, r1
    119c:	a1 f7       	brne	.-24     	; 0x1186 <pvPortMalloc+0xc8>
					pxBlock = pxBlock->pxNextFreeBlock;
				}

				/* If the end marker was reached then a block of adequate size
				was	not found. */
				if( pxBlock != pxEnd )
    119e:	80 91 0e 04 	lds	r24, 0x040E	; 0x80040e <pxEnd>
    11a2:	90 91 0f 04 	lds	r25, 0x040F	; 0x80040f <pxEnd+0x1>
    11a6:	c8 17       	cp	r28, r24
    11a8:	d9 07       	cpc	r29, r25
    11aa:	09 f4       	brne	.+2      	; 0x11ae <pvPortMalloc+0xf0>
    11ac:	3f c0       	rjmp	.+126    	; 0x122c <pvPortMalloc+0x16e>
				{
					/* Return the memory space pointed to - jumping over the
					BlockLink_t structure at its start. */
					pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );
    11ae:	c0 80       	ld	r12, Z
    11b0:	d1 80       	ldd	r13, Z+1	; 0x01
    11b2:	84 e0       	ldi	r24, 0x04	; 4
    11b4:	c8 0e       	add	r12, r24
    11b6:	d1 1c       	adc	r13, r1

					/* This block is being returned for use so must be taken out
					of the list of free blocks. */
					pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
    11b8:	88 81       	ld	r24, Y
    11ba:	99 81       	ldd	r25, Y+1	; 0x01
    11bc:	91 83       	std	Z+1, r25	; 0x01
    11be:	80 83       	st	Z, r24

					/* If the block is larger than required it can be split into
					two. */
					if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
    11c0:	2a 81       	ldd	r18, Y+2	; 0x02
    11c2:	3b 81       	ldd	r19, Y+3	; 0x03
    11c4:	24 1b       	sub	r18, r20
    11c6:	35 0b       	sbc	r19, r21
    11c8:	29 30       	cpi	r18, 0x09	; 9
    11ca:	31 05       	cpc	r19, r1
    11cc:	48 f0       	brcs	.+18     	; 0x11e0 <pvPortMalloc+0x122>
					{
						/* This block is to be split into two.  Create a new
						block following the number of bytes requested. The void
						cast is used to prevent byte alignment warnings from the
						compiler. */
						pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
    11ce:	ce 01       	movw	r24, r28
    11d0:	84 0f       	add	r24, r20
    11d2:	95 1f       	adc	r25, r21
						configASSERT( ( ( ( uint32_t ) pxNewBlockLink ) & portBYTE_ALIGNMENT_MASK ) == 0 );

						/* Calculate the sizes of two blocks split from the
						single block. */
						pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
    11d4:	fc 01       	movw	r30, r24
    11d6:	33 83       	std	Z+3, r19	; 0x03
    11d8:	22 83       	std	Z+2, r18	; 0x02
						pxBlock->xBlockSize = xWantedSize;
    11da:	5b 83       	std	Y+3, r21	; 0x03

						/* Insert the new block into the list of free blocks. */
						prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
    11dc:	4a 83       	std	Y+2, r20	; 0x02
    11de:	22 df       	rcall	.-444    	; 0x1024 <prvInsertBlockIntoFreeList>
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}

					xFreeBytesRemaining -= pxBlock->xBlockSize;
    11e0:	8a 81       	ldd	r24, Y+2	; 0x02
    11e2:	9b 81       	ldd	r25, Y+3	; 0x03
    11e4:	08 1b       	sub	r16, r24
    11e6:	19 0b       	sbc	r17, r25
    11e8:	10 93 0d 04 	sts	0x040D, r17	; 0x80040d <xFreeBytesRemaining+0x1>
    11ec:	00 93 0c 04 	sts	0x040C, r16	; 0x80040c <xFreeBytesRemaining>

					if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
    11f0:	20 91 0a 04 	lds	r18, 0x040A	; 0x80040a <xMinimumEverFreeBytesRemaining>
    11f4:	30 91 0b 04 	lds	r19, 0x040B	; 0x80040b <xMinimumEverFreeBytesRemaining+0x1>
    11f8:	02 17       	cp	r16, r18
    11fa:	13 07       	cpc	r17, r19
    11fc:	20 f4       	brcc	.+8      	; 0x1206 <pvPortMalloc+0x148>
					{
						xMinimumEverFreeBytesRemaining = xFreeBytesRemaining;
    11fe:	10 93 0b 04 	sts	0x040B, r17	; 0x80040b <xMinimumEverFreeBytesRemaining+0x1>
    1202:	00 93 0a 04 	sts	0x040A, r16	; 0x80040a <xMinimumEverFreeBytesRemaining>
						mtCOVERAGE_TEST_MARKER();
					}

					/* The block is being returned - it is allocated and owned
					by the application and has no "next" block. */
					pxBlock->xBlockSize |= xBlockAllocatedBit;
    1206:	e8 2a       	or	r14, r24
    1208:	f9 2a       	or	r15, r25
    120a:	fb 82       	std	Y+3, r15	; 0x03
    120c:	ea 82       	std	Y+2, r14	; 0x02
					pxBlock->pxNextFreeBlock = NULL;
    120e:	19 82       	std	Y+1, r1	; 0x01
    1210:	18 82       	st	Y, r1
    1212:	0e c0       	rjmp	.+28     	; 0x1230 <pvPortMalloc+0x172>
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
void *pvReturn = NULL;
    1214:	c1 2c       	mov	r12, r1
    1216:	d1 2c       	mov	r13, r1
    1218:	0b c0       	rjmp	.+22     	; 0x1230 <pvPortMalloc+0x172>
    121a:	c1 2c       	mov	r12, r1
    121c:	d1 2c       	mov	r13, r1
    121e:	08 c0       	rjmp	.+16     	; 0x1230 <pvPortMalloc+0x172>
    1220:	c1 2c       	mov	r12, r1
    1222:	d1 2c       	mov	r13, r1
    1224:	05 c0       	rjmp	.+10     	; 0x1230 <pvPortMalloc+0x172>
    1226:	c1 2c       	mov	r12, r1
    1228:	d1 2c       	mov	r13, r1
    122a:	02 c0       	rjmp	.+4      	; 0x1230 <pvPortMalloc+0x172>
    122c:	c1 2c       	mov	r12, r1
			mtCOVERAGE_TEST_MARKER();
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
    122e:	d1 2c       	mov	r13, r1
    1230:	df d7       	rcall	.+4030   	; 0x21f0 <xTaskResumeAll>
	}
	#endif

	configASSERT( ( ( ( uint32_t ) pvReturn ) & portBYTE_ALIGNMENT_MASK ) == 0 );
	return pvReturn;
}
    1232:	c6 01       	movw	r24, r12
    1234:	df 91       	pop	r29
    1236:	cf 91       	pop	r28
    1238:	1f 91       	pop	r17
    123a:	0f 91       	pop	r16
    123c:	ff 90       	pop	r15
    123e:	ef 90       	pop	r14
    1240:	df 90       	pop	r13
    1242:	cf 90       	pop	r12
    1244:	08 95       	ret

00001246 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    1246:	cf 93       	push	r28
    1248:	df 93       	push	r29
uint8_t *puc = ( uint8_t * ) pv;
BlockLink_t *pxLink;

	if( pv != NULL )
    124a:	00 97       	sbiw	r24, 0x00	; 0
    124c:	41 f1       	breq	.+80     	; 0x129e <vPortFree+0x58>

		/* Check the block is actually allocated. */
		configASSERT( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 );
		configASSERT( pxLink->pxNextFreeBlock == NULL );

		if( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 )
    124e:	fc 01       	movw	r30, r24
    1250:	34 97       	sbiw	r30, 0x04	; 4
    1252:	22 81       	ldd	r18, Z+2	; 0x02
    1254:	33 81       	ldd	r19, Z+3	; 0x03
    1256:	40 91 08 04 	lds	r20, 0x0408	; 0x800408 <__data_end>
    125a:	50 91 09 04 	lds	r21, 0x0409	; 0x800409 <__data_end+0x1>
    125e:	b9 01       	movw	r22, r18
    1260:	64 23       	and	r22, r20
    1262:	75 23       	and	r23, r21
    1264:	67 2b       	or	r22, r23
    1266:	d9 f0       	breq	.+54     	; 0x129e <vPortFree+0x58>
		{
			if( pxLink->pxNextFreeBlock == NULL )
    1268:	60 81       	ld	r22, Z
    126a:	71 81       	ldd	r23, Z+1	; 0x01
    126c:	67 2b       	or	r22, r23
    126e:	b9 f4       	brne	.+46     	; 0x129e <vPortFree+0x58>
			{
				/* The block is being returned to the heap - it is no longer
				allocated. */
				pxLink->xBlockSize &= ~xBlockAllocatedBit;
    1270:	ef 01       	movw	r28, r30
    1272:	40 95       	com	r20
    1274:	50 95       	com	r21
    1276:	24 23       	and	r18, r20
    1278:	35 23       	and	r19, r21
    127a:	33 83       	std	Z+3, r19	; 0x03
    127c:	22 83       	std	Z+2, r18	; 0x02

				vTaskSuspendAll();
    127e:	cf d6       	rcall	.+3486   	; 0x201e <vTaskSuspendAll>
				{
					/* Add this block to the list of free blocks. */
					xFreeBytesRemaining += pxLink->xBlockSize;
    1280:	20 91 0c 04 	lds	r18, 0x040C	; 0x80040c <xFreeBytesRemaining>
    1284:	30 91 0d 04 	lds	r19, 0x040D	; 0x80040d <xFreeBytesRemaining+0x1>
    1288:	8a 81       	ldd	r24, Y+2	; 0x02
    128a:	9b 81       	ldd	r25, Y+3	; 0x03
    128c:	82 0f       	add	r24, r18
    128e:	93 1f       	adc	r25, r19
    1290:	90 93 0d 04 	sts	0x040D, r25	; 0x80040d <xFreeBytesRemaining+0x1>
    1294:	80 93 0c 04 	sts	0x040C, r24	; 0x80040c <xFreeBytesRemaining>
					traceFREE( pv, pxLink->xBlockSize );
					prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
    1298:	ce 01       	movw	r24, r28
				}
				( void ) xTaskResumeAll();
    129a:	c4 de       	rcall	.-632    	; 0x1024 <prvInsertBlockIntoFreeList>
    129c:	a9 d7       	rcall	.+3922   	; 0x21f0 <xTaskResumeAll>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
}
    129e:	df 91       	pop	r29
    12a0:	cf 91       	pop	r28
    12a2:	08 95       	ret

000012a4 <pxPortInitialiseStack>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    12a4:	31 e1       	ldi	r19, 0x11	; 17
    12a6:	fc 01       	movw	r30, r24
    12a8:	30 83       	st	Z, r19
    12aa:	31 97       	sbiw	r30, 0x01	; 1
    12ac:	22 e2       	ldi	r18, 0x22	; 34
    12ae:	20 83       	st	Z, r18
    12b0:	31 97       	sbiw	r30, 0x01	; 1
    12b2:	a3 e3       	ldi	r26, 0x33	; 51
    12b4:	a0 83       	st	Z, r26
    12b6:	31 97       	sbiw	r30, 0x01	; 1
    12b8:	60 83       	st	Z, r22
    12ba:	31 97       	sbiw	r30, 0x01	; 1
    12bc:	70 83       	st	Z, r23
    12be:	31 97       	sbiw	r30, 0x01	; 1
    12c0:	10 82       	st	Z, r1
    12c2:	31 97       	sbiw	r30, 0x01	; 1
    12c4:	10 82       	st	Z, r1
    12c6:	31 97       	sbiw	r30, 0x01	; 1
    12c8:	60 e8       	ldi	r22, 0x80	; 128
    12ca:	60 83       	st	Z, r22
    12cc:	31 97       	sbiw	r30, 0x01	; 1
    12ce:	10 82       	st	Z, r1
    12d0:	31 97       	sbiw	r30, 0x01	; 1
    12d2:	10 82       	st	Z, r1
    12d4:	31 97       	sbiw	r30, 0x01	; 1
    12d6:	10 82       	st	Z, r1
    12d8:	31 97       	sbiw	r30, 0x01	; 1
    12da:	62 e0       	ldi	r22, 0x02	; 2
    12dc:	60 83       	st	Z, r22
    12de:	31 97       	sbiw	r30, 0x01	; 1
    12e0:	63 e0       	ldi	r22, 0x03	; 3
    12e2:	60 83       	st	Z, r22
    12e4:	31 97       	sbiw	r30, 0x01	; 1
    12e6:	64 e0       	ldi	r22, 0x04	; 4
    12e8:	60 83       	st	Z, r22
    12ea:	31 97       	sbiw	r30, 0x01	; 1
    12ec:	65 e0       	ldi	r22, 0x05	; 5
    12ee:	60 83       	st	Z, r22
    12f0:	31 97       	sbiw	r30, 0x01	; 1
    12f2:	66 e0       	ldi	r22, 0x06	; 6
    12f4:	60 83       	st	Z, r22
    12f6:	31 97       	sbiw	r30, 0x01	; 1
    12f8:	67 e0       	ldi	r22, 0x07	; 7
    12fa:	60 83       	st	Z, r22
    12fc:	31 97       	sbiw	r30, 0x01	; 1
    12fe:	68 e0       	ldi	r22, 0x08	; 8
    1300:	60 83       	st	Z, r22
    1302:	31 97       	sbiw	r30, 0x01	; 1
    1304:	69 e0       	ldi	r22, 0x09	; 9
    1306:	60 83       	st	Z, r22
    1308:	31 97       	sbiw	r30, 0x01	; 1
    130a:	60 e1       	ldi	r22, 0x10	; 16
    130c:	60 83       	st	Z, r22
    130e:	31 97       	sbiw	r30, 0x01	; 1
    1310:	30 83       	st	Z, r19
    1312:	31 97       	sbiw	r30, 0x01	; 1
    1314:	32 e1       	ldi	r19, 0x12	; 18
    1316:	30 83       	st	Z, r19
    1318:	31 97       	sbiw	r30, 0x01	; 1
    131a:	33 e1       	ldi	r19, 0x13	; 19
    131c:	30 83       	st	Z, r19
    131e:	31 97       	sbiw	r30, 0x01	; 1
    1320:	34 e1       	ldi	r19, 0x14	; 20
    1322:	30 83       	st	Z, r19
    1324:	31 97       	sbiw	r30, 0x01	; 1
    1326:	35 e1       	ldi	r19, 0x15	; 21
    1328:	30 83       	st	Z, r19
    132a:	31 97       	sbiw	r30, 0x01	; 1
    132c:	36 e1       	ldi	r19, 0x16	; 22
    132e:	30 83       	st	Z, r19
    1330:	31 97       	sbiw	r30, 0x01	; 1
    1332:	37 e1       	ldi	r19, 0x17	; 23
    1334:	30 83       	st	Z, r19
    1336:	31 97       	sbiw	r30, 0x01	; 1
    1338:	38 e1       	ldi	r19, 0x18	; 24
    133a:	30 83       	st	Z, r19
    133c:	31 97       	sbiw	r30, 0x01	; 1
    133e:	39 e1       	ldi	r19, 0x19	; 25
    1340:	30 83       	st	Z, r19
    1342:	31 97       	sbiw	r30, 0x01	; 1
    1344:	30 e2       	ldi	r19, 0x20	; 32
    1346:	30 83       	st	Z, r19
    1348:	31 97       	sbiw	r30, 0x01	; 1
    134a:	31 e2       	ldi	r19, 0x21	; 33
    134c:	30 83       	st	Z, r19
    134e:	31 97       	sbiw	r30, 0x01	; 1
    1350:	20 83       	st	Z, r18
    1352:	31 97       	sbiw	r30, 0x01	; 1
    1354:	23 e2       	ldi	r18, 0x23	; 35
    1356:	20 83       	st	Z, r18
    1358:	31 97       	sbiw	r30, 0x01	; 1
    135a:	40 83       	st	Z, r20
    135c:	31 97       	sbiw	r30, 0x01	; 1
    135e:	50 83       	st	Z, r21
    1360:	31 97       	sbiw	r30, 0x01	; 1
    1362:	26 e2       	ldi	r18, 0x26	; 38
    1364:	20 83       	st	Z, r18
    1366:	31 97       	sbiw	r30, 0x01	; 1
    1368:	27 e2       	ldi	r18, 0x27	; 39
    136a:	20 83       	st	Z, r18
    136c:	31 97       	sbiw	r30, 0x01	; 1
    136e:	28 e2       	ldi	r18, 0x28	; 40
    1370:	20 83       	st	Z, r18
    1372:	31 97       	sbiw	r30, 0x01	; 1
    1374:	29 e2       	ldi	r18, 0x29	; 41
    1376:	20 83       	st	Z, r18
    1378:	31 97       	sbiw	r30, 0x01	; 1
    137a:	20 e3       	ldi	r18, 0x30	; 48
    137c:	20 83       	st	Z, r18
    137e:	31 97       	sbiw	r30, 0x01	; 1
    1380:	21 e3       	ldi	r18, 0x31	; 49
    1382:	20 83       	st	Z, r18
    1384:	89 97       	sbiw	r24, 0x29	; 41
    1386:	08 95       	ret

00001388 <xPortStartScheduler>:
    1388:	10 92 89 00 	sts	0x0089, r1	; 0x800089 <__TEXT_REGION_LENGTH__+0x700089>
    138c:	89 ef       	ldi	r24, 0xF9	; 249
    138e:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__TEXT_REGION_LENGTH__+0x700088>
    1392:	10 92 80 00 	sts	0x0080, r1	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
    1396:	8b e0       	ldi	r24, 0x0B	; 11
    1398:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__TEXT_REGION_LENGTH__+0x700081>
    139c:	ef e6       	ldi	r30, 0x6F	; 111
    139e:	f0 e0       	ldi	r31, 0x00	; 0
    13a0:	80 81       	ld	r24, Z
    13a2:	82 60       	ori	r24, 0x02	; 2
    13a4:	80 83       	st	Z, r24
    13a6:	a0 91 fd 1d 	lds	r26, 0x1DFD	; 0x801dfd <pxCurrentTCB>
    13aa:	b0 91 fe 1d 	lds	r27, 0x1DFE	; 0x801dfe <pxCurrentTCB+0x1>
    13ae:	cd 91       	ld	r28, X+
    13b0:	cd bf       	out	0x3d, r28	; 61
    13b2:	dd 91       	ld	r29, X+
    13b4:	de bf       	out	0x3e, r29	; 62
    13b6:	ff 91       	pop	r31
    13b8:	ef 91       	pop	r30
    13ba:	df 91       	pop	r29
    13bc:	cf 91       	pop	r28
    13be:	bf 91       	pop	r27
    13c0:	af 91       	pop	r26
    13c2:	9f 91       	pop	r25
    13c4:	8f 91       	pop	r24
    13c6:	7f 91       	pop	r23
    13c8:	6f 91       	pop	r22
    13ca:	5f 91       	pop	r21
    13cc:	4f 91       	pop	r20
    13ce:	3f 91       	pop	r19
    13d0:	2f 91       	pop	r18
    13d2:	1f 91       	pop	r17
    13d4:	0f 91       	pop	r16
    13d6:	ff 90       	pop	r15
    13d8:	ef 90       	pop	r14
    13da:	df 90       	pop	r13
    13dc:	cf 90       	pop	r12
    13de:	bf 90       	pop	r11
    13e0:	af 90       	pop	r10
    13e2:	9f 90       	pop	r9
    13e4:	8f 90       	pop	r8
    13e6:	7f 90       	pop	r7
    13e8:	6f 90       	pop	r6
    13ea:	5f 90       	pop	r5
    13ec:	4f 90       	pop	r4
    13ee:	3f 90       	pop	r3
    13f0:	2f 90       	pop	r2
    13f2:	1f 90       	pop	r1
    13f4:	0f 90       	pop	r0
    13f6:	0c be       	out	0x3c, r0	; 60
    13f8:	0f 90       	pop	r0
    13fa:	0b be       	out	0x3b, r0	; 59
    13fc:	0f 90       	pop	r0
    13fe:	0f be       	out	0x3f, r0	; 63
    1400:	0f 90       	pop	r0
    1402:	08 95       	ret
    1404:	81 e0       	ldi	r24, 0x01	; 1
    1406:	08 95       	ret

00001408 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    1408:	0f 92       	push	r0
    140a:	0f b6       	in	r0, 0x3f	; 63
    140c:	f8 94       	cli
    140e:	0f 92       	push	r0
    1410:	0b b6       	in	r0, 0x3b	; 59
    1412:	0f 92       	push	r0
    1414:	0c b6       	in	r0, 0x3c	; 60
    1416:	0f 92       	push	r0
    1418:	1f 92       	push	r1
    141a:	11 24       	eor	r1, r1
    141c:	2f 92       	push	r2
    141e:	3f 92       	push	r3
    1420:	4f 92       	push	r4
    1422:	5f 92       	push	r5
    1424:	6f 92       	push	r6
    1426:	7f 92       	push	r7
    1428:	8f 92       	push	r8
    142a:	9f 92       	push	r9
    142c:	af 92       	push	r10
    142e:	bf 92       	push	r11
    1430:	cf 92       	push	r12
    1432:	df 92       	push	r13
    1434:	ef 92       	push	r14
    1436:	ff 92       	push	r15
    1438:	0f 93       	push	r16
    143a:	1f 93       	push	r17
    143c:	2f 93       	push	r18
    143e:	3f 93       	push	r19
    1440:	4f 93       	push	r20
    1442:	5f 93       	push	r21
    1444:	6f 93       	push	r22
    1446:	7f 93       	push	r23
    1448:	8f 93       	push	r24
    144a:	9f 93       	push	r25
    144c:	af 93       	push	r26
    144e:	bf 93       	push	r27
    1450:	cf 93       	push	r28
    1452:	df 93       	push	r29
    1454:	ef 93       	push	r30
    1456:	ff 93       	push	r31
    1458:	a0 91 fd 1d 	lds	r26, 0x1DFD	; 0x801dfd <pxCurrentTCB>
    145c:	b0 91 fe 1d 	lds	r27, 0x1DFE	; 0x801dfe <pxCurrentTCB+0x1>
    1460:	0d b6       	in	r0, 0x3d	; 61
    1462:	0d 92       	st	X+, r0
    1464:	0e b6       	in	r0, 0x3e	; 62
    1466:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    1468:	90 d7       	rcall	.+3872   	; 0x238a <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    146a:	a0 91 fd 1d 	lds	r26, 0x1DFD	; 0x801dfd <pxCurrentTCB>
    146e:	b0 91 fe 1d 	lds	r27, 0x1DFE	; 0x801dfe <pxCurrentTCB+0x1>
    1472:	cd 91       	ld	r28, X+
    1474:	cd bf       	out	0x3d, r28	; 61
    1476:	dd 91       	ld	r29, X+
    1478:	de bf       	out	0x3e, r29	; 62
    147a:	ff 91       	pop	r31
    147c:	ef 91       	pop	r30
    147e:	df 91       	pop	r29
    1480:	cf 91       	pop	r28
    1482:	bf 91       	pop	r27
    1484:	af 91       	pop	r26
    1486:	9f 91       	pop	r25
    1488:	8f 91       	pop	r24
    148a:	7f 91       	pop	r23
    148c:	6f 91       	pop	r22
    148e:	5f 91       	pop	r21
    1490:	4f 91       	pop	r20
    1492:	3f 91       	pop	r19
    1494:	2f 91       	pop	r18
    1496:	1f 91       	pop	r17
    1498:	0f 91       	pop	r16
    149a:	ff 90       	pop	r15
    149c:	ef 90       	pop	r14
    149e:	df 90       	pop	r13
    14a0:	cf 90       	pop	r12
    14a2:	bf 90       	pop	r11
    14a4:	af 90       	pop	r10
    14a6:	9f 90       	pop	r9
    14a8:	8f 90       	pop	r8
    14aa:	7f 90       	pop	r7
    14ac:	6f 90       	pop	r6
    14ae:	5f 90       	pop	r5
    14b0:	4f 90       	pop	r4
    14b2:	3f 90       	pop	r3
    14b4:	2f 90       	pop	r2
    14b6:	1f 90       	pop	r1
    14b8:	0f 90       	pop	r0
    14ba:	0c be       	out	0x3c, r0	; 60
    14bc:	0f 90       	pop	r0
    14be:	0b be       	out	0x3b, r0	; 59
    14c0:	0f 90       	pop	r0
    14c2:	0f be       	out	0x3f, r0	; 63
    14c4:	0f 90       	pop	r0

	asm volatile ( "ret" );
    14c6:	08 95       	ret

000014c8 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    14c8:	0f 92       	push	r0
    14ca:	0f b6       	in	r0, 0x3f	; 63
    14cc:	f8 94       	cli
    14ce:	0f 92       	push	r0
    14d0:	0b b6       	in	r0, 0x3b	; 59
    14d2:	0f 92       	push	r0
    14d4:	0c b6       	in	r0, 0x3c	; 60
    14d6:	0f 92       	push	r0
    14d8:	1f 92       	push	r1
    14da:	11 24       	eor	r1, r1
    14dc:	2f 92       	push	r2
    14de:	3f 92       	push	r3
    14e0:	4f 92       	push	r4
    14e2:	5f 92       	push	r5
    14e4:	6f 92       	push	r6
    14e6:	7f 92       	push	r7
    14e8:	8f 92       	push	r8
    14ea:	9f 92       	push	r9
    14ec:	af 92       	push	r10
    14ee:	bf 92       	push	r11
    14f0:	cf 92       	push	r12
    14f2:	df 92       	push	r13
    14f4:	ef 92       	push	r14
    14f6:	ff 92       	push	r15
    14f8:	0f 93       	push	r16
    14fa:	1f 93       	push	r17
    14fc:	2f 93       	push	r18
    14fe:	3f 93       	push	r19
    1500:	4f 93       	push	r20
    1502:	5f 93       	push	r21
    1504:	6f 93       	push	r22
    1506:	7f 93       	push	r23
    1508:	8f 93       	push	r24
    150a:	9f 93       	push	r25
    150c:	af 93       	push	r26
    150e:	bf 93       	push	r27
    1510:	cf 93       	push	r28
    1512:	df 93       	push	r29
    1514:	ef 93       	push	r30
    1516:	ff 93       	push	r31
    1518:	a0 91 fd 1d 	lds	r26, 0x1DFD	; 0x801dfd <pxCurrentTCB>
    151c:	b0 91 fe 1d 	lds	r27, 0x1DFE	; 0x801dfe <pxCurrentTCB+0x1>
    1520:	0d b6       	in	r0, 0x3d	; 61
    1522:	0d 92       	st	X+, r0
    1524:	0e b6       	in	r0, 0x3e	; 62
    1526:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
    1528:	8e d5       	rcall	.+2844   	; 0x2046 <xTaskIncrementTick>
    152a:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
    152c:	2e d7       	rcall	.+3676   	; 0x238a <vTaskSwitchContext>
    152e:	a0 91 fd 1d 	lds	r26, 0x1DFD	; 0x801dfd <pxCurrentTCB>
	}
	portRESTORE_CONTEXT();
    1532:	b0 91 fe 1d 	lds	r27, 0x1DFE	; 0x801dfe <pxCurrentTCB+0x1>
    1536:	cd 91       	ld	r28, X+
    1538:	cd bf       	out	0x3d, r28	; 61
    153a:	dd 91       	ld	r29, X+
    153c:	de bf       	out	0x3e, r29	; 62
    153e:	ff 91       	pop	r31
    1540:	ef 91       	pop	r30
    1542:	df 91       	pop	r29
    1544:	cf 91       	pop	r28
    1546:	bf 91       	pop	r27
    1548:	af 91       	pop	r26
    154a:	9f 91       	pop	r25
    154c:	8f 91       	pop	r24
    154e:	7f 91       	pop	r23
    1550:	6f 91       	pop	r22
    1552:	5f 91       	pop	r21
    1554:	4f 91       	pop	r20
    1556:	3f 91       	pop	r19
    1558:	2f 91       	pop	r18
    155a:	1f 91       	pop	r17
    155c:	0f 91       	pop	r16
    155e:	ff 90       	pop	r15
    1560:	ef 90       	pop	r14
    1562:	df 90       	pop	r13
    1564:	cf 90       	pop	r12
    1566:	bf 90       	pop	r11
    1568:	af 90       	pop	r10
    156a:	9f 90       	pop	r9
    156c:	8f 90       	pop	r8
    156e:	7f 90       	pop	r7
    1570:	6f 90       	pop	r6
    1572:	5f 90       	pop	r5
    1574:	4f 90       	pop	r4
    1576:	3f 90       	pop	r3
    1578:	2f 90       	pop	r2
    157a:	1f 90       	pop	r1
    157c:	0f 90       	pop	r0
    157e:	0c be       	out	0x3c, r0	; 60
    1580:	0f 90       	pop	r0
    1582:	0b be       	out	0x3b, r0	; 59
    1584:	0f 90       	pop	r0
    1586:	0f be       	out	0x3f, r0	; 63
    1588:	0f 90       	pop	r0
    158a:	08 95       	ret

0000158c <__vector_17>:

	asm volatile ( "ret" );
    158c:	9d df       	rcall	.-198    	; 0x14c8 <vPortYieldFromTick>
	 */
	ISR(TIMER1_COMPA_vect) __attribute__ ( ( signal, naked ) );
	ISR(TIMER1_COMPA_vect)
	{
		vPortYieldFromTick();
		asm volatile ( "reti" );
    158e:	18 95       	reti

00001590 <prvCopyDataToQueue>:
		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
	}
	taskEXIT_CRITICAL();

	return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    1590:	0f 93       	push	r16
    1592:	1f 93       	push	r17
    1594:	cf 93       	push	r28
    1596:	df 93       	push	r29
    1598:	ec 01       	movw	r28, r24
    159a:	04 2f       	mov	r16, r20
    159c:	1e 8d       	ldd	r17, Y+30	; 0x1e
    159e:	48 a1       	ldd	r20, Y+32	; 0x20
    15a0:	41 11       	cpse	r20, r1
    15a2:	0c c0       	rjmp	.+24     	; 0x15bc <prvCopyDataToQueue+0x2c>
    15a4:	88 81       	ld	r24, Y
    15a6:	99 81       	ldd	r25, Y+1	; 0x01
    15a8:	89 2b       	or	r24, r25
    15aa:	09 f0       	breq	.+2      	; 0x15ae <prvCopyDataToQueue+0x1e>
    15ac:	42 c0       	rjmp	.+132    	; 0x1632 <prvCopyDataToQueue+0xa2>
    15ae:	8a 81       	ldd	r24, Y+2	; 0x02
    15b0:	9b 81       	ldd	r25, Y+3	; 0x03
    15b2:	0e 94 4e 13 	call	0x269c	; 0x269c <xTaskPriorityDisinherit>
    15b6:	1b 82       	std	Y+3, r1	; 0x03
    15b8:	1a 82       	std	Y+2, r1	; 0x02
    15ba:	42 c0       	rjmp	.+132    	; 0x1640 <prvCopyDataToQueue+0xb0>
    15bc:	01 11       	cpse	r16, r1
    15be:	17 c0       	rjmp	.+46     	; 0x15ee <prvCopyDataToQueue+0x5e>
    15c0:	50 e0       	ldi	r21, 0x00	; 0
    15c2:	8c 81       	ldd	r24, Y+4	; 0x04
    15c4:	9d 81       	ldd	r25, Y+5	; 0x05
    15c6:	0e 94 3b 2c 	call	0x5876	; 0x5876 <memcpy>
    15ca:	28 a1       	ldd	r18, Y+32	; 0x20
    15cc:	8c 81       	ldd	r24, Y+4	; 0x04
    15ce:	9d 81       	ldd	r25, Y+5	; 0x05
    15d0:	82 0f       	add	r24, r18
    15d2:	91 1d       	adc	r25, r1
    15d4:	9d 83       	std	Y+5, r25	; 0x05
    15d6:	8c 83       	std	Y+4, r24	; 0x04
    15d8:	2a 81       	ldd	r18, Y+2	; 0x02
    15da:	3b 81       	ldd	r19, Y+3	; 0x03
    15dc:	82 17       	cp	r24, r18
    15de:	93 07       	cpc	r25, r19
    15e0:	50 f1       	brcs	.+84     	; 0x1636 <prvCopyDataToQueue+0xa6>
    15e2:	88 81       	ld	r24, Y
    15e4:	99 81       	ldd	r25, Y+1	; 0x01
    15e6:	9d 83       	std	Y+5, r25	; 0x05
    15e8:	8c 83       	std	Y+4, r24	; 0x04
    15ea:	80 e0       	ldi	r24, 0x00	; 0
    15ec:	29 c0       	rjmp	.+82     	; 0x1640 <prvCopyDataToQueue+0xb0>
    15ee:	50 e0       	ldi	r21, 0x00	; 0
    15f0:	8e 81       	ldd	r24, Y+6	; 0x06
    15f2:	9f 81       	ldd	r25, Y+7	; 0x07
    15f4:	0e 94 3b 2c 	call	0x5876	; 0x5876 <memcpy>
    15f8:	88 a1       	ldd	r24, Y+32	; 0x20
    15fa:	90 e0       	ldi	r25, 0x00	; 0
    15fc:	91 95       	neg	r25
    15fe:	81 95       	neg	r24
    1600:	91 09       	sbc	r25, r1
    1602:	2e 81       	ldd	r18, Y+6	; 0x06
    1604:	3f 81       	ldd	r19, Y+7	; 0x07
    1606:	28 0f       	add	r18, r24
    1608:	39 1f       	adc	r19, r25
    160a:	3f 83       	std	Y+7, r19	; 0x07
    160c:	2e 83       	std	Y+6, r18	; 0x06
    160e:	48 81       	ld	r20, Y
    1610:	59 81       	ldd	r21, Y+1	; 0x01
    1612:	24 17       	cp	r18, r20
    1614:	35 07       	cpc	r19, r21
    1616:	30 f4       	brcc	.+12     	; 0x1624 <prvCopyDataToQueue+0x94>
    1618:	2a 81       	ldd	r18, Y+2	; 0x02
    161a:	3b 81       	ldd	r19, Y+3	; 0x03
    161c:	82 0f       	add	r24, r18
    161e:	93 1f       	adc	r25, r19
    1620:	9f 83       	std	Y+7, r25	; 0x07
    1622:	8e 83       	std	Y+6, r24	; 0x06
    1624:	02 30       	cpi	r16, 0x02	; 2
    1626:	49 f4       	brne	.+18     	; 0x163a <prvCopyDataToQueue+0xaa>
    1628:	11 23       	and	r17, r17
    162a:	49 f0       	breq	.+18     	; 0x163e <prvCopyDataToQueue+0xae>
    162c:	11 50       	subi	r17, 0x01	; 1
    162e:	80 e0       	ldi	r24, 0x00	; 0
    1630:	07 c0       	rjmp	.+14     	; 0x1640 <prvCopyDataToQueue+0xb0>
    1632:	80 e0       	ldi	r24, 0x00	; 0
    1634:	05 c0       	rjmp	.+10     	; 0x1640 <prvCopyDataToQueue+0xb0>
    1636:	80 e0       	ldi	r24, 0x00	; 0
    1638:	03 c0       	rjmp	.+6      	; 0x1640 <prvCopyDataToQueue+0xb0>
    163a:	80 e0       	ldi	r24, 0x00	; 0
    163c:	01 c0       	rjmp	.+2      	; 0x1640 <prvCopyDataToQueue+0xb0>
    163e:	80 e0       	ldi	r24, 0x00	; 0
    1640:	1f 5f       	subi	r17, 0xFF	; 255
    1642:	1e 8f       	std	Y+30, r17	; 0x1e
    1644:	df 91       	pop	r29
    1646:	cf 91       	pop	r28
    1648:	1f 91       	pop	r17
    164a:	0f 91       	pop	r16
    164c:	08 95       	ret

0000164e <prvCopyDataFromQueue>:
    164e:	fc 01       	movw	r30, r24
    1650:	40 a1       	ldd	r20, Z+32	; 0x20
    1652:	44 23       	and	r20, r20
    1654:	a9 f0       	breq	.+42     	; 0x1680 <prvCopyDataFromQueue+0x32>
    1656:	50 e0       	ldi	r21, 0x00	; 0
    1658:	26 81       	ldd	r18, Z+6	; 0x06
    165a:	37 81       	ldd	r19, Z+7	; 0x07
    165c:	24 0f       	add	r18, r20
    165e:	35 1f       	adc	r19, r21
    1660:	37 83       	std	Z+7, r19	; 0x07
    1662:	26 83       	std	Z+6, r18	; 0x06
    1664:	82 81       	ldd	r24, Z+2	; 0x02
    1666:	93 81       	ldd	r25, Z+3	; 0x03
    1668:	28 17       	cp	r18, r24
    166a:	39 07       	cpc	r19, r25
    166c:	20 f0       	brcs	.+8      	; 0x1676 <prvCopyDataFromQueue+0x28>
    166e:	80 81       	ld	r24, Z
    1670:	91 81       	ldd	r25, Z+1	; 0x01
    1672:	97 83       	std	Z+7, r25	; 0x07
    1674:	86 83       	std	Z+6, r24	; 0x06
    1676:	cb 01       	movw	r24, r22
    1678:	66 81       	ldd	r22, Z+6	; 0x06
    167a:	77 81       	ldd	r23, Z+7	; 0x07
    167c:	0c 94 3b 2c 	jmp	0x5876	; 0x5876 <memcpy>
    1680:	08 95       	ret

00001682 <prvUnlockQueue>:
    1682:	ef 92       	push	r14
    1684:	ff 92       	push	r15
    1686:	0f 93       	push	r16
    1688:	1f 93       	push	r17
    168a:	cf 93       	push	r28
    168c:	8c 01       	movw	r16, r24
    168e:	0f b6       	in	r0, 0x3f	; 63
    1690:	f8 94       	cli
    1692:	0f 92       	push	r0
    1694:	fc 01       	movw	r30, r24
    1696:	c2 a1       	ldd	r28, Z+34	; 0x22
    1698:	1c 16       	cp	r1, r28
    169a:	9c f4       	brge	.+38     	; 0x16c2 <prvUnlockQueue+0x40>
    169c:	83 89       	ldd	r24, Z+19	; 0x13
    169e:	81 11       	cpse	r24, r1
    16a0:	06 c0       	rjmp	.+12     	; 0x16ae <prvUnlockQueue+0x2c>
    16a2:	0f c0       	rjmp	.+30     	; 0x16c2 <prvUnlockQueue+0x40>
    16a4:	f8 01       	movw	r30, r16
    16a6:	83 89       	ldd	r24, Z+19	; 0x13
    16a8:	81 11       	cpse	r24, r1
    16aa:	05 c0       	rjmp	.+10     	; 0x16b6 <prvUnlockQueue+0x34>
    16ac:	0a c0       	rjmp	.+20     	; 0x16c2 <prvUnlockQueue+0x40>
    16ae:	78 01       	movw	r14, r16
    16b0:	f3 e1       	ldi	r31, 0x13	; 19
    16b2:	ef 0e       	add	r14, r31
    16b4:	f1 1c       	adc	r15, r1
    16b6:	c7 01       	movw	r24, r14
    16b8:	d6 d6       	rcall	.+3500   	; 0x2466 <xTaskRemoveFromEventList>
    16ba:	81 11       	cpse	r24, r1
    16bc:	8d d7       	rcall	.+3866   	; 0x25d8 <vTaskMissedYield>
    16be:	c1 50       	subi	r28, 0x01	; 1
    16c0:	89 f7       	brne	.-30     	; 0x16a4 <prvUnlockQueue+0x22>
    16c2:	8f ef       	ldi	r24, 0xFF	; 255
    16c4:	f8 01       	movw	r30, r16
    16c6:	82 a3       	std	Z+34, r24	; 0x22
    16c8:	0f 90       	pop	r0
    16ca:	0f be       	out	0x3f, r0	; 63
    16cc:	0f b6       	in	r0, 0x3f	; 63
    16ce:	f8 94       	cli
    16d0:	0f 92       	push	r0
    16d2:	c1 a1       	ldd	r28, Z+33	; 0x21
    16d4:	1c 16       	cp	r1, r28
    16d6:	9c f4       	brge	.+38     	; 0x16fe <prvUnlockQueue+0x7c>
    16d8:	80 85       	ldd	r24, Z+8	; 0x08
    16da:	81 11       	cpse	r24, r1
    16dc:	06 c0       	rjmp	.+12     	; 0x16ea <prvUnlockQueue+0x68>
    16de:	0f c0       	rjmp	.+30     	; 0x16fe <prvUnlockQueue+0x7c>
    16e0:	f8 01       	movw	r30, r16
    16e2:	80 85       	ldd	r24, Z+8	; 0x08
    16e4:	81 11       	cpse	r24, r1
    16e6:	05 c0       	rjmp	.+10     	; 0x16f2 <prvUnlockQueue+0x70>
    16e8:	0a c0       	rjmp	.+20     	; 0x16fe <prvUnlockQueue+0x7c>
    16ea:	78 01       	movw	r14, r16
    16ec:	f8 e0       	ldi	r31, 0x08	; 8
    16ee:	ef 0e       	add	r14, r31
    16f0:	f1 1c       	adc	r15, r1
    16f2:	c7 01       	movw	r24, r14
    16f4:	b8 d6       	rcall	.+3440   	; 0x2466 <xTaskRemoveFromEventList>
    16f6:	81 11       	cpse	r24, r1
    16f8:	6f d7       	rcall	.+3806   	; 0x25d8 <vTaskMissedYield>
    16fa:	c1 50       	subi	r28, 0x01	; 1
    16fc:	89 f7       	brne	.-30     	; 0x16e0 <prvUnlockQueue+0x5e>
    16fe:	8f ef       	ldi	r24, 0xFF	; 255
    1700:	f8 01       	movw	r30, r16
    1702:	81 a3       	std	Z+33, r24	; 0x21
    1704:	0f 90       	pop	r0
    1706:	0f be       	out	0x3f, r0	; 63
    1708:	cf 91       	pop	r28
    170a:	1f 91       	pop	r17
    170c:	0f 91       	pop	r16
    170e:	ff 90       	pop	r15
    1710:	ef 90       	pop	r14
    1712:	08 95       	ret

00001714 <xQueueGenericReset>:
    1714:	cf 93       	push	r28
    1716:	df 93       	push	r29
    1718:	ec 01       	movw	r28, r24
    171a:	0f b6       	in	r0, 0x3f	; 63
    171c:	f8 94       	cli
    171e:	0f 92       	push	r0
    1720:	48 81       	ld	r20, Y
    1722:	59 81       	ldd	r21, Y+1	; 0x01
    1724:	28 a1       	ldd	r18, Y+32	; 0x20
    1726:	30 e0       	ldi	r19, 0x00	; 0
    1728:	7f 8d       	ldd	r23, Y+31	; 0x1f
    172a:	72 9f       	mul	r23, r18
    172c:	c0 01       	movw	r24, r0
    172e:	73 9f       	mul	r23, r19
    1730:	90 0d       	add	r25, r0
    1732:	11 24       	eor	r1, r1
    1734:	fa 01       	movw	r30, r20
    1736:	e8 0f       	add	r30, r24
    1738:	f9 1f       	adc	r31, r25
    173a:	fb 83       	std	Y+3, r31	; 0x03
    173c:	ea 83       	std	Y+2, r30	; 0x02
    173e:	1e 8e       	std	Y+30, r1	; 0x1e
    1740:	5d 83       	std	Y+5, r21	; 0x05
    1742:	4c 83       	std	Y+4, r20	; 0x04
    1744:	82 1b       	sub	r24, r18
    1746:	93 0b       	sbc	r25, r19
    1748:	84 0f       	add	r24, r20
    174a:	95 1f       	adc	r25, r21
    174c:	9f 83       	std	Y+7, r25	; 0x07
    174e:	8e 83       	std	Y+6, r24	; 0x06
    1750:	8f ef       	ldi	r24, 0xFF	; 255
    1752:	89 a3       	std	Y+33, r24	; 0x21
    1754:	8a a3       	std	Y+34, r24	; 0x22
    1756:	61 11       	cpse	r22, r1
    1758:	0a c0       	rjmp	.+20     	; 0x176e <xQueueGenericReset+0x5a>
    175a:	88 85       	ldd	r24, Y+8	; 0x08
    175c:	88 23       	and	r24, r24
    175e:	69 f0       	breq	.+26     	; 0x177a <xQueueGenericReset+0x66>
    1760:	ce 01       	movw	r24, r28
    1762:	08 96       	adiw	r24, 0x08	; 8
    1764:	80 d6       	rcall	.+3328   	; 0x2466 <xTaskRemoveFromEventList>
    1766:	88 23       	and	r24, r24
    1768:	41 f0       	breq	.+16     	; 0x177a <xQueueGenericReset+0x66>
    176a:	4e de       	rcall	.-868    	; 0x1408 <vPortYield>
    176c:	06 c0       	rjmp	.+12     	; 0x177a <xQueueGenericReset+0x66>
    176e:	ce 01       	movw	r24, r28
    1770:	08 96       	adiw	r24, 0x08	; 8
    1772:	bf db       	rcall	.-2178   	; 0xef2 <vListInitialise>
    1774:	ce 01       	movw	r24, r28
    1776:	43 96       	adiw	r24, 0x13	; 19
    1778:	bc db       	rcall	.-2184   	; 0xef2 <vListInitialise>
    177a:	0f 90       	pop	r0
    177c:	0f be       	out	0x3f, r0	; 63
    177e:	81 e0       	ldi	r24, 0x01	; 1
    1780:	df 91       	pop	r29
    1782:	cf 91       	pop	r28
    1784:	08 95       	ret

00001786 <xQueueGenericCreate>:
    1786:	ff 92       	push	r15
    1788:	0f 93       	push	r16
    178a:	1f 93       	push	r17
    178c:	cf 93       	push	r28
    178e:	df 93       	push	r29
    1790:	08 2f       	mov	r16, r24
    1792:	16 2f       	mov	r17, r22
    1794:	f4 2e       	mov	r15, r20
    1796:	66 23       	and	r22, r22
    1798:	b9 f0       	breq	.+46     	; 0x17c8 <xQueueGenericCreate+0x42>
    179a:	86 9f       	mul	r24, r22
    179c:	c0 01       	movw	r24, r0
    179e:	11 24       	eor	r1, r1
    17a0:	85 96       	adiw	r24, 0x25	; 37
    17a2:	8d dc       	rcall	.-1766   	; 0x10be <pvPortMalloc>
    17a4:	ec 01       	movw	r28, r24
    17a6:	00 97       	sbiw	r24, 0x00	; 0
    17a8:	41 f4       	brne	.+16     	; 0x17ba <xQueueGenericCreate+0x34>
    17aa:	14 c0       	rjmp	.+40     	; 0x17d4 <xQueueGenericCreate+0x4e>
    17ac:	0f 8f       	std	Y+31, r16	; 0x1f
    17ae:	18 a3       	std	Y+32, r17	; 0x20
    17b0:	61 e0       	ldi	r22, 0x01	; 1
    17b2:	ce 01       	movw	r24, r28
    17b4:	af df       	rcall	.-162    	; 0x1714 <xQueueGenericReset>
    17b6:	fc a2       	std	Y+36, r15	; 0x24
    17b8:	0d c0       	rjmp	.+26     	; 0x17d4 <xQueueGenericCreate+0x4e>
    17ba:	85 96       	adiw	r24, 0x25	; 37
    17bc:	99 83       	std	Y+1, r25	; 0x01
    17be:	88 83       	st	Y, r24
    17c0:	f5 cf       	rjmp	.-22     	; 0x17ac <xQueueGenericCreate+0x26>
    17c2:	d9 83       	std	Y+1, r29	; 0x01
    17c4:	c8 83       	st	Y, r28
    17c6:	f2 cf       	rjmp	.-28     	; 0x17ac <xQueueGenericCreate+0x26>
    17c8:	85 e2       	ldi	r24, 0x25	; 37
    17ca:	90 e0       	ldi	r25, 0x00	; 0
    17cc:	78 dc       	rcall	.-1808   	; 0x10be <pvPortMalloc>
    17ce:	ec 01       	movw	r28, r24
    17d0:	89 2b       	or	r24, r25
    17d2:	b9 f7       	brne	.-18     	; 0x17c2 <xQueueGenericCreate+0x3c>
    17d4:	ce 01       	movw	r24, r28
    17d6:	df 91       	pop	r29
    17d8:	cf 91       	pop	r28
    17da:	1f 91       	pop	r17
    17dc:	0f 91       	pop	r16
    17de:	ff 90       	pop	r15
    17e0:	08 95       	ret

000017e2 <xQueueGenericSend>:
    17e2:	9f 92       	push	r9
    17e4:	af 92       	push	r10
    17e6:	bf 92       	push	r11
    17e8:	cf 92       	push	r12
    17ea:	df 92       	push	r13
    17ec:	ef 92       	push	r14
    17ee:	ff 92       	push	r15
    17f0:	0f 93       	push	r16
    17f2:	1f 93       	push	r17
    17f4:	cf 93       	push	r28
    17f6:	df 93       	push	r29
    17f8:	cd b7       	in	r28, 0x3d	; 61
    17fa:	de b7       	in	r29, 0x3e	; 62
    17fc:	29 97       	sbiw	r28, 0x09	; 9
    17fe:	0f b6       	in	r0, 0x3f	; 63
    1800:	f8 94       	cli
    1802:	de bf       	out	0x3e, r29	; 62
    1804:	0f be       	out	0x3f, r0	; 63
    1806:	cd bf       	out	0x3d, r28	; 61
    1808:	7c 01       	movw	r14, r24
    180a:	5b 01       	movw	r10, r22
    180c:	2e 83       	std	Y+6, r18	; 0x06
    180e:	3f 83       	std	Y+7, r19	; 0x07
    1810:	48 87       	std	Y+8, r20	; 0x08
    1812:	59 87       	std	Y+9, r21	; 0x09
    1814:	10 e0       	ldi	r17, 0x00	; 0
    1816:	99 24       	eor	r9, r9
    1818:	93 94       	inc	r9
    181a:	6c 01       	movw	r12, r24
    181c:	88 e0       	ldi	r24, 0x08	; 8
    181e:	c8 0e       	add	r12, r24
    1820:	d1 1c       	adc	r13, r1
    1822:	0f b6       	in	r0, 0x3f	; 63
    1824:	f8 94       	cli
    1826:	0f 92       	push	r0
    1828:	f7 01       	movw	r30, r14
    182a:	96 8d       	ldd	r25, Z+30	; 0x1e
    182c:	87 8d       	ldd	r24, Z+31	; 0x1f
    182e:	98 17       	cp	r25, r24
    1830:	10 f0       	brcs	.+4      	; 0x1836 <xQueueGenericSend+0x54>
    1832:	02 30       	cpi	r16, 0x02	; 2
    1834:	a9 f4       	brne	.+42     	; 0x1860 <xQueueGenericSend+0x7e>
    1836:	40 2f       	mov	r20, r16
    1838:	b5 01       	movw	r22, r10
    183a:	c7 01       	movw	r24, r14
    183c:	a9 de       	rcall	.-686    	; 0x1590 <prvCopyDataToQueue>
    183e:	f7 01       	movw	r30, r14
    1840:	93 89       	ldd	r25, Z+19	; 0x13
    1842:	99 23       	and	r25, r25
    1844:	39 f0       	breq	.+14     	; 0x1854 <xQueueGenericSend+0x72>
    1846:	c7 01       	movw	r24, r14
    1848:	43 96       	adiw	r24, 0x13	; 19
    184a:	0d d6       	rcall	.+3098   	; 0x2466 <xTaskRemoveFromEventList>
    184c:	88 23       	and	r24, r24
    184e:	21 f0       	breq	.+8      	; 0x1858 <xQueueGenericSend+0x76>
    1850:	db dd       	rcall	.-1098   	; 0x1408 <vPortYield>
    1852:	02 c0       	rjmp	.+4      	; 0x1858 <xQueueGenericSend+0x76>
    1854:	81 11       	cpse	r24, r1
    1856:	d8 dd       	rcall	.-1104   	; 0x1408 <vPortYield>
    1858:	0f 90       	pop	r0
    185a:	0f be       	out	0x3f, r0	; 63
    185c:	81 e0       	ldi	r24, 0x01	; 1
    185e:	4b c0       	rjmp	.+150    	; 0x18f6 <xQueueGenericSend+0x114>
    1860:	8e 81       	ldd	r24, Y+6	; 0x06
    1862:	9f 81       	ldd	r25, Y+7	; 0x07
    1864:	a8 85       	ldd	r26, Y+8	; 0x08
    1866:	b9 85       	ldd	r27, Y+9	; 0x09
    1868:	89 2b       	or	r24, r25
    186a:	8a 2b       	or	r24, r26
    186c:	8b 2b       	or	r24, r27
    186e:	21 f4       	brne	.+8      	; 0x1878 <xQueueGenericSend+0x96>
    1870:	0f 90       	pop	r0
    1872:	0f be       	out	0x3f, r0	; 63
    1874:	80 e0       	ldi	r24, 0x00	; 0
    1876:	3f c0       	rjmp	.+126    	; 0x18f6 <xQueueGenericSend+0x114>
    1878:	11 11       	cpse	r17, r1
    187a:	04 c0       	rjmp	.+8      	; 0x1884 <xQueueGenericSend+0xa2>
    187c:	ce 01       	movw	r24, r28
    187e:	01 96       	adiw	r24, 0x01	; 1
    1880:	34 d6       	rcall	.+3176   	; 0x24ea <vTaskSetTimeOutState>
    1882:	19 2d       	mov	r17, r9
    1884:	0f 90       	pop	r0
    1886:	0f be       	out	0x3f, r0	; 63
    1888:	ca d3       	rcall	.+1940   	; 0x201e <vTaskSuspendAll>
    188a:	0f b6       	in	r0, 0x3f	; 63
    188c:	f8 94       	cli
    188e:	0f 92       	push	r0
    1890:	f7 01       	movw	r30, r14
    1892:	81 a1       	ldd	r24, Z+33	; 0x21
    1894:	8f 3f       	cpi	r24, 0xFF	; 255
    1896:	09 f4       	brne	.+2      	; 0x189a <xQueueGenericSend+0xb8>
    1898:	11 a2       	std	Z+33, r1	; 0x21
    189a:	f7 01       	movw	r30, r14
    189c:	82 a1       	ldd	r24, Z+34	; 0x22
    189e:	8f 3f       	cpi	r24, 0xFF	; 255
    18a0:	09 f4       	brne	.+2      	; 0x18a4 <xQueueGenericSend+0xc2>
    18a2:	12 a2       	std	Z+34, r1	; 0x22
    18a4:	0f 90       	pop	r0
    18a6:	0f be       	out	0x3f, r0	; 63
    18a8:	be 01       	movw	r22, r28
    18aa:	6a 5f       	subi	r22, 0xFA	; 250
    18ac:	7f 4f       	sbci	r23, 0xFF	; 255
    18ae:	ce 01       	movw	r24, r28
    18b0:	01 96       	adiw	r24, 0x01	; 1
    18b2:	2c d6       	rcall	.+3160   	; 0x250c <xTaskCheckForTimeOut>
    18b4:	81 11       	cpse	r24, r1
    18b6:	1b c0       	rjmp	.+54     	; 0x18ee <xQueueGenericSend+0x10c>
    18b8:	0f b6       	in	r0, 0x3f	; 63
    18ba:	f8 94       	cli
    18bc:	0f 92       	push	r0
    18be:	f7 01       	movw	r30, r14
    18c0:	96 8d       	ldd	r25, Z+30	; 0x1e
    18c2:	0f 90       	pop	r0
    18c4:	0f be       	out	0x3f, r0	; 63
    18c6:	87 8d       	ldd	r24, Z+31	; 0x1f
    18c8:	98 13       	cpse	r25, r24
    18ca:	0d c0       	rjmp	.+26     	; 0x18e6 <xQueueGenericSend+0x104>
    18cc:	4e 81       	ldd	r20, Y+6	; 0x06
    18ce:	5f 81       	ldd	r21, Y+7	; 0x07
    18d0:	68 85       	ldd	r22, Y+8	; 0x08
    18d2:	79 85       	ldd	r23, Y+9	; 0x09
    18d4:	c6 01       	movw	r24, r12
    18d6:	b0 d5       	rcall	.+2912   	; 0x2438 <vTaskPlaceOnEventList>
    18d8:	c7 01       	movw	r24, r14
    18da:	d3 de       	rcall	.-602    	; 0x1682 <prvUnlockQueue>
    18dc:	89 d4       	rcall	.+2322   	; 0x21f0 <xTaskResumeAll>
    18de:	81 11       	cpse	r24, r1
    18e0:	a0 cf       	rjmp	.-192    	; 0x1822 <xQueueGenericSend+0x40>
    18e2:	92 dd       	rcall	.-1244   	; 0x1408 <vPortYield>
    18e4:	9e cf       	rjmp	.-196    	; 0x1822 <xQueueGenericSend+0x40>
    18e6:	c7 01       	movw	r24, r14
    18e8:	cc de       	rcall	.-616    	; 0x1682 <prvUnlockQueue>
    18ea:	82 d4       	rcall	.+2308   	; 0x21f0 <xTaskResumeAll>
    18ec:	9a cf       	rjmp	.-204    	; 0x1822 <xQueueGenericSend+0x40>
    18ee:	c7 01       	movw	r24, r14
    18f0:	c8 de       	rcall	.-624    	; 0x1682 <prvUnlockQueue>
    18f2:	7e d4       	rcall	.+2300   	; 0x21f0 <xTaskResumeAll>
    18f4:	80 e0       	ldi	r24, 0x00	; 0
    18f6:	29 96       	adiw	r28, 0x09	; 9
    18f8:	0f b6       	in	r0, 0x3f	; 63
    18fa:	f8 94       	cli
    18fc:	de bf       	out	0x3e, r29	; 62
    18fe:	0f be       	out	0x3f, r0	; 63
    1900:	cd bf       	out	0x3d, r28	; 61
    1902:	df 91       	pop	r29
    1904:	cf 91       	pop	r28
    1906:	1f 91       	pop	r17
    1908:	0f 91       	pop	r16
    190a:	ff 90       	pop	r15
    190c:	ef 90       	pop	r14
    190e:	df 90       	pop	r13
    1910:	cf 90       	pop	r12
    1912:	bf 90       	pop	r11
    1914:	af 90       	pop	r10
    1916:	9f 90       	pop	r9
    1918:	08 95       	ret

0000191a <xQueueCreateMutex>:
    191a:	0f 93       	push	r16
    191c:	cf 93       	push	r28
    191e:	df 93       	push	r29
    1920:	48 2f       	mov	r20, r24
    1922:	60 e0       	ldi	r22, 0x00	; 0
    1924:	81 e0       	ldi	r24, 0x01	; 1
    1926:	2f df       	rcall	.-418    	; 0x1786 <xQueueGenericCreate>
    1928:	ec 01       	movw	r28, r24
    192a:	00 97       	sbiw	r24, 0x00	; 0
    192c:	61 f0       	breq	.+24     	; 0x1946 <xQueueCreateMutex+0x2c>
    192e:	1b 82       	std	Y+3, r1	; 0x03
    1930:	1a 82       	std	Y+2, r1	; 0x02
    1932:	19 82       	std	Y+1, r1	; 0x01
    1934:	18 82       	st	Y, r1
    1936:	1e 82       	std	Y+6, r1	; 0x06
    1938:	00 e0       	ldi	r16, 0x00	; 0
    193a:	20 e0       	ldi	r18, 0x00	; 0
    193c:	30 e0       	ldi	r19, 0x00	; 0
    193e:	a9 01       	movw	r20, r18
    1940:	60 e0       	ldi	r22, 0x00	; 0
    1942:	70 e0       	ldi	r23, 0x00	; 0
    1944:	4e df       	rcall	.-356    	; 0x17e2 <xQueueGenericSend>
    1946:	ce 01       	movw	r24, r28
    1948:	df 91       	pop	r29
    194a:	cf 91       	pop	r28
    194c:	0f 91       	pop	r16
    194e:	08 95       	ret

00001950 <xQueueGenericSendFromISR>:
    1950:	ef 92       	push	r14
    1952:	ff 92       	push	r15
    1954:	0f 93       	push	r16
    1956:	1f 93       	push	r17
    1958:	cf 93       	push	r28
    195a:	df 93       	push	r29
    195c:	8a 01       	movw	r16, r20
    195e:	fc 01       	movw	r30, r24
    1960:	56 8d       	ldd	r21, Z+30	; 0x1e
    1962:	37 8d       	ldd	r19, Z+31	; 0x1f
    1964:	53 17       	cp	r21, r19
    1966:	10 f0       	brcs	.+4      	; 0x196c <xQueueGenericSendFromISR+0x1c>
    1968:	22 30       	cpi	r18, 0x02	; 2
    196a:	e1 f4       	brne	.+56     	; 0x19a4 <xQueueGenericSendFromISR+0x54>
    196c:	42 2f       	mov	r20, r18
    196e:	78 01       	movw	r14, r16
    1970:	ec 01       	movw	r28, r24
    1972:	1a a1       	ldd	r17, Y+34	; 0x22
    1974:	0d de       	rcall	.-998    	; 0x1590 <prvCopyDataToQueue>
    1976:	1f 3f       	cpi	r17, 0xFF	; 255
    1978:	79 f4       	brne	.+30     	; 0x1998 <xQueueGenericSendFromISR+0x48>
    197a:	8b 89       	ldd	r24, Y+19	; 0x13
    197c:	88 23       	and	r24, r24
    197e:	a1 f0       	breq	.+40     	; 0x19a8 <xQueueGenericSendFromISR+0x58>
    1980:	ce 01       	movw	r24, r28
    1982:	43 96       	adiw	r24, 0x13	; 19
    1984:	70 d5       	rcall	.+2784   	; 0x2466 <xTaskRemoveFromEventList>
    1986:	88 23       	and	r24, r24
    1988:	89 f0       	breq	.+34     	; 0x19ac <xQueueGenericSendFromISR+0x5c>
    198a:	e1 14       	cp	r14, r1
    198c:	f1 04       	cpc	r15, r1
    198e:	81 f0       	breq	.+32     	; 0x19b0 <xQueueGenericSendFromISR+0x60>
    1990:	81 e0       	ldi	r24, 0x01	; 1
    1992:	f7 01       	movw	r30, r14
    1994:	80 83       	st	Z, r24
    1996:	0d c0       	rjmp	.+26     	; 0x19b2 <xQueueGenericSendFromISR+0x62>
    1998:	ff 24       	eor	r15, r15
    199a:	f3 94       	inc	r15
    199c:	f1 0e       	add	r15, r17
    199e:	fa a2       	std	Y+34, r15	; 0x22
    19a0:	81 e0       	ldi	r24, 0x01	; 1
    19a2:	07 c0       	rjmp	.+14     	; 0x19b2 <xQueueGenericSendFromISR+0x62>
    19a4:	80 e0       	ldi	r24, 0x00	; 0
    19a6:	05 c0       	rjmp	.+10     	; 0x19b2 <xQueueGenericSendFromISR+0x62>
    19a8:	81 e0       	ldi	r24, 0x01	; 1
    19aa:	03 c0       	rjmp	.+6      	; 0x19b2 <xQueueGenericSendFromISR+0x62>
    19ac:	81 e0       	ldi	r24, 0x01	; 1
    19ae:	01 c0       	rjmp	.+2      	; 0x19b2 <xQueueGenericSendFromISR+0x62>
    19b0:	81 e0       	ldi	r24, 0x01	; 1
    19b2:	df 91       	pop	r29
    19b4:	cf 91       	pop	r28
    19b6:	1f 91       	pop	r17
    19b8:	0f 91       	pop	r16
    19ba:	ff 90       	pop	r15
    19bc:	ef 90       	pop	r14
    19be:	08 95       	ret

000019c0 <xQueueGenericReceive>:
    19c0:	8f 92       	push	r8
    19c2:	9f 92       	push	r9
    19c4:	af 92       	push	r10
    19c6:	bf 92       	push	r11
    19c8:	cf 92       	push	r12
    19ca:	df 92       	push	r13
    19cc:	ef 92       	push	r14
    19ce:	ff 92       	push	r15
    19d0:	0f 93       	push	r16
    19d2:	1f 93       	push	r17
    19d4:	cf 93       	push	r28
    19d6:	df 93       	push	r29
    19d8:	cd b7       	in	r28, 0x3d	; 61
    19da:	de b7       	in	r29, 0x3e	; 62
    19dc:	29 97       	sbiw	r28, 0x09	; 9
    19de:	0f b6       	in	r0, 0x3f	; 63
    19e0:	f8 94       	cli
    19e2:	de bf       	out	0x3e, r29	; 62
    19e4:	0f be       	out	0x3f, r0	; 63
    19e6:	cd bf       	out	0x3d, r28	; 61
    19e8:	7c 01       	movw	r14, r24
    19ea:	5b 01       	movw	r10, r22
    19ec:	2e 83       	std	Y+6, r18	; 0x06
    19ee:	3f 83       	std	Y+7, r19	; 0x07
    19f0:	48 87       	std	Y+8, r20	; 0x08
    19f2:	59 87       	std	Y+9, r21	; 0x09
    19f4:	91 2c       	mov	r9, r1
    19f6:	88 24       	eor	r8, r8
    19f8:	83 94       	inc	r8
    19fa:	6c 01       	movw	r12, r24
    19fc:	83 e1       	ldi	r24, 0x13	; 19
    19fe:	c8 0e       	add	r12, r24
    1a00:	d1 1c       	adc	r13, r1
    1a02:	0f b6       	in	r0, 0x3f	; 63
    1a04:	f8 94       	cli
    1a06:	0f 92       	push	r0
    1a08:	f7 01       	movw	r30, r14
    1a0a:	16 8d       	ldd	r17, Z+30	; 0x1e
    1a0c:	11 23       	and	r17, r17
    1a0e:	61 f1       	breq	.+88     	; 0x1a68 <xQueueGenericReceive+0xa8>
    1a10:	c6 80       	ldd	r12, Z+6	; 0x06
    1a12:	d7 80       	ldd	r13, Z+7	; 0x07
    1a14:	b5 01       	movw	r22, r10
    1a16:	c7 01       	movw	r24, r14
    1a18:	1a de       	rcall	.-972    	; 0x164e <prvCopyDataFromQueue>
    1a1a:	01 11       	cpse	r16, r1
    1a1c:	16 c0       	rjmp	.+44     	; 0x1a4a <xQueueGenericReceive+0x8a>
    1a1e:	11 50       	subi	r17, 0x01	; 1
    1a20:	f7 01       	movw	r30, r14
    1a22:	16 8f       	std	Z+30, r17	; 0x1e
    1a24:	80 81       	ld	r24, Z
    1a26:	91 81       	ldd	r25, Z+1	; 0x01
    1a28:	89 2b       	or	r24, r25
    1a2a:	21 f4       	brne	.+8      	; 0x1a34 <xQueueGenericReceive+0x74>
    1a2c:	77 d6       	rcall	.+3310   	; 0x271c <pvTaskIncrementMutexHeldCount>
    1a2e:	f7 01       	movw	r30, r14
    1a30:	93 83       	std	Z+3, r25	; 0x03
    1a32:	82 83       	std	Z+2, r24	; 0x02
    1a34:	f7 01       	movw	r30, r14
    1a36:	80 85       	ldd	r24, Z+8	; 0x08
    1a38:	88 23       	and	r24, r24
    1a3a:	91 f0       	breq	.+36     	; 0x1a60 <xQueueGenericReceive+0xa0>
    1a3c:	c7 01       	movw	r24, r14
    1a3e:	08 96       	adiw	r24, 0x08	; 8
    1a40:	12 d5       	rcall	.+2596   	; 0x2466 <xTaskRemoveFromEventList>
    1a42:	88 23       	and	r24, r24
    1a44:	69 f0       	breq	.+26     	; 0x1a60 <xQueueGenericReceive+0xa0>
    1a46:	e0 dc       	rcall	.-1600   	; 0x1408 <vPortYield>
    1a48:	0b c0       	rjmp	.+22     	; 0x1a60 <xQueueGenericReceive+0xa0>
    1a4a:	f7 01       	movw	r30, r14
    1a4c:	d7 82       	std	Z+7, r13	; 0x07
    1a4e:	c6 82       	std	Z+6, r12	; 0x06
    1a50:	83 89       	ldd	r24, Z+19	; 0x13
    1a52:	88 23       	and	r24, r24
    1a54:	29 f0       	breq	.+10     	; 0x1a60 <xQueueGenericReceive+0xa0>
    1a56:	c7 01       	movw	r24, r14
    1a58:	43 96       	adiw	r24, 0x13	; 19
    1a5a:	05 d5       	rcall	.+2570   	; 0x2466 <xTaskRemoveFromEventList>
    1a5c:	81 11       	cpse	r24, r1
    1a5e:	d4 dc       	rcall	.-1624   	; 0x1408 <vPortYield>
    1a60:	0f 90       	pop	r0
    1a62:	0f be       	out	0x3f, r0	; 63
    1a64:	81 e0       	ldi	r24, 0x01	; 1
    1a66:	5e c0       	rjmp	.+188    	; 0x1b24 <xQueueGenericReceive+0x164>
    1a68:	8e 81       	ldd	r24, Y+6	; 0x06
    1a6a:	9f 81       	ldd	r25, Y+7	; 0x07
    1a6c:	a8 85       	ldd	r26, Y+8	; 0x08
    1a6e:	b9 85       	ldd	r27, Y+9	; 0x09
    1a70:	89 2b       	or	r24, r25
    1a72:	8a 2b       	or	r24, r26
    1a74:	8b 2b       	or	r24, r27
    1a76:	21 f4       	brne	.+8      	; 0x1a80 <xQueueGenericReceive+0xc0>
    1a78:	0f 90       	pop	r0
    1a7a:	0f be       	out	0x3f, r0	; 63
    1a7c:	80 e0       	ldi	r24, 0x00	; 0
    1a7e:	52 c0       	rjmp	.+164    	; 0x1b24 <xQueueGenericReceive+0x164>
    1a80:	91 10       	cpse	r9, r1
    1a82:	04 c0       	rjmp	.+8      	; 0x1a8c <xQueueGenericReceive+0xcc>
    1a84:	ce 01       	movw	r24, r28
    1a86:	01 96       	adiw	r24, 0x01	; 1
    1a88:	30 d5       	rcall	.+2656   	; 0x24ea <vTaskSetTimeOutState>
    1a8a:	98 2c       	mov	r9, r8
    1a8c:	0f 90       	pop	r0
    1a8e:	0f be       	out	0x3f, r0	; 63
    1a90:	c6 d2       	rcall	.+1420   	; 0x201e <vTaskSuspendAll>
    1a92:	0f b6       	in	r0, 0x3f	; 63
    1a94:	f8 94       	cli
    1a96:	0f 92       	push	r0
    1a98:	f7 01       	movw	r30, r14
    1a9a:	81 a1       	ldd	r24, Z+33	; 0x21
    1a9c:	8f 3f       	cpi	r24, 0xFF	; 255
    1a9e:	09 f4       	brne	.+2      	; 0x1aa2 <xQueueGenericReceive+0xe2>
    1aa0:	11 a2       	std	Z+33, r1	; 0x21
    1aa2:	f7 01       	movw	r30, r14
    1aa4:	82 a1       	ldd	r24, Z+34	; 0x22
    1aa6:	8f 3f       	cpi	r24, 0xFF	; 255
    1aa8:	09 f4       	brne	.+2      	; 0x1aac <xQueueGenericReceive+0xec>
    1aaa:	12 a2       	std	Z+34, r1	; 0x22
    1aac:	0f 90       	pop	r0
    1aae:	0f be       	out	0x3f, r0	; 63
    1ab0:	be 01       	movw	r22, r28
    1ab2:	6a 5f       	subi	r22, 0xFA	; 250
    1ab4:	7f 4f       	sbci	r23, 0xFF	; 255
    1ab6:	ce 01       	movw	r24, r28
    1ab8:	01 96       	adiw	r24, 0x01	; 1
    1aba:	28 d5       	rcall	.+2640   	; 0x250c <xTaskCheckForTimeOut>
    1abc:	81 11       	cpse	r24, r1
    1abe:	26 c0       	rjmp	.+76     	; 0x1b0c <xQueueGenericReceive+0x14c>
    1ac0:	0f b6       	in	r0, 0x3f	; 63
    1ac2:	f8 94       	cli
    1ac4:	0f 92       	push	r0
    1ac6:	f7 01       	movw	r30, r14
    1ac8:	86 8d       	ldd	r24, Z+30	; 0x1e
    1aca:	0f 90       	pop	r0
    1acc:	0f be       	out	0x3f, r0	; 63
    1ace:	81 11       	cpse	r24, r1
    1ad0:	19 c0       	rjmp	.+50     	; 0x1b04 <xQueueGenericReceive+0x144>
    1ad2:	80 81       	ld	r24, Z
    1ad4:	91 81       	ldd	r25, Z+1	; 0x01
    1ad6:	89 2b       	or	r24, r25
    1ad8:	41 f4       	brne	.+16     	; 0x1aea <xQueueGenericReceive+0x12a>
    1ada:	0f b6       	in	r0, 0x3f	; 63
    1adc:	f8 94       	cli
    1ade:	0f 92       	push	r0
    1ae0:	82 81       	ldd	r24, Z+2	; 0x02
    1ae2:	93 81       	ldd	r25, Z+3	; 0x03
    1ae4:	7d d5       	rcall	.+2810   	; 0x25e0 <vTaskPriorityInherit>
    1ae6:	0f 90       	pop	r0
    1ae8:	0f be       	out	0x3f, r0	; 63
    1aea:	4e 81       	ldd	r20, Y+6	; 0x06
    1aec:	5f 81       	ldd	r21, Y+7	; 0x07
    1aee:	68 85       	ldd	r22, Y+8	; 0x08
    1af0:	79 85       	ldd	r23, Y+9	; 0x09
    1af2:	c6 01       	movw	r24, r12
    1af4:	a1 d4       	rcall	.+2370   	; 0x2438 <vTaskPlaceOnEventList>
    1af6:	c7 01       	movw	r24, r14
    1af8:	c4 dd       	rcall	.-1144   	; 0x1682 <prvUnlockQueue>
    1afa:	7a d3       	rcall	.+1780   	; 0x21f0 <xTaskResumeAll>
    1afc:	81 11       	cpse	r24, r1
    1afe:	81 cf       	rjmp	.-254    	; 0x1a02 <xQueueGenericReceive+0x42>
    1b00:	83 dc       	rcall	.-1786   	; 0x1408 <vPortYield>
    1b02:	7f cf       	rjmp	.-258    	; 0x1a02 <xQueueGenericReceive+0x42>
    1b04:	c7 01       	movw	r24, r14
    1b06:	bd dd       	rcall	.-1158   	; 0x1682 <prvUnlockQueue>
    1b08:	73 d3       	rcall	.+1766   	; 0x21f0 <xTaskResumeAll>
    1b0a:	7b cf       	rjmp	.-266    	; 0x1a02 <xQueueGenericReceive+0x42>
    1b0c:	c7 01       	movw	r24, r14
    1b0e:	b9 dd       	rcall	.-1166   	; 0x1682 <prvUnlockQueue>
    1b10:	6f d3       	rcall	.+1758   	; 0x21f0 <xTaskResumeAll>
    1b12:	0f b6       	in	r0, 0x3f	; 63
    1b14:	f8 94       	cli
    1b16:	0f 92       	push	r0
    1b18:	f7 01       	movw	r30, r14
    1b1a:	86 8d       	ldd	r24, Z+30	; 0x1e
    1b1c:	0f 90       	pop	r0
    1b1e:	0f be       	out	0x3f, r0	; 63
    1b20:	81 11       	cpse	r24, r1
    1b22:	6f cf       	rjmp	.-290    	; 0x1a02 <xQueueGenericReceive+0x42>
    1b24:	29 96       	adiw	r28, 0x09	; 9
    1b26:	0f b6       	in	r0, 0x3f	; 63
    1b28:	f8 94       	cli
    1b2a:	de bf       	out	0x3e, r29	; 62
    1b2c:	0f be       	out	0x3f, r0	; 63
    1b2e:	cd bf       	out	0x3d, r28	; 61
    1b30:	df 91       	pop	r29
    1b32:	cf 91       	pop	r28
    1b34:	1f 91       	pop	r17
    1b36:	0f 91       	pop	r16
    1b38:	ff 90       	pop	r15
    1b3a:	ef 90       	pop	r14
    1b3c:	df 90       	pop	r13
    1b3e:	cf 90       	pop	r12
    1b40:	bf 90       	pop	r11
    1b42:	af 90       	pop	r10
    1b44:	9f 90       	pop	r9
    1b46:	8f 90       	pop	r8
    1b48:	08 95       	ret

00001b4a <xQueueReceiveFromISR>:
    1b4a:	ef 92       	push	r14
    1b4c:	ff 92       	push	r15
    1b4e:	0f 93       	push	r16
    1b50:	1f 93       	push	r17
    1b52:	cf 93       	push	r28
    1b54:	df 93       	push	r29
    1b56:	fc 01       	movw	r30, r24
    1b58:	c6 8d       	ldd	r28, Z+30	; 0x1e
    1b5a:	cc 23       	and	r28, r28
    1b5c:	e9 f0       	breq	.+58     	; 0x1b98 <xQueueReceiveFromISR+0x4e>
    1b5e:	7a 01       	movw	r14, r20
    1b60:	8c 01       	movw	r16, r24
    1b62:	d1 a1       	ldd	r29, Z+33	; 0x21
    1b64:	74 dd       	rcall	.-1304   	; 0x164e <prvCopyDataFromQueue>
    1b66:	c1 50       	subi	r28, 0x01	; 1
    1b68:	f8 01       	movw	r30, r16
    1b6a:	c6 8f       	std	Z+30, r28	; 0x1e
    1b6c:	df 3f       	cpi	r29, 0xFF	; 255
    1b6e:	79 f4       	brne	.+30     	; 0x1b8e <xQueueReceiveFromISR+0x44>
    1b70:	80 85       	ldd	r24, Z+8	; 0x08
    1b72:	88 23       	and	r24, r24
    1b74:	99 f0       	breq	.+38     	; 0x1b9c <xQueueReceiveFromISR+0x52>
    1b76:	c8 01       	movw	r24, r16
    1b78:	08 96       	adiw	r24, 0x08	; 8
    1b7a:	75 d4       	rcall	.+2282   	; 0x2466 <xTaskRemoveFromEventList>
    1b7c:	88 23       	and	r24, r24
    1b7e:	81 f0       	breq	.+32     	; 0x1ba0 <xQueueReceiveFromISR+0x56>
    1b80:	e1 14       	cp	r14, r1
    1b82:	f1 04       	cpc	r15, r1
    1b84:	79 f0       	breq	.+30     	; 0x1ba4 <xQueueReceiveFromISR+0x5a>
    1b86:	81 e0       	ldi	r24, 0x01	; 1
    1b88:	f7 01       	movw	r30, r14
    1b8a:	80 83       	st	Z, r24
    1b8c:	0c c0       	rjmp	.+24     	; 0x1ba6 <xQueueReceiveFromISR+0x5c>
    1b8e:	df 5f       	subi	r29, 0xFF	; 255
    1b90:	f8 01       	movw	r30, r16
    1b92:	d1 a3       	std	Z+33, r29	; 0x21
    1b94:	81 e0       	ldi	r24, 0x01	; 1
    1b96:	07 c0       	rjmp	.+14     	; 0x1ba6 <xQueueReceiveFromISR+0x5c>
    1b98:	80 e0       	ldi	r24, 0x00	; 0
    1b9a:	05 c0       	rjmp	.+10     	; 0x1ba6 <xQueueReceiveFromISR+0x5c>
    1b9c:	81 e0       	ldi	r24, 0x01	; 1
    1b9e:	03 c0       	rjmp	.+6      	; 0x1ba6 <xQueueReceiveFromISR+0x5c>
    1ba0:	81 e0       	ldi	r24, 0x01	; 1
    1ba2:	01 c0       	rjmp	.+2      	; 0x1ba6 <xQueueReceiveFromISR+0x5c>
    1ba4:	81 e0       	ldi	r24, 0x01	; 1
    1ba6:	df 91       	pop	r29
    1ba8:	cf 91       	pop	r28
    1baa:	1f 91       	pop	r17
    1bac:	0f 91       	pop	r16
    1bae:	ff 90       	pop	r15
    1bb0:	ef 90       	pop	r14
    1bb2:	08 95       	ret

00001bb4 <uxQueueMessagesWaiting>:
    1bb4:	0f b6       	in	r0, 0x3f	; 63
    1bb6:	f8 94       	cli
    1bb8:	0f 92       	push	r0
    1bba:	fc 01       	movw	r30, r24
    1bbc:	86 8d       	ldd	r24, Z+30	; 0x1e
    1bbe:	0f 90       	pop	r0
    1bc0:	0f be       	out	0x3f, r0	; 63
    1bc2:	08 95       	ret

00001bc4 <uxQueueMessagesWaitingFromISR>:
{
UBaseType_t uxReturn;

	configASSERT( xQueue );

	uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    1bc4:	fc 01       	movw	r30, r24
    1bc6:	86 8d       	ldd	r24, Z+30	; 0x1e

	return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    1bc8:	08 95       	ret

00001bca <prvResetNextTaskUnblockTime>:
	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */

	return uxReturn;
}
    1bca:	e0 91 ae 1d 	lds	r30, 0x1DAE	; 0x801dae <pxDelayedTaskList>
    1bce:	f0 91 af 1d 	lds	r31, 0x1DAF	; 0x801daf <pxDelayedTaskList+0x1>
    1bd2:	80 81       	ld	r24, Z
    1bd4:	81 11       	cpse	r24, r1
    1bd6:	0c c0       	rjmp	.+24     	; 0x1bf0 <prvResetNextTaskUnblockTime+0x26>
    1bd8:	8f ef       	ldi	r24, 0xFF	; 255
    1bda:	9f ef       	ldi	r25, 0xFF	; 255
    1bdc:	dc 01       	movw	r26, r24
    1bde:	80 93 7b 1d 	sts	0x1D7B, r24	; 0x801d7b <xNextTaskUnblockTime>
    1be2:	90 93 7c 1d 	sts	0x1D7C, r25	; 0x801d7c <xNextTaskUnblockTime+0x1>
    1be6:	a0 93 7d 1d 	sts	0x1D7D, r26	; 0x801d7d <xNextTaskUnblockTime+0x2>
    1bea:	b0 93 7e 1d 	sts	0x1D7E, r27	; 0x801d7e <xNextTaskUnblockTime+0x3>
    1bee:	08 95       	ret
    1bf0:	e0 91 ae 1d 	lds	r30, 0x1DAE	; 0x801dae <pxDelayedTaskList>
    1bf4:	f0 91 af 1d 	lds	r31, 0x1DAF	; 0x801daf <pxDelayedTaskList+0x1>
    1bf8:	07 80       	ldd	r0, Z+7	; 0x07
    1bfa:	f0 85       	ldd	r31, Z+8	; 0x08
    1bfc:	e0 2d       	mov	r30, r0
    1bfe:	00 84       	ldd	r0, Z+8	; 0x08
    1c00:	f1 85       	ldd	r31, Z+9	; 0x09
    1c02:	e0 2d       	mov	r30, r0
    1c04:	82 81       	ldd	r24, Z+2	; 0x02
    1c06:	93 81       	ldd	r25, Z+3	; 0x03
    1c08:	a4 81       	ldd	r26, Z+4	; 0x04
    1c0a:	b5 81       	ldd	r27, Z+5	; 0x05
    1c0c:	80 93 7b 1d 	sts	0x1D7B, r24	; 0x801d7b <xNextTaskUnblockTime>
    1c10:	90 93 7c 1d 	sts	0x1D7C, r25	; 0x801d7c <xNextTaskUnblockTime+0x1>
    1c14:	a0 93 7d 1d 	sts	0x1D7D, r26	; 0x801d7d <xNextTaskUnblockTime+0x2>
    1c18:	b0 93 7e 1d 	sts	0x1D7E, r27	; 0x801d7e <xNextTaskUnblockTime+0x3>
    1c1c:	08 95       	ret

00001c1e <prvAddCurrentTaskToDelayedList>:
    1c1e:	8f 92       	push	r8
    1c20:	9f 92       	push	r9
    1c22:	af 92       	push	r10
    1c24:	bf 92       	push	r11
    1c26:	cf 92       	push	r12
    1c28:	df 92       	push	r13
    1c2a:	ef 92       	push	r14
    1c2c:	ff 92       	push	r15
    1c2e:	cf 93       	push	r28
    1c30:	6b 01       	movw	r12, r22
    1c32:	7c 01       	movw	r14, r24
    1c34:	c4 2f       	mov	r28, r20
    1c36:	80 90 85 1d 	lds	r8, 0x1D85	; 0x801d85 <xTickCount>
    1c3a:	90 90 86 1d 	lds	r9, 0x1D86	; 0x801d86 <xTickCount+0x1>
    1c3e:	a0 90 87 1d 	lds	r10, 0x1D87	; 0x801d87 <xTickCount+0x2>
    1c42:	b0 90 88 1d 	lds	r11, 0x1D88	; 0x801d88 <xTickCount+0x3>
    1c46:	80 91 fd 1d 	lds	r24, 0x1DFD	; 0x801dfd <pxCurrentTCB>
    1c4a:	90 91 fe 1d 	lds	r25, 0x1DFE	; 0x801dfe <pxCurrentTCB+0x1>
    1c4e:	02 96       	adiw	r24, 0x02	; 2
    1c50:	c3 d9       	rcall	.-3194   	; 0xfd8 <uxListRemove>
    1c52:	8f ef       	ldi	r24, 0xFF	; 255
    1c54:	c8 16       	cp	r12, r24
    1c56:	d8 06       	cpc	r13, r24
    1c58:	e8 06       	cpc	r14, r24
    1c5a:	f8 06       	cpc	r15, r24
    1c5c:	61 f4       	brne	.+24     	; 0x1c76 <prvAddCurrentTaskToDelayedList+0x58>
    1c5e:	cc 23       	and	r28, r28
    1c60:	51 f0       	breq	.+20     	; 0x1c76 <prvAddCurrentTaskToDelayedList+0x58>
    1c62:	60 91 fd 1d 	lds	r22, 0x1DFD	; 0x801dfd <pxCurrentTCB>
    1c66:	70 91 fe 1d 	lds	r23, 0x1DFE	; 0x801dfe <pxCurrentTCB+0x1>
    1c6a:	6e 5f       	subi	r22, 0xFE	; 254
    1c6c:	7f 4f       	sbci	r23, 0xFF	; 255
    1c6e:	8a e8       	ldi	r24, 0x8A	; 138
    1c70:	9d e1       	ldi	r25, 0x1D	; 29
    1c72:	54 d9       	rcall	.-3416   	; 0xf1c <vListInsertEnd>
    1c74:	3d c0       	rjmp	.+122    	; 0x1cf0 <prvAddCurrentTaskToDelayedList+0xd2>
    1c76:	c8 0c       	add	r12, r8
    1c78:	d9 1c       	adc	r13, r9
    1c7a:	ea 1c       	adc	r14, r10
    1c7c:	fb 1c       	adc	r15, r11
    1c7e:	e0 91 fd 1d 	lds	r30, 0x1DFD	; 0x801dfd <pxCurrentTCB>
    1c82:	f0 91 fe 1d 	lds	r31, 0x1DFE	; 0x801dfe <pxCurrentTCB+0x1>
    1c86:	c2 82       	std	Z+2, r12	; 0x02
    1c88:	d3 82       	std	Z+3, r13	; 0x03
    1c8a:	e4 82       	std	Z+4, r14	; 0x04
    1c8c:	f5 82       	std	Z+5, r15	; 0x05
    1c8e:	c8 14       	cp	r12, r8
    1c90:	d9 04       	cpc	r13, r9
    1c92:	ea 04       	cpc	r14, r10
    1c94:	fb 04       	cpc	r15, r11
    1c96:	60 f4       	brcc	.+24     	; 0x1cb0 <prvAddCurrentTaskToDelayedList+0x92>
    1c98:	60 91 fd 1d 	lds	r22, 0x1DFD	; 0x801dfd <pxCurrentTCB>
    1c9c:	70 91 fe 1d 	lds	r23, 0x1DFE	; 0x801dfe <pxCurrentTCB+0x1>
    1ca0:	80 91 ac 1d 	lds	r24, 0x1DAC	; 0x801dac <pxOverflowDelayedTaskList>
    1ca4:	90 91 ad 1d 	lds	r25, 0x1DAD	; 0x801dad <pxOverflowDelayedTaskList+0x1>
    1ca8:	6e 5f       	subi	r22, 0xFE	; 254
    1caa:	7f 4f       	sbci	r23, 0xFF	; 255
    1cac:	58 d9       	rcall	.-3408   	; 0xf5e <vListInsert>
    1cae:	20 c0       	rjmp	.+64     	; 0x1cf0 <prvAddCurrentTaskToDelayedList+0xd2>
    1cb0:	60 91 fd 1d 	lds	r22, 0x1DFD	; 0x801dfd <pxCurrentTCB>
    1cb4:	70 91 fe 1d 	lds	r23, 0x1DFE	; 0x801dfe <pxCurrentTCB+0x1>
    1cb8:	80 91 ae 1d 	lds	r24, 0x1DAE	; 0x801dae <pxDelayedTaskList>
    1cbc:	90 91 af 1d 	lds	r25, 0x1DAF	; 0x801daf <pxDelayedTaskList+0x1>
    1cc0:	6e 5f       	subi	r22, 0xFE	; 254
    1cc2:	7f 4f       	sbci	r23, 0xFF	; 255
    1cc4:	4c d9       	rcall	.-3432   	; 0xf5e <vListInsert>
    1cc6:	80 91 7b 1d 	lds	r24, 0x1D7B	; 0x801d7b <xNextTaskUnblockTime>
    1cca:	90 91 7c 1d 	lds	r25, 0x1D7C	; 0x801d7c <xNextTaskUnblockTime+0x1>
    1cce:	a0 91 7d 1d 	lds	r26, 0x1D7D	; 0x801d7d <xNextTaskUnblockTime+0x2>
    1cd2:	b0 91 7e 1d 	lds	r27, 0x1D7E	; 0x801d7e <xNextTaskUnblockTime+0x3>
    1cd6:	c8 16       	cp	r12, r24
    1cd8:	d9 06       	cpc	r13, r25
    1cda:	ea 06       	cpc	r14, r26
    1cdc:	fb 06       	cpc	r15, r27
    1cde:	40 f4       	brcc	.+16     	; 0x1cf0 <prvAddCurrentTaskToDelayedList+0xd2>
    1ce0:	c0 92 7b 1d 	sts	0x1D7B, r12	; 0x801d7b <xNextTaskUnblockTime>
    1ce4:	d0 92 7c 1d 	sts	0x1D7C, r13	; 0x801d7c <xNextTaskUnblockTime+0x1>
    1ce8:	e0 92 7d 1d 	sts	0x1D7D, r14	; 0x801d7d <xNextTaskUnblockTime+0x2>
    1cec:	f0 92 7e 1d 	sts	0x1D7E, r15	; 0x801d7e <xNextTaskUnblockTime+0x3>
    1cf0:	cf 91       	pop	r28
    1cf2:	ff 90       	pop	r15
    1cf4:	ef 90       	pop	r14
    1cf6:	df 90       	pop	r13
    1cf8:	cf 90       	pop	r12
    1cfa:	bf 90       	pop	r11
    1cfc:	af 90       	pop	r10
    1cfe:	9f 90       	pop	r9
    1d00:	8f 90       	pop	r8
    1d02:	08 95       	ret

00001d04 <xTaskCreate>:
    1d04:	4f 92       	push	r4
    1d06:	5f 92       	push	r5
    1d08:	6f 92       	push	r6
    1d0a:	7f 92       	push	r7
    1d0c:	8f 92       	push	r8
    1d0e:	9f 92       	push	r9
    1d10:	af 92       	push	r10
    1d12:	bf 92       	push	r11
    1d14:	cf 92       	push	r12
    1d16:	df 92       	push	r13
    1d18:	ef 92       	push	r14
    1d1a:	ff 92       	push	r15
    1d1c:	0f 93       	push	r16
    1d1e:	1f 93       	push	r17
    1d20:	cf 93       	push	r28
    1d22:	df 93       	push	r29
    1d24:	4c 01       	movw	r8, r24
    1d26:	6b 01       	movw	r12, r22
    1d28:	5a 01       	movw	r10, r20
    1d2a:	29 01       	movw	r4, r18
    1d2c:	ca 01       	movw	r24, r20
    1d2e:	c7 d9       	rcall	.-3186   	; 0x10be <pvPortMalloc>
    1d30:	3c 01       	movw	r6, r24
    1d32:	89 2b       	or	r24, r25
    1d34:	09 f4       	brne	.+2      	; 0x1d38 <xTaskCreate+0x34>
    1d36:	e1 c0       	rjmp	.+450    	; 0x1efa <xTaskCreate+0x1f6>
    1d38:	8a e3       	ldi	r24, 0x3A	; 58
    1d3a:	90 e0       	ldi	r25, 0x00	; 0
    1d3c:	c0 d9       	rcall	.-3200   	; 0x10be <pvPortMalloc>
    1d3e:	ec 01       	movw	r28, r24
    1d40:	89 2b       	or	r24, r25
    1d42:	b1 f0       	breq	.+44     	; 0x1d70 <xTaskCreate+0x6c>
    1d44:	7c 8e       	std	Y+28, r7	; 0x1c
    1d46:	6b 8e       	std	Y+27, r6	; 0x1b
    1d48:	a5 01       	movw	r20, r10
    1d4a:	65 ea       	ldi	r22, 0xA5	; 165
    1d4c:	70 e0       	ldi	r23, 0x00	; 0
    1d4e:	c3 01       	movw	r24, r6
    1d50:	0e 94 44 2c 	call	0x5888	; 0x5888 <memset>
    1d54:	21 e0       	ldi	r18, 0x01	; 1
    1d56:	a2 1a       	sub	r10, r18
    1d58:	b1 08       	sbc	r11, r1
    1d5a:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1d5c:	9c 8d       	ldd	r25, Y+28	; 0x1c
    1d5e:	a8 0e       	add	r10, r24
    1d60:	b9 1e       	adc	r11, r25
    1d62:	d6 01       	movw	r26, r12
    1d64:	8c 91       	ld	r24, X
    1d66:	8d 8f       	std	Y+29, r24	; 0x1d
    1d68:	8c 91       	ld	r24, X
    1d6a:	81 11       	cpse	r24, r1
    1d6c:	04 c0       	rjmp	.+8      	; 0x1d76 <xTaskCreate+0x72>
    1d6e:	17 c0       	rjmp	.+46     	; 0x1d9e <xTaskCreate+0x9a>
    1d70:	c3 01       	movw	r24, r6
    1d72:	69 da       	rcall	.-2862   	; 0x1246 <vPortFree>
    1d74:	c2 c0       	rjmp	.+388    	; 0x1efa <xTaskCreate+0x1f6>
    1d76:	ae 01       	movw	r20, r28
    1d78:	42 5e       	subi	r20, 0xE2	; 226
    1d7a:	5f 4f       	sbci	r21, 0xFF	; 255
    1d7c:	f6 01       	movw	r30, r12
    1d7e:	31 96       	adiw	r30, 0x01	; 1
    1d80:	b4 e1       	ldi	r27, 0x14	; 20
    1d82:	cb 0e       	add	r12, r27
    1d84:	d1 1c       	adc	r13, r1
    1d86:	cf 01       	movw	r24, r30
    1d88:	21 91       	ld	r18, Z+
    1d8a:	da 01       	movw	r26, r20
    1d8c:	2d 93       	st	X+, r18
    1d8e:	ad 01       	movw	r20, r26
    1d90:	dc 01       	movw	r26, r24
    1d92:	8c 91       	ld	r24, X
    1d94:	88 23       	and	r24, r24
    1d96:	19 f0       	breq	.+6      	; 0x1d9e <xTaskCreate+0x9a>
    1d98:	ce 16       	cp	r12, r30
    1d9a:	df 06       	cpc	r13, r31
    1d9c:	a1 f7       	brne	.-24     	; 0x1d86 <xTaskCreate+0x82>
    1d9e:	18 aa       	std	Y+48, r1	; 0x30
    1da0:	05 30       	cpi	r16, 0x05	; 5
    1da2:	08 f0       	brcs	.+2      	; 0x1da6 <xTaskCreate+0xa2>
    1da4:	04 e0       	ldi	r16, 0x04	; 4
    1da6:	0a 8f       	std	Y+26, r16	; 0x1a
    1da8:	0b ab       	std	Y+51, r16	; 0x33
    1daa:	1c aa       	std	Y+52, r1	; 0x34
    1dac:	6e 01       	movw	r12, r28
    1dae:	b2 e0       	ldi	r27, 0x02	; 2
    1db0:	cb 0e       	add	r12, r27
    1db2:	d1 1c       	adc	r13, r1
    1db4:	c6 01       	movw	r24, r12
    1db6:	ae d8       	rcall	.-3748   	; 0xf14 <vListInitialiseItem>
    1db8:	ce 01       	movw	r24, r28
    1dba:	0e 96       	adiw	r24, 0x0e	; 14
    1dbc:	ab d8       	rcall	.-3754   	; 0xf14 <vListInitialiseItem>
    1dbe:	db 87       	std	Y+11, r29	; 0x0b
    1dc0:	ca 87       	std	Y+10, r28	; 0x0a
    1dc2:	85 e0       	ldi	r24, 0x05	; 5
    1dc4:	90 e0       	ldi	r25, 0x00	; 0
    1dc6:	a0 e0       	ldi	r26, 0x00	; 0
    1dc8:	b0 e0       	ldi	r27, 0x00	; 0
    1dca:	80 1b       	sub	r24, r16
    1dcc:	91 09       	sbc	r25, r1
    1dce:	a1 09       	sbc	r26, r1
    1dd0:	b1 09       	sbc	r27, r1
    1dd2:	8e 87       	std	Y+14, r24	; 0x0e
    1dd4:	9f 87       	std	Y+15, r25	; 0x0f
    1dd6:	a8 8b       	std	Y+16, r26	; 0x10
    1dd8:	b9 8b       	std	Y+17, r27	; 0x11
    1dda:	df 8b       	std	Y+23, r29	; 0x17
    1ddc:	ce 8b       	std	Y+22, r28	; 0x16
    1dde:	1d aa       	std	Y+53, r1	; 0x35
    1de0:	1e aa       	std	Y+54, r1	; 0x36
    1de2:	1f aa       	std	Y+55, r1	; 0x37
    1de4:	18 ae       	std	Y+56, r1	; 0x38
    1de6:	19 ae       	std	Y+57, r1	; 0x39
    1de8:	a2 01       	movw	r20, r4
    1dea:	b4 01       	movw	r22, r8
    1dec:	c5 01       	movw	r24, r10
    1dee:	5a da       	rcall	.-2892   	; 0x12a4 <pxPortInitialiseStack>
    1df0:	99 83       	std	Y+1, r25	; 0x01
    1df2:	88 83       	st	Y, r24
    1df4:	e1 14       	cp	r14, r1
    1df6:	f1 04       	cpc	r15, r1
    1df8:	19 f0       	breq	.+6      	; 0x1e00 <xTaskCreate+0xfc>
    1dfa:	f7 01       	movw	r30, r14
    1dfc:	d1 83       	std	Z+1, r29	; 0x01
    1dfe:	c0 83       	st	Z, r28
    1e00:	0f b6       	in	r0, 0x3f	; 63
    1e02:	f8 94       	cli
    1e04:	0f 92       	push	r0
    1e06:	80 91 89 1d 	lds	r24, 0x1D89	; 0x801d89 <uxCurrentNumberOfTasks>
    1e0a:	8f 5f       	subi	r24, 0xFF	; 255
    1e0c:	80 93 89 1d 	sts	0x1D89, r24	; 0x801d89 <uxCurrentNumberOfTasks>
    1e10:	80 91 fd 1d 	lds	r24, 0x1DFD	; 0x801dfd <pxCurrentTCB>
    1e14:	90 91 fe 1d 	lds	r25, 0x1DFE	; 0x801dfe <pxCurrentTCB+0x1>
    1e18:	89 2b       	or	r24, r25
    1e1a:	a9 f5       	brne	.+106    	; 0x1e86 <xTaskCreate+0x182>
    1e1c:	d0 93 fe 1d 	sts	0x1DFE, r29	; 0x801dfe <pxCurrentTCB+0x1>
    1e20:	c0 93 fd 1d 	sts	0x1DFD, r28	; 0x801dfd <pxCurrentTCB>
    1e24:	80 91 89 1d 	lds	r24, 0x1D89	; 0x801d89 <uxCurrentNumberOfTasks>
    1e28:	81 30       	cpi	r24, 0x01	; 1
    1e2a:	09 f0       	breq	.+2      	; 0x1e2e <xTaskCreate+0x12a>
    1e2c:	3c c0       	rjmp	.+120    	; 0x1ea6 <xTaskCreate+0x1a2>
    1e2e:	0f 2e       	mov	r0, r31
    1e30:	f6 ec       	ldi	r31, 0xC6	; 198
    1e32:	ef 2e       	mov	r14, r31
    1e34:	fd e1       	ldi	r31, 0x1D	; 29
    1e36:	ff 2e       	mov	r15, r31
    1e38:	f0 2d       	mov	r31, r0
    1e3a:	0d ef       	ldi	r16, 0xFD	; 253
    1e3c:	1d e1       	ldi	r17, 0x1D	; 29
    1e3e:	c7 01       	movw	r24, r14
    1e40:	58 d8       	rcall	.-3920   	; 0xef2 <vListInitialise>
    1e42:	fb e0       	ldi	r31, 0x0B	; 11
    1e44:	ef 0e       	add	r14, r31
    1e46:	f1 1c       	adc	r15, r1
    1e48:	e0 16       	cp	r14, r16
    1e4a:	f1 06       	cpc	r15, r17
    1e4c:	c1 f7       	brne	.-16     	; 0x1e3e <xTaskCreate+0x13a>
    1e4e:	8b eb       	ldi	r24, 0xBB	; 187
    1e50:	9d e1       	ldi	r25, 0x1D	; 29
    1e52:	4f d8       	rcall	.-3938   	; 0xef2 <vListInitialise>
    1e54:	80 eb       	ldi	r24, 0xB0	; 176
    1e56:	9d e1       	ldi	r25, 0x1D	; 29
    1e58:	4c d8       	rcall	.-3944   	; 0xef2 <vListInitialise>
    1e5a:	81 ea       	ldi	r24, 0xA1	; 161
    1e5c:	9d e1       	ldi	r25, 0x1D	; 29
    1e5e:	49 d8       	rcall	.-3950   	; 0xef2 <vListInitialise>
    1e60:	86 e9       	ldi	r24, 0x96	; 150
    1e62:	9d e1       	ldi	r25, 0x1D	; 29
    1e64:	46 d8       	rcall	.-3956   	; 0xef2 <vListInitialise>
    1e66:	8a e8       	ldi	r24, 0x8A	; 138
    1e68:	9d e1       	ldi	r25, 0x1D	; 29
    1e6a:	43 d8       	rcall	.-3962   	; 0xef2 <vListInitialise>
    1e6c:	8b eb       	ldi	r24, 0xBB	; 187
    1e6e:	9d e1       	ldi	r25, 0x1D	; 29
    1e70:	90 93 af 1d 	sts	0x1DAF, r25	; 0x801daf <pxDelayedTaskList+0x1>
    1e74:	80 93 ae 1d 	sts	0x1DAE, r24	; 0x801dae <pxDelayedTaskList>
    1e78:	80 eb       	ldi	r24, 0xB0	; 176
    1e7a:	9d e1       	ldi	r25, 0x1D	; 29
    1e7c:	90 93 ad 1d 	sts	0x1DAD, r25	; 0x801dad <pxOverflowDelayedTaskList+0x1>
    1e80:	80 93 ac 1d 	sts	0x1DAC, r24	; 0x801dac <pxOverflowDelayedTaskList>
    1e84:	10 c0       	rjmp	.+32     	; 0x1ea6 <xTaskCreate+0x1a2>
    1e86:	80 91 83 1d 	lds	r24, 0x1D83	; 0x801d83 <xSchedulerRunning>
    1e8a:	81 11       	cpse	r24, r1
    1e8c:	0c c0       	rjmp	.+24     	; 0x1ea6 <xTaskCreate+0x1a2>
    1e8e:	e0 91 fd 1d 	lds	r30, 0x1DFD	; 0x801dfd <pxCurrentTCB>
    1e92:	f0 91 fe 1d 	lds	r31, 0x1DFE	; 0x801dfe <pxCurrentTCB+0x1>
    1e96:	92 8d       	ldd	r25, Z+26	; 0x1a
    1e98:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1e9a:	89 17       	cp	r24, r25
    1e9c:	20 f0       	brcs	.+8      	; 0x1ea6 <xTaskCreate+0x1a2>
    1e9e:	d0 93 fe 1d 	sts	0x1DFE, r29	; 0x801dfe <pxCurrentTCB+0x1>
    1ea2:	c0 93 fd 1d 	sts	0x1DFD, r28	; 0x801dfd <pxCurrentTCB>
    1ea6:	80 91 7f 1d 	lds	r24, 0x1D7F	; 0x801d7f <uxTaskNumber>
    1eaa:	8f 5f       	subi	r24, 0xFF	; 255
    1eac:	80 93 7f 1d 	sts	0x1D7F, r24	; 0x801d7f <uxTaskNumber>
    1eb0:	89 ab       	std	Y+49, r24	; 0x31
    1eb2:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1eb4:	90 91 84 1d 	lds	r25, 0x1D84	; 0x801d84 <uxTopReadyPriority>
    1eb8:	98 17       	cp	r25, r24
    1eba:	10 f4       	brcc	.+4      	; 0x1ec0 <xTaskCreate+0x1bc>
    1ebc:	80 93 84 1d 	sts	0x1D84, r24	; 0x801d84 <uxTopReadyPriority>
    1ec0:	2b e0       	ldi	r18, 0x0B	; 11
    1ec2:	82 9f       	mul	r24, r18
    1ec4:	c0 01       	movw	r24, r0
    1ec6:	11 24       	eor	r1, r1
    1ec8:	b6 01       	movw	r22, r12
    1eca:	8a 53       	subi	r24, 0x3A	; 58
    1ecc:	92 4e       	sbci	r25, 0xE2	; 226
    1ece:	26 d8       	rcall	.-4020   	; 0xf1c <vListInsertEnd>
    1ed0:	0f 90       	pop	r0
    1ed2:	0f be       	out	0x3f, r0	; 63
    1ed4:	80 91 83 1d 	lds	r24, 0x1D83	; 0x801d83 <xSchedulerRunning>
    1ed8:	88 23       	and	r24, r24
    1eda:	59 f0       	breq	.+22     	; 0x1ef2 <xTaskCreate+0x1ee>
    1edc:	e0 91 fd 1d 	lds	r30, 0x1DFD	; 0x801dfd <pxCurrentTCB>
    1ee0:	f0 91 fe 1d 	lds	r31, 0x1DFE	; 0x801dfe <pxCurrentTCB+0x1>
    1ee4:	92 8d       	ldd	r25, Z+26	; 0x1a
    1ee6:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1ee8:	98 17       	cp	r25, r24
    1eea:	28 f4       	brcc	.+10     	; 0x1ef6 <xTaskCreate+0x1f2>
    1eec:	8d da       	rcall	.-2790   	; 0x1408 <vPortYield>
    1eee:	81 e0       	ldi	r24, 0x01	; 1
    1ef0:	05 c0       	rjmp	.+10     	; 0x1efc <xTaskCreate+0x1f8>
    1ef2:	81 e0       	ldi	r24, 0x01	; 1
    1ef4:	03 c0       	rjmp	.+6      	; 0x1efc <xTaskCreate+0x1f8>
    1ef6:	81 e0       	ldi	r24, 0x01	; 1
    1ef8:	01 c0       	rjmp	.+2      	; 0x1efc <xTaskCreate+0x1f8>
    1efa:	8f ef       	ldi	r24, 0xFF	; 255
    1efc:	df 91       	pop	r29
    1efe:	cf 91       	pop	r28
    1f00:	1f 91       	pop	r17
    1f02:	0f 91       	pop	r16
    1f04:	ff 90       	pop	r15
    1f06:	ef 90       	pop	r14
    1f08:	df 90       	pop	r13
    1f0a:	cf 90       	pop	r12
    1f0c:	bf 90       	pop	r11
    1f0e:	af 90       	pop	r10
    1f10:	9f 90       	pop	r9
    1f12:	8f 90       	pop	r8
    1f14:	7f 90       	pop	r7
    1f16:	6f 90       	pop	r6
    1f18:	5f 90       	pop	r5
    1f1a:	4f 90       	pop	r4
    1f1c:	08 95       	ret

00001f1e <xTaskResumeFromISR>:
    1f1e:	ef 92       	push	r14
    1f20:	ff 92       	push	r15
    1f22:	1f 93       	push	r17
    1f24:	cf 93       	push	r28
    1f26:	df 93       	push	r29
    1f28:	fc 01       	movw	r30, r24
    1f2a:	24 85       	ldd	r18, Z+12	; 0x0c
    1f2c:	35 85       	ldd	r19, Z+13	; 0x0d
    1f2e:	2a 58       	subi	r18, 0x8A	; 138
    1f30:	3d 41       	sbci	r19, 0x1D	; 29
    1f32:	c1 f5       	brne	.+112    	; 0x1fa4 <xTaskResumeFromISR+0x86>
    1f34:	fc 01       	movw	r30, r24
    1f36:	20 8d       	ldd	r18, Z+24	; 0x18
    1f38:	31 8d       	ldd	r19, Z+25	; 0x19
    1f3a:	fd e1       	ldi	r31, 0x1D	; 29
    1f3c:	21 3a       	cpi	r18, 0xA1	; 161
    1f3e:	3f 07       	cpc	r19, r31
    1f40:	99 f1       	breq	.+102    	; 0x1fa8 <xTaskResumeFromISR+0x8a>
    1f42:	23 2b       	or	r18, r19
    1f44:	99 f5       	brne	.+102    	; 0x1fac <xTaskResumeFromISR+0x8e>
    1f46:	ec 01       	movw	r28, r24
    1f48:	80 91 78 1d 	lds	r24, 0x1D78	; 0x801d78 <uxSchedulerSuspended>
    1f4c:	81 11       	cpse	r24, r1
    1f4e:	21 c0       	rjmp	.+66     	; 0x1f92 <xTaskResumeFromISR+0x74>
    1f50:	e0 91 fd 1d 	lds	r30, 0x1DFD	; 0x801dfd <pxCurrentTCB>
    1f54:	f0 91 fe 1d 	lds	r31, 0x1DFE	; 0x801dfe <pxCurrentTCB+0x1>
    1f58:	11 e0       	ldi	r17, 0x01	; 1
    1f5a:	9a 8d       	ldd	r25, Y+26	; 0x1a
    1f5c:	82 8d       	ldd	r24, Z+26	; 0x1a
    1f5e:	98 17       	cp	r25, r24
    1f60:	08 f4       	brcc	.+2      	; 0x1f64 <xTaskResumeFromISR+0x46>
    1f62:	10 e0       	ldi	r17, 0x00	; 0
    1f64:	7e 01       	movw	r14, r28
    1f66:	22 e0       	ldi	r18, 0x02	; 2
    1f68:	e2 0e       	add	r14, r18
    1f6a:	f1 1c       	adc	r15, r1
    1f6c:	c7 01       	movw	r24, r14
    1f6e:	34 d8       	rcall	.-3992   	; 0xfd8 <uxListRemove>
    1f70:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1f72:	90 91 84 1d 	lds	r25, 0x1D84	; 0x801d84 <uxTopReadyPriority>
    1f76:	98 17       	cp	r25, r24
    1f78:	10 f4       	brcc	.+4      	; 0x1f7e <xTaskResumeFromISR+0x60>
    1f7a:	80 93 84 1d 	sts	0x1D84, r24	; 0x801d84 <uxTopReadyPriority>
    1f7e:	4b e0       	ldi	r20, 0x0B	; 11
    1f80:	84 9f       	mul	r24, r20
    1f82:	c0 01       	movw	r24, r0
    1f84:	11 24       	eor	r1, r1
    1f86:	b7 01       	movw	r22, r14
    1f88:	8a 53       	subi	r24, 0x3A	; 58
    1f8a:	92 4e       	sbci	r25, 0xE2	; 226
    1f8c:	0e 94 8e 07 	call	0xf1c	; 0xf1c <vListInsertEnd>
    1f90:	0e c0       	rjmp	.+28     	; 0x1fae <xTaskResumeFromISR+0x90>
    1f92:	be 01       	movw	r22, r28
    1f94:	62 5f       	subi	r22, 0xF2	; 242
    1f96:	7f 4f       	sbci	r23, 0xFF	; 255
    1f98:	81 ea       	ldi	r24, 0xA1	; 161
    1f9a:	9d e1       	ldi	r25, 0x1D	; 29
    1f9c:	0e 94 8e 07 	call	0xf1c	; 0xf1c <vListInsertEnd>
    1fa0:	10 e0       	ldi	r17, 0x00	; 0
    1fa2:	05 c0       	rjmp	.+10     	; 0x1fae <xTaskResumeFromISR+0x90>
    1fa4:	10 e0       	ldi	r17, 0x00	; 0
    1fa6:	03 c0       	rjmp	.+6      	; 0x1fae <xTaskResumeFromISR+0x90>
    1fa8:	10 e0       	ldi	r17, 0x00	; 0
    1faa:	01 c0       	rjmp	.+2      	; 0x1fae <xTaskResumeFromISR+0x90>
    1fac:	10 e0       	ldi	r17, 0x00	; 0
    1fae:	81 2f       	mov	r24, r17
    1fb0:	df 91       	pop	r29
    1fb2:	cf 91       	pop	r28
    1fb4:	1f 91       	pop	r17
    1fb6:	ff 90       	pop	r15
    1fb8:	ef 90       	pop	r14
    1fba:	08 95       	ret

00001fbc <vTaskStartScheduler>:
    1fbc:	ef 92       	push	r14
    1fbe:	ff 92       	push	r15
    1fc0:	0f 93       	push	r16
    1fc2:	0f 2e       	mov	r0, r31
    1fc4:	f9 e7       	ldi	r31, 0x79	; 121
    1fc6:	ef 2e       	mov	r14, r31
    1fc8:	fd e1       	ldi	r31, 0x1D	; 29
    1fca:	ff 2e       	mov	r15, r31
    1fcc:	f0 2d       	mov	r31, r0
    1fce:	00 e0       	ldi	r16, 0x00	; 0
    1fd0:	20 e0       	ldi	r18, 0x00	; 0
    1fd2:	30 e0       	ldi	r19, 0x00	; 0
    1fd4:	40 e0       	ldi	r20, 0x00	; 0
    1fd6:	54 e0       	ldi	r21, 0x04	; 4
    1fd8:	6f e7       	ldi	r22, 0x7F	; 127
    1fda:	72 e0       	ldi	r23, 0x02	; 2
    1fdc:	8b e8       	ldi	r24, 0x8B	; 139
    1fde:	91 e1       	ldi	r25, 0x11	; 17
    1fe0:	91 de       	rcall	.-734    	; 0x1d04 <xTaskCreate>
    1fe2:	81 30       	cpi	r24, 0x01	; 1
    1fe4:	c1 f4       	brne	.+48     	; 0x2016 <vTaskStartScheduler+0x5a>
    1fe6:	f8 94       	cli
    1fe8:	8f ef       	ldi	r24, 0xFF	; 255
    1fea:	9f ef       	ldi	r25, 0xFF	; 255
    1fec:	dc 01       	movw	r26, r24
    1fee:	80 93 7b 1d 	sts	0x1D7B, r24	; 0x801d7b <xNextTaskUnblockTime>
    1ff2:	90 93 7c 1d 	sts	0x1D7C, r25	; 0x801d7c <xNextTaskUnblockTime+0x1>
    1ff6:	a0 93 7d 1d 	sts	0x1D7D, r26	; 0x801d7d <xNextTaskUnblockTime+0x2>
    1ffa:	b0 93 7e 1d 	sts	0x1D7E, r27	; 0x801d7e <xNextTaskUnblockTime+0x3>
    1ffe:	81 e0       	ldi	r24, 0x01	; 1
    2000:	80 93 83 1d 	sts	0x1D83, r24	; 0x801d83 <xSchedulerRunning>
    2004:	10 92 85 1d 	sts	0x1D85, r1	; 0x801d85 <xTickCount>
    2008:	10 92 86 1d 	sts	0x1D86, r1	; 0x801d86 <xTickCount+0x1>
    200c:	10 92 87 1d 	sts	0x1D87, r1	; 0x801d87 <xTickCount+0x2>
    2010:	10 92 88 1d 	sts	0x1D88, r1	; 0x801d88 <xTickCount+0x3>
    2014:	b9 d9       	rcall	.-3214   	; 0x1388 <xPortStartScheduler>
    2016:	0f 91       	pop	r16
    2018:	ff 90       	pop	r15
    201a:	ef 90       	pop	r14
    201c:	08 95       	ret

0000201e <vTaskSuspendAll>:
    201e:	80 91 78 1d 	lds	r24, 0x1D78	; 0x801d78 <uxSchedulerSuspended>
    2022:	8f 5f       	subi	r24, 0xFF	; 255
    2024:	80 93 78 1d 	sts	0x1D78, r24	; 0x801d78 <uxSchedulerSuspended>
    2028:	08 95       	ret

0000202a <xTaskGetTickCount>:
    202a:	0f b6       	in	r0, 0x3f	; 63
    202c:	f8 94       	cli
    202e:	0f 92       	push	r0
    2030:	60 91 85 1d 	lds	r22, 0x1D85	; 0x801d85 <xTickCount>
    2034:	70 91 86 1d 	lds	r23, 0x1D86	; 0x801d86 <xTickCount+0x1>
    2038:	80 91 87 1d 	lds	r24, 0x1D87	; 0x801d87 <xTickCount+0x2>
    203c:	90 91 88 1d 	lds	r25, 0x1D88	; 0x801d88 <xTickCount+0x3>
    2040:	0f 90       	pop	r0
    2042:	0f be       	out	0x3f, r0	; 63
    2044:	08 95       	ret

00002046 <xTaskIncrementTick>:
    2046:	9f 92       	push	r9
    2048:	af 92       	push	r10
    204a:	bf 92       	push	r11
    204c:	cf 92       	push	r12
    204e:	df 92       	push	r13
    2050:	ef 92       	push	r14
    2052:	ff 92       	push	r15
    2054:	0f 93       	push	r16
    2056:	1f 93       	push	r17
    2058:	cf 93       	push	r28
    205a:	df 93       	push	r29
    205c:	80 91 78 1d 	lds	r24, 0x1D78	; 0x801d78 <uxSchedulerSuspended>
    2060:	81 11       	cpse	r24, r1
    2062:	ad c0       	rjmp	.+346    	; 0x21be <xTaskIncrementTick+0x178>
    2064:	c0 90 85 1d 	lds	r12, 0x1D85	; 0x801d85 <xTickCount>
    2068:	d0 90 86 1d 	lds	r13, 0x1D86	; 0x801d86 <xTickCount+0x1>
    206c:	e0 90 87 1d 	lds	r14, 0x1D87	; 0x801d87 <xTickCount+0x2>
    2070:	f0 90 88 1d 	lds	r15, 0x1D88	; 0x801d88 <xTickCount+0x3>
    2074:	8f ef       	ldi	r24, 0xFF	; 255
    2076:	c8 1a       	sub	r12, r24
    2078:	d8 0a       	sbc	r13, r24
    207a:	e8 0a       	sbc	r14, r24
    207c:	f8 0a       	sbc	r15, r24
    207e:	c0 92 85 1d 	sts	0x1D85, r12	; 0x801d85 <xTickCount>
    2082:	d0 92 86 1d 	sts	0x1D86, r13	; 0x801d86 <xTickCount+0x1>
    2086:	e0 92 87 1d 	sts	0x1D87, r14	; 0x801d87 <xTickCount+0x2>
    208a:	f0 92 88 1d 	sts	0x1D88, r15	; 0x801d88 <xTickCount+0x3>
    208e:	c1 14       	cp	r12, r1
    2090:	d1 04       	cpc	r13, r1
    2092:	e1 04       	cpc	r14, r1
    2094:	f1 04       	cpc	r15, r1
    2096:	b1 f4       	brne	.+44     	; 0x20c4 <xTaskIncrementTick+0x7e>
    2098:	80 91 ae 1d 	lds	r24, 0x1DAE	; 0x801dae <pxDelayedTaskList>
    209c:	90 91 af 1d 	lds	r25, 0x1DAF	; 0x801daf <pxDelayedTaskList+0x1>
    20a0:	20 91 ac 1d 	lds	r18, 0x1DAC	; 0x801dac <pxOverflowDelayedTaskList>
    20a4:	30 91 ad 1d 	lds	r19, 0x1DAD	; 0x801dad <pxOverflowDelayedTaskList+0x1>
    20a8:	30 93 af 1d 	sts	0x1DAF, r19	; 0x801daf <pxDelayedTaskList+0x1>
    20ac:	20 93 ae 1d 	sts	0x1DAE, r18	; 0x801dae <pxDelayedTaskList>
    20b0:	90 93 ad 1d 	sts	0x1DAD, r25	; 0x801dad <pxOverflowDelayedTaskList+0x1>
    20b4:	80 93 ac 1d 	sts	0x1DAC, r24	; 0x801dac <pxOverflowDelayedTaskList>
    20b8:	80 91 80 1d 	lds	r24, 0x1D80	; 0x801d80 <xNumOfOverflows>
    20bc:	8f 5f       	subi	r24, 0xFF	; 255
    20be:	80 93 80 1d 	sts	0x1D80, r24	; 0x801d80 <xNumOfOverflows>
    20c2:	83 dd       	rcall	.-1274   	; 0x1bca <prvResetNextTaskUnblockTime>
    20c4:	80 91 7b 1d 	lds	r24, 0x1D7B	; 0x801d7b <xNextTaskUnblockTime>
    20c8:	90 91 7c 1d 	lds	r25, 0x1D7C	; 0x801d7c <xNextTaskUnblockTime+0x1>
    20cc:	a0 91 7d 1d 	lds	r26, 0x1D7D	; 0x801d7d <xNextTaskUnblockTime+0x2>
    20d0:	b0 91 7e 1d 	lds	r27, 0x1D7E	; 0x801d7e <xNextTaskUnblockTime+0x3>
    20d4:	c8 16       	cp	r12, r24
    20d6:	d9 06       	cpc	r13, r25
    20d8:	ea 06       	cpc	r14, r26
    20da:	fb 06       	cpc	r15, r27
    20dc:	10 f4       	brcc	.+4      	; 0x20e2 <xTaskIncrementTick+0x9c>
    20de:	b1 2c       	mov	r11, r1
    20e0:	5d c0       	rjmp	.+186    	; 0x219c <xTaskIncrementTick+0x156>
    20e2:	b1 2c       	mov	r11, r1
    20e4:	0f 2e       	mov	r0, r31
    20e6:	fb e0       	ldi	r31, 0x0B	; 11
    20e8:	af 2e       	mov	r10, r31
    20ea:	f0 2d       	mov	r31, r0
    20ec:	99 24       	eor	r9, r9
    20ee:	93 94       	inc	r9
    20f0:	e0 91 ae 1d 	lds	r30, 0x1DAE	; 0x801dae <pxDelayedTaskList>
    20f4:	f0 91 af 1d 	lds	r31, 0x1DAF	; 0x801daf <pxDelayedTaskList+0x1>
    20f8:	80 81       	ld	r24, Z
    20fa:	81 11       	cpse	r24, r1
    20fc:	0c c0       	rjmp	.+24     	; 0x2116 <xTaskIncrementTick+0xd0>
    20fe:	8f ef       	ldi	r24, 0xFF	; 255
    2100:	9f ef       	ldi	r25, 0xFF	; 255
    2102:	dc 01       	movw	r26, r24
    2104:	80 93 7b 1d 	sts	0x1D7B, r24	; 0x801d7b <xNextTaskUnblockTime>
    2108:	90 93 7c 1d 	sts	0x1D7C, r25	; 0x801d7c <xNextTaskUnblockTime+0x1>
    210c:	a0 93 7d 1d 	sts	0x1D7D, r26	; 0x801d7d <xNextTaskUnblockTime+0x2>
    2110:	b0 93 7e 1d 	sts	0x1D7E, r27	; 0x801d7e <xNextTaskUnblockTime+0x3>
    2114:	43 c0       	rjmp	.+134    	; 0x219c <xTaskIncrementTick+0x156>
    2116:	e0 91 ae 1d 	lds	r30, 0x1DAE	; 0x801dae <pxDelayedTaskList>
    211a:	f0 91 af 1d 	lds	r31, 0x1DAF	; 0x801daf <pxDelayedTaskList+0x1>
    211e:	07 80       	ldd	r0, Z+7	; 0x07
    2120:	f0 85       	ldd	r31, Z+8	; 0x08
    2122:	e0 2d       	mov	r30, r0
    2124:	c0 85       	ldd	r28, Z+8	; 0x08
    2126:	d1 85       	ldd	r29, Z+9	; 0x09
    2128:	8a 81       	ldd	r24, Y+2	; 0x02
    212a:	9b 81       	ldd	r25, Y+3	; 0x03
    212c:	ac 81       	ldd	r26, Y+4	; 0x04
    212e:	bd 81       	ldd	r27, Y+5	; 0x05
    2130:	c8 16       	cp	r12, r24
    2132:	d9 06       	cpc	r13, r25
    2134:	ea 06       	cpc	r14, r26
    2136:	fb 06       	cpc	r15, r27
    2138:	48 f4       	brcc	.+18     	; 0x214c <xTaskIncrementTick+0x106>
    213a:	80 93 7b 1d 	sts	0x1D7B, r24	; 0x801d7b <xNextTaskUnblockTime>
    213e:	90 93 7c 1d 	sts	0x1D7C, r25	; 0x801d7c <xNextTaskUnblockTime+0x1>
    2142:	a0 93 7d 1d 	sts	0x1D7D, r26	; 0x801d7d <xNextTaskUnblockTime+0x2>
    2146:	b0 93 7e 1d 	sts	0x1D7E, r27	; 0x801d7e <xNextTaskUnblockTime+0x3>
    214a:	28 c0       	rjmp	.+80     	; 0x219c <xTaskIncrementTick+0x156>
    214c:	8e 01       	movw	r16, r28
    214e:	0e 5f       	subi	r16, 0xFE	; 254
    2150:	1f 4f       	sbci	r17, 0xFF	; 255
    2152:	c8 01       	movw	r24, r16
    2154:	0e 94 ec 07 	call	0xfd8	; 0xfd8 <uxListRemove>
    2158:	88 8d       	ldd	r24, Y+24	; 0x18
    215a:	99 8d       	ldd	r25, Y+25	; 0x19
    215c:	89 2b       	or	r24, r25
    215e:	21 f0       	breq	.+8      	; 0x2168 <xTaskIncrementTick+0x122>
    2160:	ce 01       	movw	r24, r28
    2162:	0e 96       	adiw	r24, 0x0e	; 14
    2164:	0e 94 ec 07 	call	0xfd8	; 0xfd8 <uxListRemove>
    2168:	8a 8d       	ldd	r24, Y+26	; 0x1a
    216a:	90 91 84 1d 	lds	r25, 0x1D84	; 0x801d84 <uxTopReadyPriority>
    216e:	98 17       	cp	r25, r24
    2170:	10 f4       	brcc	.+4      	; 0x2176 <xTaskIncrementTick+0x130>
    2172:	80 93 84 1d 	sts	0x1D84, r24	; 0x801d84 <uxTopReadyPriority>
    2176:	a8 9e       	mul	r10, r24
    2178:	c0 01       	movw	r24, r0
    217a:	11 24       	eor	r1, r1
    217c:	b8 01       	movw	r22, r16
    217e:	8a 53       	subi	r24, 0x3A	; 58
    2180:	92 4e       	sbci	r25, 0xE2	; 226
    2182:	0e 94 8e 07 	call	0xf1c	; 0xf1c <vListInsertEnd>
    2186:	e0 91 fd 1d 	lds	r30, 0x1DFD	; 0x801dfd <pxCurrentTCB>
    218a:	f0 91 fe 1d 	lds	r31, 0x1DFE	; 0x801dfe <pxCurrentTCB+0x1>
    218e:	9a 8d       	ldd	r25, Y+26	; 0x1a
    2190:	82 8d       	ldd	r24, Z+26	; 0x1a
    2192:	98 17       	cp	r25, r24
    2194:	08 f4       	brcc	.+2      	; 0x2198 <xTaskIncrementTick+0x152>
    2196:	ac cf       	rjmp	.-168    	; 0x20f0 <xTaskIncrementTick+0xaa>
    2198:	b9 2c       	mov	r11, r9
    219a:	aa cf       	rjmp	.-172    	; 0x20f0 <xTaskIncrementTick+0xaa>
    219c:	e0 91 fd 1d 	lds	r30, 0x1DFD	; 0x801dfd <pxCurrentTCB>
    21a0:	f0 91 fe 1d 	lds	r31, 0x1DFE	; 0x801dfe <pxCurrentTCB+0x1>
    21a4:	e2 8d       	ldd	r30, Z+26	; 0x1a
    21a6:	8b e0       	ldi	r24, 0x0B	; 11
    21a8:	e8 9f       	mul	r30, r24
    21aa:	f0 01       	movw	r30, r0
    21ac:	11 24       	eor	r1, r1
    21ae:	ea 53       	subi	r30, 0x3A	; 58
    21b0:	f2 4e       	sbci	r31, 0xE2	; 226
    21b2:	80 81       	ld	r24, Z
    21b4:	82 30       	cpi	r24, 0x02	; 2
    21b6:	48 f0       	brcs	.+18     	; 0x21ca <xTaskIncrementTick+0x184>
    21b8:	bb 24       	eor	r11, r11
    21ba:	b3 94       	inc	r11
    21bc:	06 c0       	rjmp	.+12     	; 0x21ca <xTaskIncrementTick+0x184>
    21be:	80 91 82 1d 	lds	r24, 0x1D82	; 0x801d82 <uxPendedTicks>
    21c2:	8f 5f       	subi	r24, 0xFF	; 255
    21c4:	80 93 82 1d 	sts	0x1D82, r24	; 0x801d82 <uxPendedTicks>
    21c8:	b1 2c       	mov	r11, r1
    21ca:	80 91 81 1d 	lds	r24, 0x1D81	; 0x801d81 <xYieldPending>
    21ce:	88 23       	and	r24, r24
    21d0:	11 f0       	breq	.+4      	; 0x21d6 <xTaskIncrementTick+0x190>
    21d2:	bb 24       	eor	r11, r11
    21d4:	b3 94       	inc	r11
    21d6:	8b 2d       	mov	r24, r11
    21d8:	df 91       	pop	r29
    21da:	cf 91       	pop	r28
    21dc:	1f 91       	pop	r17
    21de:	0f 91       	pop	r16
    21e0:	ff 90       	pop	r15
    21e2:	ef 90       	pop	r14
    21e4:	df 90       	pop	r13
    21e6:	cf 90       	pop	r12
    21e8:	bf 90       	pop	r11
    21ea:	af 90       	pop	r10
    21ec:	9f 90       	pop	r9
    21ee:	08 95       	ret

000021f0 <xTaskResumeAll>:
    21f0:	cf 92       	push	r12
    21f2:	df 92       	push	r13
    21f4:	ef 92       	push	r14
    21f6:	ff 92       	push	r15
    21f8:	0f 93       	push	r16
    21fa:	1f 93       	push	r17
    21fc:	cf 93       	push	r28
    21fe:	df 93       	push	r29
    2200:	0f b6       	in	r0, 0x3f	; 63
    2202:	f8 94       	cli
    2204:	0f 92       	push	r0
    2206:	80 91 78 1d 	lds	r24, 0x1D78	; 0x801d78 <uxSchedulerSuspended>
    220a:	81 50       	subi	r24, 0x01	; 1
    220c:	80 93 78 1d 	sts	0x1D78, r24	; 0x801d78 <uxSchedulerSuspended>
    2210:	80 91 78 1d 	lds	r24, 0x1D78	; 0x801d78 <uxSchedulerSuspended>
    2214:	81 11       	cpse	r24, r1
    2216:	59 c0       	rjmp	.+178    	; 0x22ca <__stack+0xcb>
    2218:	80 91 89 1d 	lds	r24, 0x1D89	; 0x801d89 <uxCurrentNumberOfTasks>
    221c:	81 11       	cpse	r24, r1
    221e:	2c c0       	rjmp	.+88     	; 0x2278 <__stack+0x79>
    2220:	57 c0       	rjmp	.+174    	; 0x22d0 <__stack+0xd1>
    2222:	d7 01       	movw	r26, r14
    2224:	17 96       	adiw	r26, 0x07	; 7
    2226:	ed 91       	ld	r30, X+
    2228:	fc 91       	ld	r31, X
    222a:	18 97       	sbiw	r26, 0x08	; 8
    222c:	c0 85       	ldd	r28, Z+8	; 0x08
    222e:	d1 85       	ldd	r29, Z+9	; 0x09
    2230:	ce 01       	movw	r24, r28
    2232:	0e 96       	adiw	r24, 0x0e	; 14
    2234:	0e 94 ec 07 	call	0xfd8	; 0xfd8 <uxListRemove>
    2238:	8e 01       	movw	r16, r28
    223a:	0e 5f       	subi	r16, 0xFE	; 254
    223c:	1f 4f       	sbci	r17, 0xFF	; 255
    223e:	c8 01       	movw	r24, r16
    2240:	0e 94 ec 07 	call	0xfd8	; 0xfd8 <uxListRemove>
    2244:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2246:	90 91 84 1d 	lds	r25, 0x1D84	; 0x801d84 <uxTopReadyPriority>
    224a:	98 17       	cp	r25, r24
    224c:	10 f4       	brcc	.+4      	; 0x2252 <__stack+0x53>
    224e:	80 93 84 1d 	sts	0x1D84, r24	; 0x801d84 <uxTopReadyPriority>
    2252:	d8 9e       	mul	r13, r24
    2254:	c0 01       	movw	r24, r0
    2256:	11 24       	eor	r1, r1
    2258:	b8 01       	movw	r22, r16
    225a:	8a 53       	subi	r24, 0x3A	; 58
    225c:	92 4e       	sbci	r25, 0xE2	; 226
    225e:	0e 94 8e 07 	call	0xf1c	; 0xf1c <vListInsertEnd>
    2262:	e0 91 fd 1d 	lds	r30, 0x1DFD	; 0x801dfd <pxCurrentTCB>
    2266:	f0 91 fe 1d 	lds	r31, 0x1DFE	; 0x801dfe <pxCurrentTCB+0x1>
    226a:	9a 8d       	ldd	r25, Y+26	; 0x1a
    226c:	82 8d       	ldd	r24, Z+26	; 0x1a
    226e:	98 17       	cp	r25, r24
    2270:	88 f0       	brcs	.+34     	; 0x2294 <__stack+0x95>
    2272:	c0 92 81 1d 	sts	0x1D81, r12	; 0x801d81 <xYieldPending>
    2276:	0e c0       	rjmp	.+28     	; 0x2294 <__stack+0x95>
    2278:	c0 e0       	ldi	r28, 0x00	; 0
    227a:	d0 e0       	ldi	r29, 0x00	; 0
    227c:	0f 2e       	mov	r0, r31
    227e:	f1 ea       	ldi	r31, 0xA1	; 161
    2280:	ef 2e       	mov	r14, r31
    2282:	fd e1       	ldi	r31, 0x1D	; 29
    2284:	ff 2e       	mov	r15, r31
    2286:	f0 2d       	mov	r31, r0
    2288:	0f 2e       	mov	r0, r31
    228a:	fb e0       	ldi	r31, 0x0B	; 11
    228c:	df 2e       	mov	r13, r31
    228e:	f0 2d       	mov	r31, r0
    2290:	cc 24       	eor	r12, r12
    2292:	c3 94       	inc	r12
    2294:	f7 01       	movw	r30, r14
    2296:	80 81       	ld	r24, Z
    2298:	81 11       	cpse	r24, r1
    229a:	c3 cf       	rjmp	.-122    	; 0x2222 <__stack+0x23>
    229c:	cd 2b       	or	r28, r29
    229e:	09 f0       	breq	.+2      	; 0x22a2 <__stack+0xa3>
    22a0:	94 dc       	rcall	.-1752   	; 0x1bca <prvResetNextTaskUnblockTime>
    22a2:	c0 91 82 1d 	lds	r28, 0x1D82	; 0x801d82 <uxPendedTicks>
    22a6:	cc 23       	and	r28, r28
    22a8:	49 f0       	breq	.+18     	; 0x22bc <__stack+0xbd>
    22aa:	d1 e0       	ldi	r29, 0x01	; 1
    22ac:	cc de       	rcall	.-616    	; 0x2046 <xTaskIncrementTick>
    22ae:	81 11       	cpse	r24, r1
    22b0:	d0 93 81 1d 	sts	0x1D81, r29	; 0x801d81 <xYieldPending>
    22b4:	c1 50       	subi	r28, 0x01	; 1
    22b6:	d1 f7       	brne	.-12     	; 0x22ac <__stack+0xad>
    22b8:	10 92 82 1d 	sts	0x1D82, r1	; 0x801d82 <uxPendedTicks>
    22bc:	80 91 81 1d 	lds	r24, 0x1D81	; 0x801d81 <xYieldPending>
    22c0:	88 23       	and	r24, r24
    22c2:	29 f0       	breq	.+10     	; 0x22ce <__stack+0xcf>
    22c4:	a1 d8       	rcall	.-3774   	; 0x1408 <vPortYield>
    22c6:	81 e0       	ldi	r24, 0x01	; 1
    22c8:	03 c0       	rjmp	.+6      	; 0x22d0 <__stack+0xd1>
    22ca:	80 e0       	ldi	r24, 0x00	; 0
    22cc:	01 c0       	rjmp	.+2      	; 0x22d0 <__stack+0xd1>
    22ce:	80 e0       	ldi	r24, 0x00	; 0
    22d0:	0f 90       	pop	r0
    22d2:	0f be       	out	0x3f, r0	; 63
    22d4:	df 91       	pop	r29
    22d6:	cf 91       	pop	r28
    22d8:	1f 91       	pop	r17
    22da:	0f 91       	pop	r16
    22dc:	ff 90       	pop	r15
    22de:	ef 90       	pop	r14
    22e0:	df 90       	pop	r13
    22e2:	cf 90       	pop	r12
    22e4:	08 95       	ret

000022e6 <vTaskDelay>:
    22e6:	cf 92       	push	r12
    22e8:	df 92       	push	r13
    22ea:	ef 92       	push	r14
    22ec:	ff 92       	push	r15
    22ee:	6b 01       	movw	r12, r22
    22f0:	7c 01       	movw	r14, r24
    22f2:	67 2b       	or	r22, r23
    22f4:	68 2b       	or	r22, r24
    22f6:	69 2b       	or	r22, r25
    22f8:	41 f0       	breq	.+16     	; 0x230a <vTaskDelay+0x24>
    22fa:	91 de       	rcall	.-734    	; 0x201e <vTaskSuspendAll>
    22fc:	40 e0       	ldi	r20, 0x00	; 0
    22fe:	c7 01       	movw	r24, r14
    2300:	b6 01       	movw	r22, r12
    2302:	8d dc       	rcall	.-1766   	; 0x1c1e <prvAddCurrentTaskToDelayedList>
    2304:	75 df       	rcall	.-278    	; 0x21f0 <xTaskResumeAll>
    2306:	81 11       	cpse	r24, r1
    2308:	01 c0       	rjmp	.+2      	; 0x230c <vTaskDelay+0x26>
    230a:	7e d8       	rcall	.-3844   	; 0x1408 <vPortYield>
    230c:	ff 90       	pop	r15
    230e:	ef 90       	pop	r14
    2310:	df 90       	pop	r13
    2312:	cf 90       	pop	r12
    2314:	08 95       	ret

00002316 <prvIdleTask>:
    2316:	06 e9       	ldi	r16, 0x96	; 150
    2318:	1d e1       	ldi	r17, 0x1D	; 29
    231a:	0f 2e       	mov	r0, r31
    231c:	f6 ec       	ldi	r31, 0xC6	; 198
    231e:	ef 2e       	mov	r14, r31
    2320:	fd e1       	ldi	r31, 0x1D	; 29
    2322:	ff 2e       	mov	r15, r31
    2324:	f0 2d       	mov	r31, r0
    2326:	27 c0       	rjmp	.+78     	; 0x2376 <prvIdleTask+0x60>
    2328:	7a de       	rcall	.-780    	; 0x201e <vTaskSuspendAll>
    232a:	d8 01       	movw	r26, r16
    232c:	cc 91       	ld	r28, X
    232e:	60 df       	rcall	.-320    	; 0x21f0 <xTaskResumeAll>
    2330:	cc 23       	and	r28, r28
    2332:	09 f1       	breq	.+66     	; 0x2376 <prvIdleTask+0x60>
    2334:	0f b6       	in	r0, 0x3f	; 63
    2336:	f8 94       	cli
    2338:	0f 92       	push	r0
    233a:	d8 01       	movw	r26, r16
    233c:	17 96       	adiw	r26, 0x07	; 7
    233e:	ed 91       	ld	r30, X+
    2340:	fc 91       	ld	r31, X
    2342:	18 97       	sbiw	r26, 0x08	; 8
    2344:	c0 85       	ldd	r28, Z+8	; 0x08
    2346:	d1 85       	ldd	r29, Z+9	; 0x09
    2348:	ce 01       	movw	r24, r28
    234a:	02 96       	adiw	r24, 0x02	; 2
    234c:	0e 94 ec 07 	call	0xfd8	; 0xfd8 <uxListRemove>
    2350:	80 91 89 1d 	lds	r24, 0x1D89	; 0x801d89 <uxCurrentNumberOfTasks>
    2354:	81 50       	subi	r24, 0x01	; 1
    2356:	80 93 89 1d 	sts	0x1D89, r24	; 0x801d89 <uxCurrentNumberOfTasks>
    235a:	80 91 95 1d 	lds	r24, 0x1D95	; 0x801d95 <uxDeletedTasksWaitingCleanUp>
    235e:	81 50       	subi	r24, 0x01	; 1
    2360:	80 93 95 1d 	sts	0x1D95, r24	; 0x801d95 <uxDeletedTasksWaitingCleanUp>
    2364:	0f 90       	pop	r0
    2366:	0f be       	out	0x3f, r0	; 63
    2368:	8b 8d       	ldd	r24, Y+27	; 0x1b
    236a:	9c 8d       	ldd	r25, Y+28	; 0x1c
    236c:	0e 94 23 09 	call	0x1246	; 0x1246 <vPortFree>
    2370:	ce 01       	movw	r24, r28
    2372:	0e 94 23 09 	call	0x1246	; 0x1246 <vPortFree>
    2376:	80 91 95 1d 	lds	r24, 0x1D95	; 0x801d95 <uxDeletedTasksWaitingCleanUp>
    237a:	81 11       	cpse	r24, r1
    237c:	d5 cf       	rjmp	.-86     	; 0x2328 <prvIdleTask+0x12>
    237e:	f7 01       	movw	r30, r14
    2380:	80 81       	ld	r24, Z
    2382:	82 30       	cpi	r24, 0x02	; 2
    2384:	c0 f3       	brcs	.-16     	; 0x2376 <prvIdleTask+0x60>
    2386:	40 d8       	rcall	.-3968   	; 0x1408 <vPortYield>
    2388:	f6 cf       	rjmp	.-20     	; 0x2376 <prvIdleTask+0x60>

0000238a <vTaskSwitchContext>:
    238a:	80 91 78 1d 	lds	r24, 0x1D78	; 0x801d78 <uxSchedulerSuspended>
    238e:	88 23       	and	r24, r24
    2390:	21 f0       	breq	.+8      	; 0x239a <vTaskSwitchContext+0x10>
    2392:	81 e0       	ldi	r24, 0x01	; 1
    2394:	80 93 81 1d 	sts	0x1D81, r24	; 0x801d81 <xYieldPending>
    2398:	08 95       	ret
    239a:	10 92 81 1d 	sts	0x1D81, r1	; 0x801d81 <xYieldPending>
    239e:	80 91 84 1d 	lds	r24, 0x1D84	; 0x801d84 <uxTopReadyPriority>
    23a2:	28 2f       	mov	r18, r24
    23a4:	30 e0       	ldi	r19, 0x00	; 0
    23a6:	9b e0       	ldi	r25, 0x0B	; 11
    23a8:	89 9f       	mul	r24, r25
    23aa:	f0 01       	movw	r30, r0
    23ac:	11 24       	eor	r1, r1
    23ae:	ea 53       	subi	r30, 0x3A	; 58
    23b0:	f2 4e       	sbci	r31, 0xE2	; 226
    23b2:	90 81       	ld	r25, Z
    23b4:	91 11       	cpse	r25, r1
    23b6:	0e c0       	rjmp	.+28     	; 0x23d4 <vTaskSwitchContext+0x4a>
    23b8:	4b e0       	ldi	r20, 0x0B	; 11
    23ba:	81 50       	subi	r24, 0x01	; 1
    23bc:	28 2f       	mov	r18, r24
    23be:	30 e0       	ldi	r19, 0x00	; 0
    23c0:	42 9f       	mul	r20, r18
    23c2:	f0 01       	movw	r30, r0
    23c4:	43 9f       	mul	r20, r19
    23c6:	f0 0d       	add	r31, r0
    23c8:	11 24       	eor	r1, r1
    23ca:	ea 53       	subi	r30, 0x3A	; 58
    23cc:	f2 4e       	sbci	r31, 0xE2	; 226
    23ce:	90 81       	ld	r25, Z
    23d0:	99 23       	and	r25, r25
    23d2:	99 f3       	breq	.-26     	; 0x23ba <vTaskSwitchContext+0x30>
    23d4:	9b e0       	ldi	r25, 0x0B	; 11
    23d6:	92 9f       	mul	r25, r18
    23d8:	a0 01       	movw	r20, r0
    23da:	93 9f       	mul	r25, r19
    23dc:	50 0d       	add	r21, r0
    23de:	11 24       	eor	r1, r1
    23e0:	da 01       	movw	r26, r20
    23e2:	aa 53       	subi	r26, 0x3A	; 58
    23e4:	b2 4e       	sbci	r27, 0xE2	; 226
    23e6:	11 96       	adiw	r26, 0x01	; 1
    23e8:	ed 91       	ld	r30, X+
    23ea:	fc 91       	ld	r31, X
    23ec:	12 97       	sbiw	r26, 0x02	; 2
    23ee:	04 80       	ldd	r0, Z+4	; 0x04
    23f0:	f5 81       	ldd	r31, Z+5	; 0x05
    23f2:	e0 2d       	mov	r30, r0
    23f4:	12 96       	adiw	r26, 0x02	; 2
    23f6:	fc 93       	st	X, r31
    23f8:	ee 93       	st	-X, r30
    23fa:	11 97       	sbiw	r26, 0x01	; 1
    23fc:	47 53       	subi	r20, 0x37	; 55
    23fe:	52 4e       	sbci	r21, 0xE2	; 226
    2400:	e4 17       	cp	r30, r20
    2402:	f5 07       	cpc	r31, r21
    2404:	29 f4       	brne	.+10     	; 0x2410 <vTaskSwitchContext+0x86>
    2406:	44 81       	ldd	r20, Z+4	; 0x04
    2408:	55 81       	ldd	r21, Z+5	; 0x05
    240a:	fd 01       	movw	r30, r26
    240c:	52 83       	std	Z+2, r21	; 0x02
    240e:	41 83       	std	Z+1, r20	; 0x01
    2410:	9b e0       	ldi	r25, 0x0B	; 11
    2412:	92 9f       	mul	r25, r18
    2414:	f0 01       	movw	r30, r0
    2416:	93 9f       	mul	r25, r19
    2418:	f0 0d       	add	r31, r0
    241a:	11 24       	eor	r1, r1
    241c:	ea 53       	subi	r30, 0x3A	; 58
    241e:	f2 4e       	sbci	r31, 0xE2	; 226
    2420:	01 80       	ldd	r0, Z+1	; 0x01
    2422:	f2 81       	ldd	r31, Z+2	; 0x02
    2424:	e0 2d       	mov	r30, r0
    2426:	20 85       	ldd	r18, Z+8	; 0x08
    2428:	31 85       	ldd	r19, Z+9	; 0x09
    242a:	30 93 fe 1d 	sts	0x1DFE, r19	; 0x801dfe <pxCurrentTCB+0x1>
    242e:	20 93 fd 1d 	sts	0x1DFD, r18	; 0x801dfd <pxCurrentTCB>
    2432:	80 93 84 1d 	sts	0x1D84, r24	; 0x801d84 <uxTopReadyPriority>
    2436:	08 95       	ret

00002438 <vTaskPlaceOnEventList>:
    2438:	cf 92       	push	r12
    243a:	df 92       	push	r13
    243c:	ef 92       	push	r14
    243e:	ff 92       	push	r15
    2440:	6a 01       	movw	r12, r20
    2442:	7b 01       	movw	r14, r22
    2444:	60 91 fd 1d 	lds	r22, 0x1DFD	; 0x801dfd <pxCurrentTCB>
    2448:	70 91 fe 1d 	lds	r23, 0x1DFE	; 0x801dfe <pxCurrentTCB+0x1>
    244c:	62 5f       	subi	r22, 0xF2	; 242
    244e:	7f 4f       	sbci	r23, 0xFF	; 255
    2450:	0e 94 af 07 	call	0xf5e	; 0xf5e <vListInsert>
    2454:	41 e0       	ldi	r20, 0x01	; 1
    2456:	c7 01       	movw	r24, r14
    2458:	b6 01       	movw	r22, r12
    245a:	e1 db       	rcall	.-2110   	; 0x1c1e <prvAddCurrentTaskToDelayedList>
    245c:	ff 90       	pop	r15
    245e:	ef 90       	pop	r14
    2460:	df 90       	pop	r13
    2462:	cf 90       	pop	r12
    2464:	08 95       	ret

00002466 <xTaskRemoveFromEventList>:
    2466:	0f 93       	push	r16
    2468:	1f 93       	push	r17
    246a:	cf 93       	push	r28
    246c:	df 93       	push	r29
    246e:	dc 01       	movw	r26, r24
    2470:	17 96       	adiw	r26, 0x07	; 7
    2472:	ed 91       	ld	r30, X+
    2474:	fc 91       	ld	r31, X
    2476:	18 97       	sbiw	r26, 0x08	; 8
    2478:	c0 85       	ldd	r28, Z+8	; 0x08
    247a:	d1 85       	ldd	r29, Z+9	; 0x09
    247c:	8e 01       	movw	r16, r28
    247e:	02 5f       	subi	r16, 0xF2	; 242
    2480:	1f 4f       	sbci	r17, 0xFF	; 255
    2482:	c8 01       	movw	r24, r16
    2484:	0e 94 ec 07 	call	0xfd8	; 0xfd8 <uxListRemove>
    2488:	80 91 78 1d 	lds	r24, 0x1D78	; 0x801d78 <uxSchedulerSuspended>
    248c:	81 11       	cpse	r24, r1
    248e:	16 c0       	rjmp	.+44     	; 0x24bc <xTaskRemoveFromEventList+0x56>
    2490:	0c 50       	subi	r16, 0x0C	; 12
    2492:	11 09       	sbc	r17, r1
    2494:	c8 01       	movw	r24, r16
    2496:	0e 94 ec 07 	call	0xfd8	; 0xfd8 <uxListRemove>
    249a:	8a 8d       	ldd	r24, Y+26	; 0x1a
    249c:	90 91 84 1d 	lds	r25, 0x1D84	; 0x801d84 <uxTopReadyPriority>
    24a0:	98 17       	cp	r25, r24
    24a2:	10 f4       	brcc	.+4      	; 0x24a8 <xTaskRemoveFromEventList+0x42>
    24a4:	80 93 84 1d 	sts	0x1D84, r24	; 0x801d84 <uxTopReadyPriority>
    24a8:	bb e0       	ldi	r27, 0x0B	; 11
    24aa:	8b 9f       	mul	r24, r27
    24ac:	c0 01       	movw	r24, r0
    24ae:	11 24       	eor	r1, r1
    24b0:	b8 01       	movw	r22, r16
    24b2:	8a 53       	subi	r24, 0x3A	; 58
    24b4:	92 4e       	sbci	r25, 0xE2	; 226
    24b6:	0e 94 8e 07 	call	0xf1c	; 0xf1c <vListInsertEnd>
    24ba:	05 c0       	rjmp	.+10     	; 0x24c6 <xTaskRemoveFromEventList+0x60>
    24bc:	b8 01       	movw	r22, r16
    24be:	81 ea       	ldi	r24, 0xA1	; 161
    24c0:	9d e1       	ldi	r25, 0x1D	; 29
    24c2:	0e 94 8e 07 	call	0xf1c	; 0xf1c <vListInsertEnd>
    24c6:	e0 91 fd 1d 	lds	r30, 0x1DFD	; 0x801dfd <pxCurrentTCB>
    24ca:	f0 91 fe 1d 	lds	r31, 0x1DFE	; 0x801dfe <pxCurrentTCB+0x1>
    24ce:	9a 8d       	ldd	r25, Y+26	; 0x1a
    24d0:	82 8d       	ldd	r24, Z+26	; 0x1a
    24d2:	89 17       	cp	r24, r25
    24d4:	20 f4       	brcc	.+8      	; 0x24de <xTaskRemoveFromEventList+0x78>
    24d6:	81 e0       	ldi	r24, 0x01	; 1
    24d8:	80 93 81 1d 	sts	0x1D81, r24	; 0x801d81 <xYieldPending>
    24dc:	01 c0       	rjmp	.+2      	; 0x24e0 <xTaskRemoveFromEventList+0x7a>
    24de:	80 e0       	ldi	r24, 0x00	; 0
    24e0:	df 91       	pop	r29
    24e2:	cf 91       	pop	r28
    24e4:	1f 91       	pop	r17
    24e6:	0f 91       	pop	r16
    24e8:	08 95       	ret

000024ea <vTaskSetTimeOutState>:
    24ea:	20 91 80 1d 	lds	r18, 0x1D80	; 0x801d80 <xNumOfOverflows>
    24ee:	fc 01       	movw	r30, r24
    24f0:	20 83       	st	Z, r18
    24f2:	40 91 85 1d 	lds	r20, 0x1D85	; 0x801d85 <xTickCount>
    24f6:	50 91 86 1d 	lds	r21, 0x1D86	; 0x801d86 <xTickCount+0x1>
    24fa:	60 91 87 1d 	lds	r22, 0x1D87	; 0x801d87 <xTickCount+0x2>
    24fe:	70 91 88 1d 	lds	r23, 0x1D88	; 0x801d88 <xTickCount+0x3>
    2502:	41 83       	std	Z+1, r20	; 0x01
    2504:	52 83       	std	Z+2, r21	; 0x02
    2506:	63 83       	std	Z+3, r22	; 0x03
    2508:	74 83       	std	Z+4, r23	; 0x04
    250a:	08 95       	ret

0000250c <xTaskCheckForTimeOut>:
    250c:	8f 92       	push	r8
    250e:	9f 92       	push	r9
    2510:	af 92       	push	r10
    2512:	bf 92       	push	r11
    2514:	cf 92       	push	r12
    2516:	df 92       	push	r13
    2518:	ef 92       	push	r14
    251a:	ff 92       	push	r15
    251c:	0f 93       	push	r16
    251e:	1f 93       	push	r17
    2520:	cf 93       	push	r28
    2522:	df 93       	push	r29
    2524:	fb 01       	movw	r30, r22
    2526:	0f b6       	in	r0, 0x3f	; 63
    2528:	f8 94       	cli
    252a:	0f 92       	push	r0
    252c:	00 91 85 1d 	lds	r16, 0x1D85	; 0x801d85 <xTickCount>
    2530:	10 91 86 1d 	lds	r17, 0x1D86	; 0x801d86 <xTickCount+0x1>
    2534:	20 91 87 1d 	lds	r18, 0x1D87	; 0x801d87 <xTickCount+0x2>
    2538:	30 91 88 1d 	lds	r19, 0x1D88	; 0x801d88 <xTickCount+0x3>
    253c:	40 81       	ld	r20, Z
    253e:	51 81       	ldd	r21, Z+1	; 0x01
    2540:	62 81       	ldd	r22, Z+2	; 0x02
    2542:	73 81       	ldd	r23, Z+3	; 0x03
    2544:	4f 3f       	cpi	r20, 0xFF	; 255
    2546:	af ef       	ldi	r26, 0xFF	; 255
    2548:	5a 07       	cpc	r21, r26
    254a:	6a 07       	cpc	r22, r26
    254c:	7a 07       	cpc	r23, r26
    254e:	81 f1       	breq	.+96     	; 0x25b0 <xTaskCheckForTimeOut+0xa4>
    2550:	a0 91 80 1d 	lds	r26, 0x1D80	; 0x801d80 <xNumOfOverflows>
    2554:	ec 01       	movw	r28, r24
    2556:	b8 81       	ld	r27, Y
    2558:	ba 17       	cp	r27, r26
    255a:	49 f0       	breq	.+18     	; 0x256e <xTaskCheckForTimeOut+0x62>
    255c:	c9 80       	ldd	r12, Y+1	; 0x01
    255e:	da 80       	ldd	r13, Y+2	; 0x02
    2560:	eb 80       	ldd	r14, Y+3	; 0x03
    2562:	fc 80       	ldd	r15, Y+4	; 0x04
    2564:	0c 15       	cp	r16, r12
    2566:	1d 05       	cpc	r17, r13
    2568:	2e 05       	cpc	r18, r14
    256a:	3f 05       	cpc	r19, r15
    256c:	18 f5       	brcc	.+70     	; 0x25b4 <xTaskCheckForTimeOut+0xa8>
    256e:	dc 01       	movw	r26, r24
    2570:	11 96       	adiw	r26, 0x01	; 1
    2572:	cd 90       	ld	r12, X+
    2574:	dd 90       	ld	r13, X+
    2576:	ed 90       	ld	r14, X+
    2578:	fc 90       	ld	r15, X
    257a:	14 97       	sbiw	r26, 0x04	; 4
    257c:	48 01       	movw	r8, r16
    257e:	59 01       	movw	r10, r18
    2580:	8c 18       	sub	r8, r12
    2582:	9d 08       	sbc	r9, r13
    2584:	ae 08       	sbc	r10, r14
    2586:	bf 08       	sbc	r11, r15
    2588:	84 16       	cp	r8, r20
    258a:	95 06       	cpc	r9, r21
    258c:	a6 06       	cpc	r10, r22
    258e:	b7 06       	cpc	r11, r23
    2590:	98 f4       	brcc	.+38     	; 0x25b8 <xTaskCheckForTimeOut+0xac>
    2592:	c0 1a       	sub	r12, r16
    2594:	d1 0a       	sbc	r13, r17
    2596:	e2 0a       	sbc	r14, r18
    2598:	f3 0a       	sbc	r15, r19
    259a:	4c 0d       	add	r20, r12
    259c:	5d 1d       	adc	r21, r13
    259e:	6e 1d       	adc	r22, r14
    25a0:	7f 1d       	adc	r23, r15
    25a2:	40 83       	st	Z, r20
    25a4:	51 83       	std	Z+1, r21	; 0x01
    25a6:	62 83       	std	Z+2, r22	; 0x02
    25a8:	73 83       	std	Z+3, r23	; 0x03
    25aa:	9f df       	rcall	.-194    	; 0x24ea <vTaskSetTimeOutState>
    25ac:	80 e0       	ldi	r24, 0x00	; 0
    25ae:	05 c0       	rjmp	.+10     	; 0x25ba <xTaskCheckForTimeOut+0xae>
    25b0:	80 e0       	ldi	r24, 0x00	; 0
    25b2:	03 c0       	rjmp	.+6      	; 0x25ba <xTaskCheckForTimeOut+0xae>
    25b4:	81 e0       	ldi	r24, 0x01	; 1
    25b6:	01 c0       	rjmp	.+2      	; 0x25ba <xTaskCheckForTimeOut+0xae>
    25b8:	81 e0       	ldi	r24, 0x01	; 1
    25ba:	0f 90       	pop	r0
    25bc:	0f be       	out	0x3f, r0	; 63
    25be:	df 91       	pop	r29
    25c0:	cf 91       	pop	r28
    25c2:	1f 91       	pop	r17
    25c4:	0f 91       	pop	r16
    25c6:	ff 90       	pop	r15
    25c8:	ef 90       	pop	r14
    25ca:	df 90       	pop	r13
    25cc:	cf 90       	pop	r12
    25ce:	bf 90       	pop	r11
    25d0:	af 90       	pop	r10
    25d2:	9f 90       	pop	r9
    25d4:	8f 90       	pop	r8
    25d6:	08 95       	ret

000025d8 <vTaskMissedYield>:
    25d8:	81 e0       	ldi	r24, 0x01	; 1
    25da:	80 93 81 1d 	sts	0x1D81, r24	; 0x801d81 <xYieldPending>
    25de:	08 95       	ret

000025e0 <vTaskPriorityInherit>:
    25e0:	0f 93       	push	r16
    25e2:	1f 93       	push	r17
    25e4:	cf 93       	push	r28
    25e6:	df 93       	push	r29
    25e8:	fc 01       	movw	r30, r24
    25ea:	89 2b       	or	r24, r25
    25ec:	09 f4       	brne	.+2      	; 0x25f0 <vTaskPriorityInherit+0x10>
    25ee:	51 c0       	rjmp	.+162    	; 0x2692 <vTaskPriorityInherit+0xb2>
    25f0:	82 8d       	ldd	r24, Z+26	; 0x1a
    25f2:	a0 91 fd 1d 	lds	r26, 0x1DFD	; 0x801dfd <pxCurrentTCB>
    25f6:	b0 91 fe 1d 	lds	r27, 0x1DFE	; 0x801dfe <pxCurrentTCB+0x1>
    25fa:	5a 96       	adiw	r26, 0x1a	; 26
    25fc:	9c 91       	ld	r25, X
    25fe:	89 17       	cp	r24, r25
    2600:	08 f0       	brcs	.+2      	; 0x2604 <vTaskPriorityInherit+0x24>
    2602:	47 c0       	rjmp	.+142    	; 0x2692 <vTaskPriorityInherit+0xb2>
    2604:	46 85       	ldd	r20, Z+14	; 0x0e
    2606:	57 85       	ldd	r21, Z+15	; 0x0f
    2608:	60 89       	ldd	r22, Z+16	; 0x10
    260a:	71 89       	ldd	r23, Z+17	; 0x11
    260c:	77 23       	and	r23, r23
    260e:	94 f0       	brlt	.+36     	; 0x2634 <vTaskPriorityInherit+0x54>
    2610:	a0 91 fd 1d 	lds	r26, 0x1DFD	; 0x801dfd <pxCurrentTCB>
    2614:	b0 91 fe 1d 	lds	r27, 0x1DFE	; 0x801dfe <pxCurrentTCB+0x1>
    2618:	5a 96       	adiw	r26, 0x1a	; 26
    261a:	9c 91       	ld	r25, X
    261c:	45 e0       	ldi	r20, 0x05	; 5
    261e:	50 e0       	ldi	r21, 0x00	; 0
    2620:	60 e0       	ldi	r22, 0x00	; 0
    2622:	70 e0       	ldi	r23, 0x00	; 0
    2624:	49 1b       	sub	r20, r25
    2626:	51 09       	sbc	r21, r1
    2628:	61 09       	sbc	r22, r1
    262a:	71 09       	sbc	r23, r1
    262c:	46 87       	std	Z+14, r20	; 0x0e
    262e:	57 87       	std	Z+15, r21	; 0x0f
    2630:	60 8b       	std	Z+16, r22	; 0x10
    2632:	71 8b       	std	Z+17, r23	; 0x11
    2634:	2b e0       	ldi	r18, 0x0B	; 11
    2636:	82 9f       	mul	r24, r18
    2638:	c0 01       	movw	r24, r0
    263a:	11 24       	eor	r1, r1
    263c:	8a 53       	subi	r24, 0x3A	; 58
    263e:	92 4e       	sbci	r25, 0xE2	; 226
    2640:	24 85       	ldd	r18, Z+12	; 0x0c
    2642:	35 85       	ldd	r19, Z+13	; 0x0d
    2644:	28 17       	cp	r18, r24
    2646:	39 07       	cpc	r19, r25
    2648:	e9 f4       	brne	.+58     	; 0x2684 <vTaskPriorityInherit+0xa4>
    264a:	8f 01       	movw	r16, r30
    264c:	ef 01       	movw	r28, r30
    264e:	22 96       	adiw	r28, 0x02	; 2
    2650:	ce 01       	movw	r24, r28
    2652:	0e 94 ec 07 	call	0xfd8	; 0xfd8 <uxListRemove>
    2656:	e0 91 fd 1d 	lds	r30, 0x1DFD	; 0x801dfd <pxCurrentTCB>
    265a:	f0 91 fe 1d 	lds	r31, 0x1DFE	; 0x801dfe <pxCurrentTCB+0x1>
    265e:	82 8d       	ldd	r24, Z+26	; 0x1a
    2660:	f8 01       	movw	r30, r16
    2662:	82 8f       	std	Z+26, r24	; 0x1a
    2664:	90 91 84 1d 	lds	r25, 0x1D84	; 0x801d84 <uxTopReadyPriority>
    2668:	98 17       	cp	r25, r24
    266a:	10 f4       	brcc	.+4      	; 0x2670 <vTaskPriorityInherit+0x90>
    266c:	80 93 84 1d 	sts	0x1D84, r24	; 0x801d84 <uxTopReadyPriority>
    2670:	fb e0       	ldi	r31, 0x0B	; 11
    2672:	8f 9f       	mul	r24, r31
    2674:	c0 01       	movw	r24, r0
    2676:	11 24       	eor	r1, r1
    2678:	be 01       	movw	r22, r28
    267a:	8a 53       	subi	r24, 0x3A	; 58
    267c:	92 4e       	sbci	r25, 0xE2	; 226
    267e:	0e 94 8e 07 	call	0xf1c	; 0xf1c <vListInsertEnd>
    2682:	07 c0       	rjmp	.+14     	; 0x2692 <vTaskPriorityInherit+0xb2>
    2684:	a0 91 fd 1d 	lds	r26, 0x1DFD	; 0x801dfd <pxCurrentTCB>
    2688:	b0 91 fe 1d 	lds	r27, 0x1DFE	; 0x801dfe <pxCurrentTCB+0x1>
    268c:	5a 96       	adiw	r26, 0x1a	; 26
    268e:	8c 91       	ld	r24, X
    2690:	82 8f       	std	Z+26, r24	; 0x1a
    2692:	df 91       	pop	r29
    2694:	cf 91       	pop	r28
    2696:	1f 91       	pop	r17
    2698:	0f 91       	pop	r16
    269a:	08 95       	ret

0000269c <xTaskPriorityDisinherit>:
    269c:	0f 93       	push	r16
    269e:	1f 93       	push	r17
    26a0:	cf 93       	push	r28
    26a2:	df 93       	push	r29
    26a4:	fc 01       	movw	r30, r24
    26a6:	89 2b       	or	r24, r25
    26a8:	79 f1       	breq	.+94     	; 0x2708 <xTaskPriorityDisinherit+0x6c>
    26aa:	84 a9       	ldd	r24, Z+52	; 0x34
    26ac:	81 50       	subi	r24, 0x01	; 1
    26ae:	84 ab       	std	Z+52, r24	; 0x34
    26b0:	22 8d       	ldd	r18, Z+26	; 0x1a
    26b2:	93 a9       	ldd	r25, Z+51	; 0x33
    26b4:	29 17       	cp	r18, r25
    26b6:	51 f1       	breq	.+84     	; 0x270c <xTaskPriorityDisinherit+0x70>
    26b8:	81 11       	cpse	r24, r1
    26ba:	2a c0       	rjmp	.+84     	; 0x2710 <xTaskPriorityDisinherit+0x74>
    26bc:	ef 01       	movw	r28, r30
    26be:	8f 01       	movw	r16, r30
    26c0:	0e 5f       	subi	r16, 0xFE	; 254
    26c2:	1f 4f       	sbci	r17, 0xFF	; 255
    26c4:	c8 01       	movw	r24, r16
    26c6:	0e 94 ec 07 	call	0xfd8	; 0xfd8 <uxListRemove>
    26ca:	8b a9       	ldd	r24, Y+51	; 0x33
    26cc:	8a 8f       	std	Y+26, r24	; 0x1a
    26ce:	45 e0       	ldi	r20, 0x05	; 5
    26d0:	50 e0       	ldi	r21, 0x00	; 0
    26d2:	60 e0       	ldi	r22, 0x00	; 0
    26d4:	70 e0       	ldi	r23, 0x00	; 0
    26d6:	48 1b       	sub	r20, r24
    26d8:	51 09       	sbc	r21, r1
    26da:	61 09       	sbc	r22, r1
    26dc:	71 09       	sbc	r23, r1
    26de:	4e 87       	std	Y+14, r20	; 0x0e
    26e0:	5f 87       	std	Y+15, r21	; 0x0f
    26e2:	68 8b       	std	Y+16, r22	; 0x10
    26e4:	79 8b       	std	Y+17, r23	; 0x11
    26e6:	90 91 84 1d 	lds	r25, 0x1D84	; 0x801d84 <uxTopReadyPriority>
    26ea:	98 17       	cp	r25, r24
    26ec:	10 f4       	brcc	.+4      	; 0x26f2 <xTaskPriorityDisinherit+0x56>
    26ee:	80 93 84 1d 	sts	0x1D84, r24	; 0x801d84 <uxTopReadyPriority>
    26f2:	2b e0       	ldi	r18, 0x0B	; 11
    26f4:	82 9f       	mul	r24, r18
    26f6:	c0 01       	movw	r24, r0
    26f8:	11 24       	eor	r1, r1
    26fa:	b8 01       	movw	r22, r16
    26fc:	8a 53       	subi	r24, 0x3A	; 58
    26fe:	92 4e       	sbci	r25, 0xE2	; 226
    2700:	0e 94 8e 07 	call	0xf1c	; 0xf1c <vListInsertEnd>
    2704:	81 e0       	ldi	r24, 0x01	; 1
    2706:	05 c0       	rjmp	.+10     	; 0x2712 <xTaskPriorityDisinherit+0x76>
    2708:	80 e0       	ldi	r24, 0x00	; 0
    270a:	03 c0       	rjmp	.+6      	; 0x2712 <xTaskPriorityDisinherit+0x76>
    270c:	80 e0       	ldi	r24, 0x00	; 0
    270e:	01 c0       	rjmp	.+2      	; 0x2712 <xTaskPriorityDisinherit+0x76>
    2710:	80 e0       	ldi	r24, 0x00	; 0
    2712:	df 91       	pop	r29
    2714:	cf 91       	pop	r28
    2716:	1f 91       	pop	r17
    2718:	0f 91       	pop	r16
    271a:	08 95       	ret

0000271c <pvTaskIncrementMutexHeldCount>:

	void *pvTaskIncrementMutexHeldCount( void )
	{
		/* If xSemaphoreCreateMutex() is called before any tasks have been created
		then pxCurrentTCB will be NULL. */
		if( pxCurrentTCB != NULL )
    271c:	80 91 fd 1d 	lds	r24, 0x1DFD	; 0x801dfd <pxCurrentTCB>
    2720:	90 91 fe 1d 	lds	r25, 0x1DFE	; 0x801dfe <pxCurrentTCB+0x1>
    2724:	89 2b       	or	r24, r25
    2726:	39 f0       	breq	.+14     	; 0x2736 <pvTaskIncrementMutexHeldCount+0x1a>
		{
			( pxCurrentTCB->uxMutexesHeld )++;
    2728:	e0 91 fd 1d 	lds	r30, 0x1DFD	; 0x801dfd <pxCurrentTCB>
    272c:	f0 91 fe 1d 	lds	r31, 0x1DFE	; 0x801dfe <pxCurrentTCB+0x1>
    2730:	84 a9       	ldd	r24, Z+52	; 0x34
    2732:	8f 5f       	subi	r24, 0xFF	; 255
    2734:	84 ab       	std	Z+52, r24	; 0x34
		}

		return pxCurrentTCB;
    2736:	80 91 fd 1d 	lds	r24, 0x1DFD	; 0x801dfd <pxCurrentTCB>
    273a:	90 91 fe 1d 	lds	r25, 0x1DFE	; 0x801dfe <pxCurrentTCB+0x1>
	}
    273e:	08 95       	ret

00002740 <csp_malloc>:

/* FreeRTOS includes */
#include <FreeRTOS.h>

void * csp_malloc(size_t size) {
	return pvPortMalloc(size);
    2740:	0c 94 5f 08 	jmp	0x10be	; 0x10be <pvPortMalloc>
}
    2744:	08 95       	ret

00002746 <csp_free>:

void csp_free(void *ptr) {
	vPortFree(ptr);
    2746:	0c 94 23 09 	jmp	0x1246	; 0x1246 <vPortFree>
    274a:	08 95       	ret

0000274c <csp_queue_create>:
csp_queue_handle_t csp_queue_create(int length, size_t item_size) {
	return xQueueCreate(length, item_size);
}

void csp_queue_remove(csp_queue_handle_t queue) {
	vQueueDelete(queue);
    274c:	40 e0       	ldi	r20, 0x00	; 0
    274e:	1b c8       	rjmp	.-4042   	; 0x1786 <xQueueGenericCreate>
    2750:	08 95       	ret

00002752 <csp_queue_enqueue>:
}

int csp_queue_enqueue(csp_queue_handle_t handle, void * value, uint32_t timeout) {
    2752:	0f 93       	push	r16
	if (timeout != CSP_MAX_DELAY)
		timeout = timeout / portTICK_RATE_MS;
	return xQueueSendToBack(handle, value, timeout);
    2754:	00 e0       	ldi	r16, 0x00	; 0
    2756:	45 d8       	rcall	.-3958   	; 0x17e2 <xQueueGenericSend>
}
    2758:	08 2e       	mov	r0, r24
    275a:	00 0c       	add	r0, r0
    275c:	99 0b       	sbc	r25, r25
    275e:	0f 91       	pop	r16
    2760:	08 95       	ret

00002762 <csp_queue_enqueue_isr>:

int csp_queue_enqueue_isr(csp_queue_handle_t handle, void * value, CSP_BASE_TYPE * task_woken) {
	return xQueueSendToBackFromISR(handle, value, (signed CSP_BASE_TYPE *)task_woken);
    2762:	20 e0       	ldi	r18, 0x00	; 0
    2764:	f5 d8       	rcall	.-3606   	; 0x1950 <xQueueGenericSendFromISR>
}
    2766:	08 2e       	mov	r0, r24
    2768:	00 0c       	add	r0, r0
    276a:	99 0b       	sbc	r25, r25
    276c:	08 95       	ret

0000276e <csp_queue_dequeue>:

int csp_queue_dequeue(csp_queue_handle_t handle, void * buf, uint32_t timeout) {
    276e:	0f 93       	push	r16
	if (timeout != CSP_MAX_DELAY)
		timeout = timeout / portTICK_RATE_MS;
	return xQueueReceive(handle, buf, timeout);
    2770:	00 e0       	ldi	r16, 0x00	; 0
    2772:	26 d9       	rcall	.-3508   	; 0x19c0 <xQueueGenericReceive>
}
    2774:	08 2e       	mov	r0, r24
    2776:	00 0c       	add	r0, r0
    2778:	99 0b       	sbc	r25, r25
    277a:	0f 91       	pop	r16
    277c:	08 95       	ret

0000277e <csp_queue_dequeue_isr>:

int csp_queue_dequeue_isr(csp_queue_handle_t handle, void * buf, CSP_BASE_TYPE * task_woken) {
	return xQueueReceiveFromISR(handle, buf, (signed CSP_BASE_TYPE *)task_woken);
    277e:	e5 d9       	rcall	.-3126   	; 0x1b4a <xQueueReceiveFromISR>
}
    2780:	08 2e       	mov	r0, r24
    2782:	00 0c       	add	r0, r0
    2784:	99 0b       	sbc	r25, r25
    2786:	08 95       	ret

00002788 <csp_queue_size>:

int csp_queue_size(csp_queue_handle_t handle) {
	return uxQueueMessagesWaiting(handle);
    2788:	15 da       	rcall	.-3030   	; 0x1bb4 <uxQueueMessagesWaiting>
}
    278a:	90 e0       	ldi	r25, 0x00	; 0
    278c:	08 95       	ret

0000278e <csp_mutex_create>:
	return csp_bin_sem_remove(mutex);
}

int csp_mutex_lock(csp_mutex_t * mutex, uint32_t timeout) {
	return csp_bin_sem_wait(mutex, timeout);
}
    278e:	cf 93       	push	r28
    2790:	df 93       	push	r29
    2792:	ec 01       	movw	r28, r24
    2794:	81 e0       	ldi	r24, 0x01	; 1
    2796:	c1 d8       	rcall	.-3710   	; 0x191a <xQueueCreateMutex>
    2798:	99 83       	std	Y+1, r25	; 0x01
    279a:	88 83       	st	Y, r24
    279c:	21 e0       	ldi	r18, 0x01	; 1
    279e:	30 e0       	ldi	r19, 0x00	; 0
    27a0:	89 2b       	or	r24, r25
    27a2:	11 f4       	brne	.+4      	; 0x27a8 <csp_mutex_create+0x1a>
    27a4:	20 e0       	ldi	r18, 0x00	; 0
    27a6:	30 e0       	ldi	r19, 0x00	; 0
    27a8:	c9 01       	movw	r24, r18
    27aa:	df 91       	pop	r29
    27ac:	cf 91       	pop	r28
    27ae:	08 95       	ret

000027b0 <csp_bin_sem_create>:
    27b0:	0f 93       	push	r16
    27b2:	cf 93       	push	r28
    27b4:	df 93       	push	r29
    27b6:	ec 01       	movw	r28, r24
    27b8:	43 e0       	ldi	r20, 0x03	; 3
    27ba:	60 e0       	ldi	r22, 0x00	; 0
    27bc:	81 e0       	ldi	r24, 0x01	; 1
    27be:	0e 94 c3 0b 	call	0x1786	; 0x1786 <xQueueGenericCreate>
    27c2:	99 83       	std	Y+1, r25	; 0x01
    27c4:	88 83       	st	Y, r24
    27c6:	00 97       	sbiw	r24, 0x00	; 0
    27c8:	39 f0       	breq	.+14     	; 0x27d8 <csp_bin_sem_create+0x28>
    27ca:	00 e0       	ldi	r16, 0x00	; 0
    27cc:	20 e0       	ldi	r18, 0x00	; 0
    27ce:	30 e0       	ldi	r19, 0x00	; 0
    27d0:	a9 01       	movw	r20, r18
    27d2:	60 e0       	ldi	r22, 0x00	; 0
    27d4:	70 e0       	ldi	r23, 0x00	; 0
    27d6:	05 d8       	rcall	.-4086   	; 0x17e2 <xQueueGenericSend>
    27d8:	81 e0       	ldi	r24, 0x01	; 1
    27da:	90 e0       	ldi	r25, 0x00	; 0
    27dc:	df 91       	pop	r29
    27de:	cf 91       	pop	r28
    27e0:	0f 91       	pop	r16
    27e2:	08 95       	ret

000027e4 <csp_bin_sem_wait>:
    27e4:	cf 92       	push	r12
    27e6:	df 92       	push	r13
    27e8:	ef 92       	push	r14
    27ea:	ff 92       	push	r15
    27ec:	0f 93       	push	r16
    27ee:	cf 93       	push	r28
    27f0:	df 93       	push	r29
    27f2:	ec 01       	movw	r28, r24
    27f4:	6a 01       	movw	r12, r20
    27f6:	7b 01       	movw	r14, r22
    27f8:	80 91 0a 02 	lds	r24, 0x020A	; 0x80020a <csp_debug_level_enabled+0x6>
    27fc:	88 23       	and	r24, r24
    27fe:	e1 f0       	breq	.+56     	; 0x2838 <csp_bin_sem_wait+0x54>
    2800:	0e 94 6b 1c 	call	0x38d6	; 0x38d6 <csp_get_address>
    2804:	df 93       	push	r29
    2806:	cf 93       	push	r28
    2808:	1f 92       	push	r1
    280a:	95 e4       	ldi	r25, 0x45	; 69
    280c:	9f 93       	push	r25
    280e:	24 ea       	ldi	r18, 0xA4	; 164
    2810:	32 e0       	ldi	r19, 0x02	; 2
    2812:	3f 93       	push	r19
    2814:	2f 93       	push	r18
    2816:	1f 92       	push	r1
    2818:	8f 93       	push	r24
    281a:	8a e9       	ldi	r24, 0x9A	; 154
    281c:	92 e0       	ldi	r25, 0x02	; 2
    281e:	9f 93       	push	r25
    2820:	8f 93       	push	r24
    2822:	86 e0       	ldi	r24, 0x06	; 6
    2824:	8f 93       	push	r24
    2826:	6f d7       	rcall	.+3806   	; 0x3706 <do_csp_debug>
    2828:	8d b7       	in	r24, 0x3d	; 61
    282a:	9e b7       	in	r25, 0x3e	; 62
    282c:	0b 96       	adiw	r24, 0x0b	; 11
    282e:	0f b6       	in	r0, 0x3f	; 63
    2830:	f8 94       	cli
    2832:	9e bf       	out	0x3e, r25	; 62
    2834:	0f be       	out	0x3f, r0	; 63
    2836:	8d bf       	out	0x3d, r24	; 61
    2838:	00 e0       	ldi	r16, 0x00	; 0
    283a:	a7 01       	movw	r20, r14
    283c:	96 01       	movw	r18, r12
    283e:	60 e0       	ldi	r22, 0x00	; 0
    2840:	70 e0       	ldi	r23, 0x00	; 0
    2842:	88 81       	ld	r24, Y
    2844:	99 81       	ldd	r25, Y+1	; 0x01
    2846:	bc d8       	rcall	.-3720   	; 0x19c0 <xQueueGenericReceive>
    2848:	21 e0       	ldi	r18, 0x01	; 1
    284a:	30 e0       	ldi	r19, 0x00	; 0
    284c:	81 30       	cpi	r24, 0x01	; 1
    284e:	11 f0       	breq	.+4      	; 0x2854 <csp_bin_sem_wait+0x70>
    2850:	20 e0       	ldi	r18, 0x00	; 0
    2852:	30 e0       	ldi	r19, 0x00	; 0
    2854:	c9 01       	movw	r24, r18
    2856:	df 91       	pop	r29
    2858:	cf 91       	pop	r28
    285a:	0f 91       	pop	r16
    285c:	ff 90       	pop	r15
    285e:	ef 90       	pop	r14
    2860:	df 90       	pop	r13
    2862:	cf 90       	pop	r12
    2864:	08 95       	ret

00002866 <csp_bin_sem_post>:
	} else {
		return CSP_SEMAPHORE_ERROR;
	}
}

int csp_bin_sem_post(csp_bin_sem_handle_t * sem) {
    2866:	0f 93       	push	r16
    2868:	cf 93       	push	r28
    286a:	df 93       	push	r29
    286c:	ec 01       	movw	r28, r24
	csp_log_lock("Post: %p", sem);
    286e:	80 91 0a 02 	lds	r24, 0x020A	; 0x80020a <csp_debug_level_enabled+0x6>
    2872:	88 23       	and	r24, r24
    2874:	e1 f0       	breq	.+56     	; 0x28ae <csp_bin_sem_post+0x48>
    2876:	0e 94 6b 1c 	call	0x38d6	; 0x38d6 <csp_get_address>
    287a:	df 93       	push	r29
    287c:	cf 93       	push	r28
    287e:	1f 92       	push	r1
    2880:	90 e5       	ldi	r25, 0x50	; 80
    2882:	9f 93       	push	r25
    2884:	24 ea       	ldi	r18, 0xA4	; 164
    2886:	32 e0       	ldi	r19, 0x02	; 2
    2888:	3f 93       	push	r19
    288a:	2f 93       	push	r18
    288c:	1f 92       	push	r1
    288e:	8f 93       	push	r24
    2890:	84 e8       	ldi	r24, 0x84	; 132
    2892:	92 e0       	ldi	r25, 0x02	; 2
    2894:	9f 93       	push	r25
    2896:	8f 93       	push	r24
    2898:	86 e0       	ldi	r24, 0x06	; 6
    289a:	8f 93       	push	r24
    289c:	34 d7       	rcall	.+3688   	; 0x3706 <do_csp_debug>
    289e:	8d b7       	in	r24, 0x3d	; 61
    28a0:	9e b7       	in	r25, 0x3e	; 62
    28a2:	0b 96       	adiw	r24, 0x0b	; 11
    28a4:	0f b6       	in	r0, 0x3f	; 63
    28a6:	f8 94       	cli
    28a8:	9e bf       	out	0x3e, r25	; 62
    28aa:	0f be       	out	0x3f, r0	; 63
    28ac:	8d bf       	out	0x3d, r24	; 61
	if (xSemaphoreGive(*sem) == pdPASS) {
    28ae:	00 e0       	ldi	r16, 0x00	; 0
    28b0:	20 e0       	ldi	r18, 0x00	; 0
    28b2:	30 e0       	ldi	r19, 0x00	; 0
    28b4:	a9 01       	movw	r20, r18
    28b6:	60 e0       	ldi	r22, 0x00	; 0
    28b8:	70 e0       	ldi	r23, 0x00	; 0
    28ba:	88 81       	ld	r24, Y
    28bc:	99 81       	ldd	r25, Y+1	; 0x01
    28be:	0e 94 f1 0b 	call	0x17e2	; 0x17e2 <xQueueGenericSend>
    28c2:	21 e0       	ldi	r18, 0x01	; 1
    28c4:	30 e0       	ldi	r19, 0x00	; 0
    28c6:	81 30       	cpi	r24, 0x01	; 1
    28c8:	11 f0       	breq	.+4      	; 0x28ce <csp_bin_sem_post+0x68>
    28ca:	20 e0       	ldi	r18, 0x00	; 0
    28cc:	30 e0       	ldi	r19, 0x00	; 0
		return CSP_SEMAPHORE_OK;
	} else {
		return CSP_SEMAPHORE_ERROR;
	}
}
    28ce:	c9 01       	movw	r24, r18
    28d0:	df 91       	pop	r29
    28d2:	cf 91       	pop	r28
    28d4:	0f 91       	pop	r16
    28d6:	08 95       	ret

000028d8 <csp_sys_set_color>:
	csp_log_error("Failed to shutdown");

	return CSP_ERR_INVAL;
}

void csp_sys_set_color(csp_color_t color) {
    28d8:	98 2f       	mov	r25, r24

	unsigned int color_code, modifier_code;
	switch (color & COLOR_MASK_COLOR) {
    28da:	e8 2f       	mov	r30, r24
    28dc:	ef 70       	andi	r30, 0x0F	; 15
    28de:	4e 2f       	mov	r20, r30
    28e0:	50 e0       	ldi	r21, 0x00	; 0
    28e2:	fa 01       	movw	r30, r20
    28e4:	31 97       	sbiw	r30, 0x01	; 1
    28e6:	e8 30       	cpi	r30, 0x08	; 8
    28e8:	f1 05       	cpc	r31, r1
    28ea:	d8 f4       	brcc	.+54     	; 0x2922 <csp_sys_set_color+0x4a>
    28ec:	88 27       	eor	r24, r24
    28ee:	ee 58       	subi	r30, 0x8E	; 142
    28f0:	ff 4f       	sbci	r31, 0xFF	; 255
    28f2:	8f 4f       	sbci	r24, 0xFF	; 255
    28f4:	0c 94 bb 2b 	jmp	0x5776	; 0x5776 <__tablejump2__>
		case COLOR_BLACK:
			color_code = 30; break;
		case COLOR_RED:
			color_code = 31; break;
    28f8:	2f e1       	ldi	r18, 0x1F	; 31
    28fa:	30 e0       	ldi	r19, 0x00	; 0
    28fc:	17 c0       	rjmp	.+46     	; 0x292c <csp_sys_set_color+0x54>
		case COLOR_GREEN:
			color_code = 32; break;
    28fe:	20 e2       	ldi	r18, 0x20	; 32
    2900:	30 e0       	ldi	r19, 0x00	; 0
    2902:	14 c0       	rjmp	.+40     	; 0x292c <csp_sys_set_color+0x54>
		case COLOR_YELLOW:
			color_code = 33; break;
    2904:	21 e2       	ldi	r18, 0x21	; 33
    2906:	30 e0       	ldi	r19, 0x00	; 0
    2908:	11 c0       	rjmp	.+34     	; 0x292c <csp_sys_set_color+0x54>
		case COLOR_BLUE:
			color_code = 34; break;
    290a:	22 e2       	ldi	r18, 0x22	; 34
    290c:	30 e0       	ldi	r19, 0x00	; 0
    290e:	0e c0       	rjmp	.+28     	; 0x292c <csp_sys_set_color+0x54>
		case COLOR_MAGENTA:
			color_code = 35; break;
    2910:	23 e2       	ldi	r18, 0x23	; 35
    2912:	30 e0       	ldi	r19, 0x00	; 0
    2914:	0b c0       	rjmp	.+22     	; 0x292c <csp_sys_set_color+0x54>
		case COLOR_CYAN:
			color_code = 36; break;
    2916:	24 e2       	ldi	r18, 0x24	; 36
    2918:	30 e0       	ldi	r19, 0x00	; 0
    291a:	08 c0       	rjmp	.+16     	; 0x292c <csp_sys_set_color+0x54>
		case COLOR_WHITE:
			color_code = 37; break;
    291c:	25 e2       	ldi	r18, 0x25	; 37
    291e:	30 e0       	ldi	r19, 0x00	; 0
    2920:	05 c0       	rjmp	.+10     	; 0x292c <csp_sys_set_color+0x54>
		case COLOR_RESET:
		default:
			color_code = 0; break;
    2922:	20 e0       	ldi	r18, 0x00	; 0
    2924:	30 e0       	ldi	r19, 0x00	; 0
    2926:	02 c0       	rjmp	.+4      	; 0x292c <csp_sys_set_color+0x54>
void csp_sys_set_color(csp_color_t color) {

	unsigned int color_code, modifier_code;
	switch (color & COLOR_MASK_COLOR) {
		case COLOR_BLACK:
			color_code = 30; break;
    2928:	2e e1       	ldi	r18, 0x1E	; 30
    292a:	30 e0       	ldi	r19, 0x00	; 0
		case COLOR_RESET:
		default:
			color_code = 0; break;
	}
	
	switch (color & COLOR_MASK_MODIFIER) {
    292c:	89 2f       	mov	r24, r25
    292e:	80 7f       	andi	r24, 0xF0	; 240
    2930:	80 32       	cpi	r24, 0x20	; 32
    2932:	49 f0       	breq	.+18     	; 0x2946 <csp_sys_set_color+0x6e>
    2934:	18 f4       	brcc	.+6      	; 0x293c <csp_sys_set_color+0x64>
    2936:	80 31       	cpi	r24, 0x10	; 16
    2938:	91 f0       	breq	.+36     	; 0x295e <csp_sys_set_color+0x86>
    293a:	0e c0       	rjmp	.+28     	; 0x2958 <csp_sys_set_color+0x80>
    293c:	80 33       	cpi	r24, 0x30	; 48
    293e:	31 f0       	breq	.+12     	; 0x294c <csp_sys_set_color+0x74>
    2940:	80 34       	cpi	r24, 0x40	; 64
    2942:	39 f0       	breq	.+14     	; 0x2952 <csp_sys_set_color+0x7a>
    2944:	09 c0       	rjmp	.+18     	; 0x2958 <csp_sys_set_color+0x80>
		case COLOR_BOLD:
			modifier_code = 1; break;
		case COLOR_UNDERLINE:
			modifier_code = 2; break;
    2946:	82 e0       	ldi	r24, 0x02	; 2
    2948:	90 e0       	ldi	r25, 0x00	; 0
    294a:	0b c0       	rjmp	.+22     	; 0x2962 <csp_sys_set_color+0x8a>
		case COLOR_BLINK:
			modifier_code = 3; break;
    294c:	83 e0       	ldi	r24, 0x03	; 3
    294e:	90 e0       	ldi	r25, 0x00	; 0
    2950:	08 c0       	rjmp	.+16     	; 0x2962 <csp_sys_set_color+0x8a>
		case COLOR_HIDE:
			modifier_code = 4; break;
    2952:	84 e0       	ldi	r24, 0x04	; 4
    2954:	90 e0       	ldi	r25, 0x00	; 0
    2956:	05 c0       	rjmp	.+10     	; 0x2962 <csp_sys_set_color+0x8a>
		case COLOR_NORMAL:
		default:
			modifier_code = 0; break;
    2958:	80 e0       	ldi	r24, 0x00	; 0
    295a:	90 e0       	ldi	r25, 0x00	; 0
    295c:	02 c0       	rjmp	.+4      	; 0x2962 <csp_sys_set_color+0x8a>
			color_code = 0; break;
	}
	
	switch (color & COLOR_MASK_MODIFIER) {
		case COLOR_BOLD:
			modifier_code = 1; break;
    295e:	81 e0       	ldi	r24, 0x01	; 1
    2960:	90 e0       	ldi	r25, 0x00	; 0
		case COLOR_NORMAL:
		default:
			modifier_code = 0; break;
	}

	printf("\033[%u;%um", modifier_code, color_code);
    2962:	3f 93       	push	r19
    2964:	2f 93       	push	r18
    2966:	9f 93       	push	r25
    2968:	8f 93       	push	r24
    296a:	80 eb       	ldi	r24, 0xB0	; 176
    296c:	92 e0       	ldi	r25, 0x02	; 2
    296e:	9f 93       	push	r25
    2970:	8f 93       	push	r24
    2972:	0e 94 98 2c 	call	0x5930	; 0x5930 <printf_P>
}
    2976:	0f 90       	pop	r0
    2978:	0f 90       	pop	r0
    297a:	0f 90       	pop	r0
    297c:	0f 90       	pop	r0
    297e:	0f 90       	pop	r0
    2980:	0f 90       	pop	r0
    2982:	08 95       	ret

00002984 <csp_thread_create>:
/* CSP includes */
#include <csp/csp.h>

#include <csp/arch/csp_thread.h>

int csp_thread_create(csp_thread_return_t (* routine)(void *), const char * const thread_name, unsigned short stack_depth, void * parameters, unsigned int priority, csp_thread_handle_t * handle) {
    2984:	ef 92       	push	r14
    2986:	ff 92       	push	r15
    2988:	0f 93       	push	r16
#if (FREERTOS_VERSION >= 8)
	portBASE_TYPE ret = xTaskCreate(routine, thread_name, stack_depth, parameters, priority, handle);
#else
	portBASE_TYPE ret = xTaskCreate(routine, (signed char *) thread_name, stack_depth, parameters, priority, handle);
    298a:	bc d9       	rcall	.-3208   	; 0x1d04 <xTaskCreate>
    298c:	21 e0       	ldi	r18, 0x01	; 1
    298e:	30 e0       	ldi	r19, 0x00	; 0
    2990:	81 30       	cpi	r24, 0x01	; 1
    2992:	11 f4       	brne	.+4      	; 0x2998 <csp_thread_create+0x14>
    2994:	20 e0       	ldi	r18, 0x00	; 0
    2996:	30 e0       	ldi	r19, 0x00	; 0
#endif
	if (ret != pdTRUE)
		return CSP_ERR_NOMEM;
	return CSP_ERR_NONE;
}
    2998:	88 27       	eor	r24, r24
    299a:	99 27       	eor	r25, r25
    299c:	82 1b       	sub	r24, r18
    299e:	93 0b       	sbc	r25, r19
    29a0:	0f 91       	pop	r16
    29a2:	ff 90       	pop	r15
    29a4:	ef 90       	pop	r14
    29a6:	08 95       	ret

000029a8 <csp_get_ms>:
#include <csp/csp.h>

#include <csp/arch/csp_time.h>

uint32_t csp_get_ms(void) {
	return (uint32_t)(xTaskGetTickCount() * (1000/configTICK_RATE_HZ));
    29a8:	40 cb       	rjmp	.-2432   	; 0x202a <xTaskGetTickCount>
}
    29aa:	08 95       	ret

000029ac <csp_buffer_init>:
static char * csp_buffer_pool;
static unsigned int count, size;

CSP_DEFINE_CRITICAL(csp_critical_lock);

int csp_buffer_init(int buf_count, int buf_size) {
    29ac:	cf 92       	push	r12
    29ae:	df 92       	push	r13
    29b0:	ef 92       	push	r14
    29b2:	ff 92       	push	r15
    29b4:	0f 93       	push	r16
    29b6:	1f 93       	push	r17
    29b8:	cf 93       	push	r28
    29ba:	df 93       	push	r29
    29bc:	1f 92       	push	r1
    29be:	1f 92       	push	r1
    29c0:	cd b7       	in	r28, 0x3d	; 61
    29c2:	de b7       	in	r29, 0x3e	; 62

	unsigned int i;
	csp_skbf_t * buf;

	count = buf_count;
    29c4:	90 93 02 1e 	sts	0x1E02, r25	; 0x801e02 <count+0x1>
    29c8:	80 93 01 1e 	sts	0x1E01, r24	; 0x801e01 <count>
	size = buf_size + CSP_BUFFER_PACKET_OVERHEAD;
    29cc:	9b 01       	movw	r18, r22
    29ce:	22 5f       	subi	r18, 0xF2	; 242
    29d0:	3f 4f       	sbci	r19, 0xFF	; 255
    29d2:	30 93 00 1e 	sts	0x1E00, r19	; 0x801e00 <size+0x1>
    29d6:	20 93 ff 1d 	sts	0x1DFF, r18	; 0x801dff <size>
	unsigned int skbfsize = (sizeof(csp_skbf_t) + size);
	skbfsize = CSP_BUFFER_ALIGN * ((skbfsize + CSP_BUFFER_ALIGN - 1) / CSP_BUFFER_ALIGN);
    29da:	6d 5e       	subi	r22, 0xED	; 237
    29dc:	7f 4f       	sbci	r23, 0xFF	; 255
    29de:	6b 01       	movw	r12, r22
    29e0:	e8 94       	clt
    29e2:	c0 f8       	bld	r12, 0
	unsigned int poolsize = count * skbfsize;
    29e4:	8c 9d       	mul	r24, r12
    29e6:	80 01       	movw	r16, r0
    29e8:	8d 9d       	mul	r24, r13
    29ea:	10 0d       	add	r17, r0
    29ec:	9c 9d       	mul	r25, r12
    29ee:	10 0d       	add	r17, r0
    29f0:	11 24       	eor	r1, r1

	csp_buffer_pool = csp_malloc(poolsize);
    29f2:	c8 01       	movw	r24, r16
    29f4:	a5 de       	rcall	.-694    	; 0x2740 <csp_malloc>
    29f6:	90 93 04 1e 	sts	0x1E04, r25	; 0x801e04 <csp_buffer_pool+0x1>
    29fa:	80 93 03 1e 	sts	0x1E03, r24	; 0x801e03 <csp_buffer_pool>
	if (csp_buffer_pool == NULL)
    29fe:	89 2b       	or	r24, r25
    2a00:	09 f4       	brne	.+2      	; 0x2a04 <csp_buffer_init+0x58>
    2a02:	4f c0       	rjmp	.+158    	; 0x2aa2 <csp_buffer_init+0xf6>
		goto fail_malloc;

	csp_buffers = csp_queue_create(count, sizeof(void *));
    2a04:	62 e0       	ldi	r22, 0x02	; 2
    2a06:	70 e0       	ldi	r23, 0x00	; 0
    2a08:	80 91 01 1e 	lds	r24, 0x1E01	; 0x801e01 <count>
    2a0c:	90 91 02 1e 	lds	r25, 0x1E02	; 0x801e02 <count+0x1>
    2a10:	9d de       	rcall	.-710    	; 0x274c <csp_queue_create>
    2a12:	90 93 06 1e 	sts	0x1E06, r25	; 0x801e06 <csp_buffers+0x1>
    2a16:	80 93 05 1e 	sts	0x1E05, r24	; 0x801e05 <csp_buffers>
	
	if (!csp_buffers)
    2a1a:	89 2b       	or	r24, r25
    2a1c:	d1 f1       	breq	.+116    	; 0x2a92 <csp_buffer_init+0xe6>
		goto fail_queue;

	if (CSP_INIT_CRITICAL(csp_critical_lock) != CSP_ERR_NONE)
		goto fail_critical;

	memset(csp_buffer_pool, 0, poolsize);
    2a1e:	a8 01       	movw	r20, r16
    2a20:	60 e0       	ldi	r22, 0x00	; 0
    2a22:	70 e0       	ldi	r23, 0x00	; 0
    2a24:	80 91 03 1e 	lds	r24, 0x1E03	; 0x801e03 <csp_buffer_pool>
    2a28:	90 91 04 1e 	lds	r25, 0x1E04	; 0x801e04 <csp_buffer_pool+0x1>
    2a2c:	0e 94 44 2c 	call	0x5888	; 0x5888 <memset>

	for (i = 0; i < count; i++) {
    2a30:	80 91 01 1e 	lds	r24, 0x1E01	; 0x801e01 <count>
    2a34:	90 91 02 1e 	lds	r25, 0x1E02	; 0x801e02 <count+0x1>
    2a38:	89 2b       	or	r24, r25
    2a3a:	b1 f1       	breq	.+108    	; 0x2aa8 <csp_buffer_init+0xfc>
    2a3c:	e1 2c       	mov	r14, r1
    2a3e:	f1 2c       	mov	r15, r1
    2a40:	00 e0       	ldi	r16, 0x00	; 0
    2a42:	10 e0       	ldi	r17, 0x00	; 0
		/* We have already taken care of pointer alignment since
		 * skbfsize is an integer multiple of sizeof(int *)
		 * but the explicit cast to a void * is still necessary
		 * to tell the compiler so.
		 */
		buf = (void *) &csp_buffer_pool[i * skbfsize];
    2a44:	e0 91 03 1e 	lds	r30, 0x1E03	; 0x801e03 <csp_buffer_pool>
    2a48:	f0 91 04 1e 	lds	r31, 0x1E04	; 0x801e04 <csp_buffer_pool+0x1>
    2a4c:	ee 0d       	add	r30, r14
    2a4e:	ff 1d       	adc	r31, r15
    2a50:	fa 83       	std	Y+2, r31	; 0x02
    2a52:	e9 83       	std	Y+1, r30	; 0x01
		buf->refcount = 0;
    2a54:	11 82       	std	Z+1, r1	; 0x01
    2a56:	10 82       	st	Z, r1
		buf->skbf_addr = buf;
    2a58:	e9 81       	ldd	r30, Y+1	; 0x01
    2a5a:	fa 81       	ldd	r31, Y+2	; 0x02
    2a5c:	f3 83       	std	Z+3, r31	; 0x03
    2a5e:	e2 83       	std	Z+2, r30	; 0x02

		csp_queue_enqueue(csp_buffers, &buf, 0);
    2a60:	20 e0       	ldi	r18, 0x00	; 0
    2a62:	30 e0       	ldi	r19, 0x00	; 0
    2a64:	a9 01       	movw	r20, r18
    2a66:	be 01       	movw	r22, r28
    2a68:	6f 5f       	subi	r22, 0xFF	; 255
    2a6a:	7f 4f       	sbci	r23, 0xFF	; 255
    2a6c:	80 91 05 1e 	lds	r24, 0x1E05	; 0x801e05 <csp_buffers>
    2a70:	90 91 06 1e 	lds	r25, 0x1E06	; 0x801e06 <csp_buffers+0x1>
    2a74:	6e de       	rcall	.-804    	; 0x2752 <csp_queue_enqueue>
	if (CSP_INIT_CRITICAL(csp_critical_lock) != CSP_ERR_NONE)
		goto fail_critical;

	memset(csp_buffer_pool, 0, poolsize);

	for (i = 0; i < count; i++) {
    2a76:	0f 5f       	subi	r16, 0xFF	; 255
    2a78:	1f 4f       	sbci	r17, 0xFF	; 255
    2a7a:	ec 0c       	add	r14, r12
    2a7c:	fd 1c       	adc	r15, r13
    2a7e:	80 91 01 1e 	lds	r24, 0x1E01	; 0x801e01 <count>
    2a82:	90 91 02 1e 	lds	r25, 0x1E02	; 0x801e02 <count+0x1>
    2a86:	08 17       	cp	r16, r24
    2a88:	19 07       	cpc	r17, r25
    2a8a:	e0 f2       	brcs	.-72     	; 0x2a44 <csp_buffer_init+0x98>

		csp_queue_enqueue(csp_buffers, &buf, 0);

	}

	return CSP_ERR_NONE;
    2a8c:	80 e0       	ldi	r24, 0x00	; 0
    2a8e:	90 e0       	ldi	r25, 0x00	; 0
    2a90:	0d c0       	rjmp	.+26     	; 0x2aac <csp_buffer_init+0x100>

fail_critical:
	csp_queue_remove(csp_buffers);
fail_queue:
	csp_free(csp_buffer_pool);
    2a92:	80 91 03 1e 	lds	r24, 0x1E03	; 0x801e03 <csp_buffer_pool>
    2a96:	90 91 04 1e 	lds	r25, 0x1E04	; 0x801e04 <csp_buffer_pool+0x1>
    2a9a:	55 de       	rcall	.-854    	; 0x2746 <csp_free>
fail_malloc:
	return CSP_ERR_NOMEM;
    2a9c:	8f ef       	ldi	r24, 0xFF	; 255
    2a9e:	9f ef       	ldi	r25, 0xFF	; 255
    2aa0:	05 c0       	rjmp	.+10     	; 0x2aac <csp_buffer_init+0x100>
    2aa2:	8f ef       	ldi	r24, 0xFF	; 255
    2aa4:	9f ef       	ldi	r25, 0xFF	; 255
    2aa6:	02 c0       	rjmp	.+4      	; 0x2aac <csp_buffer_init+0x100>

		csp_queue_enqueue(csp_buffers, &buf, 0);

	}

	return CSP_ERR_NONE;
    2aa8:	80 e0       	ldi	r24, 0x00	; 0
    2aaa:	90 e0       	ldi	r25, 0x00	; 0
fail_queue:
	csp_free(csp_buffer_pool);
fail_malloc:
	return CSP_ERR_NOMEM;

}
    2aac:	0f 90       	pop	r0
    2aae:	0f 90       	pop	r0
    2ab0:	df 91       	pop	r29
    2ab2:	cf 91       	pop	r28
    2ab4:	1f 91       	pop	r17
    2ab6:	0f 91       	pop	r16
    2ab8:	ff 90       	pop	r15
    2aba:	ef 90       	pop	r14
    2abc:	df 90       	pop	r13
    2abe:	cf 90       	pop	r12
    2ac0:	08 95       	ret

00002ac2 <csp_buffer_get_isr>:

void *csp_buffer_get_isr(size_t buf_size) {
    2ac2:	cf 93       	push	r28
    2ac4:	df 93       	push	r29
    2ac6:	00 d0       	rcall	.+0      	; 0x2ac8 <csp_buffer_get_isr+0x6>
    2ac8:	cd b7       	in	r28, 0x3d	; 61
    2aca:	de b7       	in	r29, 0x3e	; 62

	csp_skbf_t * buffer = NULL;
    2acc:	1a 82       	std	Y+2, r1	; 0x02
    2ace:	19 82       	std	Y+1, r1	; 0x01
	CSP_BASE_TYPE task_woken = 0;
    2ad0:	1b 82       	std	Y+3, r1	; 0x03

	if (buf_size + CSP_BUFFER_PACKET_OVERHEAD > size)
    2ad2:	0e 96       	adiw	r24, 0x0e	; 14
    2ad4:	20 91 ff 1d 	lds	r18, 0x1DFF	; 0x801dff <size>
    2ad8:	30 91 00 1e 	lds	r19, 0x1E00	; 0x801e00 <size+0x1>
    2adc:	28 17       	cp	r18, r24
    2ade:	39 07       	cpc	r19, r25
    2ae0:	e8 f0       	brcs	.+58     	; 0x2b1c <csp_buffer_get_isr+0x5a>
		return NULL;

	csp_queue_dequeue_isr(csp_buffers, &buffer, &task_woken);
    2ae2:	ae 01       	movw	r20, r28
    2ae4:	4d 5f       	subi	r20, 0xFD	; 253
    2ae6:	5f 4f       	sbci	r21, 0xFF	; 255
    2ae8:	be 01       	movw	r22, r28
    2aea:	6f 5f       	subi	r22, 0xFF	; 255
    2aec:	7f 4f       	sbci	r23, 0xFF	; 255
    2aee:	80 91 05 1e 	lds	r24, 0x1E05	; 0x801e05 <csp_buffers>
    2af2:	90 91 06 1e 	lds	r25, 0x1E06	; 0x801e06 <csp_buffers+0x1>
    2af6:	43 de       	rcall	.-890    	; 0x277e <csp_queue_dequeue_isr>
	if (buffer == NULL)
    2af8:	e9 81       	ldd	r30, Y+1	; 0x01
    2afa:	fa 81       	ldd	r31, Y+2	; 0x02
    2afc:	30 97       	sbiw	r30, 0x00	; 0
    2afe:	89 f0       	breq	.+34     	; 0x2b22 <csp_buffer_get_isr+0x60>
		return NULL;

	if (buffer != buffer->skbf_addr)
    2b00:	82 81       	ldd	r24, Z+2	; 0x02
    2b02:	93 81       	ldd	r25, Z+3	; 0x03
    2b04:	e8 17       	cp	r30, r24
    2b06:	f9 07       	cpc	r31, r25
    2b08:	79 f4       	brne	.+30     	; 0x2b28 <csp_buffer_get_isr+0x66>
		return NULL;

	buffer->refcount++;
    2b0a:	80 81       	ld	r24, Z
    2b0c:	91 81       	ldd	r25, Z+1	; 0x01
    2b0e:	01 96       	adiw	r24, 0x01	; 1
    2b10:	91 83       	std	Z+1, r25	; 0x01
    2b12:	80 83       	st	Z, r24
	return buffer->skbf_data;
    2b14:	89 81       	ldd	r24, Y+1	; 0x01
    2b16:	9a 81       	ldd	r25, Y+2	; 0x02
    2b18:	04 96       	adiw	r24, 0x04	; 4
    2b1a:	08 c0       	rjmp	.+16     	; 0x2b2c <csp_buffer_get_isr+0x6a>

	csp_skbf_t * buffer = NULL;
	CSP_BASE_TYPE task_woken = 0;

	if (buf_size + CSP_BUFFER_PACKET_OVERHEAD > size)
		return NULL;
    2b1c:	80 e0       	ldi	r24, 0x00	; 0
    2b1e:	90 e0       	ldi	r25, 0x00	; 0
    2b20:	05 c0       	rjmp	.+10     	; 0x2b2c <csp_buffer_get_isr+0x6a>

	csp_queue_dequeue_isr(csp_buffers, &buffer, &task_woken);
	if (buffer == NULL)
		return NULL;
    2b22:	80 e0       	ldi	r24, 0x00	; 0
    2b24:	90 e0       	ldi	r25, 0x00	; 0
    2b26:	02 c0       	rjmp	.+4      	; 0x2b2c <csp_buffer_get_isr+0x6a>

	if (buffer != buffer->skbf_addr)
		return NULL;
    2b28:	80 e0       	ldi	r24, 0x00	; 0
    2b2a:	90 e0       	ldi	r25, 0x00	; 0

	buffer->refcount++;
	return buffer->skbf_data;

}
    2b2c:	0f 90       	pop	r0
    2b2e:	0f 90       	pop	r0
    2b30:	0f 90       	pop	r0
    2b32:	df 91       	pop	r29
    2b34:	cf 91       	pop	r28
    2b36:	08 95       	ret

00002b38 <csp_buffer_get>:

void *csp_buffer_get(size_t buf_size) {
    2b38:	ef 92       	push	r14
    2b3a:	ff 92       	push	r15
    2b3c:	0f 93       	push	r16
    2b3e:	1f 93       	push	r17
    2b40:	cf 93       	push	r28
    2b42:	df 93       	push	r29
    2b44:	1f 92       	push	r1
    2b46:	1f 92       	push	r1
    2b48:	cd b7       	in	r28, 0x3d	; 61
    2b4a:	de b7       	in	r29, 0x3e	; 62
    2b4c:	8c 01       	movw	r16, r24

	csp_skbf_t * buffer = NULL;
    2b4e:	1a 82       	std	Y+2, r1	; 0x02
    2b50:	19 82       	std	Y+1, r1	; 0x01

	if (buf_size + CSP_BUFFER_PACKET_OVERHEAD > size) {
    2b52:	9c 01       	movw	r18, r24
    2b54:	22 5f       	subi	r18, 0xF2	; 242
    2b56:	3f 4f       	sbci	r19, 0xFF	; 255
    2b58:	80 91 ff 1d 	lds	r24, 0x1DFF	; 0x801dff <size>
    2b5c:	90 91 00 1e 	lds	r25, 0x1E00	; 0x801e00 <size+0x1>
    2b60:	82 17       	cp	r24, r18
    2b62:	93 07       	cpc	r25, r19
    2b64:	f8 f4       	brcc	.+62     	; 0x2ba4 <csp_buffer_get+0x6c>
		csp_log_error("Attempt to allocate too large block %u", buf_size);
    2b66:	80 91 04 02 	lds	r24, 0x0204	; 0x800204 <csp_debug_level_enabled>
    2b6a:	88 23       	and	r24, r24
    2b6c:	09 f4       	brne	.+2      	; 0x2b70 <csp_buffer_get+0x38>
    2b6e:	94 c0       	rjmp	.+296    	; 0x2c98 <csp_buffer_get+0x160>
    2b70:	b2 d6       	rcall	.+3428   	; 0x38d6 <csp_get_address>
    2b72:	1f 93       	push	r17
    2b74:	0f 93       	push	r16
    2b76:	1f 92       	push	r1
    2b78:	9c e7       	ldi	r25, 0x7C	; 124
    2b7a:	9f 93       	push	r25
    2b7c:	26 ec       	ldi	r18, 0xC6	; 198
    2b7e:	32 e0       	ldi	r19, 0x02	; 2
    2b80:	3f 93       	push	r19
    2b82:	2f 93       	push	r18
    2b84:	1f 92       	push	r1
    2b86:	8f 93       	push	r24
    2b88:	8b e0       	ldi	r24, 0x0B	; 11
    2b8a:	94 e0       	ldi	r25, 0x04	; 4
    2b8c:	9f 93       	push	r25
    2b8e:	8f 93       	push	r24
    2b90:	1f 92       	push	r1
    2b92:	b9 d5       	rcall	.+2930   	; 0x3706 <do_csp_debug>
    2b94:	0f b6       	in	r0, 0x3f	; 63
    2b96:	f8 94       	cli
    2b98:	de bf       	out	0x3e, r29	; 62
    2b9a:	0f be       	out	0x3f, r0	; 63
    2b9c:	cd bf       	out	0x3d, r28	; 61
		return NULL;
    2b9e:	80 e0       	ldi	r24, 0x00	; 0
    2ba0:	90 e0       	ldi	r25, 0x00	; 0
    2ba2:	82 c0       	rjmp	.+260    	; 0x2ca8 <csp_buffer_get+0x170>
	}

	csp_queue_dequeue(csp_buffers, &buffer, 0);
    2ba4:	20 e0       	ldi	r18, 0x00	; 0
    2ba6:	30 e0       	ldi	r19, 0x00	; 0
    2ba8:	a9 01       	movw	r20, r18
    2baa:	be 01       	movw	r22, r28
    2bac:	6f 5f       	subi	r22, 0xFF	; 255
    2bae:	7f 4f       	sbci	r23, 0xFF	; 255
    2bb0:	80 91 05 1e 	lds	r24, 0x1E05	; 0x801e05 <csp_buffers>
    2bb4:	90 91 06 1e 	lds	r25, 0x1E06	; 0x801e06 <csp_buffers+0x1>
    2bb8:	da dd       	rcall	.-1100   	; 0x276e <csp_queue_dequeue>
	if (buffer == NULL) {
    2bba:	09 81       	ldd	r16, Y+1	; 0x01
    2bbc:	1a 81       	ldd	r17, Y+2	; 0x02
    2bbe:	01 15       	cp	r16, r1
    2bc0:	11 05       	cpc	r17, r1
    2bc2:	e9 f4       	brne	.+58     	; 0x2bfe <csp_buffer_get+0xc6>
		csp_log_error("Out of buffers");
    2bc4:	80 91 04 02 	lds	r24, 0x0204	; 0x800204 <csp_debug_level_enabled>
    2bc8:	88 23       	and	r24, r24
    2bca:	09 f4       	brne	.+2      	; 0x2bce <csp_buffer_get+0x96>
    2bcc:	68 c0       	rjmp	.+208    	; 0x2c9e <csp_buffer_get+0x166>
    2bce:	83 d6       	rcall	.+3334   	; 0x38d6 <csp_get_address>
    2bd0:	1f 92       	push	r1
    2bd2:	92 e8       	ldi	r25, 0x82	; 130
    2bd4:	9f 93       	push	r25
    2bd6:	26 ec       	ldi	r18, 0xC6	; 198
    2bd8:	32 e0       	ldi	r19, 0x02	; 2
    2bda:	3f 93       	push	r19
    2bdc:	2f 93       	push	r18
    2bde:	1f 92       	push	r1
    2be0:	8f 93       	push	r24
    2be2:	8f ee       	ldi	r24, 0xEF	; 239
    2be4:	93 e0       	ldi	r25, 0x03	; 3
    2be6:	9f 93       	push	r25
    2be8:	8f 93       	push	r24
    2bea:	1f 92       	push	r1
    2bec:	8c d5       	rcall	.+2840   	; 0x3706 <do_csp_debug>
    2bee:	0f b6       	in	r0, 0x3f	; 63
    2bf0:	f8 94       	cli
    2bf2:	de bf       	out	0x3e, r29	; 62
    2bf4:	0f be       	out	0x3f, r0	; 63
    2bf6:	cd bf       	out	0x3d, r28	; 61
		return NULL;
    2bf8:	80 e0       	ldi	r24, 0x00	; 0
    2bfa:	90 e0       	ldi	r25, 0x00	; 0
    2bfc:	55 c0       	rjmp	.+170    	; 0x2ca8 <csp_buffer_get+0x170>
	}

	csp_log_buffer("GET: %p %p", buffer, buffer->skbf_addr);
    2bfe:	80 91 07 02 	lds	r24, 0x0207	; 0x800207 <csp_debug_level_enabled+0x3>
    2c02:	88 23       	and	r24, r24
    2c04:	e9 f0       	breq	.+58     	; 0x2c40 <csp_buffer_get+0x108>
    2c06:	f8 01       	movw	r30, r16
    2c08:	f2 80       	ldd	r15, Z+2	; 0x02
    2c0a:	e3 80       	ldd	r14, Z+3	; 0x03
    2c0c:	64 d6       	rcall	.+3272   	; 0x38d6 <csp_get_address>
    2c0e:	ef 92       	push	r14
    2c10:	ff 92       	push	r15
    2c12:	1f 93       	push	r17
    2c14:	0f 93       	push	r16
    2c16:	1f 92       	push	r1
    2c18:	96 e8       	ldi	r25, 0x86	; 134
    2c1a:	9f 93       	push	r25
    2c1c:	26 ec       	ldi	r18, 0xC6	; 198
    2c1e:	32 e0       	ldi	r19, 0x02	; 2
    2c20:	3f 93       	push	r19
    2c22:	2f 93       	push	r18
    2c24:	1f 92       	push	r1
    2c26:	8f 93       	push	r24
    2c28:	87 ed       	ldi	r24, 0xD7	; 215
    2c2a:	93 e0       	ldi	r25, 0x03	; 3
    2c2c:	9f 93       	push	r25
    2c2e:	8f 93       	push	r24
    2c30:	83 e0       	ldi	r24, 0x03	; 3
    2c32:	8f 93       	push	r24
    2c34:	68 d5       	rcall	.+2768   	; 0x3706 <do_csp_debug>
    2c36:	0f b6       	in	r0, 0x3f	; 63
    2c38:	f8 94       	cli
    2c3a:	de bf       	out	0x3e, r29	; 62
    2c3c:	0f be       	out	0x3f, r0	; 63
    2c3e:	cd bf       	out	0x3d, r28	; 61

	if (buffer != buffer->skbf_addr) {
    2c40:	e9 81       	ldd	r30, Y+1	; 0x01
    2c42:	fa 81       	ldd	r31, Y+2	; 0x02
    2c44:	82 81       	ldd	r24, Z+2	; 0x02
    2c46:	93 81       	ldd	r25, Z+3	; 0x03
    2c48:	e8 17       	cp	r30, r24
    2c4a:	f9 07       	cpc	r31, r25
		csp_log_error("Corrupt CSP buffer");
    2c4c:	e1 f0       	breq	.+56     	; 0x2c86 <csp_buffer_get+0x14e>
    2c4e:	80 91 04 02 	lds	r24, 0x0204	; 0x800204 <csp_debug_level_enabled>
    2c52:	88 23       	and	r24, r24
    2c54:	39 f1       	breq	.+78     	; 0x2ca4 <csp_buffer_get+0x16c>
    2c56:	3f d6       	rcall	.+3198   	; 0x38d6 <csp_get_address>
    2c58:	1f 92       	push	r1
    2c5a:	99 e8       	ldi	r25, 0x89	; 137
    2c5c:	9f 93       	push	r25
    2c5e:	26 ec       	ldi	r18, 0xC6	; 198
    2c60:	32 e0       	ldi	r19, 0x02	; 2
    2c62:	3f 93       	push	r19
    2c64:	2f 93       	push	r18
    2c66:	1f 92       	push	r1
    2c68:	8f 93       	push	r24
    2c6a:	87 eb       	ldi	r24, 0xB7	; 183
    2c6c:	93 e0       	ldi	r25, 0x03	; 3
    2c6e:	9f 93       	push	r25
    2c70:	8f 93       	push	r24
    2c72:	1f 92       	push	r1
    2c74:	48 d5       	rcall	.+2704   	; 0x3706 <do_csp_debug>
    2c76:	0f b6       	in	r0, 0x3f	; 63
    2c78:	f8 94       	cli
    2c7a:	de bf       	out	0x3e, r29	; 62
    2c7c:	0f be       	out	0x3f, r0	; 63
    2c7e:	cd bf       	out	0x3d, r28	; 61
		return NULL;
    2c80:	80 e0       	ldi	r24, 0x00	; 0
    2c82:	90 e0       	ldi	r25, 0x00	; 0
    2c84:	11 c0       	rjmp	.+34     	; 0x2ca8 <csp_buffer_get+0x170>
	}

	buffer->refcount++;
    2c86:	80 81       	ld	r24, Z
    2c88:	91 81       	ldd	r25, Z+1	; 0x01
    2c8a:	01 96       	adiw	r24, 0x01	; 1
    2c8c:	91 83       	std	Z+1, r25	; 0x01
    2c8e:	80 83       	st	Z, r24
	return buffer->skbf_data;
    2c90:	89 81       	ldd	r24, Y+1	; 0x01
    2c92:	9a 81       	ldd	r25, Y+2	; 0x02
    2c94:	04 96       	adiw	r24, 0x04	; 4
    2c96:	08 c0       	rjmp	.+16     	; 0x2ca8 <csp_buffer_get+0x170>

	csp_skbf_t * buffer = NULL;

	if (buf_size + CSP_BUFFER_PACKET_OVERHEAD > size) {
		csp_log_error("Attempt to allocate too large block %u", buf_size);
		return NULL;
    2c98:	80 e0       	ldi	r24, 0x00	; 0
    2c9a:	90 e0       	ldi	r25, 0x00	; 0
    2c9c:	05 c0       	rjmp	.+10     	; 0x2ca8 <csp_buffer_get+0x170>
	}

	csp_queue_dequeue(csp_buffers, &buffer, 0);
	if (buffer == NULL) {
		csp_log_error("Out of buffers");
		return NULL;
    2c9e:	80 e0       	ldi	r24, 0x00	; 0
    2ca0:	90 e0       	ldi	r25, 0x00	; 0
    2ca2:	02 c0       	rjmp	.+4      	; 0x2ca8 <csp_buffer_get+0x170>

	csp_log_buffer("GET: %p %p", buffer, buffer->skbf_addr);

	if (buffer != buffer->skbf_addr) {
		csp_log_error("Corrupt CSP buffer");
		return NULL;
    2ca4:	80 e0       	ldi	r24, 0x00	; 0
    2ca6:	90 e0       	ldi	r25, 0x00	; 0
	}

	buffer->refcount++;
	return buffer->skbf_data;
}
    2ca8:	0f 90       	pop	r0
    2caa:	0f 90       	pop	r0
    2cac:	df 91       	pop	r29
    2cae:	cf 91       	pop	r28
    2cb0:	1f 91       	pop	r17
    2cb2:	0f 91       	pop	r16
    2cb4:	ff 90       	pop	r15
    2cb6:	ef 90       	pop	r14
    2cb8:	08 95       	ret

00002cba <csp_buffer_free_isr>:

void csp_buffer_free_isr(void *packet) {
    2cba:	cf 93       	push	r28
    2cbc:	df 93       	push	r29
    2cbe:	00 d0       	rcall	.+0      	; 0x2cc0 <csp_buffer_free_isr+0x6>
    2cc0:	cd b7       	in	r28, 0x3d	; 61
    2cc2:	de b7       	in	r29, 0x3e	; 62
	CSP_BASE_TYPE task_woken = 0;
    2cc4:	19 82       	std	Y+1, r1	; 0x01
	if (!packet)
    2cc6:	00 97       	sbiw	r24, 0x00	; 0
    2cc8:	51 f1       	breq	.+84     	; 0x2d1e <csp_buffer_free_isr+0x64>
		return;

	csp_skbf_t * buf = packet - sizeof(csp_skbf_t);
    2cca:	9c 01       	movw	r18, r24
    2ccc:	24 50       	subi	r18, 0x04	; 4
    2cce:	31 09       	sbc	r19, r1
    2cd0:	3b 83       	std	Y+3, r19	; 0x03
    2cd2:	2a 83       	std	Y+2, r18	; 0x02

	if (((uintptr_t) buf % CSP_BUFFER_ALIGN) > 0)
    2cd4:	20 fd       	sbrc	r18, 0
    2cd6:	23 c0       	rjmp	.+70     	; 0x2d1e <csp_buffer_free_isr+0x64>
		return;

	if (buf->skbf_addr != buf)
    2cd8:	f9 01       	movw	r30, r18
    2cda:	42 81       	ldd	r20, Z+2	; 0x02
    2cdc:	53 81       	ldd	r21, Z+3	; 0x03
    2cde:	24 17       	cp	r18, r20
    2ce0:	35 07       	cpc	r19, r21
    2ce2:	e9 f4       	brne	.+58     	; 0x2d1e <csp_buffer_free_isr+0x64>
		return;

	if (buf->refcount == 0) {
    2ce4:	f9 01       	movw	r30, r18
    2ce6:	20 81       	ld	r18, Z
    2ce8:	31 81       	ldd	r19, Z+1	; 0x01
    2cea:	21 15       	cp	r18, r1
    2cec:	31 05       	cpc	r19, r1
    2cee:	b9 f0       	breq	.+46     	; 0x2d1e <csp_buffer_free_isr+0x64>
		return;
	} else if (buf->refcount > 1) {
    2cf0:	22 30       	cpi	r18, 0x02	; 2
    2cf2:	31 05       	cpc	r19, r1
    2cf4:	28 f0       	brcs	.+10     	; 0x2d00 <csp_buffer_free_isr+0x46>
		buf->refcount--;
    2cf6:	21 50       	subi	r18, 0x01	; 1
    2cf8:	31 09       	sbc	r19, r1
    2cfa:	31 83       	std	Z+1, r19	; 0x01
    2cfc:	20 83       	st	Z, r18
		return;
    2cfe:	0f c0       	rjmp	.+30     	; 0x2d1e <csp_buffer_free_isr+0x64>
	} else {
		buf->refcount = 0;
    2d00:	fc 01       	movw	r30, r24
    2d02:	34 97       	sbiw	r30, 0x04	; 4
    2d04:	11 82       	std	Z+1, r1	; 0x01
    2d06:	10 82       	st	Z, r1
		csp_queue_enqueue_isr(csp_buffers, &buf, &task_woken);
    2d08:	ae 01       	movw	r20, r28
    2d0a:	4f 5f       	subi	r20, 0xFF	; 255
    2d0c:	5f 4f       	sbci	r21, 0xFF	; 255
    2d0e:	be 01       	movw	r22, r28
    2d10:	6e 5f       	subi	r22, 0xFE	; 254
    2d12:	7f 4f       	sbci	r23, 0xFF	; 255
    2d14:	80 91 05 1e 	lds	r24, 0x1E05	; 0x801e05 <csp_buffers>
    2d18:	90 91 06 1e 	lds	r25, 0x1E06	; 0x801e06 <csp_buffers+0x1>
    2d1c:	22 dd       	rcall	.-1468   	; 0x2762 <csp_queue_enqueue_isr>
	}

}
    2d1e:	0f 90       	pop	r0
    2d20:	0f 90       	pop	r0
    2d22:	0f 90       	pop	r0
    2d24:	df 91       	pop	r29
    2d26:	cf 91       	pop	r28
    2d28:	08 95       	ret

00002d2a <csp_buffer_free>:

void csp_buffer_free(void *packet) {
    2d2a:	cf 92       	push	r12
    2d2c:	df 92       	push	r13
    2d2e:	ef 92       	push	r14
    2d30:	ff 92       	push	r15
    2d32:	0f 93       	push	r16
    2d34:	1f 93       	push	r17
    2d36:	cf 93       	push	r28
    2d38:	df 93       	push	r29
    2d3a:	1f 92       	push	r1
    2d3c:	1f 92       	push	r1
    2d3e:	cd b7       	in	r28, 0x3d	; 61
    2d40:	de b7       	in	r29, 0x3e	; 62
    2d42:	8c 01       	movw	r16, r24
	if (!packet) {
    2d44:	00 97       	sbiw	r24, 0x00	; 0
    2d46:	d9 f4       	brne	.+54     	; 0x2d7e <csp_buffer_free+0x54>
		csp_log_error("Attempt to free null pointer");
    2d48:	80 91 04 02 	lds	r24, 0x0204	; 0x800204 <csp_debug_level_enabled>
    2d4c:	88 23       	and	r24, r24
    2d4e:	09 f4       	brne	.+2      	; 0x2d52 <csp_buffer_free+0x28>
    2d50:	d7 c0       	rjmp	.+430    	; 0x2f00 <csp_buffer_free+0x1d6>
    2d52:	c1 d5       	rcall	.+2946   	; 0x38d6 <csp_get_address>
    2d54:	1f 92       	push	r1
    2d56:	9c ea       	ldi	r25, 0xAC	; 172
    2d58:	9f 93       	push	r25
    2d5a:	26 ec       	ldi	r18, 0xC6	; 198
    2d5c:	32 e0       	ldi	r19, 0x02	; 2
    2d5e:	3f 93       	push	r19
    2d60:	2f 93       	push	r18
    2d62:	1f 92       	push	r1
    2d64:	8f 93       	push	r24
    2d66:	8d e8       	ldi	r24, 0x8D	; 141
    2d68:	93 e0       	ldi	r25, 0x03	; 3
    2d6a:	9f 93       	push	r25
    2d6c:	8f 93       	push	r24
    2d6e:	1f 92       	push	r1
    2d70:	ca d4       	rcall	.+2452   	; 0x3706 <do_csp_debug>
    2d72:	0f b6       	in	r0, 0x3f	; 63
    2d74:	f8 94       	cli
    2d76:	de bf       	out	0x3e, r29	; 62
    2d78:	0f be       	out	0x3f, r0	; 63
    2d7a:	cd bf       	out	0x3d, r28	; 61
    2d7c:	c1 c0       	rjmp	.+386    	; 0x2f00 <csp_buffer_free+0x1d6>
		return;
	}

	csp_skbf_t * buf = packet - sizeof(csp_skbf_t);
    2d7e:	7c 01       	movw	r14, r24
    2d80:	94 e0       	ldi	r25, 0x04	; 4
    2d82:	e9 1a       	sub	r14, r25
    2d84:	f1 08       	sbc	r15, r1
    2d86:	fa 82       	std	Y+2, r15	; 0x02
    2d88:	e9 82       	std	Y+1, r14	; 0x01

	if (((uintptr_t) buf % CSP_BUFFER_ALIGN) > 0) {
    2d8a:	e0 fe       	sbrs	r14, 0
    2d8c:	1d c0       	rjmp	.+58     	; 0x2dc8 <csp_buffer_free+0x9e>
		csp_log_error("FREE: Unaligned CSP buffer pointer %p", packet);
    2d8e:	80 91 04 02 	lds	r24, 0x0204	; 0x800204 <csp_debug_level_enabled>
    2d92:	88 23       	and	r24, r24
    2d94:	09 f4       	brne	.+2      	; 0x2d98 <csp_buffer_free+0x6e>
    2d96:	b4 c0       	rjmp	.+360    	; 0x2f00 <csp_buffer_free+0x1d6>
    2d98:	9e d5       	rcall	.+2876   	; 0x38d6 <csp_get_address>
    2d9a:	1f 93       	push	r17
    2d9c:	0f 93       	push	r16
    2d9e:	1f 92       	push	r1
    2da0:	93 eb       	ldi	r25, 0xB3	; 179
    2da2:	9f 93       	push	r25
    2da4:	26 ec       	ldi	r18, 0xC6	; 198
    2da6:	32 e0       	ldi	r19, 0x02	; 2
    2da8:	3f 93       	push	r19
    2daa:	2f 93       	push	r18
    2dac:	1f 92       	push	r1
    2dae:	8f 93       	push	r24
    2db0:	8a e5       	ldi	r24, 0x5A	; 90
    2db2:	93 e0       	ldi	r25, 0x03	; 3
    2db4:	9f 93       	push	r25
    2db6:	8f 93       	push	r24
    2db8:	1f 92       	push	r1
    2dba:	a5 d4       	rcall	.+2378   	; 0x3706 <do_csp_debug>
    2dbc:	0f b6       	in	r0, 0x3f	; 63
    2dbe:	f8 94       	cli
    2dc0:	de bf       	out	0x3e, r29	; 62
    2dc2:	0f be       	out	0x3f, r0	; 63
    2dc4:	cd bf       	out	0x3d, r28	; 61
    2dc6:	9c c0       	rjmp	.+312    	; 0x2f00 <csp_buffer_free+0x1d6>
		return;
	}

	if (buf->skbf_addr != buf) {
    2dc8:	f8 01       	movw	r30, r16
    2dca:	34 97       	sbiw	r30, 0x04	; 4
    2dcc:	82 81       	ldd	r24, Z+2	; 0x02
    2dce:	93 81       	ldd	r25, Z+3	; 0x03
    2dd0:	e8 16       	cp	r14, r24
    2dd2:	f9 06       	cpc	r15, r25
    2dd4:	e9 f0       	breq	.+58     	; 0x2e10 <csp_buffer_free+0xe6>
		csp_log_error("FREE: Invalid CSP buffer pointer %p", packet);
    2dd6:	80 91 04 02 	lds	r24, 0x0204	; 0x800204 <csp_debug_level_enabled>
    2dda:	88 23       	and	r24, r24
    2ddc:	09 f4       	brne	.+2      	; 0x2de0 <csp_buffer_free+0xb6>
    2dde:	90 c0       	rjmp	.+288    	; 0x2f00 <csp_buffer_free+0x1d6>
    2de0:	7a d5       	rcall	.+2804   	; 0x38d6 <csp_get_address>
    2de2:	1f 93       	push	r17
    2de4:	0f 93       	push	r16
    2de6:	1f 92       	push	r1
    2de8:	98 eb       	ldi	r25, 0xB8	; 184
    2dea:	9f 93       	push	r25
    2dec:	26 ec       	ldi	r18, 0xC6	; 198
    2dee:	32 e0       	ldi	r19, 0x02	; 2
    2df0:	3f 93       	push	r19
    2df2:	2f 93       	push	r18
    2df4:	1f 92       	push	r1
    2df6:	8f 93       	push	r24
    2df8:	89 e2       	ldi	r24, 0x29	; 41
    2dfa:	93 e0       	ldi	r25, 0x03	; 3
    2dfc:	9f 93       	push	r25
    2dfe:	8f 93       	push	r24
    2e00:	1f 92       	push	r1
    2e02:	81 d4       	rcall	.+2306   	; 0x3706 <do_csp_debug>
    2e04:	0f b6       	in	r0, 0x3f	; 63
    2e06:	f8 94       	cli
    2e08:	de bf       	out	0x3e, r29	; 62
    2e0a:	0f be       	out	0x3f, r0	; 63
    2e0c:	cd bf       	out	0x3d, r28	; 61
    2e0e:	78 c0       	rjmp	.+240    	; 0x2f00 <csp_buffer_free+0x1d6>
		return;
	}

	if (buf->refcount == 0) {
    2e10:	f8 01       	movw	r30, r16
    2e12:	34 97       	sbiw	r30, 0x04	; 4
    2e14:	80 81       	ld	r24, Z
    2e16:	91 81       	ldd	r25, Z+1	; 0x01
    2e18:	00 97       	sbiw	r24, 0x00	; 0
		csp_log_error("FREE: Buffer already free %p", buf);
    2e1a:	e9 f4       	brne	.+58     	; 0x2e56 <csp_buffer_free+0x12c>
    2e1c:	80 91 04 02 	lds	r24, 0x0204	; 0x800204 <csp_debug_level_enabled>
    2e20:	88 23       	and	r24, r24
    2e22:	09 f4       	brne	.+2      	; 0x2e26 <csp_buffer_free+0xfc>
    2e24:	6d c0       	rjmp	.+218    	; 0x2f00 <csp_buffer_free+0x1d6>
    2e26:	57 d5       	rcall	.+2734   	; 0x38d6 <csp_get_address>
    2e28:	ff 92       	push	r15
    2e2a:	ef 92       	push	r14
    2e2c:	1f 92       	push	r1
    2e2e:	9d eb       	ldi	r25, 0xBD	; 189
    2e30:	9f 93       	push	r25
    2e32:	26 ec       	ldi	r18, 0xC6	; 198
    2e34:	32 e0       	ldi	r19, 0x02	; 2
    2e36:	3f 93       	push	r19
    2e38:	2f 93       	push	r18
    2e3a:	1f 92       	push	r1
    2e3c:	8f 93       	push	r24
    2e3e:	8f ef       	ldi	r24, 0xFF	; 255
    2e40:	92 e0       	ldi	r25, 0x02	; 2
    2e42:	9f 93       	push	r25
    2e44:	8f 93       	push	r24
    2e46:	1f 92       	push	r1
    2e48:	5e d4       	rcall	.+2236   	; 0x3706 <do_csp_debug>
    2e4a:	0f b6       	in	r0, 0x3f	; 63
    2e4c:	f8 94       	cli
    2e4e:	de bf       	out	0x3e, r29	; 62
    2e50:	0f be       	out	0x3f, r0	; 63
    2e52:	cd bf       	out	0x3d, r28	; 61
    2e54:	55 c0       	rjmp	.+170    	; 0x2f00 <csp_buffer_free+0x1d6>
		return;
	} else if (buf->refcount > 1) {
    2e56:	82 30       	cpi	r24, 0x02	; 2
    2e58:	91 05       	cpc	r25, r1
    2e5a:	38 f1       	brcs	.+78     	; 0x2eaa <csp_buffer_free+0x180>
		buf->refcount--;
    2e5c:	6c 01       	movw	r12, r24
    2e5e:	21 e0       	ldi	r18, 0x01	; 1
    2e60:	c2 1a       	sub	r12, r18
    2e62:	d1 08       	sbc	r13, r1
    2e64:	f8 01       	movw	r30, r16
    2e66:	34 97       	sbiw	r30, 0x04	; 4
    2e68:	d1 82       	std	Z+1, r13	; 0x01
		csp_log_error("FREE: Buffer %p in use by %u users", buf, buf->refcount);
    2e6a:	c0 82       	st	Z, r12
    2e6c:	80 91 04 02 	lds	r24, 0x0204	; 0x800204 <csp_debug_level_enabled>
    2e70:	88 23       	and	r24, r24
    2e72:	09 f4       	brne	.+2      	; 0x2e76 <csp_buffer_free+0x14c>
    2e74:	45 c0       	rjmp	.+138    	; 0x2f00 <csp_buffer_free+0x1d6>
    2e76:	2f d5       	rcall	.+2654   	; 0x38d6 <csp_get_address>
    2e78:	df 92       	push	r13
    2e7a:	cf 92       	push	r12
    2e7c:	ff 92       	push	r15
    2e7e:	ef 92       	push	r14
    2e80:	1f 92       	push	r1
    2e82:	91 ec       	ldi	r25, 0xC1	; 193
    2e84:	9f 93       	push	r25
    2e86:	26 ec       	ldi	r18, 0xC6	; 198
    2e88:	32 e0       	ldi	r19, 0x02	; 2
    2e8a:	3f 93       	push	r19
    2e8c:	2f 93       	push	r18
    2e8e:	1f 92       	push	r1
    2e90:	8f 93       	push	r24
    2e92:	8f ec       	ldi	r24, 0xCF	; 207
    2e94:	92 e0       	ldi	r25, 0x02	; 2
    2e96:	9f 93       	push	r25
    2e98:	8f 93       	push	r24
    2e9a:	1f 92       	push	r1
    2e9c:	34 d4       	rcall	.+2152   	; 0x3706 <do_csp_debug>
    2e9e:	0f b6       	in	r0, 0x3f	; 63
    2ea0:	f8 94       	cli
    2ea2:	de bf       	out	0x3e, r29	; 62
    2ea4:	0f be       	out	0x3f, r0	; 63
    2ea6:	cd bf       	out	0x3d, r28	; 61
		return;
	} else {
		buf->refcount = 0;
    2ea8:	2b c0       	rjmp	.+86     	; 0x2f00 <csp_buffer_free+0x1d6>
    2eaa:	f8 01       	movw	r30, r16
    2eac:	34 97       	sbiw	r30, 0x04	; 4
    2eae:	11 82       	std	Z+1, r1	; 0x01
		csp_log_buffer("FREE: %p", buf);
    2eb0:	10 82       	st	Z, r1
    2eb2:	80 91 07 02 	lds	r24, 0x0207	; 0x800207 <csp_debug_level_enabled+0x3>
    2eb6:	88 23       	and	r24, r24
    2eb8:	c1 f0       	breq	.+48     	; 0x2eea <csp_buffer_free+0x1c0>
    2eba:	0d d5       	rcall	.+2586   	; 0x38d6 <csp_get_address>
    2ebc:	ff 92       	push	r15
    2ebe:	ef 92       	push	r14
    2ec0:	1f 92       	push	r1
    2ec2:	95 ec       	ldi	r25, 0xC5	; 197
    2ec4:	9f 93       	push	r25
    2ec6:	26 ec       	ldi	r18, 0xC6	; 198
    2ec8:	32 e0       	ldi	r19, 0x02	; 2
    2eca:	3f 93       	push	r19
    2ecc:	2f 93       	push	r18
    2ece:	1f 92       	push	r1
    2ed0:	8f 93       	push	r24
    2ed2:	89 eb       	ldi	r24, 0xB9	; 185
    2ed4:	92 e0       	ldi	r25, 0x02	; 2
    2ed6:	9f 93       	push	r25
    2ed8:	8f 93       	push	r24
    2eda:	83 e0       	ldi	r24, 0x03	; 3
    2edc:	8f 93       	push	r24
    2ede:	13 d4       	rcall	.+2086   	; 0x3706 <do_csp_debug>
    2ee0:	0f b6       	in	r0, 0x3f	; 63
    2ee2:	f8 94       	cli
    2ee4:	de bf       	out	0x3e, r29	; 62
    2ee6:	0f be       	out	0x3f, r0	; 63
		csp_queue_enqueue(csp_buffers, &buf, 0);
    2ee8:	cd bf       	out	0x3d, r28	; 61
    2eea:	20 e0       	ldi	r18, 0x00	; 0
    2eec:	30 e0       	ldi	r19, 0x00	; 0
    2eee:	a9 01       	movw	r20, r18
    2ef0:	be 01       	movw	r22, r28
    2ef2:	6f 5f       	subi	r22, 0xFF	; 255
    2ef4:	7f 4f       	sbci	r23, 0xFF	; 255
    2ef6:	80 91 05 1e 	lds	r24, 0x1E05	; 0x801e05 <csp_buffers>
    2efa:	90 91 06 1e 	lds	r25, 0x1E06	; 0x801e06 <csp_buffers+0x1>
    2efe:	29 dc       	rcall	.-1966   	; 0x2752 <csp_queue_enqueue>
	}

}
    2f00:	0f 90       	pop	r0
    2f02:	0f 90       	pop	r0
    2f04:	df 91       	pop	r29
    2f06:	cf 91       	pop	r28
    2f08:	1f 91       	pop	r17
    2f0a:	0f 91       	pop	r16
    2f0c:	ff 90       	pop	r15
    2f0e:	ef 90       	pop	r14
    2f10:	df 90       	pop	r13
    2f12:	cf 90       	pop	r12
    2f14:	08 95       	ret

00002f16 <csp_conn_enqueue_packet>:

	return CSP_ERR_NONE;

}

int csp_conn_enqueue_packet(csp_conn_t * conn, csp_packet_t * packet) {
    2f16:	df 92       	push	r13
    2f18:	ef 92       	push	r14
    2f1a:	ff 92       	push	r15
    2f1c:	0f 93       	push	r16
    2f1e:	1f 93       	push	r17
    2f20:	cf 93       	push	r28
    2f22:	df 93       	push	r29
    2f24:	1f 92       	push	r1
    2f26:	1f 92       	push	r1
    2f28:	cd b7       	in	r28, 0x3d	; 61
    2f2a:	de b7       	in	r29, 0x3e	; 62
    2f2c:	7a 83       	std	Y+2, r23	; 0x02
    2f2e:	69 83       	std	Y+1, r22	; 0x01

	if (!conn)
    2f30:	00 97       	sbiw	r24, 0x00	; 0
    2f32:	b1 f1       	breq	.+108    	; 0x2fa0 <csp_conn_enqueue_packet+0x8a>
    2f34:	8c 01       	movw	r16, r24
		rxq = csp_conn_get_rxq(packet->id.pri);
	} else {
		rxq = CSP_RX_QUEUES - 1;
	}

	if (csp_queue_enqueue(conn->rx_queue[rxq], &packet, 0) != CSP_QUEUE_OK) {
    2f36:	20 e0       	ldi	r18, 0x00	; 0
    2f38:	30 e0       	ldi	r19, 0x00	; 0
    2f3a:	a9 01       	movw	r20, r18
    2f3c:	be 01       	movw	r22, r28
    2f3e:	6f 5f       	subi	r22, 0xFF	; 255
    2f40:	7f 4f       	sbci	r23, 0xFF	; 255
    2f42:	fc 01       	movw	r30, r24
    2f44:	84 85       	ldd	r24, Z+12	; 0x0c
    2f46:	95 85       	ldd	r25, Z+13	; 0x0d
    2f48:	04 dc       	rcall	.-2040   	; 0x2752 <csp_queue_enqueue>
    2f4a:	01 97       	sbiw	r24, 0x01	; 1
    2f4c:	61 f1       	breq	.+88     	; 0x2fa6 <csp_conn_enqueue_packet+0x90>
		csp_log_error("RX queue %p full with %u items", conn->rx_queue[rxq], csp_queue_size(conn->rx_queue[rxq]));
    2f4e:	80 91 04 02 	lds	r24, 0x0204	; 0x800204 <csp_debug_level_enabled>
    2f52:	88 23       	and	r24, r24
    2f54:	59 f1       	breq	.+86     	; 0x2fac <csp_conn_enqueue_packet+0x96>
    2f56:	f8 01       	movw	r30, r16
    2f58:	84 85       	ldd	r24, Z+12	; 0x0c
    2f5a:	95 85       	ldd	r25, Z+13	; 0x0d
    2f5c:	15 dc       	rcall	.-2006   	; 0x2788 <csp_queue_size>
    2f5e:	e8 2e       	mov	r14, r24
    2f60:	d9 2e       	mov	r13, r25
    2f62:	f8 01       	movw	r30, r16
    2f64:	f4 84       	ldd	r15, Z+12	; 0x0c
    2f66:	15 85       	ldd	r17, Z+13	; 0x0d
    2f68:	b6 d4       	rcall	.+2412   	; 0x38d6 <csp_get_address>
    2f6a:	df 92       	push	r13
    2f6c:	ef 92       	push	r14
    2f6e:	1f 93       	push	r17
    2f70:	ff 92       	push	r15
    2f72:	1f 92       	push	r1
    2f74:	95 e6       	ldi	r25, 0x65	; 101
    2f76:	9f 93       	push	r25
    2f78:	25 ee       	ldi	r18, 0xE5	; 229
    2f7a:	32 e0       	ldi	r19, 0x02	; 2
    2f7c:	3f 93       	push	r19
    2f7e:	2f 93       	push	r18
    2f80:	1f 92       	push	r1
    2f82:	8f 93       	push	r24
    2f84:	88 e1       	ldi	r24, 0x18	; 24
    2f86:	97 e0       	ldi	r25, 0x07	; 7
    2f88:	9f 93       	push	r25
    2f8a:	8f 93       	push	r24
    2f8c:	1f 92       	push	r1
    2f8e:	bb d3       	rcall	.+1910   	; 0x3706 <do_csp_debug>
    2f90:	0f b6       	in	r0, 0x3f	; 63
    2f92:	f8 94       	cli
    2f94:	de bf       	out	0x3e, r29	; 62
    2f96:	0f be       	out	0x3f, r0	; 63
    2f98:	cd bf       	out	0x3d, r28	; 61
		return CSP_ERR_NOMEM;
    2f9a:	8f ef       	ldi	r24, 0xFF	; 255
    2f9c:	9f ef       	ldi	r25, 0xFF	; 255
    2f9e:	08 c0       	rjmp	.+16     	; 0x2fb0 <csp_conn_enqueue_packet+0x9a>
}

int csp_conn_enqueue_packet(csp_conn_t * conn, csp_packet_t * packet) {

	if (!conn)
		return CSP_ERR_INVAL;
    2fa0:	8e ef       	ldi	r24, 0xFE	; 254
    2fa2:	9f ef       	ldi	r25, 0xFF	; 255
    2fa4:	05 c0       	rjmp	.+10     	; 0x2fb0 <csp_conn_enqueue_packet+0x9a>
		csp_log_error("QOS event queue full");
		return CSP_ERR_NOMEM;
	}
#endif

	return CSP_ERR_NONE;
    2fa6:	80 e0       	ldi	r24, 0x00	; 0
    2fa8:	90 e0       	ldi	r25, 0x00	; 0
    2faa:	02 c0       	rjmp	.+4      	; 0x2fb0 <csp_conn_enqueue_packet+0x9a>
		rxq = CSP_RX_QUEUES - 1;
	}

	if (csp_queue_enqueue(conn->rx_queue[rxq], &packet, 0) != CSP_QUEUE_OK) {
		csp_log_error("RX queue %p full with %u items", conn->rx_queue[rxq], csp_queue_size(conn->rx_queue[rxq]));
		return CSP_ERR_NOMEM;
    2fac:	8f ef       	ldi	r24, 0xFF	; 255
    2fae:	9f ef       	ldi	r25, 0xFF	; 255
		return CSP_ERR_NOMEM;
	}
#endif

	return CSP_ERR_NONE;
}
    2fb0:	0f 90       	pop	r0
    2fb2:	0f 90       	pop	r0
    2fb4:	df 91       	pop	r29
    2fb6:	cf 91       	pop	r28
    2fb8:	1f 91       	pop	r17
    2fba:	0f 91       	pop	r16
    2fbc:	ff 90       	pop	r15
    2fbe:	ef 90       	pop	r14
    2fc0:	df 90       	pop	r13
    2fc2:	08 95       	ret

00002fc4 <csp_conn_init>:

int csp_conn_init(void) {
    2fc4:	0f 93       	push	r16
    2fc6:	1f 93       	push	r17
    2fc8:	cf 93       	push	r28
    2fca:	df 93       	push	r29

	/* Initialize source port */
	srand(csp_get_ms());
    2fcc:	ed dc       	rcall	.-1574   	; 0x29a8 <csp_get_ms>
    2fce:	cb 01       	movw	r24, r22
    2fd0:	0e 94 30 2c 	call	0x5860	; 0x5860 <srand>
	sport = (rand() % (CSP_ID_PORT_MAX - CSP_MAX_BIND_PORT)) + (CSP_MAX_BIND_PORT + 1);
    2fd4:	0e 94 2d 2c 	call	0x585a	; 0x585a <rand>
    2fd8:	8f 71       	andi	r24, 0x1F	; 31
    2fda:	90 78       	andi	r25, 0x80	; 128
    2fdc:	99 23       	and	r25, r25
    2fde:	24 f4       	brge	.+8      	; 0x2fe8 <csp_conn_init+0x24>
    2fe0:	01 97       	sbiw	r24, 0x01	; 1
    2fe2:	80 6e       	ori	r24, 0xE0	; 224
    2fe4:	9f 6f       	ori	r25, 0xFF	; 255
    2fe6:	01 96       	adiw	r24, 0x01	; 1
    2fe8:	80 5e       	subi	r24, 0xE0	; 224
    2fea:	80 93 0a 1e 	sts	0x1E0A, r24	; 0x801e0a <sport>

	if (csp_bin_sem_create(&sport_lock) != CSP_SEMAPHORE_OK) {
    2fee:	88 e0       	ldi	r24, 0x08	; 8
    2ff0:	9e e1       	ldi	r25, 0x1E	; 30
    2ff2:	de db       	rcall	.-2116   	; 0x27b0 <csp_bin_sem_create>
    2ff4:	01 97       	sbiw	r24, 0x01	; 1
    2ff6:	29 f4       	brne	.+10     	; 0x3002 <csp_conn_init+0x3e>
    2ff8:	cf e0       	ldi	r28, 0x0F	; 15
    2ffa:	de e1       	ldi	r29, 0x1E	; 30
    2ffc:	0f ef       	ldi	r16, 0xFF	; 255
    2ffe:	1e e1       	ldi	r17, 0x1E	; 30
    3000:	44 c0       	rjmp	.+136    	; 0x308a <csp_conn_init+0xc6>
		csp_log_error("No more memory for sport semaphore");
    3002:	80 91 04 02 	lds	r24, 0x0204	; 0x800204 <csp_debug_level_enabled>
    3006:	88 23       	and	r24, r24
    3008:	09 f4       	brne	.+2      	; 0x300c <csp_conn_init+0x48>
    300a:	72 c0       	rjmp	.+228    	; 0x30f0 <csp_conn_init+0x12c>
    300c:	64 d4       	rcall	.+2248   	; 0x38d6 <csp_get_address>
    300e:	1f 92       	push	r1
    3010:	9b e7       	ldi	r25, 0x7B	; 123
    3012:	9f 93       	push	r25
    3014:	25 ee       	ldi	r18, 0xE5	; 229
    3016:	32 e0       	ldi	r19, 0x02	; 2
    3018:	3f 93       	push	r19
    301a:	2f 93       	push	r18
    301c:	1f 92       	push	r1
    301e:	8f 93       	push	r24
    3020:	88 ee       	ldi	r24, 0xE8	; 232
    3022:	96 e0       	ldi	r25, 0x06	; 6
    3024:	9f 93       	push	r25
    3026:	8f 93       	push	r24
    3028:	1f 92       	push	r1
    302a:	6d d3       	rcall	.+1754   	; 0x3706 <do_csp_debug>
    302c:	8d b7       	in	r24, 0x3d	; 61
    302e:	9e b7       	in	r25, 0x3e	; 62
    3030:	09 96       	adiw	r24, 0x09	; 9
    3032:	0f b6       	in	r0, 0x3f	; 63
    3034:	f8 94       	cli
    3036:	9e bf       	out	0x3e, r25	; 62
    3038:	0f be       	out	0x3f, r0	; 63
    303a:	8d bf       	out	0x3d, r24	; 61
		return CSP_ERR_NOMEM;
    303c:	8f ef       	ldi	r24, 0xFF	; 255
    303e:	9f ef       	ldi	r25, 0xFF	; 255
    3040:	62 c0       	rjmp	.+196    	; 0x3106 <csp_conn_init+0x142>
		arr_conn[i].rx_event = csp_queue_create(CSP_CONN_QUEUE_LENGTH, sizeof(int));
#endif
		arr_conn[i].state = CONN_CLOSED;

		if (csp_mutex_create(&arr_conn[i].lock) != CSP_MUTEX_OK) {
			csp_log_error("Failed to create connection lock");
    3042:	80 91 04 02 	lds	r24, 0x0204	; 0x800204 <csp_debug_level_enabled>
    3046:	88 23       	and	r24, r24
    3048:	09 f4       	brne	.+2      	; 0x304c <csp_conn_init+0x88>
    304a:	55 c0       	rjmp	.+170    	; 0x30f6 <csp_conn_init+0x132>
    304c:	44 d4       	rcall	.+2184   	; 0x38d6 <csp_get_address>
    304e:	1f 92       	push	r1
    3050:	9a e8       	ldi	r25, 0x8A	; 138
    3052:	9f 93       	push	r25
    3054:	25 ee       	ldi	r18, 0xE5	; 229
    3056:	32 e0       	ldi	r19, 0x02	; 2
    3058:	3f 93       	push	r19
    305a:	2f 93       	push	r18
    305c:	1f 92       	push	r1
    305e:	8f 93       	push	r24
    3060:	8a eb       	ldi	r24, 0xBA	; 186
    3062:	96 e0       	ldi	r25, 0x06	; 6
    3064:	9f 93       	push	r25
    3066:	8f 93       	push	r24
    3068:	1f 92       	push	r1
    306a:	4d d3       	rcall	.+1690   	; 0x3706 <do_csp_debug>
    306c:	8d b7       	in	r24, 0x3d	; 61
    306e:	9e b7       	in	r25, 0x3e	; 62
    3070:	09 96       	adiw	r24, 0x09	; 9
    3072:	0f b6       	in	r0, 0x3f	; 63
    3074:	f8 94       	cli
    3076:	9e bf       	out	0x3e, r25	; 62
    3078:	0f be       	out	0x3f, r0	; 63
    307a:	8d bf       	out	0x3d, r24	; 61
			return CSP_ERR_NOMEM;
    307c:	8f ef       	ldi	r24, 0xFF	; 255
    307e:	9f ef       	ldi	r25, 0xFF	; 255
    3080:	42 c0       	rjmp	.+132    	; 0x3106 <csp_conn_init+0x142>
    3082:	68 96       	adiw	r28, 0x18	; 24
		csp_log_error("No more memory for sport semaphore");
		return CSP_ERR_NOMEM;
	}

	int i, prio;
	for (i = 0; i < CSP_CONN_MAX; i++) {
    3084:	0c 17       	cp	r16, r28
    3086:	1d 07       	cpc	r17, r29
		for (prio = 0; prio < CSP_RX_QUEUES; prio++)
			arr_conn[i].rx_queue[prio] = csp_queue_create(CSP_RX_QUEUE_LENGTH, sizeof(csp_packet_t *));
    3088:	79 f0       	breq	.+30     	; 0x30a8 <csp_conn_init+0xe4>
    308a:	62 e0       	ldi	r22, 0x02	; 2
    308c:	70 e0       	ldi	r23, 0x00	; 0
    308e:	84 e6       	ldi	r24, 0x64	; 100
    3090:	90 e0       	ldi	r25, 0x00	; 0
    3092:	5c db       	rcall	.-2376   	; 0x274c <csp_queue_create>
    3094:	9b 87       	std	Y+11, r25	; 0x0b

#ifdef CSP_USE_QOS
		arr_conn[i].rx_event = csp_queue_create(CSP_CONN_QUEUE_LENGTH, sizeof(int));
#endif
		arr_conn[i].state = CONN_CLOSED;
    3096:	8a 87       	std	Y+10, r24	; 0x0a
    3098:	fe 01       	movw	r30, r28
    309a:	31 97       	sbiw	r30, 0x01	; 1

		if (csp_mutex_create(&arr_conn[i].lock) != CSP_MUTEX_OK) {
    309c:	10 82       	st	Z, r1
    309e:	ce 01       	movw	r24, r28
    30a0:	76 db       	rcall	.-2324   	; 0x278e <csp_mutex_create>
    30a2:	01 97       	sbiw	r24, 0x01	; 1
    30a4:	71 f3       	breq	.-36     	; 0x3082 <csp_conn_init+0xbe>
			return CSP_ERR_NOMEM;
		}
#endif
	}

	if (csp_bin_sem_create(&conn_lock) != CSP_SEMAPHORE_OK) {
    30a6:	cd cf       	rjmp	.-102    	; 0x3042 <csp_conn_init+0x7e>
    30a8:	8b e0       	ldi	r24, 0x0B	; 11
    30aa:	9e e1       	ldi	r25, 0x1E	; 30
    30ac:	81 db       	rcall	.-2302   	; 0x27b0 <csp_bin_sem_create>
    30ae:	01 97       	sbiw	r24, 0x01	; 1
		csp_log_error("No more memory for conn semaphore");
    30b0:	29 f1       	breq	.+74     	; 0x30fc <csp_conn_init+0x138>
    30b2:	80 91 04 02 	lds	r24, 0x0204	; 0x800204 <csp_debug_level_enabled>
    30b6:	88 23       	and	r24, r24
    30b8:	21 f1       	breq	.+72     	; 0x3102 <csp_conn_init+0x13e>
    30ba:	0d d4       	rcall	.+2074   	; 0x38d6 <csp_get_address>
    30bc:	1f 92       	push	r1
    30be:	97 e9       	ldi	r25, 0x97	; 151
    30c0:	9f 93       	push	r25
    30c2:	25 ee       	ldi	r18, 0xE5	; 229
    30c4:	32 e0       	ldi	r19, 0x02	; 2
    30c6:	3f 93       	push	r19
    30c8:	2f 93       	push	r18
    30ca:	1f 92       	push	r1
    30cc:	8f 93       	push	r24
    30ce:	8b e8       	ldi	r24, 0x8B	; 139
    30d0:	96 e0       	ldi	r25, 0x06	; 6
    30d2:	9f 93       	push	r25
    30d4:	8f 93       	push	r24
    30d6:	1f 92       	push	r1
    30d8:	16 d3       	rcall	.+1580   	; 0x3706 <do_csp_debug>
    30da:	8d b7       	in	r24, 0x3d	; 61
    30dc:	9e b7       	in	r25, 0x3e	; 62
    30de:	09 96       	adiw	r24, 0x09	; 9
    30e0:	0f b6       	in	r0, 0x3f	; 63
    30e2:	f8 94       	cli
    30e4:	9e bf       	out	0x3e, r25	; 62
    30e6:	0f be       	out	0x3f, r0	; 63
    30e8:	8d bf       	out	0x3d, r24	; 61
		return CSP_ERR_NOMEM;
    30ea:	8f ef       	ldi	r24, 0xFF	; 255
    30ec:	9f ef       	ldi	r25, 0xFF	; 255
    30ee:	0b c0       	rjmp	.+22     	; 0x3106 <csp_conn_init+0x142>
	srand(csp_get_ms());
	sport = (rand() % (CSP_ID_PORT_MAX - CSP_MAX_BIND_PORT)) + (CSP_MAX_BIND_PORT + 1);

	if (csp_bin_sem_create(&sport_lock) != CSP_SEMAPHORE_OK) {
		csp_log_error("No more memory for sport semaphore");
		return CSP_ERR_NOMEM;
    30f0:	8f ef       	ldi	r24, 0xFF	; 255
    30f2:	9f ef       	ldi	r25, 0xFF	; 255
    30f4:	08 c0       	rjmp	.+16     	; 0x3106 <csp_conn_init+0x142>
#endif
		arr_conn[i].state = CONN_CLOSED;

		if (csp_mutex_create(&arr_conn[i].lock) != CSP_MUTEX_OK) {
			csp_log_error("Failed to create connection lock");
			return CSP_ERR_NOMEM;
    30f6:	8f ef       	ldi	r24, 0xFF	; 255
    30f8:	9f ef       	ldi	r25, 0xFF	; 255
    30fa:	05 c0       	rjmp	.+10     	; 0x3106 <csp_conn_init+0x142>
	if (csp_bin_sem_create(&conn_lock) != CSP_SEMAPHORE_OK) {
		csp_log_error("No more memory for conn semaphore");
		return CSP_ERR_NOMEM;
	}

	return CSP_ERR_NONE;
    30fc:	80 e0       	ldi	r24, 0x00	; 0
    30fe:	90 e0       	ldi	r25, 0x00	; 0
    3100:	02 c0       	rjmp	.+4      	; 0x3106 <csp_conn_init+0x142>
#endif
	}

	if (csp_bin_sem_create(&conn_lock) != CSP_SEMAPHORE_OK) {
		csp_log_error("No more memory for conn semaphore");
		return CSP_ERR_NOMEM;
    3102:	8f ef       	ldi	r24, 0xFF	; 255
    3104:	9f ef       	ldi	r25, 0xFF	; 255
	}

	return CSP_ERR_NONE;

}
    3106:	df 91       	pop	r29
    3108:	cf 91       	pop	r28
    310a:	1f 91       	pop	r17
    310c:	0f 91       	pop	r16
    310e:	08 95       	ret

00003110 <csp_conn_find>:

csp_conn_t * csp_conn_find(uint32_t id, uint32_t mask) {
    3110:	8f 92       	push	r8
    3112:	9f 92       	push	r9
    3114:	af 92       	push	r10
    3116:	bf 92       	push	r11
    3118:	cf 92       	push	r12
    311a:	df 92       	push	r13
    311c:	ef 92       	push	r14
    311e:	ff 92       	push	r15
    3120:	6b 01       	movw	r12, r22
    3122:	7c 01       	movw	r14, r24
    3124:	49 01       	movw	r8, r18
    3126:	5a 01       	movw	r10, r20
    3128:	ed e0       	ldi	r30, 0x0D	; 13
    312a:	fe e1       	ldi	r31, 0x1E	; 30

	/* Search for matching connection */
	int i;
	csp_conn_t * conn;

	for (i = 0; i < CSP_CONN_MAX; i++) {
    312c:	80 e0       	ldi	r24, 0x00	; 0
    312e:	90 e0       	ldi	r25, 0x00	; 0
		conn = &arr_conn[i];
		if ((conn->state != CONN_CLOSED) && (conn->type == CONN_CLIENT) && (conn->idin.ext & mask) == (id & mask))
    3130:	31 81       	ldd	r19, Z+1	; 0x01
    3132:	33 23       	and	r19, r19
    3134:	09 f1       	breq	.+66     	; 0x3178 <csp_conn_find+0x68>
    3136:	20 81       	ld	r18, Z
    3138:	21 11       	cpse	r18, r1
    313a:	1e c0       	rjmp	.+60     	; 0x3178 <csp_conn_find+0x68>
    313c:	44 81       	ldd	r20, Z+4	; 0x04
    313e:	55 81       	ldd	r21, Z+5	; 0x05
    3140:	66 81       	ldd	r22, Z+6	; 0x06
    3142:	77 81       	ldd	r23, Z+7	; 0x07
    3144:	4c 25       	eor	r20, r12
    3146:	5d 25       	eor	r21, r13
    3148:	6e 25       	eor	r22, r14
    314a:	7f 25       	eor	r23, r15
    314c:	48 21       	and	r20, r8
    314e:	59 21       	and	r21, r9
    3150:	6a 21       	and	r22, r10
    3152:	7b 21       	and	r23, r11
    3154:	45 2b       	or	r20, r21
    3156:	46 2b       	or	r20, r22
    3158:	47 2b       	or	r20, r23
    315a:	71 f4       	brne	.+28     	; 0x3178 <csp_conn_find+0x68>
	/* Search for matching connection */
	int i;
	csp_conn_t * conn;

	for (i = 0; i < CSP_CONN_MAX; i++) {
		conn = &arr_conn[i];
    315c:	9c 01       	movw	r18, r24
    315e:	22 0f       	add	r18, r18
    3160:	33 1f       	adc	r19, r19
    3162:	82 0f       	add	r24, r18
    3164:	93 1f       	adc	r25, r19
    3166:	88 0f       	add	r24, r24
    3168:	99 1f       	adc	r25, r25
    316a:	88 0f       	add	r24, r24
    316c:	99 1f       	adc	r25, r25
    316e:	88 0f       	add	r24, r24
    3170:	99 1f       	adc	r25, r25
    3172:	83 5f       	subi	r24, 0xF3	; 243
    3174:	91 4e       	sbci	r25, 0xE1	; 225
    3176:	07 c0       	rjmp	.+14     	; 0x3186 <csp_conn_find+0x76>

	/* Search for matching connection */
	int i;
	csp_conn_t * conn;

	for (i = 0; i < CSP_CONN_MAX; i++) {
    3178:	01 96       	adiw	r24, 0x01	; 1
    317a:	78 96       	adiw	r30, 0x18	; 24
    317c:	8a 30       	cpi	r24, 0x0A	; 10
    317e:	91 05       	cpc	r25, r1
    3180:	b9 f6       	brne	.-82     	; 0x3130 <csp_conn_find+0x20>
		conn = &arr_conn[i];
		if ((conn->state != CONN_CLOSED) && (conn->type == CONN_CLIENT) && (conn->idin.ext & mask) == (id & mask))
			return conn;
	}
	
	return NULL;
    3182:	80 e0       	ldi	r24, 0x00	; 0
    3184:	90 e0       	ldi	r25, 0x00	; 0

}
    3186:	ff 90       	pop	r15
    3188:	ef 90       	pop	r14
    318a:	df 90       	pop	r13
    318c:	cf 90       	pop	r12
    318e:	bf 90       	pop	r11
    3190:	af 90       	pop	r10
    3192:	9f 90       	pop	r9
    3194:	8f 90       	pop	r8
    3196:	08 95       	ret

00003198 <csp_conn_flush_rx_queue>:

int csp_conn_flush_rx_queue(csp_conn_t * conn) {
    3198:	0f 93       	push	r16
    319a:	1f 93       	push	r17
    319c:	cf 93       	push	r28
    319e:	df 93       	push	r29
    31a0:	1f 92       	push	r1
    31a2:	1f 92       	push	r1
    31a4:	cd b7       	in	r28, 0x3d	; 61
    31a6:	de b7       	in	r29, 0x3e	; 62
    31a8:	8c 01       	movw	r16, r24
    31aa:	05 c0       	rjmp	.+10     	; 0x31b6 <csp_conn_flush_rx_queue+0x1e>
	int prio;

	/* Flush packet queues */
	for (prio = 0; prio < CSP_RX_QUEUES; prio++) {
		while (csp_queue_dequeue(conn->rx_queue[prio], &packet, 0) == CSP_QUEUE_OK)
			if (packet != NULL)
    31ac:	89 81       	ldd	r24, Y+1	; 0x01
    31ae:	9a 81       	ldd	r25, Y+2	; 0x02
    31b0:	00 97       	sbiw	r24, 0x00	; 0
    31b2:	09 f0       	breq	.+2      	; 0x31b6 <csp_conn_flush_rx_queue+0x1e>
				csp_buffer_free(packet);
    31b4:	ba dd       	rcall	.-1164   	; 0x2d2a <csp_buffer_free>

	int prio;

	/* Flush packet queues */
	for (prio = 0; prio < CSP_RX_QUEUES; prio++) {
		while (csp_queue_dequeue(conn->rx_queue[prio], &packet, 0) == CSP_QUEUE_OK)
    31b6:	20 e0       	ldi	r18, 0x00	; 0
    31b8:	30 e0       	ldi	r19, 0x00	; 0
    31ba:	a9 01       	movw	r20, r18
    31bc:	be 01       	movw	r22, r28
    31be:	6f 5f       	subi	r22, 0xFF	; 255
    31c0:	7f 4f       	sbci	r23, 0xFF	; 255
    31c2:	f8 01       	movw	r30, r16
    31c4:	84 85       	ldd	r24, Z+12	; 0x0c
    31c6:	95 85       	ldd	r25, Z+13	; 0x0d
    31c8:	d2 da       	rcall	.-2652   	; 0x276e <csp_queue_dequeue>
    31ca:	01 97       	sbiw	r24, 0x01	; 1
    31cc:	79 f3       	breq	.-34     	; 0x31ac <csp_conn_flush_rx_queue+0x14>
	while (csp_queue_dequeue(conn->rx_event, &event, 0) == CSP_QUEUE_OK);
#endif

	return CSP_ERR_NONE;

}
    31ce:	80 e0       	ldi	r24, 0x00	; 0
    31d0:	90 e0       	ldi	r25, 0x00	; 0
    31d2:	0f 90       	pop	r0
    31d4:	0f 90       	pop	r0
    31d6:	df 91       	pop	r29
    31d8:	cf 91       	pop	r28
    31da:	1f 91       	pop	r17
    31dc:	0f 91       	pop	r16
    31de:	08 95       	ret

000031e0 <csp_conn_allocate>:

csp_conn_t * csp_conn_allocate(csp_conn_type_t type) {
    31e0:	1f 93       	push	r17
    31e2:	cf 93       	push	r28
    31e4:	df 93       	push	r29
    31e6:	18 2f       	mov	r17, r24

	int i, j;
	static uint8_t csp_conn_last_given = 0;
	csp_conn_t * conn;

	if (csp_bin_sem_wait(&conn_lock, 100) != CSP_SEMAPHORE_OK) {
    31e8:	44 e6       	ldi	r20, 0x64	; 100
    31ea:	50 e0       	ldi	r21, 0x00	; 0
    31ec:	60 e0       	ldi	r22, 0x00	; 0
    31ee:	70 e0       	ldi	r23, 0x00	; 0
    31f0:	8b e0       	ldi	r24, 0x0B	; 11
    31f2:	9e e1       	ldi	r25, 0x1E	; 30
    31f4:	f7 da       	rcall	.-2578   	; 0x27e4 <csp_bin_sem_wait>
    31f6:	01 97       	sbiw	r24, 0x01	; 1
    31f8:	01 f1       	breq	.+64     	; 0x323a <csp_conn_allocate+0x5a>
		csp_log_error("Failed to lock conn array");
    31fa:	80 91 04 02 	lds	r24, 0x0204	; 0x800204 <csp_debug_level_enabled>
    31fe:	88 23       	and	r24, r24
    3200:	09 f4       	brne	.+2      	; 0x3204 <csp_conn_allocate+0x24>
    3202:	7e c0       	rjmp	.+252    	; 0x3300 <csp_conn_allocate+0x120>
    3204:	68 d3       	rcall	.+1744   	; 0x38d6 <csp_get_address>
    3206:	1f 92       	push	r1
    3208:	9d ec       	ldi	r25, 0xCD	; 205
    320a:	9f 93       	push	r25
    320c:	25 ee       	ldi	r18, 0xE5	; 229
    320e:	32 e0       	ldi	r19, 0x02	; 2
    3210:	3f 93       	push	r19
    3212:	2f 93       	push	r18
    3214:	1f 92       	push	r1
    3216:	8f 93       	push	r24
    3218:	84 e6       	ldi	r24, 0x64	; 100
    321a:	96 e0       	ldi	r25, 0x06	; 6
    321c:	9f 93       	push	r25
    321e:	8f 93       	push	r24
    3220:	1f 92       	push	r1
    3222:	71 d2       	rcall	.+1250   	; 0x3706 <do_csp_debug>
    3224:	8d b7       	in	r24, 0x3d	; 61
    3226:	9e b7       	in	r25, 0x3e	; 62
    3228:	09 96       	adiw	r24, 0x09	; 9
    322a:	0f b6       	in	r0, 0x3f	; 63
    322c:	f8 94       	cli
    322e:	9e bf       	out	0x3e, r25	; 62
    3230:	0f be       	out	0x3f, r0	; 63
    3232:	8d bf       	out	0x3d, r24	; 61
		return NULL;
    3234:	80 e0       	ldi	r24, 0x00	; 0
    3236:	90 e0       	ldi	r25, 0x00	; 0
    3238:	70 c0       	rjmp	.+224    	; 0x331a <csp_conn_allocate+0x13a>
	}

	/* Search for free connection */
	i = csp_conn_last_given;
	i = (i + 1) % CSP_CONN_MAX;
    323a:	80 91 07 1e 	lds	r24, 0x1E07	; 0x801e07 <csp_conn_last_given.3225>
    323e:	90 e0       	ldi	r25, 0x00	; 0
    3240:	01 96       	adiw	r24, 0x01	; 1
    3242:	6a e0       	ldi	r22, 0x0A	; 10
    3244:	70 e0       	ldi	r23, 0x00	; 0
    3246:	0e 94 86 2b 	call	0x570c	; 0x570c <__divmodhi4>

	for (j = 0; j < CSP_CONN_MAX; j++) {
		conn = &arr_conn[i];
		if (conn->state == CONN_CLOSED)
    324a:	fc 01       	movw	r30, r24
    324c:	ee 0f       	add	r30, r30
    324e:	ff 1f       	adc	r31, r31
    3250:	e8 0f       	add	r30, r24
    3252:	f9 1f       	adc	r31, r25
    3254:	ee 0f       	add	r30, r30
    3256:	ff 1f       	adc	r31, r31
    3258:	ee 0f       	add	r30, r30
    325a:	ff 1f       	adc	r31, r31
    325c:	ee 0f       	add	r30, r30
    325e:	ff 1f       	adc	r31, r31
    3260:	e3 5f       	subi	r30, 0xF3	; 243
    3262:	f1 4e       	sbci	r31, 0xE1	; 225
    3264:	41 81       	ldd	r20, Z+1	; 0x01
    3266:	41 11       	cpse	r20, r1
    3268:	4e c0       	rjmp	.+156    	; 0x3306 <csp_conn_allocate+0x126>
	/* Search for free connection */
	i = csp_conn_last_given;
	i = (i + 1) % CSP_CONN_MAX;

	for (j = 0; j < CSP_CONN_MAX; j++) {
		conn = &arr_conn[i];
    326a:	ef 01       	movw	r28, r30
    326c:	17 c0       	rjmp	.+46     	; 0x329c <csp_conn_allocate+0xbc>
    326e:	ec 01       	movw	r28, r24
    3270:	cc 0f       	add	r28, r28
    3272:	dd 1f       	adc	r29, r29
    3274:	c8 0f       	add	r28, r24
    3276:	d9 1f       	adc	r29, r25
    3278:	cc 0f       	add	r28, r28
    327a:	dd 1f       	adc	r29, r29
    327c:	cc 0f       	add	r28, r28
    327e:	dd 1f       	adc	r29, r29
    3280:	cc 0f       	add	r28, r28
    3282:	dd 1f       	adc	r29, r29
    3284:	c3 5f       	subi	r28, 0xF3	; 243
    3286:	d1 4e       	sbci	r29, 0xE1	; 225
		if (conn->state == CONN_CLOSED)
    3288:	49 81       	ldd	r20, Y+1	; 0x01
    328a:	44 23       	and	r20, r20
    328c:	39 f0       	breq	.+14     	; 0x329c <csp_conn_allocate+0xbc>
			break;
		i = (i + 1) % CSP_CONN_MAX;
    328e:	01 96       	adiw	r24, 0x01	; 1
    3290:	bf 01       	movw	r22, r30
    3292:	0e 94 86 2b 	call	0x570c	; 0x570c <__divmodhi4>
    3296:	21 50       	subi	r18, 0x01	; 1
    3298:	31 09       	sbc	r19, r1

	/* Search for free connection */
	i = csp_conn_last_given;
	i = (i + 1) % CSP_CONN_MAX;

	for (j = 0; j < CSP_CONN_MAX; j++) {
    329a:	49 f7       	brne	.-46     	; 0x326e <csp_conn_allocate+0x8e>
		if (conn->state == CONN_CLOSED)
			break;
		i = (i + 1) % CSP_CONN_MAX;
	}

	if (conn->state == CONN_OPEN) {
    329c:	29 81       	ldd	r18, Y+1	; 0x01
    329e:	21 30       	cpi	r18, 0x01	; 1
    32a0:	11 f5       	brne	.+68     	; 0x32e6 <csp_conn_allocate+0x106>
		csp_log_error("No more free connections");
    32a2:	80 91 04 02 	lds	r24, 0x0204	; 0x800204 <csp_debug_level_enabled>
    32a6:	88 23       	and	r24, r24
    32a8:	c1 f0       	breq	.+48     	; 0x32da <csp_conn_allocate+0xfa>
    32aa:	15 d3       	rcall	.+1578   	; 0x38d6 <csp_get_address>
    32ac:	1f 92       	push	r1
    32ae:	9d ed       	ldi	r25, 0xDD	; 221
    32b0:	9f 93       	push	r25
    32b2:	25 ee       	ldi	r18, 0xE5	; 229
    32b4:	32 e0       	ldi	r19, 0x02	; 2
    32b6:	3f 93       	push	r19
    32b8:	2f 93       	push	r18
    32ba:	1f 92       	push	r1
    32bc:	8f 93       	push	r24
    32be:	8e e3       	ldi	r24, 0x3E	; 62
    32c0:	96 e0       	ldi	r25, 0x06	; 6
    32c2:	9f 93       	push	r25
    32c4:	8f 93       	push	r24
    32c6:	1f 92       	push	r1
    32c8:	1e d2       	rcall	.+1084   	; 0x3706 <do_csp_debug>
    32ca:	8d b7       	in	r24, 0x3d	; 61
    32cc:	9e b7       	in	r25, 0x3e	; 62
    32ce:	09 96       	adiw	r24, 0x09	; 9
    32d0:	0f b6       	in	r0, 0x3f	; 63
    32d2:	f8 94       	cli
    32d4:	9e bf       	out	0x3e, r25	; 62
    32d6:	0f be       	out	0x3f, r0	; 63
		csp_bin_sem_post(&conn_lock);
    32d8:	8d bf       	out	0x3d, r24	; 61
    32da:	8b e0       	ldi	r24, 0x0B	; 11
    32dc:	9e e1       	ldi	r25, 0x1E	; 30
    32de:	c3 da       	rcall	.-2682   	; 0x2866 <csp_bin_sem_post>
		return NULL;
    32e0:	80 e0       	ldi	r24, 0x00	; 0
    32e2:	90 e0       	ldi	r25, 0x00	; 0
    32e4:	1a c0       	rjmp	.+52     	; 0x331a <csp_conn_allocate+0x13a>
	}

	conn->state = CONN_OPEN;
    32e6:	91 e0       	ldi	r25, 0x01	; 1
    32e8:	99 83       	std	Y+1, r25	; 0x01
	conn->socket = NULL;
    32ea:	1f 86       	std	Y+15, r1	; 0x0f
	conn->type = type;
    32ec:	1e 86       	std	Y+14, r1	; 0x0e
	csp_conn_last_given = i;
    32ee:	18 83       	st	Y, r17
    32f0:	80 93 07 1e 	sts	0x1E07, r24	; 0x801e07 <csp_conn_last_given.3225>
	csp_bin_sem_post(&conn_lock);
    32f4:	8b e0       	ldi	r24, 0x0B	; 11
    32f6:	9e e1       	ldi	r25, 0x1E	; 30
    32f8:	b6 da       	rcall	.-2708   	; 0x2866 <csp_bin_sem_post>

	return conn;
    32fa:	8c 2f       	mov	r24, r28
    32fc:	9d 2f       	mov	r25, r29
    32fe:	0d c0       	rjmp	.+26     	; 0x331a <csp_conn_allocate+0x13a>
	static uint8_t csp_conn_last_given = 0;
	csp_conn_t * conn;

	if (csp_bin_sem_wait(&conn_lock, 100) != CSP_SEMAPHORE_OK) {
		csp_log_error("Failed to lock conn array");
		return NULL;
    3300:	80 e0       	ldi	r24, 0x00	; 0
    3302:	90 e0       	ldi	r25, 0x00	; 0
    3304:	0a c0       	rjmp	.+20     	; 0x331a <csp_conn_allocate+0x13a>

	for (j = 0; j < CSP_CONN_MAX; j++) {
		conn = &arr_conn[i];
		if (conn->state == CONN_CLOSED)
			break;
		i = (i + 1) % CSP_CONN_MAX;
    3306:	01 96       	adiw	r24, 0x01	; 1
    3308:	6a e0       	ldi	r22, 0x0A	; 10
    330a:	70 e0       	ldi	r23, 0x00	; 0
    330c:	0e 94 86 2b 	call	0x570c	; 0x570c <__divmodhi4>
    3310:	29 e0       	ldi	r18, 0x09	; 9
    3312:	30 e0       	ldi	r19, 0x00	; 0
    3314:	ea e0       	ldi	r30, 0x0A	; 10
    3316:	f0 e0       	ldi	r31, 0x00	; 0
    3318:	aa cf       	rjmp	.-172    	; 0x326e <csp_conn_allocate+0x8e>
	csp_conn_last_given = i;
	csp_bin_sem_post(&conn_lock);

	return conn;

}
    331a:	df 91       	pop	r29
    331c:	cf 91       	pop	r28
    331e:	1f 91       	pop	r17
    3320:	08 95       	ret

00003322 <csp_conn_new>:

csp_conn_t * csp_conn_new(csp_id_t idin, csp_id_t idout) {
    3322:	8f 92       	push	r8
    3324:	9f 92       	push	r9
    3326:	af 92       	push	r10
    3328:	bf 92       	push	r11
    332a:	cf 92       	push	r12
    332c:	df 92       	push	r13
    332e:	ef 92       	push	r14
    3330:	ff 92       	push	r15
    3332:	cf 93       	push	r28
    3334:	df 93       	push	r29
    3336:	4b 01       	movw	r8, r22
    3338:	5c 01       	movw	r10, r24
    333a:	69 01       	movw	r12, r18
    333c:	7a 01       	movw	r14, r20

	/* Allocate connection structure */
	csp_conn_t * conn = csp_conn_allocate(CONN_CLIENT);
    333e:	80 e0       	ldi	r24, 0x00	; 0
    3340:	4f df       	rcall	.-354    	; 0x31e0 <csp_conn_allocate>
    3342:	ec 01       	movw	r28, r24

	if (conn) {
    3344:	89 2b       	or	r24, r25
    3346:	79 f0       	breq	.+30     	; 0x3366 <csp_conn_new+0x44>
		/* No lock is needed here, because nobody else *
		 * has a reference to this connection yet.     */
		conn->idin.ext = idin.ext;
    3348:	8c 82       	std	Y+4, r8	; 0x04
    334a:	9d 82       	std	Y+5, r9	; 0x05
    334c:	ae 82       	std	Y+6, r10	; 0x06
    334e:	bf 82       	std	Y+7, r11	; 0x07
		conn->idout.ext = idout.ext;
    3350:	c8 86       	std	Y+8, r12	; 0x08
    3352:	d9 86       	std	Y+9, r13	; 0x09
    3354:	ea 86       	std	Y+10, r14	; 0x0a
		conn->timestamp = csp_get_ms();
    3356:	fb 86       	std	Y+11, r15	; 0x0b
    3358:	27 db       	rcall	.-2482   	; 0x29a8 <csp_get_ms>
    335a:	68 8b       	std	Y+16, r22	; 0x10
    335c:	79 8b       	std	Y+17, r23	; 0x11
    335e:	8a 8b       	std	Y+18, r24	; 0x12

		/* Ensure connection queue is empty */
		csp_conn_flush_rx_queue(conn);
    3360:	9b 8b       	std	Y+19, r25	; 0x13
    3362:	ce 01       	movw	r24, r28
    3364:	19 df       	rcall	.-462    	; 0x3198 <csp_conn_flush_rx_queue>
	}

	return conn;

}
    3366:	ce 01       	movw	r24, r28
    3368:	df 91       	pop	r29
    336a:	cf 91       	pop	r28
    336c:	ff 90       	pop	r15
    336e:	ef 90       	pop	r14
    3370:	df 90       	pop	r13
    3372:	cf 90       	pop	r12
    3374:	bf 90       	pop	r11
    3376:	af 90       	pop	r10
    3378:	9f 90       	pop	r9
    337a:	8f 90       	pop	r8
    337c:	08 95       	ret

0000337e <csp_close>:

int csp_close(csp_conn_t * conn) {
    337e:	cf 93       	push	r28
    3380:	df 93       	push	r29
    3382:	ec 01       	movw	r28, r24

	if (conn == NULL) {
    3384:	89 2b       	or	r24, r25
    3386:	09 f5       	brne	.+66     	; 0x33ca <csp_close+0x4c>
		csp_log_error("NULL Pointer given to csp_close");
    3388:	80 91 04 02 	lds	r24, 0x0204	; 0x800204 <csp_debug_level_enabled>
    338c:	88 23       	and	r24, r24
    338e:	09 f4       	brne	.+2      	; 0x3392 <csp_close+0x14>
    3390:	73 c0       	rjmp	.+230    	; 0x3478 <csp_close+0xfa>
    3392:	a1 d2       	rcall	.+1346   	; 0x38d6 <csp_get_address>
    3394:	91 e0       	ldi	r25, 0x01	; 1
    3396:	9f 93       	push	r25
    3398:	93 e0       	ldi	r25, 0x03	; 3
    339a:	9f 93       	push	r25
    339c:	25 ee       	ldi	r18, 0xE5	; 229
    339e:	32 e0       	ldi	r19, 0x02	; 2
    33a0:	3f 93       	push	r19
    33a2:	2f 93       	push	r18
    33a4:	1f 92       	push	r1
    33a6:	8f 93       	push	r24
    33a8:	81 e1       	ldi	r24, 0x11	; 17
    33aa:	96 e0       	ldi	r25, 0x06	; 6
    33ac:	9f 93       	push	r25
    33ae:	8f 93       	push	r24
    33b0:	1f 92       	push	r1
    33b2:	a9 d1       	rcall	.+850    	; 0x3706 <do_csp_debug>
    33b4:	8d b7       	in	r24, 0x3d	; 61
    33b6:	9e b7       	in	r25, 0x3e	; 62
    33b8:	09 96       	adiw	r24, 0x09	; 9
    33ba:	0f b6       	in	r0, 0x3f	; 63
    33bc:	f8 94       	cli
    33be:	9e bf       	out	0x3e, r25	; 62
    33c0:	0f be       	out	0x3f, r0	; 63
    33c2:	8d bf       	out	0x3d, r24	; 61
		return CSP_ERR_INVAL;
    33c4:	8e ef       	ldi	r24, 0xFE	; 254
    33c6:	9f ef       	ldi	r25, 0xFF	; 255
    33c8:	5f c0       	rjmp	.+190    	; 0x3488 <csp_close+0x10a>
	}

	if (conn->state == CONN_CLOSED) {
    33ca:	89 81       	ldd	r24, Y+1	; 0x01
    33cc:	81 11       	cpse	r24, r1
    33ce:	22 c0       	rjmp	.+68     	; 0x3414 <csp_close+0x96>
		csp_log_protocol("Conn already closed");
    33d0:	80 91 09 02 	lds	r24, 0x0209	; 0x800209 <csp_debug_level_enabled+0x5>
    33d4:	88 23       	and	r24, r24
    33d6:	09 f4       	brne	.+2      	; 0x33da <csp_close+0x5c>
    33d8:	52 c0       	rjmp	.+164    	; 0x347e <csp_close+0x100>
    33da:	7d d2       	rcall	.+1274   	; 0x38d6 <csp_get_address>
    33dc:	91 e0       	ldi	r25, 0x01	; 1
    33de:	9f 93       	push	r25
    33e0:	98 e0       	ldi	r25, 0x08	; 8
    33e2:	9f 93       	push	r25
    33e4:	25 ee       	ldi	r18, 0xE5	; 229
    33e6:	32 e0       	ldi	r19, 0x02	; 2
    33e8:	3f 93       	push	r19
    33ea:	2f 93       	push	r18
    33ec:	1f 92       	push	r1
    33ee:	8f 93       	push	r24
    33f0:	80 ef       	ldi	r24, 0xF0	; 240
    33f2:	95 e0       	ldi	r25, 0x05	; 5
    33f4:	9f 93       	push	r25
    33f6:	8f 93       	push	r24
    33f8:	85 e0       	ldi	r24, 0x05	; 5
    33fa:	8f 93       	push	r24
    33fc:	84 d1       	rcall	.+776    	; 0x3706 <do_csp_debug>
    33fe:	8d b7       	in	r24, 0x3d	; 61
    3400:	9e b7       	in	r25, 0x3e	; 62
    3402:	09 96       	adiw	r24, 0x09	; 9
    3404:	0f b6       	in	r0, 0x3f	; 63
    3406:	f8 94       	cli
    3408:	9e bf       	out	0x3e, r25	; 62
    340a:	0f be       	out	0x3f, r0	; 63
    340c:	8d bf       	out	0x3d, r24	; 61
		return CSP_ERR_NONE;
    340e:	80 e0       	ldi	r24, 0x00	; 0
    3410:	90 e0       	ldi	r25, 0x00	; 0
    3412:	3a c0       	rjmp	.+116    	; 0x3488 <csp_close+0x10a>
		if (csp_rdp_close(conn) == CSP_ERR_AGAIN)
			return CSP_ERR_NONE;
#endif

	/* Lock connection array while closing connection */
	if (csp_bin_sem_wait(&conn_lock, 100) != CSP_SEMAPHORE_OK) {
    3414:	44 e6       	ldi	r20, 0x64	; 100
    3416:	50 e0       	ldi	r21, 0x00	; 0
    3418:	60 e0       	ldi	r22, 0x00	; 0
    341a:	70 e0       	ldi	r23, 0x00	; 0
    341c:	8b e0       	ldi	r24, 0x0B	; 11
    341e:	9e e1       	ldi	r25, 0x1E	; 30
    3420:	e1 d9       	rcall	.-3134   	; 0x27e4 <csp_bin_sem_wait>
    3422:	01 97       	sbiw	r24, 0x01	; 1
    3424:	01 f1       	breq	.+64     	; 0x3466 <csp_close+0xe8>
		csp_log_error("Failed to lock conn array");
    3426:	80 91 04 02 	lds	r24, 0x0204	; 0x800204 <csp_debug_level_enabled>
    342a:	88 23       	and	r24, r24
    342c:	59 f1       	breq	.+86     	; 0x3484 <csp_close+0x106>
    342e:	53 d2       	rcall	.+1190   	; 0x38d6 <csp_get_address>
    3430:	91 e0       	ldi	r25, 0x01	; 1
    3432:	9f 93       	push	r25
    3434:	95 e1       	ldi	r25, 0x15	; 21
    3436:	9f 93       	push	r25
    3438:	25 ee       	ldi	r18, 0xE5	; 229
    343a:	32 e0       	ldi	r19, 0x02	; 2
    343c:	3f 93       	push	r19
    343e:	2f 93       	push	r18
    3440:	1f 92       	push	r1
    3442:	8f 93       	push	r24
    3444:	89 ec       	ldi	r24, 0xC9	; 201
    3446:	95 e0       	ldi	r25, 0x05	; 5
    3448:	9f 93       	push	r25
    344a:	8f 93       	push	r24
    344c:	1f 92       	push	r1
    344e:	5b d1       	rcall	.+694    	; 0x3706 <do_csp_debug>
    3450:	8d b7       	in	r24, 0x3d	; 61
    3452:	9e b7       	in	r25, 0x3e	; 62
    3454:	09 96       	adiw	r24, 0x09	; 9
    3456:	0f b6       	in	r0, 0x3f	; 63
    3458:	f8 94       	cli
    345a:	9e bf       	out	0x3e, r25	; 62
    345c:	0f be       	out	0x3f, r0	; 63
    345e:	8d bf       	out	0x3d, r24	; 61
		return CSP_ERR_TIMEDOUT;
    3460:	8d ef       	ldi	r24, 0xFD	; 253
    3462:	9f ef       	ldi	r25, 0xFF	; 255
	}

	/* Set to closed */
	conn->state = CONN_CLOSED;
    3464:	11 c0       	rjmp	.+34     	; 0x3488 <csp_close+0x10a>

	/* Ensure connection queue is empty */
	csp_conn_flush_rx_queue(conn);
    3466:	19 82       	std	Y+1, r1	; 0x01
    3468:	ce 01       	movw	r24, r28
    346a:	96 de       	rcall	.-724    	; 0x3198 <csp_conn_flush_rx_queue>
	if (conn->idin.flags & CSP_FRDP)
		csp_rdp_flush_all(conn);
#endif

	/* Unlock connection array */
	csp_bin_sem_post(&conn_lock);
    346c:	8b e0       	ldi	r24, 0x0B	; 11
    346e:	9e e1       	ldi	r25, 0x1E	; 30
    3470:	fa d9       	rcall	.-3084   	; 0x2866 <csp_bin_sem_post>
    3472:	80 e0       	ldi	r24, 0x00	; 0

	return CSP_ERR_NONE;
    3474:	90 e0       	ldi	r25, 0x00	; 0
    3476:	08 c0       	rjmp	.+16     	; 0x3488 <csp_close+0x10a>
    3478:	8e ef       	ldi	r24, 0xFE	; 254

int csp_close(csp_conn_t * conn) {

	if (conn == NULL) {
		csp_log_error("NULL Pointer given to csp_close");
		return CSP_ERR_INVAL;
    347a:	9f ef       	ldi	r25, 0xFF	; 255
    347c:	05 c0       	rjmp	.+10     	; 0x3488 <csp_close+0x10a>
    347e:	80 e0       	ldi	r24, 0x00	; 0
	}

	if (conn->state == CONN_CLOSED) {
		csp_log_protocol("Conn already closed");
		return CSP_ERR_NONE;
    3480:	90 e0       	ldi	r25, 0x00	; 0
    3482:	02 c0       	rjmp	.+4      	; 0x3488 <csp_close+0x10a>
    3484:	8d ef       	ldi	r24, 0xFD	; 253
#endif

	/* Lock connection array while closing connection */
	if (csp_bin_sem_wait(&conn_lock, 100) != CSP_SEMAPHORE_OK) {
		csp_log_error("Failed to lock conn array");
		return CSP_ERR_TIMEDOUT;
    3486:	9f ef       	ldi	r25, 0xFF	; 255
    3488:	df 91       	pop	r29

	/* Unlock connection array */
	csp_bin_sem_post(&conn_lock);

	return CSP_ERR_NONE;
}
    348a:	cf 91       	pop	r28
    348c:	08 95       	ret

0000348e <csp_connect>:
    348e:	7f 92       	push	r7

csp_conn_t * csp_connect(uint8_t prio, uint8_t dest, uint8_t dport, uint32_t timeout, uint32_t opts) {
    3490:	8f 92       	push	r8
    3492:	9f 92       	push	r9
    3494:	af 92       	push	r10
    3496:	bf 92       	push	r11
    3498:	cf 92       	push	r12
    349a:	df 92       	push	r13
    349c:	ef 92       	push	r14
    349e:	ff 92       	push	r15
    34a0:	0f 93       	push	r16
    34a2:	1f 93       	push	r17
    34a4:	cf 93       	push	r28
    34a6:	df 93       	push	r29
    34a8:	16 2f       	mov	r17, r22
    34aa:	b4 2e       	mov	r11, r20
	/* Force options on all connections */
	opts |= CSP_CONNECTION_SO;

	/* Generate identifier */
	csp_id_t incoming_id, outgoing_id;
	incoming_id.pri = prio;
    34ac:	c8 2f       	mov	r28, r24
    34ae:	c2 95       	swap	r28
    34b0:	cc 0f       	add	r28, r28
    34b2:	cc 0f       	add	r28, r28
    34b4:	c0 7c       	andi	r28, 0xC0	; 192
    34b6:	0c 2f       	mov	r16, r28
	incoming_id.dst = csp_get_address();
    34b8:	0e d2       	rcall	.+1052   	; 0x38d6 <csp_get_address>
    34ba:	a8 2e       	mov	r10, r24
    34bc:	aa 0c       	add	r10, r10
    34be:	aa 0c       	add	r10, r10
    34c0:	aa 0c       	add	r10, r10
    34c2:	aa 0c       	add	r10, r10
    34c4:	82 95       	swap	r24
    34c6:	81 70       	andi	r24, 0x01	; 1
    34c8:	08 2b       	or	r16, r24
	incoming_id.src = dest;
    34ca:	81 2f       	mov	r24, r17
    34cc:	8f 71       	andi	r24, 0x1F	; 31
    34ce:	98 2f       	mov	r25, r24
    34d0:	99 0f       	add	r25, r25
    34d2:	09 2b       	or	r16, r25
	incoming_id.sport = dport;
    34d4:	db 2d       	mov	r29, r11
    34d6:	df 73       	andi	r29, 0x3F	; 63
    34d8:	9d 2e       	mov	r9, r29
	incoming_id.flags = 0;
    34da:	81 2c       	mov	r8, r1
	outgoing_id.pri = prio;
	outgoing_id.dst = dest;
    34dc:	12 95       	swap	r17
    34de:	10 7f       	andi	r17, 0xF0	; 240
    34e0:	82 95       	swap	r24
    34e2:	8f 70       	andi	r24, 0x0F	; 15
	outgoing_id.src = csp_get_address();
    34e4:	c8 2b       	or	r28, r24
    34e6:	f7 d1       	rcall	.+1006   	; 0x38d6 <csp_get_address>
    34e8:	8f 71       	andi	r24, 0x1F	; 31
    34ea:	88 0f       	add	r24, r24
    34ec:	c8 2b       	or	r28, r24
	outgoing_id.dport = dport;
    34ee:	bb 0c       	add	r11, r11
    34f0:	bb 0c       	add	r11, r11
    34f2:	bb 0c       	add	r11, r11
    34f4:	bb 0c       	add	r11, r11
    34f6:	bb 0c       	add	r11, r11
    34f8:	bb 0c       	add	r11, r11
    34fa:	8d 2f       	mov	r24, r29
    34fc:	86 95       	lsr	r24
    34fe:	86 95       	lsr	r24
    3500:	18 2b       	or	r17, r24
	outgoing_id.flags = 0;

	/* Set connection options */
	if (opts & CSP_O_RDP) {
    3502:	c0 fe       	sbrs	r12, 0
    3504:	21 c0       	rjmp	.+66     	; 0x3548 <csp_connect+0xba>
#ifdef CSP_USE_RDP
		incoming_id.flags |= CSP_FRDP;
		outgoing_id.flags |= CSP_FRDP;
#else
		csp_log_error("Attempt to create RDP connection, but CSP was compiled without RDP support");
    3506:	80 91 04 02 	lds	r24, 0x0204	; 0x800204 <csp_debug_level_enabled>
    350a:	88 23       	and	r24, r24
    350c:	09 f4       	brne	.+2      	; 0x3510 <csp_connect+0x82>
    350e:	da c0       	rjmp	.+436    	; 0x36c4 <csp_connect+0x236>
    3510:	e2 d1       	rcall	.+964    	; 0x38d6 <csp_get_address>
    3512:	91 e0       	ldi	r25, 0x01	; 1
    3514:	9f 93       	push	r25
    3516:	93 e4       	ldi	r25, 0x43	; 67
    3518:	9f 93       	push	r25
    351a:	25 ee       	ldi	r18, 0xE5	; 229
    351c:	32 e0       	ldi	r19, 0x02	; 2
    351e:	3f 93       	push	r19
    3520:	2f 93       	push	r18
    3522:	1f 92       	push	r1
    3524:	8f 93       	push	r24
    3526:	81 e7       	ldi	r24, 0x71	; 113
    3528:	95 e0       	ldi	r25, 0x05	; 5
    352a:	9f 93       	push	r25
    352c:	8f 93       	push	r24
    352e:	1f 92       	push	r1
    3530:	ea d0       	rcall	.+468    	; 0x3706 <do_csp_debug>
    3532:	8d b7       	in	r24, 0x3d	; 61
    3534:	9e b7       	in	r25, 0x3e	; 62
    3536:	09 96       	adiw	r24, 0x09	; 9
    3538:	0f b6       	in	r0, 0x3f	; 63
    353a:	f8 94       	cli
    353c:	9e bf       	out	0x3e, r25	; 62
    353e:	0f be       	out	0x3f, r0	; 63
    3540:	8d bf       	out	0x3d, r24	; 61
		return NULL;
    3542:	80 e0       	ldi	r24, 0x00	; 0
    3544:	90 e0       	ldi	r25, 0x00	; 0
    3546:	d1 c0       	rjmp	.+418    	; 0x36ea <csp_connect+0x25c>
#endif
	}

	if (opts & CSP_O_HMAC) {
    3548:	c2 fe       	sbrs	r12, 2
    354a:	21 c0       	rjmp	.+66     	; 0x358e <csp_connect+0x100>
#ifdef CSP_USE_HMAC
		outgoing_id.flags |= CSP_FHMAC;
		incoming_id.flags |= CSP_FHMAC;
#else
		csp_log_error("Attempt to create HMAC authenticated connection, but CSP was compiled without HMAC support");
    354c:	80 91 04 02 	lds	r24, 0x0204	; 0x800204 <csp_debug_level_enabled>
    3550:	88 23       	and	r24, r24
    3552:	09 f4       	brne	.+2      	; 0x3556 <csp_connect+0xc8>
    3554:	ba c0       	rjmp	.+372    	; 0x36ca <csp_connect+0x23c>
    3556:	bf d1       	rcall	.+894    	; 0x38d6 <csp_get_address>
    3558:	91 e0       	ldi	r25, 0x01	; 1
    355a:	9f 93       	push	r25
    355c:	9d e4       	ldi	r25, 0x4D	; 77
    355e:	9f 93       	push	r25
    3560:	25 ee       	ldi	r18, 0xE5	; 229
    3562:	32 e0       	ldi	r19, 0x02	; 2
    3564:	3f 93       	push	r19
    3566:	2f 93       	push	r18
    3568:	1f 92       	push	r1
    356a:	8f 93       	push	r24
    356c:	89 e0       	ldi	r24, 0x09	; 9
    356e:	95 e0       	ldi	r25, 0x05	; 5
    3570:	9f 93       	push	r25
    3572:	8f 93       	push	r24
    3574:	1f 92       	push	r1
    3576:	c7 d0       	rcall	.+398    	; 0x3706 <do_csp_debug>
    3578:	8d b7       	in	r24, 0x3d	; 61
    357a:	9e b7       	in	r25, 0x3e	; 62
    357c:	09 96       	adiw	r24, 0x09	; 9
    357e:	0f b6       	in	r0, 0x3f	; 63
    3580:	f8 94       	cli
    3582:	9e bf       	out	0x3e, r25	; 62
    3584:	0f be       	out	0x3f, r0	; 63
    3586:	8d bf       	out	0x3d, r24	; 61
		return NULL;
    3588:	80 e0       	ldi	r24, 0x00	; 0
    358a:	90 e0       	ldi	r25, 0x00	; 0
    358c:	ae c0       	rjmp	.+348    	; 0x36ea <csp_connect+0x25c>
#endif
	}

	if (opts & CSP_O_XTEA) {
    358e:	c4 fe       	sbrs	r12, 4
#ifdef CSP_USE_XTEA
		outgoing_id.flags |= CSP_FXTEA;
		incoming_id.flags |= CSP_FXTEA;
#else
		csp_log_error("Attempt to create XTEA encrypted connection, but CSP was compiled without XTEA support");
    3590:	21 c0       	rjmp	.+66     	; 0x35d4 <csp_connect+0x146>
    3592:	80 91 04 02 	lds	r24, 0x0204	; 0x800204 <csp_debug_level_enabled>
    3596:	88 23       	and	r24, r24
    3598:	09 f4       	brne	.+2      	; 0x359c <csp_connect+0x10e>
    359a:	9a c0       	rjmp	.+308    	; 0x36d0 <csp_connect+0x242>
    359c:	9c d1       	rcall	.+824    	; 0x38d6 <csp_get_address>
    359e:	91 e0       	ldi	r25, 0x01	; 1
    35a0:	9f 93       	push	r25
    35a2:	97 e5       	ldi	r25, 0x57	; 87
    35a4:	9f 93       	push	r25
    35a6:	25 ee       	ldi	r18, 0xE5	; 229
    35a8:	32 e0       	ldi	r19, 0x02	; 2
    35aa:	3f 93       	push	r19
    35ac:	2f 93       	push	r18
    35ae:	1f 92       	push	r1
    35b0:	8f 93       	push	r24
    35b2:	85 ea       	ldi	r24, 0xA5	; 165
    35b4:	94 e0       	ldi	r25, 0x04	; 4
    35b6:	9f 93       	push	r25
    35b8:	8f 93       	push	r24
    35ba:	1f 92       	push	r1
    35bc:	a4 d0       	rcall	.+328    	; 0x3706 <do_csp_debug>
    35be:	8d b7       	in	r24, 0x3d	; 61
    35c0:	9e b7       	in	r25, 0x3e	; 62
    35c2:	09 96       	adiw	r24, 0x09	; 9
    35c4:	0f b6       	in	r0, 0x3f	; 63
    35c6:	f8 94       	cli
    35c8:	9e bf       	out	0x3e, r25	; 62
    35ca:	0f be       	out	0x3f, r0	; 63
    35cc:	8d bf       	out	0x3d, r24	; 61
		return NULL;
    35ce:	80 e0       	ldi	r24, 0x00	; 0
    35d0:	90 e0       	ldi	r25, 0x00	; 0
#endif
	}

	if (opts & CSP_O_CRC32) {
    35d2:	8b c0       	rjmp	.+278    	; 0x36ea <csp_connect+0x25c>
    35d4:	c6 fe       	sbrs	r12, 6
#ifdef CSP_USE_CRC32
		outgoing_id.flags |= CSP_FCRC32;
		incoming_id.flags |= CSP_FCRC32;
#else
		csp_log_error("Attempt to create CRC32 validated connection, but CSP was compiled without CRC32 support");
    35d6:	21 c0       	rjmp	.+66     	; 0x361a <csp_connect+0x18c>
    35d8:	80 91 04 02 	lds	r24, 0x0204	; 0x800204 <csp_debug_level_enabled>
    35dc:	88 23       	and	r24, r24
    35de:	09 f4       	brne	.+2      	; 0x35e2 <csp_connect+0x154>
    35e0:	7a c0       	rjmp	.+244    	; 0x36d6 <csp_connect+0x248>
    35e2:	79 d1       	rcall	.+754    	; 0x38d6 <csp_get_address>
    35e4:	91 e0       	ldi	r25, 0x01	; 1
    35e6:	9f 93       	push	r25
    35e8:	91 e6       	ldi	r25, 0x61	; 97
    35ea:	9f 93       	push	r25
    35ec:	25 ee       	ldi	r18, 0xE5	; 229
    35ee:	32 e0       	ldi	r19, 0x02	; 2
    35f0:	3f 93       	push	r19
    35f2:	2f 93       	push	r18
    35f4:	1f 92       	push	r1
    35f6:	8f 93       	push	r24
    35f8:	8f e3       	ldi	r24, 0x3F	; 63
    35fa:	94 e0       	ldi	r25, 0x04	; 4
    35fc:	9f 93       	push	r25
    35fe:	8f 93       	push	r24
    3600:	1f 92       	push	r1
    3602:	81 d0       	rcall	.+258    	; 0x3706 <do_csp_debug>
    3604:	8d b7       	in	r24, 0x3d	; 61
    3606:	9e b7       	in	r25, 0x3e	; 62
    3608:	09 96       	adiw	r24, 0x09	; 9
    360a:	0f b6       	in	r0, 0x3f	; 63
    360c:	f8 94       	cli
    360e:	9e bf       	out	0x3e, r25	; 62
    3610:	0f be       	out	0x3f, r0	; 63
    3612:	8d bf       	out	0x3d, r24	; 61
		return NULL;
    3614:	80 e0       	ldi	r24, 0x00	; 0
    3616:	90 e0       	ldi	r25, 0x00	; 0
    3618:	68 c0       	rjmp	.+208    	; 0x36ea <csp_connect+0x25c>
	
	/* Find an unused ephemeral port */
	csp_conn_t * conn;

	/* Wait for sport lock */
	if (csp_bin_sem_wait(&sport_lock, 1000) != CSP_SEMAPHORE_OK)
    361a:	48 ee       	ldi	r20, 0xE8	; 232
    361c:	53 e0       	ldi	r21, 0x03	; 3
    361e:	60 e0       	ldi	r22, 0x00	; 0
    3620:	70 e0       	ldi	r23, 0x00	; 0
    3622:	88 e0       	ldi	r24, 0x08	; 8
    3624:	9e e1       	ldi	r25, 0x1E	; 30
    3626:	de d8       	rcall	.-3652   	; 0x27e4 <csp_bin_sem_wait>
    3628:	01 97       	sbiw	r24, 0x01	; 1
    362a:	09 f0       	breq	.+2      	; 0x362e <csp_connect+0x1a0>
    362c:	57 c0       	rjmp	.+174    	; 0x36dc <csp_connect+0x24e>
    362e:	d0 91 0a 1e 	lds	r29, 0x1E0A	; 0x801e0a <sport>
		return NULL;

	uint8_t start = sport;
    3632:	68 94       	set
	while (++sport != start) {
		if (sport > CSP_ID_PORT_MAX)
			sport = CSP_MAX_BIND_PORT + 1;
    3634:	77 24       	eor	r7, r7
    3636:	75 f8       	bld	r7, 5
    3638:	25 c0       	rjmp	.+74     	; 0x3684 <csp_connect+0x1f6>
	/* Wait for sport lock */
	if (csp_bin_sem_wait(&sport_lock, 1000) != CSP_SEMAPHORE_OK)
		return NULL;

	uint8_t start = sport;
	while (++sport != start) {
    363a:	80 34       	cpi	r24, 0x40	; 64
		if (sport > CSP_ID_PORT_MAX)
    363c:	10 f0       	brcs	.+4      	; 0x3642 <csp_connect+0x1b4>
    363e:	70 92 0a 1e 	sts	0x1E0A, r7	; 0x801e0a <sport>
			sport = CSP_MAX_BIND_PORT + 1;
    3642:	90 91 0a 1e 	lds	r25, 0x1E0A	; 0x801e0a <sport>

		outgoing_id.sport = sport;
    3646:	89 2f       	mov	r24, r25
    3648:	8f 73       	andi	r24, 0x3F	; 63
    364a:	2b 2d       	mov	r18, r11
    364c:	20 7c       	andi	r18, 0xC0	; 192
    364e:	b2 2e       	mov	r11, r18
    3650:	b8 2a       	or	r11, r24
    3652:	92 95       	swap	r25
		incoming_id.dport = sport;
    3654:	99 0f       	add	r25, r25
    3656:	99 0f       	add	r25, r25
    3658:	90 7c       	andi	r25, 0xC0	; 192
    365a:	29 2d       	mov	r18, r9
    365c:	2f 73       	andi	r18, 0x3F	; 63
    365e:	92 2e       	mov	r9, r18
    3660:	99 2a       	or	r9, r25
    3662:	86 95       	lsr	r24
    3664:	86 95       	lsr	r24
    3666:	9a 2d       	mov	r25, r10
    3668:	90 7f       	andi	r25, 0xF0	; 240
    366a:	a9 2e       	mov	r10, r25
    366c:	a8 2a       	or	r10, r24
		
		/* Match on destination port of _incoming_ identifier */
		conn = csp_conn_find(incoming_id.ext, CSP_ID_DPORT_MASK);
    366e:	20 e0       	ldi	r18, 0x00	; 0
    3670:	30 ec       	ldi	r19, 0xC0	; 192
    3672:	4f e0       	ldi	r20, 0x0F	; 15
    3674:	50 e0       	ldi	r21, 0x00	; 0
    3676:	68 2d       	mov	r22, r8
    3678:	79 2d       	mov	r23, r9
    367a:	8a 2d       	mov	r24, r10
    367c:	90 2f       	mov	r25, r16
    367e:	48 dd       	rcall	.-1392   	; 0x3110 <csp_conn_find>

		/* Break if we found an unused ephemeral port */
		if (conn == NULL)
    3680:	89 2b       	or	r24, r25
    3682:	39 f0       	breq	.+14     	; 0x3692 <csp_connect+0x204>
	/* Wait for sport lock */
	if (csp_bin_sem_wait(&sport_lock, 1000) != CSP_SEMAPHORE_OK)
		return NULL;

	uint8_t start = sport;
	while (++sport != start) {
    3684:	80 91 0a 1e 	lds	r24, 0x1E0A	; 0x801e0a <sport>
    3688:	8f 5f       	subi	r24, 0xFF	; 255
    368a:	80 93 0a 1e 	sts	0x1E0A, r24	; 0x801e0a <sport>
    368e:	d8 13       	cpse	r29, r24
    3690:	d4 cf       	rjmp	.-88     	; 0x363a <csp_connect+0x1ac>
		if (conn == NULL)
			break;
	}

	/* Post sport lock */
	csp_bin_sem_post(&sport_lock);
    3692:	88 e0       	ldi	r24, 0x08	; 8
    3694:	9e e1       	ldi	r25, 0x1E	; 30
    3696:	e7 d8       	rcall	.-3634   	; 0x2866 <csp_bin_sem_post>
    3698:	80 91 0a 1e 	lds	r24, 0x1E0A	; 0x801e0a <sport>

	/* If no available ephemeral port was found */
	if (sport == start)
    369c:	d8 17       	cp	r29, r24
    369e:	09 f1       	breq	.+66     	; 0x36e2 <csp_connect+0x254>
		return NULL;

	/* Get storage for new connection */
	conn = csp_conn_new(incoming_id, outgoing_id);
    36a0:	20 e0       	ldi	r18, 0x00	; 0
    36a2:	3b 2d       	mov	r19, r11
    36a4:	41 2f       	mov	r20, r17
    36a6:	5c 2f       	mov	r21, r28
    36a8:	60 e0       	ldi	r22, 0x00	; 0
    36aa:	79 2d       	mov	r23, r9
    36ac:	8a 2d       	mov	r24, r10
    36ae:	90 2f       	mov	r25, r16
    36b0:	38 de       	rcall	.-912    	; 0x3322 <csp_conn_new>
    36b2:	fc 01       	movw	r30, r24
    36b4:	00 97       	sbiw	r24, 0x00	; 0
	if (conn == NULL)
    36b6:	c1 f0       	breq	.+48     	; 0x36e8 <csp_connect+0x25a>
    36b8:	c4 8a       	std	Z+20, r12	; 0x14
		return NULL;

	/* Set connection options */
	conn->opts = opts;
    36ba:	d5 8a       	std	Z+21, r13	; 0x15
    36bc:	e6 8a       	std	Z+22, r14	; 0x16
    36be:	f7 8a       	std	Z+23, r15	; 0x17
    36c0:	9f 2f       	mov	r25, r31
		}
	}
#endif

	/* We have a successful connection */
	return conn;
    36c2:	13 c0       	rjmp	.+38     	; 0x36ea <csp_connect+0x25c>
    36c4:	80 e0       	ldi	r24, 0x00	; 0
#ifdef CSP_USE_RDP
		incoming_id.flags |= CSP_FRDP;
		outgoing_id.flags |= CSP_FRDP;
#else
		csp_log_error("Attempt to create RDP connection, but CSP was compiled without RDP support");
		return NULL;
    36c6:	90 e0       	ldi	r25, 0x00	; 0
    36c8:	10 c0       	rjmp	.+32     	; 0x36ea <csp_connect+0x25c>
    36ca:	80 e0       	ldi	r24, 0x00	; 0
#ifdef CSP_USE_HMAC
		outgoing_id.flags |= CSP_FHMAC;
		incoming_id.flags |= CSP_FHMAC;
#else
		csp_log_error("Attempt to create HMAC authenticated connection, but CSP was compiled without HMAC support");
		return NULL;
    36cc:	90 e0       	ldi	r25, 0x00	; 0
    36ce:	0d c0       	rjmp	.+26     	; 0x36ea <csp_connect+0x25c>
    36d0:	80 e0       	ldi	r24, 0x00	; 0
#ifdef CSP_USE_XTEA
		outgoing_id.flags |= CSP_FXTEA;
		incoming_id.flags |= CSP_FXTEA;
#else
		csp_log_error("Attempt to create XTEA encrypted connection, but CSP was compiled without XTEA support");
		return NULL;
    36d2:	90 e0       	ldi	r25, 0x00	; 0
    36d4:	0a c0       	rjmp	.+20     	; 0x36ea <csp_connect+0x25c>
    36d6:	80 e0       	ldi	r24, 0x00	; 0
#ifdef CSP_USE_CRC32
		outgoing_id.flags |= CSP_FCRC32;
		incoming_id.flags |= CSP_FCRC32;
#else
		csp_log_error("Attempt to create CRC32 validated connection, but CSP was compiled without CRC32 support");
		return NULL;
    36d8:	90 e0       	ldi	r25, 0x00	; 0
    36da:	07 c0       	rjmp	.+14     	; 0x36ea <csp_connect+0x25c>
    36dc:	80 e0       	ldi	r24, 0x00	; 0
	/* Find an unused ephemeral port */
	csp_conn_t * conn;

	/* Wait for sport lock */
	if (csp_bin_sem_wait(&sport_lock, 1000) != CSP_SEMAPHORE_OK)
		return NULL;
    36de:	90 e0       	ldi	r25, 0x00	; 0
    36e0:	04 c0       	rjmp	.+8      	; 0x36ea <csp_connect+0x25c>
    36e2:	80 e0       	ldi	r24, 0x00	; 0
	/* Post sport lock */
	csp_bin_sem_post(&sport_lock);

	/* If no available ephemeral port was found */
	if (sport == start)
		return NULL;
    36e4:	90 e0       	ldi	r25, 0x00	; 0
    36e6:	01 c0       	rjmp	.+2      	; 0x36ea <csp_connect+0x25c>
    36e8:	9f 2f       	mov	r25, r31

	/* Get storage for new connection */
	conn = csp_conn_new(incoming_id, outgoing_id);
	if (conn == NULL)
		return NULL;
    36ea:	df 91       	pop	r29
#endif

	/* We have a successful connection */
	return conn;

}
    36ec:	cf 91       	pop	r28
    36ee:	1f 91       	pop	r17
    36f0:	0f 91       	pop	r16
    36f2:	ff 90       	pop	r15
    36f4:	ef 90       	pop	r14
    36f6:	df 90       	pop	r13
    36f8:	cf 90       	pop	r12
    36fa:	bf 90       	pop	r11
    36fc:	af 90       	pop	r10
    36fe:	9f 90       	pop	r9
    3700:	8f 90       	pop	r8
    3702:	7f 90       	pop	r7
    3704:	08 95       	ret

00003706 <do_csp_debug>:
    3706:	0f 93       	push	r16
 * can be used instead to set a custom debug hook */
void csp_debug_hook_set(csp_debug_hook_func_t f) {
	csp_debug_hook_func = f;
}

void do_csp_debug(csp_debug_level_t level, const char * format, ...) {
    3708:	1f 93       	push	r17
    370a:	cf 93       	push	r28
    370c:	df 93       	push	r29
    370e:	cd b7       	in	r28, 0x3d	; 61
    3710:	de b7       	in	r29, 0x3e	; 62
    3712:	98 85       	ldd	r25, Y+8	; 0x08

	int color = COLOR_RESET;
	va_list args;

	/* Don't print anything if log level is disabled */
	if (level > CSP_LOCK || !csp_debug_level_enabled[level])
    3714:	97 30       	cpi	r25, 0x07	; 7
    3716:	08 f0       	brcs	.+2      	; 0x371a <do_csp_debug+0x14>
    3718:	46 c0       	rjmp	.+140    	; 0x37a6 <do_csp_debug+0xa0>
    371a:	e9 2f       	mov	r30, r25
    371c:	f0 e0       	ldi	r31, 0x00	; 0
    371e:	ec 5f       	subi	r30, 0xFC	; 252
    3720:	fd 4f       	sbci	r31, 0xFD	; 253
    3722:	80 81       	ld	r24, Z
    3724:	88 23       	and	r24, r24
    3726:	09 f4       	brne	.+2      	; 0x372a <do_csp_debug+0x24>
    3728:	3e c0       	rjmp	.+124    	; 0x37a6 <do_csp_debug+0xa0>
		return;

	switch(level) {
    372a:	49 2f       	mov	r20, r25
    372c:	50 e0       	ldi	r21, 0x00	; 0
    372e:	47 30       	cpi	r20, 0x07	; 7
    3730:	51 05       	cpc	r21, r1
    3732:	c8 f5       	brcc	.+114    	; 0x37a6 <do_csp_debug+0xa0>
    3734:	fa 01       	movw	r30, r20
    3736:	88 27       	eor	r24, r24
    3738:	e6 58       	subi	r30, 0x86	; 134
    373a:	ff 4f       	sbci	r31, 0xFF	; 255
    373c:	8f 4f       	sbci	r24, 0xFF	; 255
    373e:	0c 94 bb 2b 	jmp	0x5776	; 0x5776 <__tablejump2__>
	case CSP_INFO:
		color = COLOR_GREEN | COLOR_BOLD;
		break;
	case CSP_ERROR:
		color = COLOR_RED | COLOR_BOLD;
    3742:	82 e1       	ldi	r24, 0x12	; 18
    3744:	0b c0       	rjmp	.+22     	; 0x375c <do_csp_debug+0x56>
		break;
	case CSP_WARN:
		color = COLOR_YELLOW | COLOR_BOLD;
    3746:	84 e1       	ldi	r24, 0x14	; 20
		break;
    3748:	09 c0       	rjmp	.+18     	; 0x375c <do_csp_debug+0x56>
	case CSP_BUFFER:
		color = COLOR_MAGENTA;
    374a:	86 e0       	ldi	r24, 0x06	; 6
		break;
    374c:	07 c0       	rjmp	.+14     	; 0x375c <do_csp_debug+0x56>
	case CSP_PACKET:
		color = COLOR_GREEN;
    374e:	83 e0       	ldi	r24, 0x03	; 3
		break;
    3750:	05 c0       	rjmp	.+10     	; 0x375c <do_csp_debug+0x56>
	case CSP_PROTOCOL:
		color = COLOR_BLUE;
    3752:	85 e0       	ldi	r24, 0x05	; 5
		break;
    3754:	03 c0       	rjmp	.+6      	; 0x375c <do_csp_debug+0x56>
	case CSP_LOCK:
		color = COLOR_CYAN;
    3756:	87 e0       	ldi	r24, 0x07	; 7
		break;
    3758:	01 c0       	rjmp	.+2      	; 0x375c <do_csp_debug+0x56>
	if (level > CSP_LOCK || !csp_debug_level_enabled[level])
		return;

	switch(level) {
	case CSP_INFO:
		color = COLOR_GREEN | COLOR_BOLD;
    375a:	83 e1       	ldi	r24, 0x13	; 19
		break;
	default:
		return;
	}
	
	va_start(args, format);
    375c:	ae 01       	movw	r20, r28
    375e:	45 5f       	subi	r20, 0xF5	; 245
    3760:	5f 4f       	sbci	r21, 0xFF	; 255
    3762:	04 2f       	mov	r16, r20
    3764:	15 2f       	mov	r17, r21

	/* If csp_debug_hook symbol is defined, pass on the message.
	 * Otherwise, just print with pretty colors ... */
	if (csp_debug_hook_func) {
    3766:	e0 91 fd 1e 	lds	r30, 0x1EFD	; 0x801efd <csp_debug_hook_func>
    376a:	f0 91 fe 1e 	lds	r31, 0x1EFE	; 0x801efe <csp_debug_hook_func+0x1>
    376e:	30 97       	sbiw	r30, 0x00	; 0
    3770:	29 f0       	breq	.+10     	; 0x377c <do_csp_debug+0x76>
		csp_debug_hook_func(level, format, args);
    3772:	69 85       	ldd	r22, Y+9	; 0x09
    3774:	7a 85       	ldd	r23, Y+10	; 0x0a
    3776:	89 2f       	mov	r24, r25
    3778:	19 95       	eicall
    377a:	15 c0       	rjmp	.+42     	; 0x37a6 <do_csp_debug+0xa0>
	} else {
		csp_sys_set_color(color);
    377c:	ad d8       	rcall	.-3750   	; 0x28d8 <csp_sys_set_color>
#ifdef __AVR__
		vfprintf_P(stdout, format, args);
    377e:	40 2f       	mov	r20, r16
    3780:	51 2f       	mov	r21, r17
    3782:	69 85       	ldd	r22, Y+9	; 0x09
    3784:	7a 85       	ldd	r23, Y+10	; 0x0a
    3786:	80 91 40 20 	lds	r24, 0x2040	; 0x802040 <__iob+0x2>
    378a:	90 91 41 20 	lds	r25, 0x2041	; 0x802041 <__iob+0x3>
    378e:	0e 94 bf 2c 	call	0x597e	; 0x597e <vfprintf_P>
#else
		vprintf(format, args);
#endif
		printf("\r\n");
    3792:	84 e4       	ldi	r24, 0x44	; 68
    3794:	97 e0       	ldi	r25, 0x07	; 7
    3796:	9f 93       	push	r25
    3798:	8f 93       	push	r24
    379a:	0e 94 98 2c 	call	0x5930	; 0x5930 <printf_P>
		csp_sys_set_color(COLOR_RESET);
    379e:	80 ef       	ldi	r24, 0xF0	; 240
    37a0:	9b d8       	rcall	.-3786   	; 0x28d8 <csp_sys_set_color>
    37a2:	0f 90       	pop	r0
    37a4:	0f 90       	pop	r0
	}

	va_end(args);

}
    37a6:	df 91       	pop	r29
    37a8:	cf 91       	pop	r28
    37aa:	1f 91       	pop	r17
    37ac:	0f 91       	pop	r16
    37ae:	08 95       	ret

000037b0 <csp_hton32>:
inline uint16_t __attribute__ ((__const__)) csp_ntoh16(uint16_t n16) {
	return csp_hton16(n16);
}

/* Convert 32-bit number from host byte order to network byte order */
inline uint32_t __attribute__ ((__const__)) csp_hton32(uint32_t h32) {
    37b0:	cf 92       	push	r12
    37b2:	df 92       	push	r13
    37b4:	ef 92       	push	r14
    37b6:	ff 92       	push	r15
    37b8:	0f 93       	push	r16
    37ba:	1f 93       	push	r17
#ifdef CSP_BIG_ENDIAN
	return h32;
#else
	return (((h32 & 0xff000000) >> 24) |
    37bc:	c9 2e       	mov	r12, r25
    37be:	dd 24       	eor	r13, r13
    37c0:	ee 24       	eor	r14, r14
    37c2:	ff 24       	eor	r15, r15
    37c4:	36 2f       	mov	r19, r22
    37c6:	22 27       	eor	r18, r18
    37c8:	11 27       	eor	r17, r17
    37ca:	00 27       	eor	r16, r16
    37cc:	0c 29       	or	r16, r12
    37ce:	1d 29       	or	r17, r13
    37d0:	2e 29       	or	r18, r14
    37d2:	3f 29       	or	r19, r15
    37d4:	6b 01       	movw	r12, r22
    37d6:	7c 01       	movw	r14, r24
    37d8:	cc 24       	eor	r12, r12
    37da:	ee 24       	eor	r14, r14
    37dc:	ff 24       	eor	r15, r15
    37de:	fe 2c       	mov	r15, r14
    37e0:	ed 2c       	mov	r14, r13
    37e2:	dc 2c       	mov	r13, r12
    37e4:	cc 24       	eor	r12, r12
    37e6:	0c 29       	or	r16, r12
    37e8:	1d 29       	or	r17, r13
    37ea:	2e 29       	or	r18, r14
    37ec:	3f 29       	or	r19, r15
    37ee:	dc 01       	movw	r26, r24
    37f0:	cb 01       	movw	r24, r22
    37f2:	88 27       	eor	r24, r24
    37f4:	99 27       	eor	r25, r25
    37f6:	bb 27       	eor	r27, r27
    37f8:	89 2f       	mov	r24, r25
    37fa:	9a 2f       	mov	r25, r26
    37fc:	ab 2f       	mov	r26, r27
    37fe:	bb 27       	eor	r27, r27
    3800:	bc 01       	movw	r22, r24
    3802:	cd 01       	movw	r24, r26
    3804:	60 2b       	or	r22, r16
    3806:	71 2b       	or	r23, r17
    3808:	82 2b       	or	r24, r18
    380a:	93 2b       	or	r25, r19
			((h32 & 0x000000ff) << 24) |
			((h32 & 0x0000ff00) <<  8) |
			((h32 & 0x00ff0000) >>  8));
#endif
}
    380c:	1f 91       	pop	r17
    380e:	0f 91       	pop	r16
    3810:	ff 90       	pop	r15
    3812:	ef 90       	pop	r14
    3814:	df 90       	pop	r13
    3816:	cf 90       	pop	r12
    3818:	08 95       	ret

0000381a <csp_ntoh32>:

/* Convert 32-bit number from network byte order to host byte order */
inline uint32_t __attribute__ ((__const__)) csp_ntoh32(uint32_t n32) {
    381a:	cf 92       	push	r12
    381c:	df 92       	push	r13
    381e:	ef 92       	push	r14
    3820:	ff 92       	push	r15
    3822:	0f 93       	push	r16
    3824:	1f 93       	push	r17
	return csp_hton32(n32);
    3826:	c9 2e       	mov	r12, r25
    3828:	dd 24       	eor	r13, r13
    382a:	ee 24       	eor	r14, r14
    382c:	ff 24       	eor	r15, r15
    382e:	36 2f       	mov	r19, r22
    3830:	22 27       	eor	r18, r18
    3832:	11 27       	eor	r17, r17
    3834:	00 27       	eor	r16, r16
    3836:	0c 29       	or	r16, r12
    3838:	1d 29       	or	r17, r13
    383a:	2e 29       	or	r18, r14
    383c:	3f 29       	or	r19, r15
    383e:	6b 01       	movw	r12, r22
    3840:	7c 01       	movw	r14, r24
    3842:	cc 24       	eor	r12, r12
    3844:	ee 24       	eor	r14, r14
    3846:	ff 24       	eor	r15, r15
    3848:	fe 2c       	mov	r15, r14
    384a:	ed 2c       	mov	r14, r13
    384c:	dc 2c       	mov	r13, r12
    384e:	cc 24       	eor	r12, r12
    3850:	0c 29       	or	r16, r12
    3852:	1d 29       	or	r17, r13
    3854:	2e 29       	or	r18, r14
    3856:	3f 29       	or	r19, r15
    3858:	dc 01       	movw	r26, r24
    385a:	cb 01       	movw	r24, r22
    385c:	88 27       	eor	r24, r24
    385e:	99 27       	eor	r25, r25
    3860:	bb 27       	eor	r27, r27
    3862:	89 2f       	mov	r24, r25
    3864:	9a 2f       	mov	r25, r26
    3866:	ab 2f       	mov	r26, r27
    3868:	bb 27       	eor	r27, r27
    386a:	bc 01       	movw	r22, r24
    386c:	cd 01       	movw	r24, r26
    386e:	60 2b       	or	r22, r16
    3870:	71 2b       	or	r23, r17
    3872:	82 2b       	or	r24, r18
    3874:	93 2b       	or	r25, r19
}
    3876:	1f 91       	pop	r17
    3878:	0f 91       	pop	r16
    387a:	ff 90       	pop	r15
    387c:	ef 90       	pop	r14
    387e:	df 90       	pop	r13
    3880:	cf 90       	pop	r12
    3882:	08 95       	ret

00003884 <csp_iflist_add>:
}

void csp_iflist_add(csp_iface_t *ifc) {

	/* Add interface to pool */
	if (interfaces == NULL) {
    3884:	a0 91 ff 1e 	lds	r26, 0x1EFF	; 0x801eff <interfaces>
    3888:	b0 91 00 1f 	lds	r27, 0x1F00	; 0x801f00 <interfaces+0x1>
    388c:	10 97       	sbiw	r26, 0x00	; 0
    388e:	41 f4       	brne	.+16     	; 0x38a0 <csp_iflist_add+0x1c>
		/* This is the first interface to be added */
		interfaces = ifc;
    3890:	90 93 00 1f 	sts	0x1F00, r25	; 0x801f00 <interfaces+0x1>
    3894:	80 93 ff 1e 	sts	0x1EFF, r24	; 0x801eff <interfaces>
		ifc->next = NULL;
    3898:	fc 01       	movw	r30, r24
    389a:	12 aa       	std	Z+50, r1	; 0x32
    389c:	11 aa       	std	Z+49, r1	; 0x31
    389e:	08 95       	ret
	} else {
		/* One or more interfaces were already added */
		csp_iface_t * i = interfaces;
		while (i != ifc && i->next)
    38a0:	a8 17       	cp	r26, r24
    38a2:	b9 07       	cpc	r27, r25
    38a4:	b9 f0       	breq	.+46     	; 0x38d4 <csp_iflist_add+0x50>
    38a6:	d1 96       	adiw	r26, 0x31	; 49
    38a8:	ed 91       	ld	r30, X+
    38aa:	fc 91       	ld	r31, X
    38ac:	d2 97       	sbiw	r26, 0x32	; 50
    38ae:	30 97       	sbiw	r30, 0x00	; 0
    38b0:	41 f4       	brne	.+16     	; 0x38c2 <csp_iflist_add+0x3e>
    38b2:	fd 01       	movw	r30, r26
    38b4:	0a c0       	rjmp	.+20     	; 0x38ca <csp_iflist_add+0x46>
    38b6:	21 a9       	ldd	r18, Z+49	; 0x31
    38b8:	32 a9       	ldd	r19, Z+50	; 0x32
    38ba:	21 15       	cp	r18, r1
    38bc:	31 05       	cpc	r19, r1
    38be:	29 f0       	breq	.+10     	; 0x38ca <csp_iflist_add+0x46>
    38c0:	f9 01       	movw	r30, r18
    38c2:	8e 17       	cp	r24, r30
    38c4:	9f 07       	cpc	r25, r31
    38c6:	b9 f7       	brne	.-18     	; 0x38b6 <csp_iflist_add+0x32>
    38c8:	08 95       	ret
			i = i->next;

		/* Insert interface last if not already in pool */
		if (i != ifc && i->next == NULL) {
			i->next = ifc;
    38ca:	92 ab       	std	Z+50, r25	; 0x32
    38cc:	81 ab       	std	Z+49, r24	; 0x31
			ifc->next = NULL;
    38ce:	fc 01       	movw	r30, r24
    38d0:	12 aa       	std	Z+50, r1	; 0x32
    38d2:	11 aa       	std	Z+49, r1	; 0x31
    38d4:	08 95       	ret

000038d6 <csp_get_address>:
}

int csp_send_prio(uint8_t prio, csp_conn_t * conn, csp_packet_t * packet, uint32_t timeout) {
	conn->idout.pri = prio;
	return csp_send(conn, packet, timeout);
}
    38d6:	80 91 01 1f 	lds	r24, 0x1F01	; 0x801f01 <csp_my_address>
    38da:	08 95       	ret

000038dc <csp_init>:
    38dc:	cf 93       	push	r28
    38de:	df 93       	push	r29
    38e0:	80 93 01 1f 	sts	0x1F01, r24	; 0x801f01 <csp_my_address>
    38e4:	6f db       	rcall	.-2338   	; 0x2fc4 <csp_conn_init>
    38e6:	00 97       	sbiw	r24, 0x00	; 0
    38e8:	e9 f4       	brne	.+58     	; 0x3924 <csp_init+0x48>
    38ea:	3c d3       	rcall	.+1656   	; 0x3f64 <csp_port_init>
    38ec:	00 97       	sbiw	r24, 0x00	; 0
    38ee:	d1 f4       	brne	.+52     	; 0x3924 <csp_init+0x48>
    38f0:	43 d3       	rcall	.+1670   	; 0x3f78 <csp_qfifo_init>
    38f2:	ec 01       	movw	r28, r24
    38f4:	00 97       	sbiw	r24, 0x00	; 0
    38f6:	a9 f4       	brne	.+42     	; 0x3922 <csp_init+0x46>
    38f8:	8e e3       	ldi	r24, 0x3E	; 62
    38fa:	92 e0       	ldi	r25, 0x02	; 2
    38fc:	c3 df       	rcall	.-122    	; 0x3884 <csp_iflist_add>
    38fe:	2f ef       	ldi	r18, 0xFF	; 255
    3900:	4e e3       	ldi	r20, 0x3E	; 62
    3902:	52 e0       	ldi	r21, 0x02	; 2
    3904:	65 e0       	ldi	r22, 0x05	; 5
    3906:	80 91 01 1f 	lds	r24, 0x1F01	; 0x801f01 <csp_my_address>
    390a:	0e 94 c4 24 	call	0x4988	; 0x4988 <csp_rtable_set>
    390e:	2f ef       	ldi	r18, 0xFF	; 255
    3910:	4e e3       	ldi	r20, 0x3E	; 62
    3912:	52 e0       	ldi	r21, 0x02	; 2
    3914:	65 e0       	ldi	r22, 0x05	; 5
    3916:	80 e2       	ldi	r24, 0x20	; 32
    3918:	0e 94 c4 24 	call	0x4988	; 0x4988 <csp_rtable_set>
    391c:	8c 2f       	mov	r24, r28
    391e:	9d 2f       	mov	r25, r29
    3920:	01 c0       	rjmp	.+2      	; 0x3924 <csp_init+0x48>
    3922:	9d 2f       	mov	r25, r29
    3924:	df 91       	pop	r29
    3926:	cf 91       	pop	r28
    3928:	08 95       	ret

0000392a <csp_read>:
    392a:	cf 93       	push	r28
    392c:	df 93       	push	r29
    392e:	1f 92       	push	r1
    3930:	1f 92       	push	r1
    3932:	cd b7       	in	r28, 0x3d	; 61
    3934:	de b7       	in	r29, 0x3e	; 62
    3936:	1a 82       	std	Y+2, r1	; 0x02
    3938:	19 82       	std	Y+1, r1	; 0x01
    393a:	00 97       	sbiw	r24, 0x00	; 0
    393c:	91 f0       	breq	.+36     	; 0x3962 <csp_read+0x38>
    393e:	fc 01       	movw	r30, r24
    3940:	21 81       	ldd	r18, Z+1	; 0x01
    3942:	21 30       	cpi	r18, 0x01	; 1
    3944:	89 f4       	brne	.+34     	; 0x3968 <csp_read+0x3e>
    3946:	9a 01       	movw	r18, r20
    3948:	ab 01       	movw	r20, r22
    394a:	be 01       	movw	r22, r28
    394c:	6f 5f       	subi	r22, 0xFF	; 255
    394e:	7f 4f       	sbci	r23, 0xFF	; 255
    3950:	84 85       	ldd	r24, Z+12	; 0x0c
    3952:	95 85       	ldd	r25, Z+13	; 0x0d
    3954:	0e 94 b7 13 	call	0x276e	; 0x276e <csp_queue_dequeue>
    3958:	01 97       	sbiw	r24, 0x01	; 1
    395a:	49 f4       	brne	.+18     	; 0x396e <csp_read+0x44>
    395c:	89 81       	ldd	r24, Y+1	; 0x01
    395e:	9a 81       	ldd	r25, Y+2	; 0x02
    3960:	08 c0       	rjmp	.+16     	; 0x3972 <csp_read+0x48>
    3962:	80 e0       	ldi	r24, 0x00	; 0
    3964:	90 e0       	ldi	r25, 0x00	; 0
    3966:	05 c0       	rjmp	.+10     	; 0x3972 <csp_read+0x48>
    3968:	80 e0       	ldi	r24, 0x00	; 0
    396a:	90 e0       	ldi	r25, 0x00	; 0
    396c:	02 c0       	rjmp	.+4      	; 0x3972 <csp_read+0x48>
    396e:	80 e0       	ldi	r24, 0x00	; 0
    3970:	90 e0       	ldi	r25, 0x00	; 0
    3972:	0f 90       	pop	r0
    3974:	0f 90       	pop	r0
    3976:	df 91       	pop	r29
    3978:	cf 91       	pop	r28
    397a:	08 95       	ret

0000397c <csp_send_direct>:
    397c:	4f 92       	push	r4
    397e:	5f 92       	push	r5
    3980:	6f 92       	push	r6
    3982:	7f 92       	push	r7
    3984:	8f 92       	push	r8
    3986:	9f 92       	push	r9
    3988:	af 92       	push	r10
    398a:	bf 92       	push	r11
    398c:	cf 92       	push	r12
    398e:	df 92       	push	r13
    3990:	ef 92       	push	r14
    3992:	ff 92       	push	r15
    3994:	0f 93       	push	r16
    3996:	1f 93       	push	r17
    3998:	cf 93       	push	r28
    399a:	df 93       	push	r29
    399c:	a6 2e       	mov	r10, r22
    399e:	87 2e       	mov	r8, r23
    39a0:	98 2e       	mov	r9, r24
    39a2:	b9 2e       	mov	r11, r25
    39a4:	6a 01       	movw	r12, r20
    39a6:	e9 01       	movw	r28, r18
    39a8:	27 01       	movw	r4, r14
    39aa:	38 01       	movw	r6, r16
    39ac:	41 15       	cp	r20, r1
    39ae:	51 05       	cpc	r21, r1
    39b0:	09 f5       	brne	.+66     	; 0x39f4 <csp_send_direct+0x78>
    39b2:	80 91 04 02 	lds	r24, 0x0204	; 0x800204 <csp_debug_level_enabled>
    39b6:	88 23       	and	r24, r24
    39b8:	09 f4       	brne	.+2      	; 0x39bc <csp_send_direct+0x40>
    39ba:	45 c1       	rjmp	.+650    	; 0x3c46 <csp_send_direct+0x2ca>
    39bc:	1f 92       	push	r1
    39be:	85 ef       	ldi	r24, 0xF5	; 245
    39c0:	8f 93       	push	r24
    39c2:	82 e0       	ldi	r24, 0x02	; 2
    39c4:	93 e0       	ldi	r25, 0x03	; 3
    39c6:	9f 93       	push	r25
    39c8:	8f 93       	push	r24
    39ca:	80 91 01 1f 	lds	r24, 0x1F01	; 0x801f01 <csp_my_address>
    39ce:	1f 92       	push	r1
    39d0:	8f 93       	push	r24
    39d2:	87 e5       	ldi	r24, 0x57	; 87
    39d4:	99 e0       	ldi	r25, 0x09	; 9
    39d6:	9f 93       	push	r25
    39d8:	8f 93       	push	r24
    39da:	1f 92       	push	r1
    39dc:	94 de       	rcall	.-728    	; 0x3706 <do_csp_debug>
    39de:	8d b7       	in	r24, 0x3d	; 61
    39e0:	9e b7       	in	r25, 0x3e	; 62
    39e2:	09 96       	adiw	r24, 0x09	; 9
    39e4:	0f b6       	in	r0, 0x3f	; 63
    39e6:	f8 94       	cli
    39e8:	9e bf       	out	0x3e, r25	; 62
    39ea:	0f be       	out	0x3f, r0	; 63
    39ec:	8d bf       	out	0x3d, r24	; 61
    39ee:	86 ef       	ldi	r24, 0xF6	; 246
    39f0:	9f ef       	ldi	r25, 0xFF	; 255
    39f2:	2e c1       	rjmp	.+604    	; 0x3c50 <csp_send_direct+0x2d4>
    39f4:	20 97       	sbiw	r28, 0x00	; 0
    39f6:	21 f0       	breq	.+8      	; 0x3a00 <csp_send_direct+0x84>
    39f8:	8c 81       	ldd	r24, Y+4	; 0x04
    39fa:	9d 81       	ldd	r25, Y+5	; 0x05
    39fc:	89 2b       	or	r24, r25
    39fe:	29 f5       	brne	.+74     	; 0x3a4a <csp_send_direct+0xce>
    3a00:	80 91 04 02 	lds	r24, 0x0204	; 0x800204 <csp_debug_level_enabled>
    3a04:	88 23       	and	r24, r24
    3a06:	09 f4       	brne	.+2      	; 0x3a0a <csp_send_direct+0x8e>
    3a08:	21 c1       	rjmp	.+578    	; 0x3c4c <csp_send_direct+0x2d0>
    3a0a:	bf 92       	push	r11
    3a0c:	9f 92       	push	r9
    3a0e:	8f 92       	push	r8
    3a10:	af 92       	push	r10
    3a12:	1f 92       	push	r1
    3a14:	8a ef       	ldi	r24, 0xFA	; 250
    3a16:	8f 93       	push	r24
    3a18:	82 e0       	ldi	r24, 0x02	; 2
    3a1a:	93 e0       	ldi	r25, 0x03	; 3
    3a1c:	9f 93       	push	r25
    3a1e:	8f 93       	push	r24
    3a20:	80 91 01 1f 	lds	r24, 0x1F01	; 0x801f01 <csp_my_address>
    3a24:	1f 92       	push	r1
    3a26:	8f 93       	push	r24
    3a28:	82 e3       	ldi	r24, 0x32	; 50
    3a2a:	99 e0       	ldi	r25, 0x09	; 9
    3a2c:	9f 93       	push	r25
    3a2e:	8f 93       	push	r24
    3a30:	1f 92       	push	r1
    3a32:	69 de       	rcall	.-814    	; 0x3706 <do_csp_debug>
    3a34:	ed b7       	in	r30, 0x3d	; 61
    3a36:	fe b7       	in	r31, 0x3e	; 62
    3a38:	3d 96       	adiw	r30, 0x0d	; 13
    3a3a:	0f b6       	in	r0, 0x3f	; 63
    3a3c:	f8 94       	cli
    3a3e:	fe bf       	out	0x3e, r31	; 62
    3a40:	0f be       	out	0x3f, r0	; 63
    3a42:	ed bf       	out	0x3d, r30	; 61
    3a44:	86 ef       	ldi	r24, 0xF6	; 246
    3a46:	9f ef       	ldi	r25, 0xFF	; 255
    3a48:	03 c1       	rjmp	.+518    	; 0x3c50 <csp_send_direct+0x2d4>
    3a4a:	80 91 08 02 	lds	r24, 0x0208	; 0x800208 <csp_debug_level_enabled+0x4>
    3a4e:	88 23       	and	r24, r24
    3a50:	09 f4       	brne	.+2      	; 0x3a54 <csp_send_direct+0xd8>
    3a52:	4b c0       	rjmp	.+150    	; 0x3aea <csp_send_direct+0x16e>
    3a54:	89 81       	ldd	r24, Y+1	; 0x01
    3a56:	8f 93       	push	r24
    3a58:	88 81       	ld	r24, Y
    3a5a:	8f 93       	push	r24
    3a5c:	fa 01       	movw	r30, r20
    3a5e:	81 85       	ldd	r24, Z+9	; 0x09
    3a60:	8f 93       	push	r24
    3a62:	80 85       	ldd	r24, Z+8	; 0x08
    3a64:	8f 93       	push	r24
    3a66:	1f 92       	push	r1
    3a68:	6f 93       	push	r22
    3a6a:	1f 92       	push	r1
    3a6c:	8b 2d       	mov	r24, r11
    3a6e:	82 95       	swap	r24
    3a70:	86 95       	lsr	r24
    3a72:	86 95       	lsr	r24
    3a74:	83 70       	andi	r24, 0x03	; 3
    3a76:	8f 93       	push	r24
    3a78:	1f 92       	push	r1
    3a7a:	87 2f       	mov	r24, r23
    3a7c:	8f 73       	andi	r24, 0x3F	; 63
    3a7e:	8f 93       	push	r24
    3a80:	89 2d       	mov	r24, r9
    3a82:	8f 70       	andi	r24, 0x0F	; 15
    3a84:	88 0f       	add	r24, r24
    3a86:	88 0f       	add	r24, r24
    3a88:	97 2f       	mov	r25, r23
    3a8a:	92 95       	swap	r25
    3a8c:	96 95       	lsr	r25
    3a8e:	96 95       	lsr	r25
    3a90:	93 70       	andi	r25, 0x03	; 3
    3a92:	89 2b       	or	r24, r25
    3a94:	1f 92       	push	r1
    3a96:	8f 93       	push	r24
    3a98:	8b 2d       	mov	r24, r11
    3a9a:	81 70       	andi	r24, 0x01	; 1
    3a9c:	82 95       	swap	r24
    3a9e:	80 7f       	andi	r24, 0xF0	; 240
    3aa0:	99 2d       	mov	r25, r9
    3aa2:	92 95       	swap	r25
    3aa4:	9f 70       	andi	r25, 0x0F	; 15
    3aa6:	89 2b       	or	r24, r25
    3aa8:	1f 92       	push	r1
    3aaa:	8f 93       	push	r24
    3aac:	8b 2d       	mov	r24, r11
    3aae:	86 95       	lsr	r24
    3ab0:	8f 71       	andi	r24, 0x1F	; 31
    3ab2:	1f 92       	push	r1
    3ab4:	8f 93       	push	r24
    3ab6:	1f 92       	push	r1
    3ab8:	8f ef       	ldi	r24, 0xFF	; 255
    3aba:	8f 93       	push	r24
    3abc:	82 e0       	ldi	r24, 0x02	; 2
    3abe:	93 e0       	ldi	r25, 0x03	; 3
    3ac0:	9f 93       	push	r25
    3ac2:	8f 93       	push	r24
    3ac4:	80 91 01 1f 	lds	r24, 0x1F01	; 0x801f01 <csp_my_address>
    3ac8:	1f 92       	push	r1
    3aca:	8f 93       	push	r24
    3acc:	86 ee       	ldi	r24, 0xE6	; 230
    3ace:	98 e0       	ldi	r25, 0x08	; 8
    3ad0:	9f 93       	push	r25
    3ad2:	8f 93       	push	r24
    3ad4:	84 e0       	ldi	r24, 0x04	; 4
    3ad6:	8f 93       	push	r24
    3ad8:	16 de       	rcall	.-980    	; 0x3706 <do_csp_debug>
    3ada:	8d b7       	in	r24, 0x3d	; 61
    3adc:	9e b7       	in	r25, 0x3e	; 62
    3ade:	49 96       	adiw	r24, 0x19	; 25
    3ae0:	0f b6       	in	r0, 0x3f	; 63
    3ae2:	f8 94       	cli
    3ae4:	9e bf       	out	0x3e, r25	; 62
    3ae6:	0f be       	out	0x3f, r0	; 63
    3ae8:	8d bf       	out	0x3d, r24	; 61
    3aea:	f6 01       	movw	r30, r12
    3aec:	a2 86       	std	Z+10, r10	; 0x0a
    3aee:	83 86       	std	Z+11, r8	; 0x0b
    3af0:	94 86       	std	Z+12, r9	; 0x0c
    3af2:	b5 86       	std	Z+13, r11	; 0x0d
    3af4:	8b 2d       	mov	r24, r11
    3af6:	86 95       	lsr	r24
    3af8:	8f 71       	andi	r24, 0x1F	; 31
    3afa:	48 2f       	mov	r20, r24
    3afc:	50 e0       	ldi	r21, 0x00	; 0
    3afe:	20 91 01 1f 	lds	r18, 0x1F01	; 0x801f01 <csp_my_address>
    3b02:	30 e0       	ldi	r19, 0x00	; 0
    3b04:	42 17       	cp	r20, r18
    3b06:	53 07       	cpc	r21, r19
    3b08:	09 f0       	breq	.+2      	; 0x3b0c <csp_send_direct+0x190>
    3b0a:	63 c0       	rjmp	.+198    	; 0x3bd2 <csp_send_direct+0x256>
    3b0c:	1a 2d       	mov	r17, r10
    3b0e:	a3 fe       	sbrs	r10, 3
    3b10:	1e c0       	rjmp	.+60     	; 0x3b4e <csp_send_direct+0x1d2>
    3b12:	90 91 05 02 	lds	r25, 0x0205	; 0x800205 <csp_debug_level_enabled+0x1>
    3b16:	99 23       	and	r25, r25
    3b18:	09 f4       	brne	.+2      	; 0x3b1c <csp_send_direct+0x1a0>
    3b1a:	87 c0       	rjmp	.+270    	; 0x3c2a <csp_send_direct+0x2ae>
    3b1c:	91 e0       	ldi	r25, 0x01	; 1
    3b1e:	9f 93       	push	r25
    3b20:	28 e1       	ldi	r18, 0x18	; 24
    3b22:	2f 93       	push	r18
    3b24:	22 e0       	ldi	r18, 0x02	; 2
    3b26:	33 e0       	ldi	r19, 0x03	; 3
    3b28:	3f 93       	push	r19
    3b2a:	2f 93       	push	r18
    3b2c:	1f 92       	push	r1
    3b2e:	8f 93       	push	r24
    3b30:	2a e7       	ldi	r18, 0x7A	; 122
    3b32:	38 e0       	ldi	r19, 0x08	; 8
    3b34:	3f 93       	push	r19
    3b36:	2f 93       	push	r18
    3b38:	9f 93       	push	r25
    3b3a:	e5 dd       	rcall	.-1078   	; 0x3706 <do_csp_debug>
    3b3c:	8d b7       	in	r24, 0x3d	; 61
    3b3e:	9e b7       	in	r25, 0x3e	; 62
    3b40:	09 96       	adiw	r24, 0x09	; 9
    3b42:	0f b6       	in	r0, 0x3f	; 63
    3b44:	f8 94       	cli
    3b46:	9e bf       	out	0x3e, r25	; 62
    3b48:	0f be       	out	0x3f, r0	; 63
    3b4a:	8d bf       	out	0x3d, r24	; 61
    3b4c:	6e c0       	rjmp	.+220    	; 0x3c2a <csp_send_direct+0x2ae>
    3b4e:	a0 fe       	sbrs	r10, 0
    3b50:	1e c0       	rjmp	.+60     	; 0x3b8e <csp_send_direct+0x212>
    3b52:	90 91 05 02 	lds	r25, 0x0205	; 0x800205 <csp_debug_level_enabled+0x1>
    3b56:	99 23       	and	r25, r25
    3b58:	c1 f0       	breq	.+48     	; 0x3b8a <csp_send_direct+0x20e>
    3b5a:	91 e0       	ldi	r25, 0x01	; 1
    3b5c:	9f 93       	push	r25
    3b5e:	27 e2       	ldi	r18, 0x27	; 39
    3b60:	2f 93       	push	r18
    3b62:	22 e0       	ldi	r18, 0x02	; 2
    3b64:	33 e0       	ldi	r19, 0x03	; 3
    3b66:	3f 93       	push	r19
    3b68:	2f 93       	push	r18
    3b6a:	1f 92       	push	r1
    3b6c:	8f 93       	push	r24
    3b6e:	27 e0       	ldi	r18, 0x07	; 7
    3b70:	38 e0       	ldi	r19, 0x08	; 8
    3b72:	3f 93       	push	r19
    3b74:	2f 93       	push	r18
    3b76:	9f 93       	push	r25
    3b78:	c6 dd       	rcall	.-1140   	; 0x3706 <do_csp_debug>
    3b7a:	ed b7       	in	r30, 0x3d	; 61
    3b7c:	fe b7       	in	r31, 0x3e	; 62
    3b7e:	39 96       	adiw	r30, 0x09	; 9
    3b80:	0f b6       	in	r0, 0x3f	; 63
    3b82:	f8 94       	cli
    3b84:	fe bf       	out	0x3e, r31	; 62
    3b86:	0f be       	out	0x3f, r0	; 63
    3b88:	ed bf       	out	0x3d, r30	; 61
    3b8a:	1e 7f       	andi	r17, 0xFE	; 254
    3b8c:	a1 2e       	mov	r10, r17
    3b8e:	a2 fe       	sbrs	r10, 2
    3b90:	20 c0       	rjmp	.+64     	; 0x3bd2 <csp_send_direct+0x256>
    3b92:	80 91 05 02 	lds	r24, 0x0205	; 0x800205 <csp_debug_level_enabled+0x1>
    3b96:	88 23       	and	r24, r24
    3b98:	09 f4       	brne	.+2      	; 0x3b9c <csp_send_direct+0x220>
    3b9a:	47 c0       	rjmp	.+142    	; 0x3c2a <csp_send_direct+0x2ae>
    3b9c:	81 e0       	ldi	r24, 0x01	; 1
    3b9e:	8f 93       	push	r24
    3ba0:	90 e4       	ldi	r25, 0x40	; 64
    3ba2:	9f 93       	push	r25
    3ba4:	22 e0       	ldi	r18, 0x02	; 2
    3ba6:	33 e0       	ldi	r19, 0x03	; 3
    3ba8:	3f 93       	push	r19
    3baa:	2f 93       	push	r18
    3bac:	90 91 01 1f 	lds	r25, 0x1F01	; 0x801f01 <csp_my_address>
    3bb0:	1f 92       	push	r1
    3bb2:	9f 93       	push	r25
    3bb4:	26 e9       	ldi	r18, 0x96	; 150
    3bb6:	37 e0       	ldi	r19, 0x07	; 7
    3bb8:	3f 93       	push	r19
    3bba:	2f 93       	push	r18
    3bbc:	8f 93       	push	r24
    3bbe:	a3 dd       	rcall	.-1210   	; 0x3706 <do_csp_debug>
    3bc0:	8d b7       	in	r24, 0x3d	; 61
    3bc2:	9e b7       	in	r25, 0x3e	; 62
    3bc4:	09 96       	adiw	r24, 0x09	; 9
    3bc6:	0f b6       	in	r0, 0x3f	; 63
    3bc8:	f8 94       	cli
    3bca:	9e bf       	out	0x3e, r25	; 62
    3bcc:	0f be       	out	0x3f, r0	; 63
    3bce:	8d bf       	out	0x3d, r24	; 61
    3bd0:	2c c0       	rjmp	.+88     	; 0x3c2a <csp_send_direct+0x2ae>
    3bd2:	f6 01       	movw	r30, r12
    3bd4:	a0 84       	ldd	r10, Z+8	; 0x08
    3bd6:	b1 84       	ldd	r11, Z+9	; 0x09
    3bd8:	8e 81       	ldd	r24, Y+6	; 0x06
    3bda:	9f 81       	ldd	r25, Y+7	; 0x07
    3bdc:	00 97       	sbiw	r24, 0x00	; 0
    3bde:	19 f0       	breq	.+6      	; 0x3be6 <csp_send_direct+0x26a>
    3be0:	8a 15       	cp	r24, r10
    3be2:	9b 05       	cpc	r25, r11
    3be4:	10 f1       	brcs	.+68     	; 0x3c2a <csp_send_direct+0x2ae>
    3be6:	ec 81       	ldd	r30, Y+4	; 0x04
    3be8:	fd 81       	ldd	r31, Y+5	; 0x05
    3bea:	a3 01       	movw	r20, r6
    3bec:	92 01       	movw	r18, r4
    3bee:	b6 01       	movw	r22, r12
    3bf0:	ce 01       	movw	r24, r28
    3bf2:	19 95       	eicall
    3bf4:	00 97       	sbiw	r24, 0x00	; 0
    3bf6:	c9 f4       	brne	.+50     	; 0x3c2a <csp_send_direct+0x2ae>
    3bf8:	49 85       	ldd	r20, Y+9	; 0x09
    3bfa:	5a 85       	ldd	r21, Y+10	; 0x0a
    3bfc:	6b 85       	ldd	r22, Y+11	; 0x0b
    3bfe:	7c 85       	ldd	r23, Y+12	; 0x0c
    3c00:	4f 5f       	subi	r20, 0xFF	; 255
    3c02:	5f 4f       	sbci	r21, 0xFF	; 255
    3c04:	6f 4f       	sbci	r22, 0xFF	; 255
    3c06:	7f 4f       	sbci	r23, 0xFF	; 255
    3c08:	49 87       	std	Y+9, r20	; 0x09
    3c0a:	5a 87       	std	Y+10, r21	; 0x0a
    3c0c:	6b 87       	std	Y+11, r22	; 0x0b
    3c0e:	7c 87       	std	Y+12, r23	; 0x0c
    3c10:	4d a1       	ldd	r20, Y+37	; 0x25
    3c12:	5e a1       	ldd	r21, Y+38	; 0x26
    3c14:	6f a1       	ldd	r22, Y+39	; 0x27
    3c16:	78 a5       	ldd	r23, Y+40	; 0x28
    3c18:	4a 0d       	add	r20, r10
    3c1a:	5b 1d       	adc	r21, r11
    3c1c:	61 1d       	adc	r22, r1
    3c1e:	71 1d       	adc	r23, r1
    3c20:	4d a3       	std	Y+37, r20	; 0x25
    3c22:	5e a3       	std	Y+38, r21	; 0x26
    3c24:	6f a3       	std	Y+39, r22	; 0x27
    3c26:	78 a7       	std	Y+40, r23	; 0x28
    3c28:	13 c0       	rjmp	.+38     	; 0x3c50 <csp_send_direct+0x2d4>
    3c2a:	89 89       	ldd	r24, Y+17	; 0x11
    3c2c:	9a 89       	ldd	r25, Y+18	; 0x12
    3c2e:	ab 89       	ldd	r26, Y+19	; 0x13
    3c30:	bc 89       	ldd	r27, Y+20	; 0x14
    3c32:	01 96       	adiw	r24, 0x01	; 1
    3c34:	a1 1d       	adc	r26, r1
    3c36:	b1 1d       	adc	r27, r1
    3c38:	89 8b       	std	Y+17, r24	; 0x11
    3c3a:	9a 8b       	std	Y+18, r25	; 0x12
    3c3c:	ab 8b       	std	Y+19, r26	; 0x13
    3c3e:	bc 8b       	std	Y+20, r27	; 0x14
    3c40:	86 ef       	ldi	r24, 0xF6	; 246
    3c42:	9f ef       	ldi	r25, 0xFF	; 255
    3c44:	05 c0       	rjmp	.+10     	; 0x3c50 <csp_send_direct+0x2d4>
    3c46:	86 ef       	ldi	r24, 0xF6	; 246
    3c48:	9f ef       	ldi	r25, 0xFF	; 255
    3c4a:	02 c0       	rjmp	.+4      	; 0x3c50 <csp_send_direct+0x2d4>
    3c4c:	86 ef       	ldi	r24, 0xF6	; 246
    3c4e:	9f ef       	ldi	r25, 0xFF	; 255
    3c50:	df 91       	pop	r29
    3c52:	cf 91       	pop	r28
    3c54:	1f 91       	pop	r17
    3c56:	0f 91       	pop	r16
    3c58:	ff 90       	pop	r15
    3c5a:	ef 90       	pop	r14
    3c5c:	df 90       	pop	r13
    3c5e:	cf 90       	pop	r12
    3c60:	bf 90       	pop	r11
    3c62:	af 90       	pop	r10
    3c64:	9f 90       	pop	r9
    3c66:	8f 90       	pop	r8
    3c68:	7f 90       	pop	r7
    3c6a:	6f 90       	pop	r6
    3c6c:	5f 90       	pop	r5
    3c6e:	4f 90       	pop	r4
    3c70:	08 95       	ret

00003c72 <csp_send>:
    3c72:	8f 92       	push	r8
    3c74:	9f 92       	push	r9
    3c76:	af 92       	push	r10
    3c78:	bf 92       	push	r11
    3c7a:	cf 92       	push	r12
    3c7c:	df 92       	push	r13
    3c7e:	ef 92       	push	r14
    3c80:	ff 92       	push	r15
    3c82:	0f 93       	push	r16
    3c84:	1f 93       	push	r17
    3c86:	cf 93       	push	r28
    3c88:	df 93       	push	r29
    3c8a:	ec 01       	movw	r28, r24
    3c8c:	6b 01       	movw	r12, r22
    3c8e:	49 01       	movw	r8, r18
    3c90:	5a 01       	movw	r10, r20
    3c92:	89 2b       	or	r24, r25
    3c94:	29 f0       	breq	.+10     	; 0x3ca0 <csp_send+0x2e>
    3c96:	67 2b       	or	r22, r23
    3c98:	19 f0       	breq	.+6      	; 0x3ca0 <csp_send+0x2e>
    3c9a:	89 81       	ldd	r24, Y+1	; 0x01
    3c9c:	81 30       	cpi	r24, 0x01	; 1
    3c9e:	09 f1       	breq	.+66     	; 0x3ce2 <csp_send+0x70>
    3ca0:	80 91 04 02 	lds	r24, 0x0204	; 0x800204 <csp_debug_level_enabled>
    3ca4:	88 23       	and	r24, r24
    3ca6:	b9 f1       	breq	.+110    	; 0x3d16 <csp_send+0xa4>
    3ca8:	81 e0       	ldi	r24, 0x01	; 1
    3caa:	8f 93       	push	r24
    3cac:	80 e6       	ldi	r24, 0x60	; 96
    3cae:	8f 93       	push	r24
    3cb0:	82 e0       	ldi	r24, 0x02	; 2
    3cb2:	93 e0       	ldi	r25, 0x03	; 3
    3cb4:	9f 93       	push	r25
    3cb6:	8f 93       	push	r24
    3cb8:	80 91 01 1f 	lds	r24, 0x1F01	; 0x801f01 <csp_my_address>
    3cbc:	1f 92       	push	r1
    3cbe:	8f 93       	push	r24
    3cc0:	80 e7       	ldi	r24, 0x70	; 112
    3cc2:	97 e0       	ldi	r25, 0x07	; 7
    3cc4:	9f 93       	push	r25
    3cc6:	8f 93       	push	r24
    3cc8:	1f 92       	push	r1
    3cca:	1d dd       	rcall	.-1478   	; 0x3706 <do_csp_debug>
    3ccc:	8d b7       	in	r24, 0x3d	; 61
    3cce:	9e b7       	in	r25, 0x3e	; 62
    3cd0:	09 96       	adiw	r24, 0x09	; 9
    3cd2:	0f b6       	in	r0, 0x3f	; 63
    3cd4:	f8 94       	cli
    3cd6:	9e bf       	out	0x3e, r25	; 62
    3cd8:	0f be       	out	0x3f, r0	; 63
    3cda:	8d bf       	out	0x3d, r24	; 61
    3cdc:	80 e0       	ldi	r24, 0x00	; 0
    3cde:	90 e0       	ldi	r25, 0x00	; 0
    3ce0:	1c c0       	rjmp	.+56     	; 0x3d1a <csp_send+0xa8>
    3ce2:	9a 85       	ldd	r25, Y+10	; 0x0a
    3ce4:	92 95       	swap	r25
    3ce6:	9f 70       	andi	r25, 0x0F	; 15
    3ce8:	8b 85       	ldd	r24, Y+11	; 0x0b
    3cea:	81 70       	andi	r24, 0x01	; 1
    3cec:	82 95       	swap	r24
    3cee:	80 7f       	andi	r24, 0xF0	; 240
    3cf0:	89 2b       	or	r24, r25
    3cf2:	09 d6       	rcall	.+3090   	; 0x4906 <csp_rtable_find_iface>
    3cf4:	9c 01       	movw	r18, r24
    3cf6:	68 85       	ldd	r22, Y+8	; 0x08
    3cf8:	79 85       	ldd	r23, Y+9	; 0x09
    3cfa:	8a 85       	ldd	r24, Y+10	; 0x0a
    3cfc:	9b 85       	ldd	r25, Y+11	; 0x0b
    3cfe:	85 01       	movw	r16, r10
    3d00:	74 01       	movw	r14, r8
    3d02:	a6 01       	movw	r20, r12
    3d04:	3b de       	rcall	.-906    	; 0x397c <csp_send_direct>
    3d06:	31 e0       	ldi	r19, 0x01	; 1
    3d08:	20 e0       	ldi	r18, 0x00	; 0
    3d0a:	89 2b       	or	r24, r25
    3d0c:	09 f0       	breq	.+2      	; 0x3d10 <csp_send+0x9e>
    3d0e:	30 e0       	ldi	r19, 0x00	; 0
    3d10:	83 2f       	mov	r24, r19
    3d12:	92 2f       	mov	r25, r18
    3d14:	02 c0       	rjmp	.+4      	; 0x3d1a <csp_send+0xa8>
    3d16:	80 e0       	ldi	r24, 0x00	; 0
    3d18:	90 e0       	ldi	r25, 0x00	; 0
    3d1a:	df 91       	pop	r29
    3d1c:	cf 91       	pop	r28
    3d1e:	1f 91       	pop	r17
    3d20:	0f 91       	pop	r16
    3d22:	ff 90       	pop	r15
    3d24:	ef 90       	pop	r14
    3d26:	df 90       	pop	r13
    3d28:	cf 90       	pop	r12
    3d2a:	bf 90       	pop	r11
    3d2c:	af 90       	pop	r10
    3d2e:	9f 90       	pop	r9
    3d30:	8f 90       	pop	r8
    3d32:	08 95       	ret

00003d34 <csp_transaction_persistent>:

int csp_transaction_persistent(csp_conn_t * conn, uint32_t timeout, void * outbuf, int outlen, void * inbuf, int inlen) {
    3d34:	4f 92       	push	r4
    3d36:	5f 92       	push	r5
    3d38:	6f 92       	push	r6
    3d3a:	7f 92       	push	r7
    3d3c:	8f 92       	push	r8
    3d3e:	9f 92       	push	r9
    3d40:	af 92       	push	r10
    3d42:	bf 92       	push	r11
    3d44:	cf 92       	push	r12
    3d46:	df 92       	push	r13
    3d48:	ef 92       	push	r14
    3d4a:	ff 92       	push	r15
    3d4c:	0f 93       	push	r16
    3d4e:	1f 93       	push	r17
    3d50:	cf 93       	push	r28
    3d52:	df 93       	push	r29
    3d54:	3c 01       	movw	r6, r24
    3d56:	4a 01       	movw	r8, r20
    3d58:	5b 01       	movw	r10, r22
    3d5a:	29 01       	movw	r4, r18

	int size = (inlen > outlen) ? inlen : outlen;
	csp_packet_t * packet = csp_buffer_get(size);
    3d5c:	80 2f       	mov	r24, r16
    3d5e:	91 2f       	mov	r25, r17
    3d60:	0c 15       	cp	r16, r12
    3d62:	1d 05       	cpc	r17, r13
    3d64:	14 f4       	brge	.+4      	; 0x3d6a <csp_transaction_persistent+0x36>
    3d66:	8c 2d       	mov	r24, r12
    3d68:	9d 2d       	mov	r25, r13
    3d6a:	0e 94 9c 15 	call	0x2b38	; 0x2b38 <csp_buffer_get>
    3d6e:	ec 01       	movw	r28, r24
	if (packet == NULL)
    3d70:	00 97       	sbiw	r24, 0x00	; 0
    3d72:	09 f4       	brne	.+2      	; 0x3d76 <csp_transaction_persistent+0x42>
    3d74:	66 c0       	rjmp	.+204    	; 0x3e42 <csp_transaction_persistent+0x10e>
		return 0;

	/* Copy the request */
	if (outlen > 0 && outbuf != NULL)
    3d76:	10 16       	cp	r1, r16
    3d78:	11 06       	cpc	r1, r17
    3d7a:	44 f4       	brge	.+16     	; 0x3d8c <csp_transaction_persistent+0x58>
    3d7c:	41 14       	cp	r4, r1
    3d7e:	51 04       	cpc	r5, r1
    3d80:	29 f0       	breq	.+10     	; 0x3d8c <csp_transaction_persistent+0x58>
		memcpy(packet->data, outbuf, outlen);
    3d82:	a8 01       	movw	r20, r16
    3d84:	b2 01       	movw	r22, r4
    3d86:	0e 96       	adiw	r24, 0x0e	; 14
    3d88:	0e 94 3b 2c 	call	0x5876	; 0x5876 <memcpy>
	packet->length = outlen;
    3d8c:	19 87       	std	Y+9, r17	; 0x09
    3d8e:	08 87       	std	Y+8, r16	; 0x08

	if (!csp_send(conn, packet, timeout)) {
    3d90:	a5 01       	movw	r20, r10
    3d92:	94 01       	movw	r18, r8
    3d94:	be 01       	movw	r22, r28
    3d96:	c3 01       	movw	r24, r6
    3d98:	6c df       	rcall	.-296    	; 0x3c72 <csp_send>
    3d9a:	8c 01       	movw	r16, r24
    3d9c:	89 2b       	or	r24, r25
    3d9e:	21 f4       	brne	.+8      	; 0x3da8 <csp_transaction_persistent+0x74>
		csp_buffer_free(packet);
    3da0:	ce 01       	movw	r24, r28
    3da2:	0e 94 95 16 	call	0x2d2a	; 0x2d2a <csp_buffer_free>
		return 0;
    3da6:	55 c0       	rjmp	.+170    	; 0x3e52 <csp_transaction_persistent+0x11e>
	}

	/* If no reply is expected, return now */
	if (inlen == 0)
    3da8:	c1 14       	cp	r12, r1
    3daa:	d1 04       	cpc	r13, r1
    3dac:	09 f4       	brne	.+2      	; 0x3db0 <csp_transaction_persistent+0x7c>
    3dae:	4c c0       	rjmp	.+152    	; 0x3e48 <csp_transaction_persistent+0x114>
		return 1;

	packet = csp_read(conn, timeout);
    3db0:	b5 01       	movw	r22, r10
    3db2:	a4 01       	movw	r20, r8
    3db4:	c3 01       	movw	r24, r6
    3db6:	b9 dd       	rcall	.-1166   	; 0x392a <csp_read>
    3db8:	ec 01       	movw	r28, r24
	if (packet == NULL)
    3dba:	89 2b       	or	r24, r25
    3dbc:	09 f4       	brne	.+2      	; 0x3dc0 <csp_transaction_persistent+0x8c>
    3dbe:	47 c0       	rjmp	.+142    	; 0x3e4e <csp_transaction_persistent+0x11a>
		return 0;

	if ((inlen != -1) && ((int)packet->length != inlen)) {
    3dc0:	8f ef       	ldi	r24, 0xFF	; 255
    3dc2:	c8 16       	cp	r12, r24
    3dc4:	d8 06       	cpc	r13, r24
    3dc6:	69 f1       	breq	.+90     	; 0x3e22 <csp_transaction_persistent+0xee>
    3dc8:	88 85       	ldd	r24, Y+8	; 0x08
    3dca:	99 85       	ldd	r25, Y+9	; 0x09
    3dcc:	c8 16       	cp	r12, r24
    3dce:	d9 06       	cpc	r13, r25
    3dd0:	41 f1       	breq	.+80     	; 0x3e22 <csp_transaction_persistent+0xee>
		csp_log_error("Reply length %u expected %u", packet->length, inlen);
    3dd2:	20 91 04 02 	lds	r18, 0x0204	; 0x800204 <csp_debug_level_enabled>
    3dd6:	22 23       	and	r18, r18
    3dd8:	f1 f0       	breq	.+60     	; 0x3e16 <csp_transaction_persistent+0xe2>
    3dda:	df 92       	push	r13
    3ddc:	cf 92       	push	r12
    3dde:	9f 93       	push	r25
    3de0:	8f 93       	push	r24
    3de2:	81 e0       	ldi	r24, 0x01	; 1
    3de4:	8f 93       	push	r24
    3de6:	86 e9       	ldi	r24, 0x96	; 150
    3de8:	8f 93       	push	r24
    3dea:	82 e0       	ldi	r24, 0x02	; 2
    3dec:	93 e0       	ldi	r25, 0x03	; 3
    3dee:	9f 93       	push	r25
    3df0:	8f 93       	push	r24
    3df2:	80 91 01 1f 	lds	r24, 0x1F01	; 0x801f01 <csp_my_address>
    3df6:	1f 92       	push	r1
    3df8:	8f 93       	push	r24
    3dfa:	87 e4       	ldi	r24, 0x47	; 71
    3dfc:	97 e0       	ldi	r25, 0x07	; 7
    3dfe:	9f 93       	push	r25
    3e00:	8f 93       	push	r24
    3e02:	1f 92       	push	r1
    3e04:	80 dc       	rcall	.-1792   	; 0x3706 <do_csp_debug>
    3e06:	8d b7       	in	r24, 0x3d	; 61
    3e08:	9e b7       	in	r25, 0x3e	; 62
    3e0a:	0d 96       	adiw	r24, 0x0d	; 13
    3e0c:	0f b6       	in	r0, 0x3f	; 63
    3e0e:	f8 94       	cli
    3e10:	9e bf       	out	0x3e, r25	; 62
    3e12:	0f be       	out	0x3f, r0	; 63
    3e14:	8d bf       	out	0x3d, r24	; 61
		csp_buffer_free(packet);
    3e16:	ce 01       	movw	r24, r28
    3e18:	0e 94 95 16 	call	0x2d2a	; 0x2d2a <csp_buffer_free>
		return 0;
    3e1c:	00 e0       	ldi	r16, 0x00	; 0
    3e1e:	10 e0       	ldi	r17, 0x00	; 0
    3e20:	18 c0       	rjmp	.+48     	; 0x3e52 <csp_transaction_persistent+0x11e>
	}

	memcpy(inbuf, packet->data, packet->length);
    3e22:	be 01       	movw	r22, r28
    3e24:	62 5f       	subi	r22, 0xF2	; 242
    3e26:	7f 4f       	sbci	r23, 0xFF	; 255
    3e28:	48 85       	ldd	r20, Y+8	; 0x08
    3e2a:	59 85       	ldd	r21, Y+9	; 0x09
    3e2c:	c7 01       	movw	r24, r14
    3e2e:	0e 94 3b 2c 	call	0x5876	; 0x5876 <memcpy>
	int length = packet->length;
    3e32:	e8 84       	ldd	r14, Y+8	; 0x08
    3e34:	f9 84       	ldd	r15, Y+9	; 0x09
	csp_buffer_free(packet);
    3e36:	ce 01       	movw	r24, r28
    3e38:	0e 94 95 16 	call	0x2d2a	; 0x2d2a <csp_buffer_free>
	return length;
    3e3c:	0e 2d       	mov	r16, r14
    3e3e:	1f 2d       	mov	r17, r15
    3e40:	08 c0       	rjmp	.+16     	; 0x3e52 <csp_transaction_persistent+0x11e>
int csp_transaction_persistent(csp_conn_t * conn, uint32_t timeout, void * outbuf, int outlen, void * inbuf, int inlen) {

	int size = (inlen > outlen) ? inlen : outlen;
	csp_packet_t * packet = csp_buffer_get(size);
	if (packet == NULL)
		return 0;
    3e42:	00 e0       	ldi	r16, 0x00	; 0
    3e44:	10 e0       	ldi	r17, 0x00	; 0
    3e46:	05 c0       	rjmp	.+10     	; 0x3e52 <csp_transaction_persistent+0x11e>
		return 0;
	}

	/* If no reply is expected, return now */
	if (inlen == 0)
		return 1;
    3e48:	01 e0       	ldi	r16, 0x01	; 1
    3e4a:	10 e0       	ldi	r17, 0x00	; 0
    3e4c:	02 c0       	rjmp	.+4      	; 0x3e52 <csp_transaction_persistent+0x11e>

	packet = csp_read(conn, timeout);
	if (packet == NULL)
		return 0;
    3e4e:	00 e0       	ldi	r16, 0x00	; 0
    3e50:	10 e0       	ldi	r17, 0x00	; 0
	memcpy(inbuf, packet->data, packet->length);
	int length = packet->length;
	csp_buffer_free(packet);
	return length;

}
    3e52:	c8 01       	movw	r24, r16
    3e54:	df 91       	pop	r29
    3e56:	cf 91       	pop	r28
    3e58:	1f 91       	pop	r17
    3e5a:	0f 91       	pop	r16
    3e5c:	ff 90       	pop	r15
    3e5e:	ef 90       	pop	r14
    3e60:	df 90       	pop	r13
    3e62:	cf 90       	pop	r12
    3e64:	bf 90       	pop	r11
    3e66:	af 90       	pop	r10
    3e68:	9f 90       	pop	r9
    3e6a:	8f 90       	pop	r8
    3e6c:	7f 90       	pop	r7
    3e6e:	6f 90       	pop	r6
    3e70:	5f 90       	pop	r5
    3e72:	4f 90       	pop	r4
    3e74:	08 95       	ret

00003e76 <csp_transaction>:

int csp_transaction(uint8_t prio, uint8_t dest, uint8_t port, uint32_t timeout, void * outbuf, int outlen, void * inbuf, int inlen) {
    3e76:	2f 92       	push	r2
    3e78:	3f 92       	push	r3
    3e7a:	4f 92       	push	r4
    3e7c:	5f 92       	push	r5
    3e7e:	6f 92       	push	r6
    3e80:	7f 92       	push	r7
    3e82:	8f 92       	push	r8
    3e84:	9f 92       	push	r9
    3e86:	af 92       	push	r10
    3e88:	bf 92       	push	r11
    3e8a:	cf 92       	push	r12
    3e8c:	df 92       	push	r13
    3e8e:	ef 92       	push	r14
    3e90:	ff 92       	push	r15
    3e92:	0f 93       	push	r16
    3e94:	1f 93       	push	r17
    3e96:	cf 93       	push	r28
    3e98:	df 93       	push	r29
    3e9a:	00 d0       	rcall	.+0      	; 0x3e9c <csp_transaction+0x26>
    3e9c:	1f 92       	push	r1
    3e9e:	cd b7       	in	r28, 0x3d	; 61
    3ea0:	de b7       	in	r29, 0x3e	; 62
    3ea2:	28 01       	movw	r4, r16
    3ea4:	39 01       	movw	r6, r18
    3ea6:	fa 82       	std	Y+2, r15	; 0x02
    3ea8:	e9 82       	std	Y+1, r14	; 0x01
    3eaa:	dc 82       	std	Y+4, r13	; 0x04
    3eac:	cb 82       	std	Y+3, r12	; 0x03
    3eae:	15 01       	movw	r2, r10

	csp_conn_t * conn = csp_connect(prio, dest, port, 0, CSP_CONNECTION_SO);
    3eb0:	c1 2c       	mov	r12, r1
    3eb2:	d1 2c       	mov	r13, r1
    3eb4:	76 01       	movw	r14, r12
    3eb6:	00 e0       	ldi	r16, 0x00	; 0
    3eb8:	10 e0       	ldi	r17, 0x00	; 0
    3eba:	98 01       	movw	r18, r16
    3ebc:	e8 da       	rcall	.-2608   	; 0x348e <csp_connect>
    3ebe:	5c 01       	movw	r10, r24
	if (conn == NULL){
    3ec0:	00 97       	sbiw	r24, 0x00	; 0
    3ec2:	81 f0       	breq	.+32     	; 0x3ee4 <csp_transaction+0x6e>
		return 0;
	}

	int status = csp_transaction_persistent(conn, timeout, outbuf, outlen, inbuf, inlen);
    3ec4:	64 01       	movw	r12, r8
    3ec6:	71 01       	movw	r14, r2
    3ec8:	0b 81       	ldd	r16, Y+3	; 0x03
    3eca:	1c 81       	ldd	r17, Y+4	; 0x04
    3ecc:	29 81       	ldd	r18, Y+1	; 0x01
    3ece:	3a 81       	ldd	r19, Y+2	; 0x02
    3ed0:	b3 01       	movw	r22, r6
    3ed2:	a2 01       	movw	r20, r4
    3ed4:	2f df       	rcall	.-418    	; 0x3d34 <csp_transaction_persistent>
    3ed6:	88 2e       	mov	r8, r24
    3ed8:	99 2e       	mov	r9, r25

	csp_close(conn);
    3eda:	c5 01       	movw	r24, r10
    3edc:	50 da       	rcall	.-2912   	; 0x337e <csp_close>
    3ede:	88 2d       	mov	r24, r8

	return status;
    3ee0:	99 2d       	mov	r25, r9
    3ee2:	02 c0       	rjmp	.+4      	; 0x3ee8 <csp_transaction+0x72>
    3ee4:	80 e0       	ldi	r24, 0x00	; 0

int csp_transaction(uint8_t prio, uint8_t dest, uint8_t port, uint32_t timeout, void * outbuf, int outlen, void * inbuf, int inlen) {

	csp_conn_t * conn = csp_connect(prio, dest, port, 0, CSP_CONNECTION_SO);
	if (conn == NULL){
		return 0;
    3ee6:	90 e0       	ldi	r25, 0x00	; 0
    3ee8:	0f 90       	pop	r0

	csp_close(conn);

	return status;

}
    3eea:	0f 90       	pop	r0
    3eec:	0f 90       	pop	r0
    3eee:	0f 90       	pop	r0
    3ef0:	df 91       	pop	r29
    3ef2:	cf 91       	pop	r28
    3ef4:	1f 91       	pop	r17
    3ef6:	0f 91       	pop	r16
    3ef8:	ff 90       	pop	r15
    3efa:	ef 90       	pop	r14
    3efc:	df 90       	pop	r13
    3efe:	cf 90       	pop	r12
    3f00:	bf 90       	pop	r11
    3f02:	af 90       	pop	r10
    3f04:	9f 90       	pop	r9
    3f06:	8f 90       	pop	r8
    3f08:	7f 90       	pop	r7
    3f0a:	6f 90       	pop	r6
    3f0c:	5f 90       	pop	r5
    3f0e:	4f 90       	pop	r4
    3f10:	3f 90       	pop	r3
    3f12:	2f 90       	pop	r2
    3f14:	08 95       	ret

00003f16 <csp_port_get_socket>:

csp_socket_t * csp_port_get_socket(unsigned int port) {

	csp_socket_t * ret = NULL;

	if (port >= CSP_ANY)
    3f16:	80 32       	cpi	r24, 0x20	; 32
    3f18:	91 05       	cpc	r25, r1
    3f1a:	f0 f4       	brcc	.+60     	; 0x3f58 <csp_port_get_socket+0x42>
		return NULL;

	/* Match dport to socket or local "catch all" port number */
	if (ports[port].state == PORT_OPEN)
    3f1c:	fc 01       	movw	r30, r24
    3f1e:	ee 0f       	add	r30, r30
    3f20:	ff 1f       	adc	r31, r31
    3f22:	e8 0f       	add	r30, r24
    3f24:	f9 1f       	adc	r31, r25
    3f26:	ee 5f       	subi	r30, 0xFE	; 254
    3f28:	f0 4e       	sbci	r31, 0xE0	; 224
    3f2a:	20 81       	ld	r18, Z
    3f2c:	21 30       	cpi	r18, 0x01	; 1
    3f2e:	59 f4       	brne	.+22     	; 0x3f46 <csp_port_get_socket+0x30>
		ret = ports[port].socket;
    3f30:	fc 01       	movw	r30, r24
    3f32:	ee 0f       	add	r30, r30
    3f34:	ff 1f       	adc	r31, r31
    3f36:	8e 0f       	add	r24, r30
    3f38:	9f 1f       	adc	r25, r31
    3f3a:	fc 01       	movw	r30, r24
    3f3c:	ee 5f       	subi	r30, 0xFE	; 254
    3f3e:	f0 4e       	sbci	r31, 0xE0	; 224
    3f40:	81 81       	ldd	r24, Z+1	; 0x01
    3f42:	92 81       	ldd	r25, Z+2	; 0x02
    3f44:	08 95       	ret
	else if (ports[CSP_ANY].state == PORT_OPEN)
    3f46:	80 91 62 1f 	lds	r24, 0x1F62	; 0x801f62 <ports+0x60>
    3f4a:	81 30       	cpi	r24, 0x01	; 1
    3f4c:	41 f4       	brne	.+16     	; 0x3f5e <csp_port_get_socket+0x48>
		ret = ports[CSP_ANY].socket;
    3f4e:	80 91 63 1f 	lds	r24, 0x1F63	; 0x801f63 <ports+0x61>
    3f52:	90 91 64 1f 	lds	r25, 0x1F64	; 0x801f64 <ports+0x62>
    3f56:	08 95       	ret
csp_socket_t * csp_port_get_socket(unsigned int port) {

	csp_socket_t * ret = NULL;

	if (port >= CSP_ANY)
		return NULL;
    3f58:	80 e0       	ldi	r24, 0x00	; 0
    3f5a:	90 e0       	ldi	r25, 0x00	; 0
    3f5c:	08 95       	ret
/* Allocation of ports */
static csp_port_t ports[CSP_MAX_BIND_PORT + 2];

csp_socket_t * csp_port_get_socket(unsigned int port) {

	csp_socket_t * ret = NULL;
    3f5e:	80 e0       	ldi	r24, 0x00	; 0
    3f60:	90 e0       	ldi	r25, 0x00	; 0
	else if (ports[CSP_ANY].state == PORT_OPEN)
		ret = ports[CSP_ANY].socket;

	return ret;

}
    3f62:	08 95       	ret

00003f64 <csp_port_init>:

int csp_port_init(void) {

	memset(ports, PORT_CLOSED, sizeof(csp_port_t) * (CSP_MAX_BIND_PORT + 2));
    3f64:	83 e6       	ldi	r24, 0x63	; 99
    3f66:	e2 e0       	ldi	r30, 0x02	; 2
    3f68:	ff e1       	ldi	r31, 0x1F	; 31
    3f6a:	df 01       	movw	r26, r30
    3f6c:	1d 92       	st	X+, r1
    3f6e:	8a 95       	dec	r24
    3f70:	e9 f7       	brne	.-6      	; 0x3f6c <csp_port_init+0x8>

	return CSP_ERR_NONE;

}
    3f72:	80 e0       	ldi	r24, 0x00	; 0
    3f74:	90 e0       	ldi	r25, 0x00	; 0
    3f76:	08 95       	ret

00003f78 <csp_qfifo_init>:
int csp_qfifo_init(void) {
	int prio;

	/* Create router fifos for each priority */
	for (prio = 0; prio < CSP_ROUTE_FIFOS; prio++) {
		if (qfifo[prio] == NULL) {
    3f78:	80 91 65 1f 	lds	r24, 0x1F65	; 0x801f65 <qfifo>
    3f7c:	90 91 66 1f 	lds	r25, 0x1F66	; 0x801f66 <qfifo+0x1>
    3f80:	89 2b       	or	r24, r25
    3f82:	61 f4       	brne	.+24     	; 0x3f9c <csp_qfifo_init+0x24>
			qfifo[prio] = csp_queue_create(CSP_FIFO_INPUT, sizeof(csp_qfifo_t));
    3f84:	64 e0       	ldi	r22, 0x04	; 4
    3f86:	70 e0       	ldi	r23, 0x00	; 0
    3f88:	8a e0       	ldi	r24, 0x0A	; 10
    3f8a:	90 e0       	ldi	r25, 0x00	; 0
    3f8c:	0e 94 a6 13 	call	0x274c	; 0x274c <csp_queue_create>
    3f90:	90 93 66 1f 	sts	0x1F66, r25	; 0x801f66 <qfifo+0x1>
    3f94:	80 93 65 1f 	sts	0x1F65, r24	; 0x801f65 <qfifo>
			if (!qfifo[prio])
    3f98:	89 2b       	or	r24, r25
    3f9a:	19 f0       	breq	.+6      	; 0x3fa2 <csp_qfifo_init+0x2a>
	qfifo_events = csp_queue_create(CSP_FIFO_INPUT, sizeof(int));
	if (!qfifo_events)
		return CSP_ERR_NOMEM;
#endif

	return CSP_ERR_NONE;
    3f9c:	80 e0       	ldi	r24, 0x00	; 0
    3f9e:	90 e0       	ldi	r25, 0x00	; 0
    3fa0:	08 95       	ret
	/* Create router fifos for each priority */
	for (prio = 0; prio < CSP_ROUTE_FIFOS; prio++) {
		if (qfifo[prio] == NULL) {
			qfifo[prio] = csp_queue_create(CSP_FIFO_INPUT, sizeof(csp_qfifo_t));
			if (!qfifo[prio])
				return CSP_ERR_NOMEM;
    3fa2:	8f ef       	ldi	r24, 0xFF	; 255
    3fa4:	9f ef       	ldi	r25, 0xFF	; 255
		return CSP_ERR_NOMEM;
#endif

	return CSP_ERR_NONE;

}
    3fa6:	08 95       	ret

00003fa8 <csp_qfifo_read>:
	if (!found) {
		csp_log_warn("Spurious wakeup: No packet found");
		return CSP_ERR_TIMEDOUT;
	}
#else
	if (csp_queue_dequeue(qfifo[0], input, FIFO_TIMEOUT) != CSP_QUEUE_OK)
    3fa8:	2f ef       	ldi	r18, 0xFF	; 255
    3faa:	3f ef       	ldi	r19, 0xFF	; 255
    3fac:	a9 01       	movw	r20, r18
    3fae:	bc 01       	movw	r22, r24
    3fb0:	80 91 65 1f 	lds	r24, 0x1F65	; 0x801f65 <qfifo>
    3fb4:	90 91 66 1f 	lds	r25, 0x1F66	; 0x801f66 <qfifo+0x1>
    3fb8:	0e 94 b7 13 	call	0x276e	; 0x276e <csp_queue_dequeue>
    3fbc:	01 97       	sbiw	r24, 0x01	; 1
    3fbe:	19 f4       	brne	.+6      	; 0x3fc6 <csp_qfifo_read+0x1e>
		return CSP_ERR_TIMEDOUT;
#endif

	return CSP_ERR_NONE;
    3fc0:	80 e0       	ldi	r24, 0x00	; 0
    3fc2:	90 e0       	ldi	r25, 0x00	; 0
    3fc4:	08 95       	ret
		csp_log_warn("Spurious wakeup: No packet found");
		return CSP_ERR_TIMEDOUT;
	}
#else
	if (csp_queue_dequeue(qfifo[0], input, FIFO_TIMEOUT) != CSP_QUEUE_OK)
		return CSP_ERR_TIMEDOUT;
    3fc6:	8d ef       	ldi	r24, 0xFD	; 253
    3fc8:	9f ef       	ldi	r25, 0xFF	; 255
#endif

	return CSP_ERR_NONE;

}
    3fca:	08 95       	ret

00003fcc <csp_qfifo_write>:

void csp_qfifo_write(csp_packet_t * packet, csp_iface_t * interface, CSP_BASE_TYPE * pxTaskWoken) {
    3fcc:	cf 92       	push	r12
    3fce:	df 92       	push	r13
    3fd0:	ef 92       	push	r14
    3fd2:	ff 92       	push	r15
    3fd4:	0f 93       	push	r16
    3fd6:	1f 93       	push	r17
    3fd8:	cf 93       	push	r28
    3fda:	df 93       	push	r29
    3fdc:	00 d0       	rcall	.+0      	; 0x3fde <csp_qfifo_write+0x12>
    3fde:	1f 92       	push	r1
    3fe0:	cd b7       	in	r28, 0x3d	; 61
    3fe2:	de b7       	in	r29, 0x3e	; 62
    3fe4:	7c 01       	movw	r14, r24
    3fe6:	8b 01       	movw	r16, r22
    3fe8:	6a 01       	movw	r12, r20
	int result;

	if (packet == NULL) {
    3fea:	00 97       	sbiw	r24, 0x00	; 0
    3fec:	e1 f4       	brne	.+56     	; 0x4026 <csp_qfifo_write+0x5a>
		csp_log_warn("csp_new packet called with NULL packet");
    3fee:	80 91 05 02 	lds	r24, 0x0205	; 0x800205 <csp_debug_level_enabled+0x1>
    3ff2:	88 23       	and	r24, r24
    3ff4:	09 f4       	brne	.+2      	; 0x3ff8 <csp_qfifo_write+0x2c>
    3ff6:	a9 c0       	rjmp	.+338    	; 0x414a <csp_qfifo_write+0x17e>
    3ff8:	6e dc       	rcall	.-1828   	; 0x38d6 <csp_get_address>
    3ffa:	1f 92       	push	r1
    3ffc:	9d e5       	ldi	r25, 0x5D	; 93
    3ffe:	9f 93       	push	r25
    4000:	2e e2       	ldi	r18, 0x2E	; 46
    4002:	33 e0       	ldi	r19, 0x03	; 3
    4004:	3f 93       	push	r19
    4006:	2f 93       	push	r18
    4008:	1f 92       	push	r1
    400a:	8f 93       	push	r24
    400c:	84 e0       	ldi	r24, 0x04	; 4
    400e:	9a e0       	ldi	r25, 0x0A	; 10
    4010:	9f 93       	push	r25
    4012:	8f 93       	push	r24
    4014:	81 e0       	ldi	r24, 0x01	; 1
    4016:	8f 93       	push	r24
    4018:	76 db       	rcall	.-2324   	; 0x3706 <do_csp_debug>
    401a:	0f b6       	in	r0, 0x3f	; 63
    401c:	f8 94       	cli
    401e:	de bf       	out	0x3e, r29	; 62
    4020:	0f be       	out	0x3f, r0	; 63
    4022:	cd bf       	out	0x3d, r28	; 61
    4024:	92 c0       	rjmp	.+292    	; 0x414a <csp_qfifo_write+0x17e>
		return;
	} else if (interface == NULL) {
    4026:	61 15       	cp	r22, r1
    4028:	71 05       	cpc	r23, r1
    402a:	21 f5       	brne	.+72     	; 0x4074 <csp_qfifo_write+0xa8>
		csp_log_warn("csp_new packet called with NULL interface");
    402c:	80 91 05 02 	lds	r24, 0x0205	; 0x800205 <csp_debug_level_enabled+0x1>
    4030:	88 23       	and	r24, r24
    4032:	b1 f0       	breq	.+44     	; 0x4060 <csp_qfifo_write+0x94>
    4034:	50 dc       	rcall	.-1888   	; 0x38d6 <csp_get_address>
    4036:	1f 92       	push	r1
    4038:	90 e6       	ldi	r25, 0x60	; 96
    403a:	9f 93       	push	r25
    403c:	2e e2       	ldi	r18, 0x2E	; 46
    403e:	33 e0       	ldi	r19, 0x03	; 3
    4040:	3f 93       	push	r19
    4042:	2f 93       	push	r18
    4044:	1f 92       	push	r1
    4046:	8f 93       	push	r24
    4048:	8d ec       	ldi	r24, 0xCD	; 205
    404a:	99 e0       	ldi	r25, 0x09	; 9
    404c:	9f 93       	push	r25
    404e:	8f 93       	push	r24
    4050:	81 e0       	ldi	r24, 0x01	; 1
    4052:	8f 93       	push	r24
    4054:	58 db       	rcall	.-2384   	; 0x3706 <do_csp_debug>
    4056:	0f b6       	in	r0, 0x3f	; 63
    4058:	f8 94       	cli
    405a:	de bf       	out	0x3e, r29	; 62
    405c:	0f be       	out	0x3f, r0	; 63
    405e:	cd bf       	out	0x3d, r28	; 61
		if (pxTaskWoken == NULL)
    4060:	cd 28       	or	r12, r13
    4062:	21 f4       	brne	.+8      	; 0x406c <csp_qfifo_write+0xa0>
			csp_buffer_free(packet);
    4064:	c7 01       	movw	r24, r14
    4066:	0e 94 95 16 	call	0x2d2a	; 0x2d2a <csp_buffer_free>
    406a:	6f c0       	rjmp	.+222    	; 0x414a <csp_qfifo_write+0x17e>
		else
			csp_buffer_free_isr(packet);
    406c:	c7 01       	movw	r24, r14
    406e:	0e 94 5d 16 	call	0x2cba	; 0x2cba <csp_buffer_free_isr>
    4072:	6b c0       	rjmp	.+214    	; 0x414a <csp_qfifo_write+0x17e>
		return;
	}

	csp_qfifo_t queue_element;
	queue_element.interface = interface;
    4074:	7a 83       	std	Y+2, r23	; 0x02
    4076:	69 83       	std	Y+1, r22	; 0x01
	queue_element.packet = packet;
    4078:	9c 83       	std	Y+4, r25	; 0x04
    407a:	8b 83       	std	Y+3, r24	; 0x03
	int fifo = packet->id.pri;
#else
	int fifo = 0;
#endif

	if (pxTaskWoken == NULL)
    407c:	41 15       	cp	r20, r1
    407e:	51 05       	cpc	r21, r1
    4080:	69 f4       	brne	.+26     	; 0x409c <csp_qfifo_write+0xd0>
		result = csp_queue_enqueue(qfifo[fifo], &queue_element, 0);
    4082:	20 e0       	ldi	r18, 0x00	; 0
    4084:	30 e0       	ldi	r19, 0x00	; 0
    4086:	a9 01       	movw	r20, r18
    4088:	be 01       	movw	r22, r28
    408a:	6f 5f       	subi	r22, 0xFF	; 255
    408c:	7f 4f       	sbci	r23, 0xFF	; 255
    408e:	80 91 65 1f 	lds	r24, 0x1F65	; 0x801f65 <qfifo>
    4092:	90 91 66 1f 	lds	r25, 0x1F66	; 0x801f66 <qfifo+0x1>
    4096:	0e 94 a9 13 	call	0x2752	; 0x2752 <csp_queue_enqueue>
    409a:	09 c0       	rjmp	.+18     	; 0x40ae <csp_qfifo_write+0xe2>
	else
		result = csp_queue_enqueue_isr(qfifo[fifo], &queue_element, pxTaskWoken);
    409c:	be 01       	movw	r22, r28
    409e:	6f 5f       	subi	r22, 0xFF	; 255
    40a0:	7f 4f       	sbci	r23, 0xFF	; 255
    40a2:	80 91 65 1f 	lds	r24, 0x1F65	; 0x801f65 <qfifo>
    40a6:	90 91 66 1f 	lds	r25, 0x1F66	; 0x801f66 <qfifo+0x1>
    40aa:	0e 94 b1 13 	call	0x2762	; 0x2762 <csp_queue_enqueue_isr>
		else
			csp_queue_enqueue_isr(qfifo_events, &event, pxTaskWoken);
	}
#endif

	if (result != CSP_QUEUE_OK) {
    40ae:	01 97       	sbiw	r24, 0x01	; 1
    40b0:	81 f1       	breq	.+96     	; 0x4112 <csp_qfifo_write+0x146>
		csp_log_warn("ERROR: Routing input FIFO is FULL. Dropping packet.");
    40b2:	80 91 05 02 	lds	r24, 0x0205	; 0x800205 <csp_debug_level_enabled+0x1>
    40b6:	88 23       	and	r24, r24
    40b8:	b1 f0       	breq	.+44     	; 0x40e6 <csp_qfifo_write+0x11a>
    40ba:	0d dc       	rcall	.-2022   	; 0x38d6 <csp_get_address>
    40bc:	1f 92       	push	r1
    40be:	93 e8       	ldi	r25, 0x83	; 131
    40c0:	9f 93       	push	r25
    40c2:	2e e2       	ldi	r18, 0x2E	; 46
    40c4:	33 e0       	ldi	r19, 0x03	; 3
    40c6:	3f 93       	push	r19
    40c8:	2f 93       	push	r18
    40ca:	1f 92       	push	r1
    40cc:	8f 93       	push	r24
    40ce:	8c e8       	ldi	r24, 0x8C	; 140
    40d0:	99 e0       	ldi	r25, 0x09	; 9
    40d2:	9f 93       	push	r25
    40d4:	8f 93       	push	r24
    40d6:	81 e0       	ldi	r24, 0x01	; 1
    40d8:	8f 93       	push	r24
    40da:	15 db       	rcall	.-2518   	; 0x3706 <do_csp_debug>
    40dc:	0f b6       	in	r0, 0x3f	; 63
    40de:	f8 94       	cli
    40e0:	de bf       	out	0x3e, r29	; 62
    40e2:	0f be       	out	0x3f, r0	; 63
    40e4:	cd bf       	out	0x3d, r28	; 61
		interface->drop++;
    40e6:	f8 01       	movw	r30, r16
    40e8:	81 8d       	ldd	r24, Z+25	; 0x19
    40ea:	92 8d       	ldd	r25, Z+26	; 0x1a
    40ec:	a3 8d       	ldd	r26, Z+27	; 0x1b
    40ee:	b4 8d       	ldd	r27, Z+28	; 0x1c
    40f0:	01 96       	adiw	r24, 0x01	; 1
    40f2:	a1 1d       	adc	r26, r1
    40f4:	b1 1d       	adc	r27, r1
    40f6:	81 8f       	std	Z+25, r24	; 0x19
    40f8:	92 8f       	std	Z+26, r25	; 0x1a
    40fa:	a3 8f       	std	Z+27, r26	; 0x1b
    40fc:	b4 8f       	std	Z+28, r27	; 0x1c
		if (pxTaskWoken == NULL)
    40fe:	cd 28       	or	r12, r13
    4100:	21 f4       	brne	.+8      	; 0x410a <csp_qfifo_write+0x13e>
			csp_buffer_free(packet);
    4102:	c7 01       	movw	r24, r14
    4104:	0e 94 95 16 	call	0x2d2a	; 0x2d2a <csp_buffer_free>
    4108:	20 c0       	rjmp	.+64     	; 0x414a <csp_qfifo_write+0x17e>
		else
			csp_buffer_free_isr(packet);
    410a:	c7 01       	movw	r24, r14
    410c:	0e 94 5d 16 	call	0x2cba	; 0x2cba <csp_buffer_free_isr>
    4110:	1c c0       	rjmp	.+56     	; 0x414a <csp_qfifo_write+0x17e>
	} else {
		interface->rx++;
    4112:	f8 01       	movw	r30, r16
    4114:	85 85       	ldd	r24, Z+13	; 0x0d
    4116:	96 85       	ldd	r25, Z+14	; 0x0e
    4118:	a7 85       	ldd	r26, Z+15	; 0x0f
    411a:	b0 89       	ldd	r27, Z+16	; 0x10
    411c:	01 96       	adiw	r24, 0x01	; 1
    411e:	a1 1d       	adc	r26, r1
    4120:	b1 1d       	adc	r27, r1
    4122:	85 87       	std	Z+13, r24	; 0x0d
    4124:	96 87       	std	Z+14, r25	; 0x0e
    4126:	a7 87       	std	Z+15, r26	; 0x0f
    4128:	b0 8b       	std	Z+16, r27	; 0x10
		interface->rxbytes += packet->length;
    412a:	f7 01       	movw	r30, r14
    412c:	20 85       	ldd	r18, Z+8	; 0x08
    412e:	31 85       	ldd	r19, Z+9	; 0x09
    4130:	f8 01       	movw	r30, r16
    4132:	81 a5       	ldd	r24, Z+41	; 0x29
    4134:	92 a5       	ldd	r25, Z+42	; 0x2a
    4136:	a3 a5       	ldd	r26, Z+43	; 0x2b
    4138:	b4 a5       	ldd	r27, Z+44	; 0x2c
    413a:	82 0f       	add	r24, r18
    413c:	93 1f       	adc	r25, r19
    413e:	a1 1d       	adc	r26, r1
    4140:	b1 1d       	adc	r27, r1
    4142:	81 a7       	std	Z+41, r24	; 0x29
    4144:	92 a7       	std	Z+42, r25	; 0x2a
    4146:	a3 a7       	std	Z+43, r26	; 0x2b
    4148:	b4 a7       	std	Z+44, r27	; 0x2c
	}

}
    414a:	0f 90       	pop	r0
    414c:	0f 90       	pop	r0
    414e:	0f 90       	pop	r0
    4150:	0f 90       	pop	r0
    4152:	df 91       	pop	r29
    4154:	cf 91       	pop	r28
    4156:	1f 91       	pop	r17
    4158:	0f 91       	pop	r16
    415a:	ff 90       	pop	r15
    415c:	ef 90       	pop	r14
    415e:	df 90       	pop	r13
    4160:	cf 90       	pop	r12
    4162:	08 95       	ret

00004164 <csp_route_security_check>:
 * @param security_opts either socket_opts or conn_opts
 * @param interface pointer to incoming interface
 * @param packet pointer to packet
 * @return -1 Missing feature, -2 XTEA error, -3 CRC error, -4 HMAC error, 0 = OK.
 */
static int csp_route_security_check(uint32_t security_opts, csp_iface_t * interface, csp_packet_t * packet) {
    4164:	cf 93       	push	r28
    4166:	df 93       	push	r29
		return CSP_ERR_XTEA;
	}
#endif

	/* CRC32 verified packet */
	if (packet->id.flags & CSP_FCRC32) {
    4168:	f9 01       	movw	r30, r18
    416a:	82 85       	ldd	r24, Z+10	; 0x0a
    416c:	80 ff       	sbrs	r24, 0
    416e:	23 c0       	rjmp	.+70     	; 0x41b6 <csp_route_security_check+0x52>
    4170:	e9 01       	movw	r28, r18
		}
	} else if (security_opts & CSP_SO_CRC32REQ) {
		csp_log_warn("Received packet without CRC32. Accepting packet");
#else
		/* Strip CRC32 field and accept the packet */
		csp_log_warn("Received packet with CRC32, but CSP was compiled without CRC32 support. Accepting packet");
    4172:	80 91 05 02 	lds	r24, 0x0205	; 0x800205 <csp_debug_level_enabled+0x1>
    4176:	88 23       	and	r24, r24
    4178:	c9 f0       	breq	.+50     	; 0x41ac <csp_route_security_check+0x48>
    417a:	ad db       	rcall	.-2214   	; 0x38d6 <csp_get_address>
    417c:	1f 92       	push	r1
    417e:	94 e8       	ldi	r25, 0x84	; 132
    4180:	9f 93       	push	r25
    4182:	2c e4       	ldi	r18, 0x4C	; 76
    4184:	33 e0       	ldi	r19, 0x03	; 3
    4186:	3f 93       	push	r19
    4188:	2f 93       	push	r18
    418a:	1f 92       	push	r1
    418c:	8f 93       	push	r24
    418e:	81 e6       	ldi	r24, 0x61	; 97
    4190:	9a e0       	ldi	r25, 0x0A	; 10
    4192:	9f 93       	push	r25
    4194:	8f 93       	push	r24
    4196:	81 e0       	ldi	r24, 0x01	; 1
    4198:	8f 93       	push	r24
    419a:	b5 da       	rcall	.-2710   	; 0x3706 <do_csp_debug>
    419c:	8d b7       	in	r24, 0x3d	; 61
    419e:	9e b7       	in	r25, 0x3e	; 62
    41a0:	09 96       	adiw	r24, 0x09	; 9
    41a2:	0f b6       	in	r0, 0x3f	; 63
    41a4:	f8 94       	cli
    41a6:	9e bf       	out	0x3e, r25	; 62
    41a8:	0f be       	out	0x3f, r0	; 63
    41aa:	8d bf       	out	0x3d, r24	; 61
		packet->length -= sizeof(uint32_t);
    41ac:	88 85       	ldd	r24, Y+8	; 0x08
    41ae:	99 85       	ldd	r25, Y+9	; 0x09
    41b0:	04 97       	sbiw	r24, 0x04	; 4
    41b2:	99 87       	std	Y+9, r25	; 0x09
    41b4:	88 87       	std	Y+8, r24	; 0x08
	}
#endif

	return CSP_ERR_NONE;

}
    41b6:	80 e0       	ldi	r24, 0x00	; 0
    41b8:	90 e0       	ldi	r25, 0x00	; 0
    41ba:	df 91       	pop	r29
    41bc:	cf 91       	pop	r28
    41be:	08 95       	ret

000041c0 <csp_route_work>:

int csp_route_work(uint32_t timeout) {
    41c0:	6f 92       	push	r6
    41c2:	7f 92       	push	r7
    41c4:	8f 92       	push	r8
    41c6:	9f 92       	push	r9
    41c8:	af 92       	push	r10
    41ca:	bf 92       	push	r11
    41cc:	cf 92       	push	r12
    41ce:	df 92       	push	r13
    41d0:	ef 92       	push	r14
    41d2:	ff 92       	push	r15
    41d4:	0f 93       	push	r16
    41d6:	1f 93       	push	r17
    41d8:	cf 93       	push	r28
    41da:	df 93       	push	r29
    41dc:	00 d0       	rcall	.+0      	; 0x41de <csp_route_work+0x1e>
    41de:	00 d0       	rcall	.+0      	; 0x41e0 <csp_route_work+0x20>
    41e0:	cd b7       	in	r28, 0x3d	; 61
    41e2:	de b7       	in	r29, 0x3e	; 62
	/* Check connection timeouts (currently only for RDP) */
	csp_conn_check_timeouts();
#endif

	/* Get next packet to route */
	if (csp_qfifo_read(&input) != CSP_ERR_NONE)
    41e4:	ce 01       	movw	r24, r28
    41e6:	01 96       	adiw	r24, 0x01	; 1
    41e8:	df de       	rcall	.-578    	; 0x3fa8 <csp_qfifo_read>
    41ea:	6c 01       	movw	r12, r24
    41ec:	89 2b       	or	r24, r25
    41ee:	09 f0       	breq	.+2      	; 0x41f2 <csp_route_work+0x32>
    41f0:	0f c2       	rjmp	.+1054   	; 0x4610 <csp_route_work+0x450>
		return -1;

	packet = input.packet;
    41f2:	eb 81       	ldd	r30, Y+3	; 0x03
    41f4:	fc 81       	ldd	r31, Y+4	; 0x04
    41f6:	fe 83       	std	Y+6, r31	; 0x06
    41f8:	ed 83       	std	Y+5, r30	; 0x05

	csp_log_packet("INP: S %u, D %u, Dp %u, Sp %u, Pr %u, Fl 0x%02X, Sz %"PRIu16" VIA: %s",
    41fa:	80 91 08 02 	lds	r24, 0x0208	; 0x800208 <csp_debug_level_enabled+0x4>
    41fe:	88 23       	and	r24, r24
    4200:	09 f4       	brne	.+2      	; 0x4204 <csp_route_work+0x44>
    4202:	50 c0       	rjmp	.+160    	; 0x42a4 <csp_route_work+0xe4>
    4204:	a9 81       	ldd	r26, Y+1	; 0x01
    4206:	ba 81       	ldd	r27, Y+2	; 0x02
    4208:	8c 90       	ld	r8, X
    420a:	11 96       	adiw	r26, 0x01	; 1
    420c:	7c 90       	ld	r7, X
    420e:	a0 84       	ldd	r10, Z+8	; 0x08
    4210:	91 84       	ldd	r9, Z+9	; 0x09
    4212:	b2 84       	ldd	r11, Z+10	; 0x0a
    4214:	85 85       	ldd	r24, Z+13	; 0x0d
    4216:	e8 2e       	mov	r14, r24
    4218:	e6 94       	lsr	r14
    421a:	e6 94       	lsr	r14
    421c:	e6 94       	lsr	r14
    421e:	e6 94       	lsr	r14
    4220:	e6 94       	lsr	r14
    4222:	e6 94       	lsr	r14
    4224:	93 85       	ldd	r25, Z+11	; 0x0b
    4226:	29 2f       	mov	r18, r25
    4228:	2f 73       	andi	r18, 0x3F	; 63
    422a:	f2 2e       	mov	r15, r18
    422c:	29 2f       	mov	r18, r25
    422e:	22 95       	swap	r18
    4230:	26 95       	lsr	r18
    4232:	26 95       	lsr	r18
    4234:	23 70       	andi	r18, 0x03	; 3
    4236:	94 85       	ldd	r25, Z+12	; 0x0c
    4238:	39 2f       	mov	r19, r25
    423a:	3f 70       	andi	r19, 0x0F	; 15
    423c:	63 2e       	mov	r6, r19
    423e:	66 0c       	add	r6, r6
    4240:	66 0c       	add	r6, r6
    4242:	62 2a       	or	r6, r18
    4244:	92 95       	swap	r25
    4246:	9f 70       	andi	r25, 0x0F	; 15
    4248:	08 2f       	mov	r16, r24
    424a:	01 70       	andi	r16, 0x01	; 1
    424c:	02 95       	swap	r16
    424e:	00 7f       	andi	r16, 0xF0	; 240
    4250:	09 2b       	or	r16, r25
    4252:	86 95       	lsr	r24
    4254:	18 2f       	mov	r17, r24
    4256:	1f 71       	andi	r17, 0x1F	; 31
    4258:	3e db       	rcall	.-2436   	; 0x38d6 <csp_get_address>
    425a:	7f 92       	push	r7
    425c:	8f 92       	push	r8
    425e:	9f 92       	push	r9
    4260:	af 92       	push	r10
    4262:	1f 92       	push	r1
    4264:	bf 92       	push	r11
    4266:	1f 92       	push	r1
    4268:	ef 92       	push	r14
    426a:	1f 92       	push	r1
    426c:	ff 92       	push	r15
    426e:	1f 92       	push	r1
    4270:	6f 92       	push	r6
    4272:	1f 92       	push	r1
    4274:	0f 93       	push	r16
    4276:	1f 92       	push	r1
    4278:	1f 93       	push	r17
    427a:	1f 92       	push	r1
    427c:	9d eb       	ldi	r25, 0xBD	; 189
    427e:	9f 93       	push	r25
    4280:	2c e4       	ldi	r18, 0x4C	; 76
    4282:	33 e0       	ldi	r19, 0x03	; 3
    4284:	3f 93       	push	r19
    4286:	2f 93       	push	r18
    4288:	1f 92       	push	r1
    428a:	8f 93       	push	r24
    428c:	8b e6       	ldi	r24, 0x6B	; 107
    428e:	9c e0       	ldi	r25, 0x0C	; 12
    4290:	9f 93       	push	r25
    4292:	8f 93       	push	r24
    4294:	84 e0       	ldi	r24, 0x04	; 4
    4296:	8f 93       	push	r24
    4298:	36 da       	rcall	.-2964   	; 0x3706 <do_csp_debug>
    429a:	0f b6       	in	r0, 0x3f	; 63
    429c:	f8 94       	cli
    429e:	de bf       	out	0x3e, r29	; 62
    42a0:	0f be       	out	0x3f, r0	; 63
    42a2:	cd bf       	out	0x3d, r28	; 61
		return 0;
	}
#endif

	/* If the message is not to me, route the message to the correct interface */
	if ((packet->id.dst != csp_get_address()) && (packet->id.dst != CSP_BROADCAST_ADDR)) {
    42a4:	ed 81       	ldd	r30, Y+5	; 0x05
    42a6:	fe 81       	ldd	r31, Y+6	; 0x06
    42a8:	04 85       	ldd	r16, Z+12	; 0x0c
    42aa:	80 2f       	mov	r24, r16
    42ac:	82 95       	swap	r24
    42ae:	8f 70       	andi	r24, 0x0F	; 15
    42b0:	05 85       	ldd	r16, Z+13	; 0x0d
    42b2:	01 70       	andi	r16, 0x01	; 1
    42b4:	02 95       	swap	r16
    42b6:	00 7f       	andi	r16, 0xF0	; 240
    42b8:	08 2b       	or	r16, r24
    42ba:	10 e0       	ldi	r17, 0x00	; 0
    42bc:	0c db       	rcall	.-2536   	; 0x38d6 <csp_get_address>
    42be:	90 e0       	ldi	r25, 0x00	; 0
    42c0:	08 17       	cp	r16, r24
    42c2:	19 07       	cpc	r17, r25
    42c4:	09 f4       	brne	.+2      	; 0x42c8 <csp_route_work+0x108>
    42c6:	4f c0       	rjmp	.+158    	; 0x4366 <csp_route_work+0x1a6>
    42c8:	ed 81       	ldd	r30, Y+5	; 0x05
    42ca:	fe 81       	ldd	r31, Y+6	; 0x06
    42cc:	84 85       	ldd	r24, Z+12	; 0x0c
    42ce:	98 2f       	mov	r25, r24
    42d0:	92 95       	swap	r25
    42d2:	9f 70       	andi	r25, 0x0F	; 15
    42d4:	85 85       	ldd	r24, Z+13	; 0x0d
    42d6:	81 70       	andi	r24, 0x01	; 1
    42d8:	82 95       	swap	r24
    42da:	80 7f       	andi	r24, 0xF0	; 240
    42dc:	89 2b       	or	r24, r25
    42de:	8f 31       	cpi	r24, 0x1F	; 31
    42e0:	09 f4       	brne	.+2      	; 0x42e4 <csp_route_work+0x124>

		/* Find the destination interface */
		csp_iface_t * dstif = csp_rtable_find_iface(packet->id.dst);
    42e2:	41 c0       	rjmp	.+130    	; 0x4366 <csp_route_work+0x1a6>
    42e4:	10 d3       	rcall	.+1568   	; 0x4906 <csp_rtable_find_iface>
    42e6:	fc 01       	movw	r30, r24

		/* If the message resolves to the input interface, don't loop it back out */
		if ((dstif == NULL) || ((dstif == input.interface) && (input.interface->split_horizon_off == 0))) {
    42e8:	00 97       	sbiw	r24, 0x00	; 0
    42ea:	41 f0       	breq	.+16     	; 0x42fc <csp_route_work+0x13c>
    42ec:	29 81       	ldd	r18, Y+1	; 0x01
    42ee:	3a 81       	ldd	r19, Y+2	; 0x02
    42f0:	82 17       	cp	r24, r18
    42f2:	93 07       	cpc	r25, r19
    42f4:	41 f4       	brne	.+16     	; 0x4306 <csp_route_work+0x146>
    42f6:	20 85       	ldd	r18, Z+8	; 0x08
    42f8:	21 11       	cpse	r18, r1
    42fa:	05 c0       	rjmp	.+10     	; 0x4306 <csp_route_work+0x146>
			csp_buffer_free(packet);
    42fc:	8d 81       	ldd	r24, Y+5	; 0x05
    42fe:	9e 81       	ldd	r25, Y+6	; 0x06
    4300:	0e 94 95 16 	call	0x2d2a	; 0x2d2a <csp_buffer_free>
			return 0;
    4304:	c3 c1       	rjmp	.+902    	; 0x468c <csp_route_work+0x4cc>
		}

		/* Otherwise, actually send the message */
		if (csp_send_direct(packet->id, packet, dstif, 0) != CSP_ERR_NONE) {
    4306:	4d 81       	ldd	r20, Y+5	; 0x05
    4308:	5e 81       	ldd	r21, Y+6	; 0x06
    430a:	da 01       	movw	r26, r20
    430c:	1a 96       	adiw	r26, 0x0a	; 10
    430e:	6d 91       	ld	r22, X+
    4310:	7d 91       	ld	r23, X+
    4312:	8d 91       	ld	r24, X+
    4314:	9c 91       	ld	r25, X
    4316:	1d 97       	sbiw	r26, 0x0d	; 13
    4318:	e1 2c       	mov	r14, r1
    431a:	f1 2c       	mov	r15, r1
    431c:	87 01       	movw	r16, r14
    431e:	9f 01       	movw	r18, r30
    4320:	2d db       	rcall	.-2470   	; 0x397c <csp_send_direct>
    4322:	00 97       	sbiw	r24, 0x00	; 0
    4324:	09 f4       	brne	.+2      	; 0x4328 <csp_route_work+0x168>
			csp_log_warn("Router failed to send");
    4326:	78 c1       	rjmp	.+752    	; 0x4618 <csp_route_work+0x458>
    4328:	80 91 05 02 	lds	r24, 0x0205	; 0x800205 <csp_debug_level_enabled+0x1>
    432c:	88 23       	and	r24, r24
    432e:	b1 f0       	breq	.+44     	; 0x435c <csp_route_work+0x19c>
    4330:	d2 da       	rcall	.-2652   	; 0x38d6 <csp_get_address>
    4332:	1f 92       	push	r1
    4334:	9c ed       	ldi	r25, 0xDC	; 220
    4336:	9f 93       	push	r25
    4338:	2c e4       	ldi	r18, 0x4C	; 76
    433a:	33 e0       	ldi	r19, 0x03	; 3
    433c:	3f 93       	push	r19
    433e:	2f 93       	push	r18
    4340:	1f 92       	push	r1
    4342:	8f 93       	push	r24
    4344:	88 e4       	ldi	r24, 0x48	; 72
    4346:	9c e0       	ldi	r25, 0x0C	; 12
    4348:	9f 93       	push	r25
    434a:	8f 93       	push	r24
    434c:	81 e0       	ldi	r24, 0x01	; 1
    434e:	8f 93       	push	r24
    4350:	da d9       	rcall	.-3148   	; 0x3706 <do_csp_debug>
    4352:	0f b6       	in	r0, 0x3f	; 63
    4354:	f8 94       	cli
    4356:	de bf       	out	0x3e, r29	; 62
    4358:	0f be       	out	0x3f, r0	; 63
    435a:	cd bf       	out	0x3d, r28	; 61
			csp_buffer_free(packet);
    435c:	8d 81       	ldd	r24, Y+5	; 0x05
    435e:	9e 81       	ldd	r25, Y+6	; 0x06
    4360:	0e 94 95 16 	call	0x2d2a	; 0x2d2a <csp_buffer_free>
    4364:	93 c1       	rjmp	.+806    	; 0x468c <csp_route_work+0x4cc>
		/* Next message, please */
		return 0;
	}

	/* Discard packets with unsupported options */
	if (csp_route_check_options(input.interface, packet) != CSP_ERR_NONE) {
    4366:	ed 81       	ldd	r30, Y+5	; 0x05
    4368:	fe 81       	ldd	r31, Y+6	; 0x06
    436a:	09 81       	ldd	r16, Y+1	; 0x01
 */
static int csp_route_check_options(csp_iface_t *interface, csp_packet_t *packet)
{
#ifndef CSP_USE_XTEA
	/* Drop XTEA packets */
	if (packet->id.flags & CSP_FXTEA) {
    436c:	1a 81       	ldd	r17, Y+2	; 0x02
    436e:	82 85       	ldd	r24, Z+10	; 0x0a
    4370:	82 ff       	sbrs	r24, 2
		csp_log_error("Received XTEA encrypted packet, but CSP was compiled without XTEA support. Discarding packet");
    4372:	26 c0       	rjmp	.+76     	; 0x43c0 <csp_route_work+0x200>
    4374:	80 91 04 02 	lds	r24, 0x0204	; 0x800204 <csp_debug_level_enabled>
    4378:	88 23       	and	r24, r24
    437a:	a9 f0       	breq	.+42     	; 0x43a6 <csp_route_work+0x1e6>
    437c:	ac da       	rcall	.-2728   	; 0x38d6 <csp_get_address>
    437e:	1f 92       	push	r1
    4380:	97 e3       	ldi	r25, 0x37	; 55
    4382:	9f 93       	push	r25
    4384:	2c e4       	ldi	r18, 0x4C	; 76
    4386:	33 e0       	ldi	r19, 0x03	; 3
    4388:	3f 93       	push	r19
    438a:	2f 93       	push	r18
    438c:	1f 92       	push	r1
    438e:	8f 93       	push	r24
    4390:	8a e8       	ldi	r24, 0x8A	; 138
    4392:	9b e0       	ldi	r25, 0x0B	; 11
    4394:	9f 93       	push	r25
    4396:	8f 93       	push	r24
    4398:	1f 92       	push	r1
    439a:	b5 d9       	rcall	.-3222   	; 0x3706 <do_csp_debug>
    439c:	0f b6       	in	r0, 0x3f	; 63
    439e:	f8 94       	cli
    43a0:	de bf       	out	0x3e, r29	; 62
    43a2:	0f be       	out	0x3f, r0	; 63
    43a4:	cd bf       	out	0x3d, r28	; 61
		interface->autherr++;
    43a6:	f8 01       	movw	r30, r16
    43a8:	85 8d       	ldd	r24, Z+29	; 0x1d
    43aa:	96 8d       	ldd	r25, Z+30	; 0x1e
    43ac:	a7 8d       	ldd	r26, Z+31	; 0x1f
    43ae:	b0 a1       	ldd	r27, Z+32	; 0x20
    43b0:	01 96       	adiw	r24, 0x01	; 1
    43b2:	a1 1d       	adc	r26, r1
    43b4:	b1 1d       	adc	r27, r1
    43b6:	85 8f       	std	Z+29, r24	; 0x1d
    43b8:	96 8f       	std	Z+30, r25	; 0x1e
    43ba:	a7 8f       	std	Z+31, r26	; 0x1f
    43bc:	b0 a3       	std	Z+32, r27	; 0x20
	}
#endif

#ifndef CSP_USE_HMAC
	/* Drop HMAC packets */
	if (packet->id.flags & CSP_FHMAC) {
    43be:	2e c1       	rjmp	.+604    	; 0x461c <csp_route_work+0x45c>
    43c0:	83 ff       	sbrs	r24, 3
		csp_log_error("Received packet with HMAC, but CSP was compiled without HMAC support. Discarding packet");
    43c2:	26 c0       	rjmp	.+76     	; 0x4410 <csp_route_work+0x250>
    43c4:	80 91 04 02 	lds	r24, 0x0204	; 0x800204 <csp_debug_level_enabled>
    43c8:	88 23       	and	r24, r24
    43ca:	a9 f0       	breq	.+42     	; 0x43f6 <csp_route_work+0x236>
    43cc:	84 da       	rcall	.-2808   	; 0x38d6 <csp_get_address>
    43ce:	1f 92       	push	r1
    43d0:	90 e4       	ldi	r25, 0x40	; 64
    43d2:	9f 93       	push	r25
    43d4:	2c e4       	ldi	r18, 0x4C	; 76
    43d6:	33 e0       	ldi	r19, 0x03	; 3
    43d8:	3f 93       	push	r19
    43da:	2f 93       	push	r18
    43dc:	1f 92       	push	r1
    43de:	8f 93       	push	r24
    43e0:	85 e2       	ldi	r24, 0x25	; 37
    43e2:	9b e0       	ldi	r25, 0x0B	; 11
    43e4:	9f 93       	push	r25
    43e6:	8f 93       	push	r24
    43e8:	1f 92       	push	r1
    43ea:	8d d9       	rcall	.-3302   	; 0x3706 <do_csp_debug>
    43ec:	0f b6       	in	r0, 0x3f	; 63
    43ee:	f8 94       	cli
    43f0:	de bf       	out	0x3e, r29	; 62
    43f2:	0f be       	out	0x3f, r0	; 63
    43f4:	cd bf       	out	0x3d, r28	; 61
		interface->autherr++;
    43f6:	f8 01       	movw	r30, r16
    43f8:	85 8d       	ldd	r24, Z+29	; 0x1d
    43fa:	96 8d       	ldd	r25, Z+30	; 0x1e
    43fc:	a7 8d       	ldd	r26, Z+31	; 0x1f
    43fe:	b0 a1       	ldd	r27, Z+32	; 0x20
    4400:	01 96       	adiw	r24, 0x01	; 1
    4402:	a1 1d       	adc	r26, r1
    4404:	b1 1d       	adc	r27, r1
    4406:	85 8f       	std	Z+29, r24	; 0x1d
    4408:	96 8f       	std	Z+30, r25	; 0x1e
    440a:	a7 8f       	std	Z+31, r26	; 0x1f
    440c:	b0 a3       	std	Z+32, r27	; 0x20
	}
#endif

#ifndef CSP_USE_RDP
	/* Drop RDP packets */
	if (packet->id.flags & CSP_FRDP) {
    440e:	06 c1       	rjmp	.+524    	; 0x461c <csp_route_work+0x45c>
    4410:	81 ff       	sbrs	r24, 1
		csp_log_error("Received RDP packet, but CSP was compiled without RDP support. Discarding packet");
    4412:	09 c1       	rjmp	.+530    	; 0x4626 <csp_route_work+0x466>
    4414:	80 91 04 02 	lds	r24, 0x0204	; 0x800204 <csp_debug_level_enabled>
    4418:	88 23       	and	r24, r24
    441a:	a9 f0       	breq	.+42     	; 0x4446 <csp_route_work+0x286>
    441c:	5c da       	rcall	.-2888   	; 0x38d6 <csp_get_address>
    441e:	1f 92       	push	r1
    4420:	99 e4       	ldi	r25, 0x49	; 73
    4422:	9f 93       	push	r25
    4424:	2c e4       	ldi	r18, 0x4C	; 76
    4426:	33 e0       	ldi	r19, 0x03	; 3
    4428:	3f 93       	push	r19
    442a:	2f 93       	push	r18
    442c:	1f 92       	push	r1
    442e:	8f 93       	push	r24
    4430:	87 ec       	ldi	r24, 0xC7	; 199
    4432:	9a e0       	ldi	r25, 0x0A	; 10
    4434:	9f 93       	push	r25
    4436:	8f 93       	push	r24
    4438:	1f 92       	push	r1
    443a:	65 d9       	rcall	.-3382   	; 0x3706 <do_csp_debug>
    443c:	0f b6       	in	r0, 0x3f	; 63
    443e:	f8 94       	cli
    4440:	de bf       	out	0x3e, r29	; 62
    4442:	0f be       	out	0x3f, r0	; 63
    4444:	cd bf       	out	0x3d, r28	; 61
		interface->rx_error++;
    4446:	f8 01       	movw	r30, r16
    4448:	85 89       	ldd	r24, Z+21	; 0x15
    444a:	96 89       	ldd	r25, Z+22	; 0x16
    444c:	a7 89       	ldd	r26, Z+23	; 0x17
    444e:	b0 8d       	ldd	r27, Z+24	; 0x18
    4450:	01 96       	adiw	r24, 0x01	; 1
    4452:	a1 1d       	adc	r26, r1
    4454:	b1 1d       	adc	r27, r1
    4456:	85 8b       	std	Z+21, r24	; 0x15
    4458:	96 8b       	std	Z+22, r25	; 0x16
    445a:	a7 8b       	std	Z+23, r26	; 0x17
    445c:	b0 8f       	std	Z+24, r27	; 0x18

	/* The message is to me, search for incoming socket */
	socket = csp_port_get_socket(packet->id.dport);

	/* If the socket is connection-less, deliver now */
	if (socket && (socket->opts & CSP_SO_CONN_LESS)) {
    445e:	de c0       	rjmp	.+444    	; 0x461c <csp_route_work+0x45c>
    4460:	d8 01       	movw	r26, r16
    4462:	54 96       	adiw	r26, 0x14	; 20
    4464:	6d 91       	ld	r22, X+
    4466:	7d 91       	ld	r23, X+
    4468:	8d 91       	ld	r24, X+
    446a:	9c 91       	ld	r25, X
    446c:	57 97       	sbiw	r26, 0x17	; 23
    446e:	70 ff       	sbrs	r23, 0
		if (csp_route_security_check(socket->opts, input.interface, packet) < 0) {
    4470:	fc c0       	rjmp	.+504    	; 0x466a <csp_route_work+0x4aa>
    4472:	2d 81       	ldd	r18, Y+5	; 0x05
    4474:	3e 81       	ldd	r19, Y+6	; 0x06
    4476:	49 81       	ldd	r20, Y+1	; 0x01
    4478:	5a 81       	ldd	r21, Y+2	; 0x02
    447a:	74 de       	rcall	.-792    	; 0x4164 <csp_route_security_check>
    447c:	99 23       	and	r25, r25
    447e:	2c f4       	brge	.+10     	; 0x448a <csp_route_work+0x2ca>
			csp_buffer_free(packet);
    4480:	8d 81       	ldd	r24, Y+5	; 0x05
    4482:	9e 81       	ldd	r25, Y+6	; 0x06
    4484:	0e 94 95 16 	call	0x2d2a	; 0x2d2a <csp_buffer_free>
			return 0;
    4488:	01 c1       	rjmp	.+514    	; 0x468c <csp_route_work+0x4cc>
		}
		if (csp_queue_enqueue(socket->socket, &packet, 0) != CSP_QUEUE_OK) {
    448a:	20 e0       	ldi	r18, 0x00	; 0
    448c:	30 e0       	ldi	r19, 0x00	; 0
    448e:	a9 01       	movw	r20, r18
    4490:	be 01       	movw	r22, r28
    4492:	6b 5f       	subi	r22, 0xFB	; 251
    4494:	7f 4f       	sbci	r23, 0xFF	; 255
    4496:	f8 01       	movw	r30, r16
    4498:	86 85       	ldd	r24, Z+14	; 0x0e
    449a:	97 85       	ldd	r25, Z+15	; 0x0f
    449c:	0e 94 a9 13 	call	0x2752	; 0x2752 <csp_queue_enqueue>
    44a0:	01 97       	sbiw	r24, 0x01	; 1
    44a2:	09 f4       	brne	.+2      	; 0x44a6 <csp_route_work+0x2e6>
			csp_log_error("Conn-less socket queue full");
    44a4:	f3 c0       	rjmp	.+486    	; 0x468c <csp_route_work+0x4cc>
    44a6:	80 91 04 02 	lds	r24, 0x0204	; 0x800204 <csp_debug_level_enabled>
    44aa:	88 23       	and	r24, r24
    44ac:	a9 f0       	breq	.+42     	; 0x44d8 <csp_route_work+0x318>
    44ae:	13 da       	rcall	.-3034   	; 0x38d6 <csp_get_address>
    44b0:	1f 92       	push	r1
    44b2:	94 ef       	ldi	r25, 0xF4	; 244
    44b4:	9f 93       	push	r25
    44b6:	2c e4       	ldi	r18, 0x4C	; 76
    44b8:	33 e0       	ldi	r19, 0x03	; 3
    44ba:	3f 93       	push	r19
    44bc:	2f 93       	push	r18
    44be:	1f 92       	push	r1
    44c0:	8f 93       	push	r24
    44c2:	8f e1       	ldi	r24, 0x1F	; 31
    44c4:	9c e0       	ldi	r25, 0x0C	; 12
    44c6:	9f 93       	push	r25
    44c8:	8f 93       	push	r24
    44ca:	1f 92       	push	r1
    44cc:	1c d9       	rcall	.-3528   	; 0x3706 <do_csp_debug>
    44ce:	0f b6       	in	r0, 0x3f	; 63
    44d0:	f8 94       	cli
    44d2:	de bf       	out	0x3e, r29	; 62
    44d4:	0f be       	out	0x3f, r0	; 63
    44d6:	cd bf       	out	0x3d, r28	; 61
			csp_buffer_free(packet);
    44d8:	8d 81       	ldd	r24, Y+5	; 0x05
    44da:	9e 81       	ldd	r25, Y+6	; 0x06
    44dc:	0e 94 95 16 	call	0x2d2a	; 0x2d2a <csp_buffer_free>
	/* If this is an incoming packet on a new connection */
	if (conn == NULL) {

		/* Reject packet if no matching socket is found */
		if (!socket) {
			csp_buffer_free(packet);
    44e0:	d5 c0       	rjmp	.+426    	; 0x468c <csp_route_work+0x4cc>
    44e2:	8d 81       	ldd	r24, Y+5	; 0x05
    44e4:	9e 81       	ldd	r25, Y+6	; 0x06
    44e6:	0e 94 95 16 	call	0x2d2a	; 0x2d2a <csp_buffer_free>
			return 0;
		}

		/* Run security check on incoming packet */
		if (csp_route_security_check(socket->opts, input.interface, packet) < 0) {
    44ea:	d0 c0       	rjmp	.+416    	; 0x468c <csp_route_work+0x4cc>
    44ec:	2d 81       	ldd	r18, Y+5	; 0x05
    44ee:	3e 81       	ldd	r19, Y+6	; 0x06
    44f0:	49 81       	ldd	r20, Y+1	; 0x01
    44f2:	5a 81       	ldd	r21, Y+2	; 0x02
    44f4:	d8 01       	movw	r26, r16
    44f6:	54 96       	adiw	r26, 0x14	; 20
    44f8:	6d 91       	ld	r22, X+
    44fa:	7d 91       	ld	r23, X+
    44fc:	8d 91       	ld	r24, X+
    44fe:	9c 91       	ld	r25, X
    4500:	57 97       	sbiw	r26, 0x17	; 23
    4502:	30 de       	rcall	.-928    	; 0x4164 <csp_route_security_check>
    4504:	99 23       	and	r25, r25
			csp_buffer_free(packet);
    4506:	2c f4       	brge	.+10     	; 0x4512 <csp_route_work+0x352>
    4508:	8d 81       	ldd	r24, Y+5	; 0x05
    450a:	9e 81       	ldd	r25, Y+6	; 0x06
    450c:	0e 94 95 16 	call	0x2d2a	; 0x2d2a <csp_buffer_free>
			return 0;
		}

		/* New incoming connection accepted */
		csp_id_t idout;
		idout.pri   = packet->id.pri;
    4510:	bd c0       	rjmp	.+378    	; 0x468c <csp_route_work+0x4cc>
    4512:	ed 81       	ldd	r30, Y+5	; 0x05
    4514:	fe 81       	ldd	r31, Y+6	; 0x06
    4516:	85 85       	ldd	r24, Z+13	; 0x0d
    4518:	80 7c       	andi	r24, 0xC0	; 192
		idout.src   = csp_get_address();
    451a:	f8 2e       	mov	r15, r24
    451c:	dc d9       	rcall	.-3144   	; 0x38d6 <csp_get_address>
    451e:	8f 71       	andi	r24, 0x1F	; 31
    4520:	88 0f       	add	r24, r24
    4522:	f8 2a       	or	r15, r24

		idout.dst   = packet->id.src;
    4524:	ed 81       	ldd	r30, Y+5	; 0x05
    4526:	fe 81       	ldd	r31, Y+6	; 0x06
    4528:	85 85       	ldd	r24, Z+13	; 0x0d
    452a:	86 95       	lsr	r24
    452c:	84 fb       	bst	r24, 4
    452e:	99 27       	eor	r25, r25
    4530:	90 f9       	bld	r25, 0
    4532:	f9 2a       	or	r15, r25
		idout.dport = packet->id.sport;
    4534:	53 85       	ldd	r21, Z+11	; 0x0b
    4536:	45 2f       	mov	r20, r21
    4538:	4f 73       	andi	r20, 0x3F	; 63
    453a:	46 95       	lsr	r20
    453c:	46 95       	lsr	r20
    453e:	82 95       	swap	r24
    4540:	80 7f       	andi	r24, 0xF0	; 240
    4542:	48 2b       	or	r20, r24
		idout.sport = packet->id.dport;
    4544:	25 2f       	mov	r18, r21
    4546:	22 95       	swap	r18
    4548:	26 95       	lsr	r18
    454a:	26 95       	lsr	r18
    454c:	23 70       	andi	r18, 0x03	; 3
    454e:	34 85       	ldd	r19, Z+12	; 0x0c
    4550:	3f 70       	andi	r19, 0x0F	; 15
    4552:	33 0f       	add	r19, r19
    4554:	33 0f       	add	r19, r19
    4556:	93 2f       	mov	r25, r19
    4558:	92 2b       	or	r25, r18
    455a:	35 2f       	mov	r19, r21
    455c:	32 95       	swap	r19
    455e:	33 0f       	add	r19, r19
    4560:	33 0f       	add	r19, r19
    4562:	30 7c       	andi	r19, 0xC0	; 192
		idout.flags = packet->id.flags;
    4564:	39 2b       	or	r19, r25

		/* Create connection */
		conn = csp_conn_new(packet->id, idout);
    4566:	22 85       	ldd	r18, Z+10	; 0x0a
    4568:	62 85       	ldd	r22, Z+10	; 0x0a
    456a:	73 85       	ldd	r23, Z+11	; 0x0b
    456c:	84 85       	ldd	r24, Z+12	; 0x0c
    456e:	95 85       	ldd	r25, Z+13	; 0x0d
    4570:	5f 2d       	mov	r21, r15
    4572:	0e 94 91 19 	call	0x3322	; 0x3322 <csp_conn_new>

		if (!conn) {
    4576:	7c 01       	movw	r14, r24
    4578:	89 2b       	or	r24, r25
			csp_log_error("No more connections available");
    457a:	f9 f4       	brne	.+62     	; 0x45ba <csp_route_work+0x3fa>
    457c:	80 91 04 02 	lds	r24, 0x0204	; 0x800204 <csp_debug_level_enabled>
    4580:	88 23       	and	r24, r24
    4582:	b1 f0       	breq	.+44     	; 0x45b0 <csp_route_work+0x3f0>
    4584:	a8 d9       	rcall	.-3248   	; 0x38d6 <csp_get_address>
    4586:	91 e0       	ldi	r25, 0x01	; 1
    4588:	9f 93       	push	r25
    458a:	9b e1       	ldi	r25, 0x1B	; 27
    458c:	9f 93       	push	r25
    458e:	2c e4       	ldi	r18, 0x4C	; 76
    4590:	33 e0       	ldi	r19, 0x03	; 3
    4592:	3f 93       	push	r19
    4594:	2f 93       	push	r18
    4596:	1f 92       	push	r1
    4598:	8f 93       	push	r24
    459a:	84 ef       	ldi	r24, 0xF4	; 244
    459c:	9b e0       	ldi	r25, 0x0B	; 11
    459e:	9f 93       	push	r25
    45a0:	8f 93       	push	r24
    45a2:	1f 92       	push	r1
    45a4:	b0 d8       	rcall	.-3744   	; 0x3706 <do_csp_debug>
    45a6:	0f b6       	in	r0, 0x3f	; 63
    45a8:	f8 94       	cli
    45aa:	de bf       	out	0x3e, r29	; 62
    45ac:	0f be       	out	0x3f, r0	; 63
    45ae:	cd bf       	out	0x3d, r28	; 61
			csp_buffer_free(packet);
    45b0:	8d 81       	ldd	r24, Y+5	; 0x05
    45b2:	9e 81       	ldd	r25, Y+6	; 0x06
    45b4:	0e 94 95 16 	call	0x2d2a	; 0x2d2a <csp_buffer_free>
			return 0;
    45b8:	69 c0       	rjmp	.+210    	; 0x468c <csp_route_work+0x4cc>
		}

		/* Store the socket queue and options */
		conn->socket = socket->socket;
    45ba:	d8 01       	movw	r26, r16
    45bc:	1e 96       	adiw	r26, 0x0e	; 14
    45be:	8d 91       	ld	r24, X+
    45c0:	9c 91       	ld	r25, X
    45c2:	1f 97       	sbiw	r26, 0x0f	; 15
    45c4:	f7 01       	movw	r30, r14
    45c6:	97 87       	std	Z+15, r25	; 0x0f
    45c8:	86 87       	std	Z+14, r24	; 0x0e
		conn->opts = socket->opts;
    45ca:	54 96       	adiw	r26, 0x14	; 20
    45cc:	8d 91       	ld	r24, X+
    45ce:	9d 91       	ld	r25, X+
    45d0:	0d 90       	ld	r0, X+
    45d2:	bc 91       	ld	r27, X
    45d4:	a0 2d       	mov	r26, r0
    45d6:	84 8b       	std	Z+20, r24	; 0x14
    45d8:	95 8b       	std	Z+21, r25	; 0x15
    45da:	a6 8b       	std	Z+22, r26	; 0x16
    45dc:	b7 8b       	std	Z+23, r27	; 0x17

	/* Packet to existing connection */
	} else {

		/* Run security check on incoming packet */
		if (csp_route_security_check(conn->opts, input.interface, packet) < 0) {
    45de:	13 c0       	rjmp	.+38     	; 0x4606 <csp_route_work+0x446>
    45e0:	2d 81       	ldd	r18, Y+5	; 0x05
    45e2:	3e 81       	ldd	r19, Y+6	; 0x06
    45e4:	49 81       	ldd	r20, Y+1	; 0x01
    45e6:	5a 81       	ldd	r21, Y+2	; 0x02
    45e8:	d7 01       	movw	r26, r14
    45ea:	54 96       	adiw	r26, 0x14	; 20
    45ec:	6d 91       	ld	r22, X+
    45ee:	7d 91       	ld	r23, X+
    45f0:	8d 91       	ld	r24, X+
    45f2:	9c 91       	ld	r25, X
    45f4:	57 97       	sbiw	r26, 0x17	; 23
    45f6:	b6 dd       	rcall	.-1172   	; 0x4164 <csp_route_security_check>
    45f8:	99 23       	and	r25, r25
			csp_buffer_free(packet);
    45fa:	2c f4       	brge	.+10     	; 0x4606 <csp_route_work+0x446>
    45fc:	8d 81       	ldd	r24, Y+5	; 0x05
    45fe:	9e 81       	ldd	r25, Y+6	; 0x06
    4600:	0e 94 95 16 	call	0x2d2a	; 0x2d2a <csp_buffer_free>
		return 0;
	}
#endif

	/* Pass packet to UDP module */
	csp_udp_new_packet(conn, packet);
    4604:	43 c0       	rjmp	.+134    	; 0x468c <csp_route_work+0x4cc>
    4606:	6d 81       	ldd	r22, Y+5	; 0x05
    4608:	7e 81       	ldd	r23, Y+6	; 0x06
    460a:	c7 01       	movw	r24, r14
    460c:	63 d2       	rcall	.+1222   	; 0x4ad4 <csp_udp_new_packet>
	return 0;
    460e:	3e c0       	rjmp	.+124    	; 0x468c <csp_route_work+0x4cc>
	csp_conn_check_timeouts();
#endif

	/* Get next packet to route */
	if (csp_qfifo_read(&input) != CSP_ERR_NONE)
		return -1;
    4610:	cc 24       	eor	r12, r12
    4612:	ca 94       	dec	r12
    4614:	dc 2c       	mov	r13, r12
			csp_log_warn("Router failed to send");
			csp_buffer_free(packet);
		}

		/* Next message, please */
		return 0;
    4616:	3a c0       	rjmp	.+116    	; 0x468c <csp_route_work+0x4cc>
    4618:	6c 01       	movw	r12, r24
	}

	/* Discard packets with unsupported options */
	if (csp_route_check_options(input.interface, packet) != CSP_ERR_NONE) {
		csp_buffer_free(packet);
    461a:	38 c0       	rjmp	.+112    	; 0x468c <csp_route_work+0x4cc>
    461c:	8d 81       	ldd	r24, Y+5	; 0x05
    461e:	9e 81       	ldd	r25, Y+6	; 0x06
    4620:	0e 94 95 16 	call	0x2d2a	; 0x2d2a <csp_buffer_free>
		return 0;
	}

	/* The message is to me, search for incoming socket */
	socket = csp_port_get_socket(packet->id.dport);
    4624:	33 c0       	rjmp	.+102    	; 0x468c <csp_route_work+0x4cc>
    4626:	83 85       	ldd	r24, Z+11	; 0x0b
    4628:	98 2f       	mov	r25, r24
    462a:	92 95       	swap	r25
    462c:	96 95       	lsr	r25
    462e:	96 95       	lsr	r25
    4630:	93 70       	andi	r25, 0x03	; 3
    4632:	84 85       	ldd	r24, Z+12	; 0x0c
    4634:	8f 70       	andi	r24, 0x0F	; 15
    4636:	88 0f       	add	r24, r24
    4638:	88 0f       	add	r24, r24
    463a:	89 2b       	or	r24, r25
    463c:	90 e0       	ldi	r25, 0x00	; 0
    463e:	6b dc       	rcall	.-1834   	; 0x3f16 <csp_port_get_socket>
    4640:	8c 01       	movw	r16, r24

	/* If the socket is connection-less, deliver now */
	if (socket && (socket->opts & CSP_SO_CONN_LESS)) {
    4642:	89 2b       	or	r24, r25
    4644:	09 f0       	breq	.+2      	; 0x4648 <csp_route_work+0x488>
    4646:	0c cf       	rjmp	.-488    	; 0x4460 <csp_route_work+0x2a0>
		}
		return 0;
	}

	/* Search for an existing connection */
	conn = csp_conn_find(packet->id.ext, CSP_ID_CONN_MASK);
    4648:	ed 81       	ldd	r30, Y+5	; 0x05
    464a:	fe 81       	ldd	r31, Y+6	; 0x06
    464c:	62 85       	ldd	r22, Z+10	; 0x0a
    464e:	73 85       	ldd	r23, Z+11	; 0x0b
    4650:	84 85       	ldd	r24, Z+12	; 0x0c
    4652:	95 85       	ldd	r25, Z+13	; 0x0d
    4654:	20 e0       	ldi	r18, 0x00	; 0
    4656:	3f ef       	ldi	r19, 0xFF	; 255
    4658:	4f ef       	ldi	r20, 0xFF	; 255
    465a:	5f e3       	ldi	r21, 0x3F	; 63
    465c:	0e 94 88 18 	call	0x3110	; 0x3110 <csp_conn_find>
    4660:	7c 01       	movw	r14, r24

	/* If this is an incoming packet on a new connection */
	if (conn == NULL) {
    4662:	89 2b       	or	r24, r25
    4664:	09 f0       	breq	.+2      	; 0x4668 <csp_route_work+0x4a8>
    4666:	bc cf       	rjmp	.-136    	; 0x45e0 <csp_route_work+0x420>
    4668:	3c cf       	rjmp	.-392    	; 0x44e2 <csp_route_work+0x322>
		}
		return 0;
	}

	/* Search for an existing connection */
	conn = csp_conn_find(packet->id.ext, CSP_ID_CONN_MASK);
    466a:	ed 81       	ldd	r30, Y+5	; 0x05
    466c:	fe 81       	ldd	r31, Y+6	; 0x06
    466e:	62 85       	ldd	r22, Z+10	; 0x0a
    4670:	73 85       	ldd	r23, Z+11	; 0x0b
    4672:	84 85       	ldd	r24, Z+12	; 0x0c
    4674:	95 85       	ldd	r25, Z+13	; 0x0d
    4676:	20 e0       	ldi	r18, 0x00	; 0
    4678:	3f ef       	ldi	r19, 0xFF	; 255
    467a:	4f ef       	ldi	r20, 0xFF	; 255
    467c:	5f e3       	ldi	r21, 0x3F	; 63
    467e:	0e 94 88 18 	call	0x3110	; 0x3110 <csp_conn_find>
    4682:	7c 01       	movw	r14, r24

	/* If this is an incoming packet on a new connection */
	if (conn == NULL) {
    4684:	89 2b       	or	r24, r25
    4686:	09 f0       	breq	.+2      	; 0x468a <csp_route_work+0x4ca>
    4688:	ab cf       	rjmp	.-170    	; 0x45e0 <csp_route_work+0x420>
    468a:	30 cf       	rjmp	.-416    	; 0x44ec <csp_route_work+0x32c>
#endif

	/* Pass packet to UDP module */
	csp_udp_new_packet(conn, packet);
	return 0;
}
    468c:	c6 01       	movw	r24, r12
    468e:	26 96       	adiw	r28, 0x06	; 6
    4690:	0f b6       	in	r0, 0x3f	; 63
    4692:	f8 94       	cli
    4694:	de bf       	out	0x3e, r29	; 62
    4696:	0f be       	out	0x3f, r0	; 63
    4698:	cd bf       	out	0x3d, r28	; 61
    469a:	df 91       	pop	r29
    469c:	cf 91       	pop	r28
    469e:	1f 91       	pop	r17
    46a0:	0f 91       	pop	r16
    46a2:	ff 90       	pop	r15
    46a4:	ef 90       	pop	r14
    46a6:	df 90       	pop	r13
    46a8:	cf 90       	pop	r12
    46aa:	bf 90       	pop	r11
    46ac:	af 90       	pop	r10
    46ae:	9f 90       	pop	r9
    46b0:	8f 90       	pop	r8
    46b2:	7f 90       	pop	r7
    46b4:	6f 90       	pop	r6
    46b6:	08 95       	ret

000046b8 <csp_task_router>:

CSP_DEFINE_TASK(csp_task_router) {

	/* Here there be routing */
	while (1) {
		csp_route_work(FIFO_TIMEOUT);
    46b8:	6f ef       	ldi	r22, 0xFF	; 255
    46ba:	7f ef       	ldi	r23, 0xFF	; 255
    46bc:	cb 01       	movw	r24, r22
    46be:	80 dd       	rcall	.-1280   	; 0x41c0 <csp_route_work>
    46c0:	fb cf       	rjmp	.-10     	; 0x46b8 <csp_task_router>

000046c2 <csp_route_start_task>:
	}

}

int csp_route_start_task(unsigned int task_stack_size, unsigned int priority) {
    46c2:	ef 92       	push	r14
    46c4:	ff 92       	push	r15
    46c6:	0f 93       	push	r16
    46c8:	1f 93       	push	r17

	static csp_thread_handle_t handle_router;
	int ret = csp_thread_create(csp_task_router, "RTE", task_stack_size, NULL, priority, &handle_router);
    46ca:	0f 2e       	mov	r0, r31
    46cc:	f7 e6       	ldi	r31, 0x67	; 103
    46ce:	ef 2e       	mov	r14, r31
    46d0:	ff e1       	ldi	r31, 0x1F	; 31
    46d2:	ff 2e       	mov	r15, r31
    46d4:	f0 2d       	mov	r31, r0
    46d6:	8b 01       	movw	r16, r22
    46d8:	20 e0       	ldi	r18, 0x00	; 0
    46da:	30 e0       	ldi	r19, 0x00	; 0
    46dc:	ac 01       	movw	r20, r24
    46de:	68 e5       	ldi	r22, 0x58	; 88
    46e0:	73 e0       	ldi	r23, 0x03	; 3
    46e2:	8c e5       	ldi	r24, 0x5C	; 92
    46e4:	93 e2       	ldi	r25, 0x23	; 35
    46e6:	0e 94 c2 14 	call	0x2984	; 0x2984 <csp_thread_create>

	if (ret != 0) {
    46ea:	89 2b       	or	r24, r25
    46ec:	09 f1       	breq	.+66     	; 0x4730 <csp_route_start_task+0x6e>
		csp_log_error("Failed to start router task");
    46ee:	80 91 04 02 	lds	r24, 0x0204	; 0x800204 <csp_debug_level_enabled>
    46f2:	88 23       	and	r24, r24
    46f4:	01 f1       	breq	.+64     	; 0x4736 <csp_route_start_task+0x74>
    46f6:	ef d8       	rcall	.-3618   	; 0x38d6 <csp_get_address>
    46f8:	91 e0       	ldi	r25, 0x01	; 1
    46fa:	9f 93       	push	r25
    46fc:	9b e4       	ldi	r25, 0x4B	; 75
    46fe:	9f 93       	push	r25
    4700:	2c e4       	ldi	r18, 0x4C	; 76
    4702:	33 e0       	ldi	r19, 0x03	; 3
    4704:	3f 93       	push	r19
    4706:	2f 93       	push	r18
    4708:	1f 92       	push	r1
    470a:	8f 93       	push	r24
    470c:	88 e3       	ldi	r24, 0x38	; 56
    470e:	9a e0       	ldi	r25, 0x0A	; 10
    4710:	9f 93       	push	r25
    4712:	8f 93       	push	r24
    4714:	1f 92       	push	r1
    4716:	0e 94 83 1b 	call	0x3706	; 0x3706 <do_csp_debug>
    471a:	8d b7       	in	r24, 0x3d	; 61
    471c:	9e b7       	in	r25, 0x3e	; 62
    471e:	09 96       	adiw	r24, 0x09	; 9
    4720:	0f b6       	in	r0, 0x3f	; 63
    4722:	f8 94       	cli
    4724:	9e bf       	out	0x3e, r25	; 62
    4726:	0f be       	out	0x3f, r0	; 63
    4728:	8d bf       	out	0x3d, r24	; 61
		return CSP_ERR_NOMEM;
    472a:	8f ef       	ldi	r24, 0xFF	; 255
    472c:	9f ef       	ldi	r25, 0xFF	; 255
    472e:	05 c0       	rjmp	.+10     	; 0x473a <csp_route_start_task+0x78>
	}

	return CSP_ERR_NONE;
    4730:	80 e0       	ldi	r24, 0x00	; 0
    4732:	90 e0       	ldi	r25, 0x00	; 0
    4734:	02 c0       	rjmp	.+4      	; 0x473a <csp_route_start_task+0x78>
	static csp_thread_handle_t handle_router;
	int ret = csp_thread_create(csp_task_router, "RTE", task_stack_size, NULL, priority, &handle_router);

	if (ret != 0) {
		csp_log_error("Failed to start router task");
		return CSP_ERR_NOMEM;
    4736:	8f ef       	ldi	r24, 0xFF	; 255
    4738:	9f ef       	ldi	r25, 0xFF	; 255
	}

	return CSP_ERR_NONE;

}
    473a:	1f 91       	pop	r17
    473c:	0f 91       	pop	r16
    473e:	ff 90       	pop	r15
    4740:	ef 90       	pop	r14
    4742:	08 95       	ret

00004744 <csp_i2c_tx>:
#include <csp/interfaces/csp_if_i2c.h>
#include <csp/drivers/i2c.h>

static int csp_i2c_handle = 0;

int csp_i2c_tx(csp_iface_t * interface, csp_packet_t * packet, uint32_t timeout) {
    4744:	cf 92       	push	r12
    4746:	df 92       	push	r13
    4748:	ef 92       	push	r14
    474a:	ff 92       	push	r15
    474c:	cf 93       	push	r28
    474e:	df 93       	push	r29
    4750:	eb 01       	movw	r28, r22
    4752:	69 01       	movw	r12, r18
    4754:	7a 01       	movw	r14, r20

	/* Cast the CSP packet buffer into an i2c frame */
	i2c_frame_t * frame = (i2c_frame_t *) packet;

	/* Insert destination node into the i2c destination field */
	if (csp_rtable_find_mac(packet->id.dst) == CSP_NODE_MAC) {
    4756:	9c 85       	ldd	r25, Y+12	; 0x0c
    4758:	92 95       	swap	r25
    475a:	9f 70       	andi	r25, 0x0F	; 15
    475c:	8d 85       	ldd	r24, Y+13	; 0x0d
    475e:	81 70       	andi	r24, 0x01	; 1
    4760:	82 95       	swap	r24
    4762:	80 7f       	andi	r24, 0xF0	; 240
    4764:	89 2b       	or	r24, r25
    4766:	ef d0       	rcall	.+478    	; 0x4946 <csp_rtable_find_mac>
    4768:	8f 3f       	cpi	r24, 0xFF	; 255
    476a:	59 f4       	brne	.+22     	; 0x4782 <csp_i2c_tx+0x3e>
		frame->dest = packet->id.dst;
    476c:	8c 85       	ldd	r24, Y+12	; 0x0c
    476e:	98 2f       	mov	r25, r24
    4770:	92 95       	swap	r25
    4772:	9f 70       	andi	r25, 0x0F	; 15
    4774:	8d 85       	ldd	r24, Y+13	; 0x0d
    4776:	81 70       	andi	r24, 0x01	; 1
    4778:	82 95       	swap	r24
    477a:	80 7f       	andi	r24, 0xF0	; 240
    477c:	89 2b       	or	r24, r25
    477e:	8e 83       	std	Y+6, r24	; 0x06
    4780:	0a c0       	rjmp	.+20     	; 0x4796 <csp_i2c_tx+0x52>
	} else {
		frame->dest = csp_rtable_find_mac(packet->id.dst);
    4782:	9c 85       	ldd	r25, Y+12	; 0x0c
    4784:	92 95       	swap	r25
    4786:	9f 70       	andi	r25, 0x0F	; 15
    4788:	8d 85       	ldd	r24, Y+13	; 0x0d
    478a:	81 70       	andi	r24, 0x01	; 1
    478c:	82 95       	swap	r24
    478e:	80 7f       	andi	r24, 0xF0	; 240
    4790:	89 2b       	or	r24, r25
    4792:	d9 d0       	rcall	.+434    	; 0x4946 <csp_rtable_find_mac>
    4794:	8e 83       	std	Y+6, r24	; 0x06
	}

	/* Save the outgoing id in the buffer */
	packet->id.ext = csp_hton32(packet->id.ext);
    4796:	6a 85       	ldd	r22, Y+10	; 0x0a
    4798:	7b 85       	ldd	r23, Y+11	; 0x0b
    479a:	8c 85       	ldd	r24, Y+12	; 0x0c
    479c:	9d 85       	ldd	r25, Y+13	; 0x0d
    479e:	08 d8       	rcall	.-4080   	; 0x37b0 <csp_hton32>
    47a0:	6a 87       	std	Y+10, r22	; 0x0a
    47a2:	7b 87       	std	Y+11, r23	; 0x0b
    47a4:	8c 87       	std	Y+12, r24	; 0x0c
    47a6:	9d 87       	std	Y+13, r25	; 0x0d

	/* Add the CSP header to the I2C length field */
	frame->len += sizeof(packet->id);
    47a8:	88 85       	ldd	r24, Y+8	; 0x08
    47aa:	99 85       	ldd	r25, Y+9	; 0x09
    47ac:	04 96       	adiw	r24, 0x04	; 4
    47ae:	99 87       	std	Y+9, r25	; 0x09
    47b0:	88 87       	std	Y+8, r24	; 0x08
	frame->len_rx = 0;
    47b2:	1f 82       	std	Y+7, r1	; 0x07

	/* Some I2C drivers support X number of retries
	 * CSP don't care about this. If it doesn't work the first
	 * time, don'y use time on it.
	 */
	frame->retries = 0;
    47b4:	19 82       	std	Y+1, r1	; 0x01

	/* enqueue the frame */
	if (i2c_send(csp_i2c_handle, frame, timeout) != E_NO_ERR)
    47b6:	a6 01       	movw	r20, r12
    47b8:	be 01       	movw	r22, r28
    47ba:	80 91 6b 1f 	lds	r24, 0x1F6B	; 0x801f6b <csp_i2c_handle>
    47be:	90 91 6c 1f 	lds	r25, 0x1F6C	; 0x801f6c <csp_i2c_handle+0x1>
    47c2:	04 d3       	rcall	.+1544   	; 0x4dcc <i2c_send>
    47c4:	01 96       	adiw	r24, 0x01	; 1
    47c6:	19 f4       	brne	.+6      	; 0x47ce <csp_i2c_tx+0x8a>
		return CSP_ERR_DRIVER;

	return CSP_ERR_NONE;
    47c8:	80 e0       	ldi	r24, 0x00	; 0
    47ca:	90 e0       	ldi	r25, 0x00	; 0
    47cc:	02 c0       	rjmp	.+4      	; 0x47d2 <csp_i2c_tx+0x8e>
	 */
	frame->retries = 0;

	/* enqueue the frame */
	if (i2c_send(csp_i2c_handle, frame, timeout) != E_NO_ERR)
		return CSP_ERR_DRIVER;
    47ce:	85 ef       	ldi	r24, 0xF5	; 245
    47d0:	9f ef       	ldi	r25, 0xFF	; 255

	return CSP_ERR_NONE;

}
    47d2:	df 91       	pop	r29
    47d4:	cf 91       	pop	r28
    47d6:	ff 90       	pop	r15
    47d8:	ef 90       	pop	r14
    47da:	df 90       	pop	r13
    47dc:	cf 90       	pop	r12
    47de:	08 95       	ret

000047e0 <csp_i2c_rx>:
 * When a frame is received, cast it to a csp_packet
 * and send it directly to the CSP new packet function.
 * Context: ISR only
 * @param frame
 */
void csp_i2c_rx(i2c_frame_t * frame, void * pxTaskWoken) {
    47e0:	0f 93       	push	r16
    47e2:	1f 93       	push	r17
    47e4:	cf 93       	push	r28
    47e6:	df 93       	push	r29
	
	static csp_packet_t * packet;

	/* Validate input */
	if (frame == NULL)
    47e8:	00 97       	sbiw	r24, 0x00	; 0
    47ea:	89 f1       	breq	.+98     	; 0x484e <csp_i2c_rx+0x6e>
    47ec:	8b 01       	movw	r16, r22
    47ee:	ec 01       	movw	r28, r24
		return;

	if ((frame->len < 4) || (frame->len > I2C_MTU)) {
    47f0:	88 85       	ldd	r24, Y+8	; 0x08
    47f2:	99 85       	ldd	r25, Y+9	; 0x09
    47f4:	04 97       	sbiw	r24, 0x04	; 4
    47f6:	8d 3f       	cpi	r24, 0xFD	; 253
    47f8:	91 05       	cpc	r25, r1
    47fa:	88 f0       	brcs	.+34     	; 0x481e <csp_i2c_rx+0x3e>
		csp_if_i2c.frame++;
    47fc:	eb e0       	ldi	r30, 0x0B	; 11
    47fe:	f2 e0       	ldi	r31, 0x02	; 2
    4800:	81 a1       	ldd	r24, Z+33	; 0x21
    4802:	92 a1       	ldd	r25, Z+34	; 0x22
    4804:	a3 a1       	ldd	r26, Z+35	; 0x23
    4806:	b4 a1       	ldd	r27, Z+36	; 0x24
    4808:	01 96       	adiw	r24, 0x01	; 1
    480a:	a1 1d       	adc	r26, r1
    480c:	b1 1d       	adc	r27, r1
    480e:	81 a3       	std	Z+33, r24	; 0x21
    4810:	92 a3       	std	Z+34, r25	; 0x22
    4812:	a3 a3       	std	Z+35, r26	; 0x23
    4814:	b4 a3       	std	Z+36, r27	; 0x24
		csp_buffer_free_isr(frame);
    4816:	ce 01       	movw	r24, r28
    4818:	0e 94 5d 16 	call	0x2cba	; 0x2cba <csp_buffer_free_isr>
		return;
    481c:	18 c0       	rjmp	.+48     	; 0x484e <csp_i2c_rx+0x6e>
	}

	/* Strip the CSP header off the length field before converting to CSP packet */
	frame->len -= sizeof(csp_id_t);
    481e:	99 87       	std	Y+9, r25	; 0x09
    4820:	88 87       	std	Y+8, r24	; 0x08

	/* Convert the packet from network to host order */
	packet = (csp_packet_t *) frame;
    4822:	d0 93 6a 1f 	sts	0x1F6A, r29	; 0x801f6a <packet.2416+0x1>
    4826:	c0 93 69 1f 	sts	0x1F69, r28	; 0x801f69 <packet.2416>
	packet->id.ext = csp_ntoh32(packet->id.ext);
    482a:	6a 85       	ldd	r22, Y+10	; 0x0a
    482c:	7b 85       	ldd	r23, Y+11	; 0x0b
    482e:	8c 85       	ldd	r24, Y+12	; 0x0c
    4830:	9d 85       	ldd	r25, Y+13	; 0x0d
    4832:	0e 94 0d 1c 	call	0x381a	; 0x381a <csp_ntoh32>
    4836:	6a 87       	std	Y+10, r22	; 0x0a
    4838:	7b 87       	std	Y+11, r23	; 0x0b
    483a:	8c 87       	std	Y+12, r24	; 0x0c
    483c:	9d 87       	std	Y+13, r25	; 0x0d

	/* Receive the packet in CSP */
	csp_new_packet(packet, &csp_if_i2c, pxTaskWoken);
    483e:	a8 01       	movw	r20, r16
    4840:	6b e0       	ldi	r22, 0x0B	; 11
    4842:	72 e0       	ldi	r23, 0x02	; 2
    4844:	80 91 69 1f 	lds	r24, 0x1F69	; 0x801f69 <packet.2416>
    4848:	90 91 6a 1f 	lds	r25, 0x1F6A	; 0x801f6a <packet.2416+0x1>
    484c:	bf db       	rcall	.-2178   	; 0x3fcc <csp_qfifo_write>

}
    484e:	df 91       	pop	r29
    4850:	cf 91       	pop	r28
    4852:	1f 91       	pop	r17
    4854:	0f 91       	pop	r16
    4856:	08 95       	ret

00004858 <csp_i2c_init>:

int csp_i2c_init(uint8_t addr, int handle, int speed) {
    4858:	cf 92       	push	r12
    485a:	df 92       	push	r13
    485c:	ef 92       	push	r14
    485e:	ff 92       	push	r15
    4860:	0f 93       	push	r16
    4862:	1f 93       	push	r17
    4864:	e8 2f       	mov	r30, r24
    4866:	cb 01       	movw	r24, r22
    4868:	9a 01       	movw	r18, r20

	/* Create i2c_handle */
	csp_i2c_handle = handle;
    486a:	70 93 6c 1f 	sts	0x1F6C, r23	; 0x801f6c <csp_i2c_handle+0x1>
    486e:	60 93 6b 1f 	sts	0x1F6B, r22	; 0x801f6b <csp_i2c_handle>
	if (i2c_init(csp_i2c_handle, I2C_MASTER, addr, speed, 10, 10, csp_i2c_rx) != E_NO_ERR)
    4872:	0f 2e       	mov	r0, r31
    4874:	f0 ef       	ldi	r31, 0xF0	; 240
    4876:	cf 2e       	mov	r12, r31
    4878:	f3 e2       	ldi	r31, 0x23	; 35
    487a:	df 2e       	mov	r13, r31
    487c:	f0 2d       	mov	r31, r0
    487e:	0f 2e       	mov	r0, r31
    4880:	fa e0       	ldi	r31, 0x0A	; 10
    4882:	ef 2e       	mov	r14, r31
    4884:	f1 2c       	mov	r15, r1
    4886:	f0 2d       	mov	r31, r0
    4888:	0a e0       	ldi	r16, 0x0A	; 10
    488a:	10 e0       	ldi	r17, 0x00	; 0
    488c:	4e 2f       	mov	r20, r30
    488e:	60 e0       	ldi	r22, 0x00	; 0
    4890:	70 e0       	ldi	r23, 0x00	; 0
    4892:	17 d2       	rcall	.+1070   	; 0x4cc2 <i2c_init>
    4894:	01 96       	adiw	r24, 0x01	; 1
    4896:	39 f4       	brne	.+14     	; 0x48a6 <csp_i2c_init+0x4e>
		return CSP_ERR_DRIVER;

	/* Register interface */
	csp_iflist_add(&csp_if_i2c);
    4898:	8b e0       	ldi	r24, 0x0B	; 11
    489a:	92 e0       	ldi	r25, 0x02	; 2
    489c:	0e 94 42 1c 	call	0x3884	; 0x3884 <csp_iflist_add>

	return CSP_ERR_NONE;
    48a0:	80 e0       	ldi	r24, 0x00	; 0
    48a2:	90 e0       	ldi	r25, 0x00	; 0
    48a4:	02 c0       	rjmp	.+4      	; 0x48aa <csp_i2c_init+0x52>
int csp_i2c_init(uint8_t addr, int handle, int speed) {

	/* Create i2c_handle */
	csp_i2c_handle = handle;
	if (i2c_init(csp_i2c_handle, I2C_MASTER, addr, speed, 10, 10, csp_i2c_rx) != E_NO_ERR)
		return CSP_ERR_DRIVER;
    48a6:	85 ef       	ldi	r24, 0xF5	; 245
    48a8:	9f ef       	ldi	r25, 0xFF	; 255
	/* Register interface */
	csp_iflist_add(&csp_if_i2c);

	return CSP_ERR_NONE;

}
    48aa:	1f 91       	pop	r17
    48ac:	0f 91       	pop	r16
    48ae:	ff 90       	pop	r15
    48b0:	ef 90       	pop	r14
    48b2:	df 90       	pop	r13
    48b4:	cf 90       	pop	r12
    48b6:	08 95       	ret

000048b8 <csp_lo_tx>:
 * Loopback interface transmit function
 * @param packet Packet to transmit
 * @param timeout Timout in ms
 * @return 1 if packet was successfully transmitted, 0 on error
 */
int csp_lo_tx(csp_iface_t * interface, csp_packet_t * packet, uint32_t timeout) {
    48b8:	0f 93       	push	r16
    48ba:	1f 93       	push	r17
    48bc:	cf 93       	push	r28
    48be:	df 93       	push	r29
    48c0:	8b 01       	movw	r16, r22

	/* Drop packet silently if not destined for us. This allows
	 * blackhole routing addresses by setting their nexthop to
	 * the loopback interface.
	 */
	if (packet->id.dst != csp_get_address()) {
    48c2:	fb 01       	movw	r30, r22
    48c4:	c4 85       	ldd	r28, Z+12	; 0x0c
    48c6:	8c 2f       	mov	r24, r28
    48c8:	82 95       	swap	r24
    48ca:	8f 70       	andi	r24, 0x0F	; 15
    48cc:	c5 85       	ldd	r28, Z+13	; 0x0d
    48ce:	c1 70       	andi	r28, 0x01	; 1
    48d0:	c2 95       	swap	r28
    48d2:	c0 7f       	andi	r28, 0xF0	; 240
    48d4:	c8 2b       	or	r28, r24
    48d6:	d0 e0       	ldi	r29, 0x00	; 0
    48d8:	0e 94 6b 1c 	call	0x38d6	; 0x38d6 <csp_get_address>
    48dc:	90 e0       	ldi	r25, 0x00	; 0
    48de:	c8 17       	cp	r28, r24
    48e0:	d9 07       	cpc	r29, r25
    48e2:	21 f0       	breq	.+8      	; 0x48ec <csp_lo_tx+0x34>
		/* Consume and drop packet */
		csp_buffer_free(packet);
    48e4:	c8 01       	movw	r24, r16
    48e6:	0e 94 95 16 	call	0x2d2a	; 0x2d2a <csp_buffer_free>
		return CSP_ERR_NONE;
    48ea:	06 c0       	rjmp	.+12     	; 0x48f8 <csp_lo_tx+0x40>
	}

	/* Send back into CSP, notice calling from task so last argument must be NULL! */
	csp_qfifo_write(packet, &csp_if_lo, NULL);
    48ec:	40 e0       	ldi	r20, 0x00	; 0
    48ee:	50 e0       	ldi	r21, 0x00	; 0
    48f0:	6e e3       	ldi	r22, 0x3E	; 62
    48f2:	72 e0       	ldi	r23, 0x02	; 2
    48f4:	c8 01       	movw	r24, r16
    48f6:	6a db       	rcall	.-2348   	; 0x3fcc <csp_qfifo_write>

	return CSP_ERR_NONE;

}
    48f8:	80 e0       	ldi	r24, 0x00	; 0
    48fa:	90 e0       	ldi	r25, 0x00	; 0
    48fc:	df 91       	pop	r29
    48fe:	cf 91       	pop	r28
    4900:	1f 91       	pop	r17
    4902:	0f 91       	pop	r16
    4904:	08 95       	ret

00004906 <csp_rtable_find_iface>:
void csp_route_table_load(uint8_t route_table_in[CSP_ROUTE_TABLE_SIZE]) {
	memcpy(routes, route_table_in, sizeof(routes[0]) * CSP_ROUTE_COUNT);
}

void csp_route_table_save(uint8_t route_table_out[CSP_ROUTE_TABLE_SIZE]) {
	memcpy(route_table_out, routes, sizeof(routes[0]) * CSP_ROUTE_COUNT);
    4906:	90 e0       	ldi	r25, 0x00	; 0
    4908:	fc 01       	movw	r30, r24
    490a:	ee 0f       	add	r30, r30
    490c:	ff 1f       	adc	r31, r31
    490e:	e8 0f       	add	r30, r24
    4910:	f9 1f       	adc	r31, r25
    4912:	e3 59       	subi	r30, 0x93	; 147
    4914:	f0 4e       	sbci	r31, 0xE0	; 224
    4916:	20 81       	ld	r18, Z
    4918:	31 81       	ldd	r19, Z+1	; 0x01
    491a:	23 2b       	or	r18, r19
    491c:	49 f0       	breq	.+18     	; 0x4930 <csp_rtable_find_iface+0x2a>
    491e:	fc 01       	movw	r30, r24
    4920:	ee 0f       	add	r30, r30
    4922:	ff 1f       	adc	r31, r31
    4924:	8e 0f       	add	r24, r30
    4926:	9f 1f       	adc	r25, r31
    4928:	fc 01       	movw	r30, r24
    492a:	e3 59       	subi	r30, 0x93	; 147
    492c:	f0 4e       	sbci	r31, 0xE0	; 224
    492e:	08 c0       	rjmp	.+16     	; 0x4940 <csp_rtable_find_iface+0x3a>
    4930:	80 91 cd 1f 	lds	r24, 0x1FCD	; 0x801fcd <routes+0x60>
    4934:	90 91 ce 1f 	lds	r25, 0x1FCE	; 0x801fce <routes+0x61>
    4938:	00 97       	sbiw	r24, 0x00	; 0
    493a:	21 f0       	breq	.+8      	; 0x4944 <csp_rtable_find_iface+0x3e>
    493c:	ed ec       	ldi	r30, 0xCD	; 205
    493e:	ff e1       	ldi	r31, 0x1F	; 31
    4940:	80 81       	ld	r24, Z
    4942:	91 81       	ldd	r25, Z+1	; 0x01
    4944:	08 95       	ret

00004946 <csp_rtable_find_mac>:
    4946:	90 e0       	ldi	r25, 0x00	; 0
    4948:	fc 01       	movw	r30, r24
    494a:	ee 0f       	add	r30, r30
    494c:	ff 1f       	adc	r31, r31
    494e:	e8 0f       	add	r30, r24
    4950:	f9 1f       	adc	r31, r25
    4952:	e3 59       	subi	r30, 0x93	; 147
    4954:	f0 4e       	sbci	r31, 0xE0	; 224
    4956:	20 81       	ld	r18, Z
    4958:	31 81       	ldd	r19, Z+1	; 0x01
    495a:	23 2b       	or	r18, r19
    495c:	49 f0       	breq	.+18     	; 0x4970 <csp_rtable_find_mac+0x2a>
    495e:	fc 01       	movw	r30, r24
    4960:	ee 0f       	add	r30, r30
    4962:	ff 1f       	adc	r31, r31
    4964:	8e 0f       	add	r24, r30
    4966:	9f 1f       	adc	r25, r31
    4968:	fc 01       	movw	r30, r24
    496a:	e3 59       	subi	r30, 0x93	; 147
    496c:	f0 4e       	sbci	r31, 0xE0	; 224
    496e:	08 c0       	rjmp	.+16     	; 0x4980 <csp_rtable_find_mac+0x3a>
    4970:	80 91 cd 1f 	lds	r24, 0x1FCD	; 0x801fcd <routes+0x60>
    4974:	90 91 ce 1f 	lds	r25, 0x1FCE	; 0x801fce <routes+0x61>
    4978:	89 2b       	or	r24, r25
    497a:	21 f0       	breq	.+8      	; 0x4984 <csp_rtable_find_mac+0x3e>
    497c:	ed ec       	ldi	r30, 0xCD	; 205
    497e:	ff e1       	ldi	r31, 0x1F	; 31
    4980:	82 81       	ldd	r24, Z+2	; 0x02
    4982:	08 95       	ret
    4984:	8f ef       	ldi	r24, 0xFF	; 255
    4986:	08 95       	ret

00004988 <csp_rtable_set>:
}

int csp_rtable_set(uint8_t node, uint8_t mask, csp_iface_t *ifc, uint8_t mac) {
    4988:	0f 93       	push	r16
    498a:	1f 93       	push	r17
    498c:	cf 93       	push	r28
    498e:	df 93       	push	r29

	/* Don't add nothing */
	if (ifc == NULL)
    4990:	41 15       	cp	r20, r1
    4992:	51 05       	cpc	r21, r1
    4994:	d1 f1       	breq	.+116    	; 0x4a0a <csp_rtable_set+0x82>
    4996:	d2 2f       	mov	r29, r18
    4998:	8a 01       	movw	r16, r20
    499a:	c8 2f       	mov	r28, r24
	 * NOTE: For future implementations, interfaces should call
	 * csp_route_add_if in its csp_if_<name>_init function, instead
	 * of registering at first route_set, in order to make the interface
	 * available to network based (CMP) route configuration.
	 */
	csp_iflist_add(ifc);
    499c:	ca 01       	movw	r24, r20
    499e:	0e 94 42 1c 	call	0x3884	; 0x3884 <csp_iflist_add>

	/* Set route */
	if (node <= CSP_DEFAULT_ROUTE) {
    49a2:	c1 32       	cpi	r28, 0x21	; 33
    49a4:	78 f4       	brcc	.+30     	; 0x49c4 <csp_rtable_set+0x3c>
		routes[node].interface = ifc;
    49a6:	8c 2f       	mov	r24, r28
    49a8:	90 e0       	ldi	r25, 0x00	; 0
    49aa:	fc 01       	movw	r30, r24
    49ac:	ee 0f       	add	r30, r30
    49ae:	ff 1f       	adc	r31, r31
    49b0:	e8 0f       	add	r30, r24
    49b2:	f9 1f       	adc	r31, r25
    49b4:	e3 59       	subi	r30, 0x93	; 147
    49b6:	f0 4e       	sbci	r31, 0xE0	; 224
    49b8:	11 83       	std	Z+1, r17	; 0x01
    49ba:	00 83       	st	Z, r16
		routes[node].mac = mac;
    49bc:	d2 83       	std	Z+2, r29	; 0x02
	} else {
		csp_log_error("Failed to set route: invalid node id %u", node);
		return CSP_ERR_INVAL;
	}

	return CSP_ERR_NONE;
    49be:	80 e0       	ldi	r24, 0x00	; 0
    49c0:	90 e0       	ldi	r25, 0x00	; 0
    49c2:	28 c0       	rjmp	.+80     	; 0x4a14 <csp_rtable_set+0x8c>
	/* Set route */
	if (node <= CSP_DEFAULT_ROUTE) {
		routes[node].interface = ifc;
		routes[node].mac = mac;
	} else {
		csp_log_error("Failed to set route: invalid node id %u", node);
    49c4:	80 91 04 02 	lds	r24, 0x0204	; 0x800204 <csp_debug_level_enabled>
    49c8:	88 23       	and	r24, r24
    49ca:	11 f1       	breq	.+68     	; 0x4a10 <csp_rtable_set+0x88>
    49cc:	0e 94 6b 1c 	call	0x38d6	; 0x38d6 <csp_get_address>
    49d0:	1f 92       	push	r1
    49d2:	cf 93       	push	r28
    49d4:	1f 92       	push	r1
    49d6:	95 e6       	ldi	r25, 0x65	; 101
    49d8:	9f 93       	push	r25
    49da:	2e e7       	ldi	r18, 0x7E	; 126
    49dc:	33 e0       	ldi	r19, 0x03	; 3
    49de:	3f 93       	push	r19
    49e0:	2f 93       	push	r18
    49e2:	1f 92       	push	r1
    49e4:	8f 93       	push	r24
    49e6:	83 ef       	ldi	r24, 0xF3	; 243
    49e8:	9c e0       	ldi	r25, 0x0C	; 12
    49ea:	9f 93       	push	r25
    49ec:	8f 93       	push	r24
    49ee:	1f 92       	push	r1
    49f0:	0e 94 83 1b 	call	0x3706	; 0x3706 <do_csp_debug>
    49f4:	8d b7       	in	r24, 0x3d	; 61
    49f6:	9e b7       	in	r25, 0x3e	; 62
    49f8:	0b 96       	adiw	r24, 0x0b	; 11
    49fa:	0f b6       	in	r0, 0x3f	; 63
    49fc:	f8 94       	cli
    49fe:	9e bf       	out	0x3e, r25	; 62
    4a00:	0f be       	out	0x3f, r0	; 63
    4a02:	8d bf       	out	0x3d, r24	; 61
		return CSP_ERR_INVAL;
    4a04:	8e ef       	ldi	r24, 0xFE	; 254
    4a06:	9f ef       	ldi	r25, 0xFF	; 255
    4a08:	05 c0       	rjmp	.+10     	; 0x4a14 <csp_rtable_set+0x8c>

int csp_rtable_set(uint8_t node, uint8_t mask, csp_iface_t *ifc, uint8_t mac) {

	/* Don't add nothing */
	if (ifc == NULL)
		return CSP_ERR_INVAL;
    4a0a:	8e ef       	ldi	r24, 0xFE	; 254
    4a0c:	9f ef       	ldi	r25, 0xFF	; 255
    4a0e:	02 c0       	rjmp	.+4      	; 0x4a14 <csp_rtable_set+0x8c>
	if (node <= CSP_DEFAULT_ROUTE) {
		routes[node].interface = ifc;
		routes[node].mac = mac;
	} else {
		csp_log_error("Failed to set route: invalid node id %u", node);
		return CSP_ERR_INVAL;
    4a10:	8e ef       	ldi	r24, 0xFE	; 254
    4a12:	9f ef       	ldi	r25, 0xFF	; 255
	}

	return CSP_ERR_NONE;

}
    4a14:	df 91       	pop	r29
    4a16:	cf 91       	pop	r28
    4a18:	1f 91       	pop	r17
    4a1a:	0f 91       	pop	r16
    4a1c:	08 95       	ret

00004a1e <csp_rtable_print>:

#ifdef CSP_DEBUG
void csp_rtable_print(void) {
    4a1e:	ef 92       	push	r14
    4a20:	ff 92       	push	r15
    4a22:	0f 93       	push	r16
    4a24:	1f 93       	push	r17
    4a26:	cf 93       	push	r28
    4a28:	df 93       	push	r29
	int i;
	printf("Node  Interface  Address\r\n");
    4a2a:	88 ed       	ldi	r24, 0xD8	; 216
    4a2c:	9c e0       	ldi	r25, 0x0C	; 12
    4a2e:	9f 93       	push	r25
    4a30:	8f 93       	push	r24
    4a32:	7e d7       	rcall	.+3836   	; 0x5930 <printf_P>
    4a34:	0d e6       	ldi	r16, 0x6D	; 109
    4a36:	1f e1       	ldi	r17, 0x1F	; 31
    4a38:	0f 90       	pop	r0
    4a3a:	0f 90       	pop	r0
	for (i = 0; i < CSP_DEFAULT_ROUTE; i++)
    4a3c:	c0 e0       	ldi	r28, 0x00	; 0
    4a3e:	d0 e0       	ldi	r29, 0x00	; 0
		if (routes[i].interface != NULL)
			printf("%4u  %-9s  %u\r\n", i,
    4a40:	0f 2e       	mov	r0, r31
    4a42:	f8 ec       	ldi	r31, 0xC8	; 200
    4a44:	ef 2e       	mov	r14, r31
    4a46:	fc e0       	ldi	r31, 0x0C	; 12
    4a48:	ff 2e       	mov	r15, r31
    4a4a:	f0 2d       	mov	r31, r0
#ifdef CSP_DEBUG
void csp_rtable_print(void) {
	int i;
	printf("Node  Interface  Address\r\n");
	for (i = 0; i < CSP_DEFAULT_ROUTE; i++)
		if (routes[i].interface != NULL)
    4a4c:	d8 01       	movw	r26, r16
    4a4e:	ed 91       	ld	r30, X+
    4a50:	fc 91       	ld	r31, X
    4a52:	11 97       	sbiw	r26, 0x01	; 1
    4a54:	30 97       	sbiw	r30, 0x00	; 0
    4a56:	d1 f0       	breq	.+52     	; 0x4a8c <csp_rtable_print+0x6e>
			printf("%4u  %-9s  %u\r\n", i,
    4a58:	12 96       	adiw	r26, 0x02	; 2
    4a5a:	8c 91       	ld	r24, X
    4a5c:	8f 3f       	cpi	r24, 0xFF	; 255
    4a5e:	11 f0       	breq	.+4      	; 0x4a64 <csp_rtable_print+0x46>
    4a60:	90 e0       	ldi	r25, 0x00	; 0
    4a62:	01 c0       	rjmp	.+2      	; 0x4a66 <csp_rtable_print+0x48>
    4a64:	ce 01       	movw	r24, r28
    4a66:	9f 93       	push	r25
    4a68:	8f 93       	push	r24
    4a6a:	81 81       	ldd	r24, Z+1	; 0x01
    4a6c:	8f 93       	push	r24
    4a6e:	80 81       	ld	r24, Z
    4a70:	8f 93       	push	r24
    4a72:	df 93       	push	r29
    4a74:	cf 93       	push	r28
    4a76:	ff 92       	push	r15
    4a78:	ef 92       	push	r14
    4a7a:	5a d7       	rcall	.+3764   	; 0x5930 <printf_P>
    4a7c:	ad b7       	in	r26, 0x3d	; 61
    4a7e:	be b7       	in	r27, 0x3e	; 62
    4a80:	18 96       	adiw	r26, 0x08	; 8
    4a82:	0f b6       	in	r0, 0x3f	; 63
    4a84:	f8 94       	cli
    4a86:	be bf       	out	0x3e, r27	; 62
    4a88:	0f be       	out	0x3f, r0	; 63
    4a8a:	ad bf       	out	0x3d, r26	; 61

#ifdef CSP_DEBUG
void csp_rtable_print(void) {
	int i;
	printf("Node  Interface  Address\r\n");
	for (i = 0; i < CSP_DEFAULT_ROUTE; i++)
    4a8c:	21 96       	adiw	r28, 0x01	; 1
    4a8e:	0d 5f       	subi	r16, 0xFD	; 253
    4a90:	1f 4f       	sbci	r17, 0xFF	; 255
    4a92:	c0 32       	cpi	r28, 0x20	; 32
    4a94:	d1 05       	cpc	r29, r1
    4a96:	d1 f6       	brne	.-76     	; 0x4a4c <csp_rtable_print+0x2e>
		if (routes[i].interface != NULL)
			printf("%4u  %-9s  %u\r\n", i,
				routes[i].interface->name,
				routes[i].mac == CSP_NODE_MAC ? i : routes[i].mac);
	printf("   *  %-9s  %u\r\n", routes[CSP_DEFAULT_ROUTE].interface->name, routes[CSP_DEFAULT_ROUTE].mac);
    4a98:	80 91 cf 1f 	lds	r24, 0x1FCF	; 0x801fcf <routes+0x62>
    4a9c:	1f 92       	push	r1
    4a9e:	8f 93       	push	r24
    4aa0:	e0 91 cd 1f 	lds	r30, 0x1FCD	; 0x801fcd <routes+0x60>
    4aa4:	f0 91 ce 1f 	lds	r31, 0x1FCE	; 0x801fce <routes+0x61>
    4aa8:	81 81       	ldd	r24, Z+1	; 0x01
    4aaa:	8f 93       	push	r24
    4aac:	80 81       	ld	r24, Z
    4aae:	8f 93       	push	r24
    4ab0:	87 eb       	ldi	r24, 0xB7	; 183
    4ab2:	9c e0       	ldi	r25, 0x0C	; 12
    4ab4:	9f 93       	push	r25
    4ab6:	8f 93       	push	r24
    4ab8:	3b d7       	rcall	.+3702   	; 0x5930 <printf_P>

}
    4aba:	0f 90       	pop	r0
    4abc:	0f 90       	pop	r0
    4abe:	0f 90       	pop	r0
    4ac0:	0f 90       	pop	r0
    4ac2:	0f 90       	pop	r0
    4ac4:	0f 90       	pop	r0
    4ac6:	df 91       	pop	r29
    4ac8:	cf 91       	pop	r28
    4aca:	1f 91       	pop	r17
    4acc:	0f 91       	pop	r16
    4ace:	ff 90       	pop	r15
    4ad0:	ef 90       	pop	r14
    4ad2:	08 95       	ret

00004ad4 <csp_udp_new_packet>:
#include <csp/csp.h>
#include <csp/arch/csp_queue.h>
#include "../csp_port.h"
#include "../csp_conn.h"

void csp_udp_new_packet(csp_conn_t * conn, csp_packet_t * packet) {
    4ad4:	0f 93       	push	r16
    4ad6:	1f 93       	push	r17
    4ad8:	cf 93       	push	r28
    4ada:	df 93       	push	r29
    4adc:	1f 92       	push	r1
    4ade:	1f 92       	push	r1
    4ae0:	cd b7       	in	r28, 0x3d	; 61
    4ae2:	de b7       	in	r29, 0x3e	; 62
    4ae4:	9a 83       	std	Y+2, r25	; 0x02
    4ae6:	89 83       	std	Y+1, r24	; 0x01
    4ae8:	8b 01       	movw	r16, r22

	/* Enqueue */
	if (csp_conn_enqueue_packet(conn, packet) < 0) {
    4aea:	0e 94 8b 17 	call	0x2f16	; 0x2f16 <csp_conn_enqueue_packet>
    4aee:	99 23       	and	r25, r25
    4af0:	fc f4       	brge	.+62     	; 0x4b30 <csp_udp_new_packet+0x5c>
		csp_log_error("Connection buffer queue full!");
    4af2:	80 91 04 02 	lds	r24, 0x0204	; 0x800204 <csp_debug_level_enabled>
    4af6:	88 23       	and	r24, r24
    4af8:	b9 f0       	breq	.+46     	; 0x4b28 <csp_udp_new_packet+0x54>
    4afa:	0e 94 6b 1c 	call	0x38d6	; 0x38d6 <csp_get_address>
    4afe:	1f 92       	push	r1
    4b00:	9e e1       	ldi	r25, 0x1E	; 30
    4b02:	9f 93       	push	r25
    4b04:	2e ea       	ldi	r18, 0xAE	; 174
    4b06:	33 e0       	ldi	r19, 0x03	; 3
    4b08:	3f 93       	push	r19
    4b0a:	2f 93       	push	r18
    4b0c:	1f 92       	push	r1
    4b0e:	8f 93       	push	r24
    4b10:	8a e5       	ldi	r24, 0x5A	; 90
    4b12:	9d e0       	ldi	r25, 0x0D	; 13
    4b14:	9f 93       	push	r25
    4b16:	8f 93       	push	r24
    4b18:	1f 92       	push	r1
    4b1a:	0e 94 83 1b 	call	0x3706	; 0x3706 <do_csp_debug>
    4b1e:	0f b6       	in	r0, 0x3f	; 63
    4b20:	f8 94       	cli
    4b22:	de bf       	out	0x3e, r29	; 62
    4b24:	0f be       	out	0x3f, r0	; 63
    4b26:	cd bf       	out	0x3d, r28	; 61
		csp_buffer_free(packet);
    4b28:	c8 01       	movw	r24, r16
    4b2a:	0e 94 95 16 	call	0x2d2a	; 0x2d2a <csp_buffer_free>
		return;
    4b2e:	35 c0       	rjmp	.+106    	; 0x4b9a <csp_udp_new_packet+0xc6>
	}

	/* Try to queue up the new connection pointer */
	if (conn->socket != NULL) {
    4b30:	e9 81       	ldd	r30, Y+1	; 0x01
    4b32:	fa 81       	ldd	r31, Y+2	; 0x02
    4b34:	86 85       	ldd	r24, Z+14	; 0x0e
    4b36:	97 85       	ldd	r25, Z+15	; 0x0f
    4b38:	00 97       	sbiw	r24, 0x00	; 0
    4b3a:	79 f1       	breq	.+94     	; 0x4b9a <csp_udp_new_packet+0xc6>
		if (csp_queue_enqueue(conn->socket, &conn, 0) != CSP_QUEUE_OK) {
    4b3c:	20 e0       	ldi	r18, 0x00	; 0
    4b3e:	30 e0       	ldi	r19, 0x00	; 0
    4b40:	a9 01       	movw	r20, r18
    4b42:	be 01       	movw	r22, r28
    4b44:	6f 5f       	subi	r22, 0xFF	; 255
    4b46:	7f 4f       	sbci	r23, 0xFF	; 255
    4b48:	0e 94 a9 13 	call	0x2752	; 0x2752 <csp_queue_enqueue>
    4b4c:	01 97       	sbiw	r24, 0x01	; 1
    4b4e:	09 f1       	breq	.+66     	; 0x4b92 <csp_udp_new_packet+0xbe>
			csp_log_warn("Warning socket connection queue full");
    4b50:	80 91 05 02 	lds	r24, 0x0205	; 0x800205 <csp_debug_level_enabled+0x1>
    4b54:	88 23       	and	r24, r24
    4b56:	c1 f0       	breq	.+48     	; 0x4b88 <csp_udp_new_packet+0xb4>
    4b58:	0e 94 6b 1c 	call	0x38d6	; 0x38d6 <csp_get_address>
    4b5c:	1f 92       	push	r1
    4b5e:	96 e2       	ldi	r25, 0x26	; 38
    4b60:	9f 93       	push	r25
    4b62:	2e ea       	ldi	r18, 0xAE	; 174
    4b64:	33 e0       	ldi	r19, 0x03	; 3
    4b66:	3f 93       	push	r19
    4b68:	2f 93       	push	r18
    4b6a:	1f 92       	push	r1
    4b6c:	8f 93       	push	r24
    4b6e:	88 e2       	ldi	r24, 0x28	; 40
    4b70:	9d e0       	ldi	r25, 0x0D	; 13
    4b72:	9f 93       	push	r25
    4b74:	8f 93       	push	r24
    4b76:	81 e0       	ldi	r24, 0x01	; 1
    4b78:	8f 93       	push	r24
    4b7a:	0e 94 83 1b 	call	0x3706	; 0x3706 <do_csp_debug>
    4b7e:	0f b6       	in	r0, 0x3f	; 63
    4b80:	f8 94       	cli
    4b82:	de bf       	out	0x3e, r29	; 62
    4b84:	0f be       	out	0x3f, r0	; 63
    4b86:	cd bf       	out	0x3d, r28	; 61
			csp_close(conn);
    4b88:	89 81       	ldd	r24, Y+1	; 0x01
    4b8a:	9a 81       	ldd	r25, Y+2	; 0x02
    4b8c:	0e 94 bf 19 	call	0x337e	; 0x337e <csp_close>
			return;
    4b90:	04 c0       	rjmp	.+8      	; 0x4b9a <csp_udp_new_packet+0xc6>
		}

		/* Ensure that this connection will not be posted to this socket again */
		conn->socket = NULL;
    4b92:	e9 81       	ldd	r30, Y+1	; 0x01
    4b94:	fa 81       	ldd	r31, Y+2	; 0x02
    4b96:	17 86       	std	Z+15, r1	; 0x0f
    4b98:	16 86       	std	Z+14, r1	; 0x0e
	}

}
    4b9a:	0f 90       	pop	r0
    4b9c:	0f 90       	pop	r0
    4b9e:	df 91       	pop	r29
    4ba0:	cf 91       	pop	r28
    4ba2:	1f 91       	pop	r17
    4ba4:	0f 91       	pop	r16
    4ba6:	08 95       	ret

00004ba8 <__portable_avr_delay_cycles>:
 *
 * @{
 */
__always_optimize
static inline void __portable_avr_delay_cycles(unsigned long n)
{
    4ba8:	04 c0       	rjmp	.+8      	; 0x4bb2 <__portable_avr_delay_cycles+0xa>
	while (n) {
		barrier();
		n--;
    4baa:	61 50       	subi	r22, 0x01	; 1
    4bac:	71 09       	sbc	r23, r1
    4bae:	81 09       	sbc	r24, r1
    4bb0:	91 09       	sbc	r25, r1
 * @{
 */
__always_optimize
static inline void __portable_avr_delay_cycles(unsigned long n)
{
	while (n) {
    4bb2:	61 15       	cp	r22, r1
    4bb4:	71 05       	cpc	r23, r1
    4bb6:	81 05       	cpc	r24, r1
    4bb8:	91 05       	cpc	r25, r1
    4bba:	b9 f7       	brne	.-18     	; 0x4baa <__portable_avr_delay_cycles+0x2>
    4bbc:	08 95       	ret

00004bbe <led_blinky>:
 */
__always_inline static void arch_ioport_toggle_pin_level(ioport_pin_t pin)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);

	base->PINCRL = arch_ioport_pin_to_mask(pin);
    4bbe:	c0 e8       	ldi	r28, 0x80	; 128
    4bc0:	c3 b9       	out	0x03, r28	; 3
TaskHandle_t I2C_task;

void led_blinky(void *pvParameters) {
    while (1) {
        ioport_toggle_pin_level(MY_LED);
        delay_ms(2000);
    4bc2:	66 e1       	ldi	r22, 0x16	; 22
    4bc4:	76 e1       	ldi	r23, 0x16	; 22
    4bc6:	85 e0       	ldi	r24, 0x05	; 5
    4bc8:	90 e0       	ldi	r25, 0x00	; 0
    4bca:	ee df       	rcall	.-36     	; 0x4ba8 <__portable_avr_delay_cycles>
    4bcc:	f9 cf       	rjmp	.-14     	; 0x4bc0 <led_blinky+0x2>

00004bce <csp_twoway_client>:
    }
}

void csp_twoway_client(void *pvParameters) {
    4bce:	cf 93       	push	r28
    4bd0:	df 93       	push	r29
    4bd2:	cd b7       	in	r28, 0x3d	; 61
    4bd4:	de b7       	in	r29, 0x3e	; 62
    4bd6:	ce 57       	subi	r28, 0x7E	; 126
    4bd8:	d1 09       	sbc	r29, r1
    4bda:	0f b6       	in	r0, 0x3f	; 63
    4bdc:	f8 94       	cli
    4bde:	de bf       	out	0x3e, r29	; 62
    4be0:	0f be       	out	0x3f, r0	; 63
    4be2:	cd bf       	out	0x3d, r28	; 61
    int count = 0;
    int ret;
    char incoming[100] = "";
    4be4:	1a 82       	std	Y+2, r1	; 0x02
    4be6:	19 82       	std	Y+1, r1	; 0x01
    4be8:	fe 01       	movw	r30, r28
    4bea:	33 96       	adiw	r30, 0x03	; 3
    4bec:	82 e6       	ldi	r24, 0x62	; 98
    4bee:	df 01       	movw	r26, r30
    4bf0:	1d 92       	st	X+, r1
    4bf2:	8a 95       	dec	r24
    4bf4:	e9 f7       	brne	.-6      	; 0x4bf0 <csp_twoway_client+0x22>
    char outgoing_data[] = "hello_twoway";
    char outgoing_ping[] = "Ping";
    char outgoing_hk[] = "Housekeeping data Request";
    4bf6:	8a e1       	ldi	r24, 0x1A	; 26
    4bf8:	e8 eb       	ldi	r30, 0xB8	; 184
    4bfa:	f3 e0       	ldi	r31, 0x03	; 3
    4bfc:	de 01       	movw	r26, r28
    4bfe:	ab 59       	subi	r26, 0x9B	; 155
    4c00:	bf 4f       	sbci	r27, 0xFF	; 255
    4c02:	01 90       	ld	r0, Z+
    4c04:	0d 92       	st	X+, r0
    4c06:	8a 95       	dec	r24
    4c08:	e1 f7       	brne	.-8      	; 0x4c02 <csp_twoway_client+0x34>
        delay_ms(2000);
    }
}

void csp_twoway_client(void *pvParameters) {
    int count = 0;
    4c0a:	41 2c       	mov	r4, r1
    4c0c:	51 2c       	mov	r5, r1
            @param inbuf pointer to incoming data buffer
            @param inlen length of expected reply, -1 for unknown size (note inbuf MUST be large enough)
            @return Return 1 or reply size if successful, 0 if error or incoming length does not match or -1 if timeout was reached
        */
        ret = csp_transaction(OBC_CSP_PRIO, EPS_ADDR, EPS_CONN_PORT_HK, OBC_CSP_TRANSACTION_TIMEOUT, outgoing_hk,
                              strlen(outgoing_hk), incoming, -1);
    4c0e:	3e 01       	movw	r6, r28
    4c10:	b5 e6       	ldi	r27, 0x65	; 101
    4c12:	6b 0e       	add	r6, r27
    4c14:	71 1c       	adc	r7, r1
            @param outlen length of request to send
            @param inbuf pointer to incoming data buffer
            @param inlen length of expected reply, -1 for unknown size (note inbuf MUST be large enough)
            @return Return 1 or reply size if successful, 0 if error or incoming length does not match or -1 if timeout was reached
        */
        ret = csp_transaction(OBC_CSP_PRIO, EPS_ADDR, EPS_CONN_PORT_HK, OBC_CSP_TRANSACTION_TIMEOUT, outgoing_hk,
    4c16:	ce 01       	movw	r24, r28
    4c18:	01 96       	adiw	r24, 0x01	; 1
    4c1a:	1c 01       	movw	r2, r24
                              strlen(outgoing_hk), incoming, -1);
    4c1c:	f3 01       	movw	r30, r6
    4c1e:	01 90       	ld	r0, Z+
    4c20:	00 20       	and	r0, r0
    4c22:	e9 f7       	brne	.-6      	; 0x4c1e <csp_twoway_client+0x50>
    4c24:	31 97       	sbiw	r30, 0x01	; 1
    4c26:	6f 01       	movw	r12, r30
    4c28:	c6 18       	sub	r12, r6
    4c2a:	d7 08       	sbc	r13, r7
            @param outlen length of request to send
            @param inbuf pointer to incoming data buffer
            @param inlen length of expected reply, -1 for unknown size (note inbuf MUST be large enough)
            @return Return 1 or reply size if successful, 0 if error or incoming length does not match or -1 if timeout was reached
        */
        ret = csp_transaction(OBC_CSP_PRIO, EPS_ADDR, EPS_CONN_PORT_HK, OBC_CSP_TRANSACTION_TIMEOUT, outgoing_hk,
    4c2c:	88 24       	eor	r8, r8
    4c2e:	8a 94       	dec	r8
    4c30:	98 2c       	mov	r9, r8
    4c32:	51 01       	movw	r10, r2
    4c34:	73 01       	movw	r14, r6
    4c36:	08 ee       	ldi	r16, 0xE8	; 232
    4c38:	13 e0       	ldi	r17, 0x03	; 3
    4c3a:	20 e0       	ldi	r18, 0x00	; 0
    4c3c:	30 e0       	ldi	r19, 0x00	; 0
    4c3e:	42 e0       	ldi	r20, 0x02	; 2
    4c40:	62 e0       	ldi	r22, 0x02	; 2
    4c42:	85 e0       	ldi	r24, 0x05	; 5
    4c44:	18 d9       	rcall	.-3536   	; 0x3e76 <csp_transaction>
                              strlen(outgoing_hk), incoming, -1);

        if (ret != -1 && ret != 0) {
    4c46:	9c 01       	movw	r18, r24
    4c48:	2f 5f       	subi	r18, 0xFF	; 255
    4c4a:	3f 4f       	sbci	r19, 0xFF	; 255
    4c4c:	22 30       	cpi	r18, 0x02	; 2
    4c4e:	31 05       	cpc	r19, r1
    4c50:	b8 f0       	brcs	.+46     	; 0x4c80 <csp_twoway_client+0xb2>
            //printf("Ping -- Success\r\n");
            //printf("Reply: %s, Length: %d\r\n\r\n", incoming, ret);
            count++;
    4c52:	9f ef       	ldi	r25, 0xFF	; 255
    4c54:	49 1a       	sub	r4, r25
    4c56:	59 0a       	sbc	r5, r25
            printf("Received packet #%d\r\n", count);
    4c58:	5f 92       	push	r5
    4c5a:	4f 92       	push	r4
    4c5c:	ad ec       	ldi	r26, 0xCD	; 205
    4c5e:	bd e0       	ldi	r27, 0x0D	; 13
    4c60:	bf 93       	push	r27
    4c62:	af 93       	push	r26
    4c64:	65 d6       	rcall	.+3274   	; 0x5930 <printf_P>
            printf("Received temperature: %s  *C\r\n\r\n", incoming);
    4c66:	3f 92       	push	r3
    4c68:	2f 92       	push	r2
    4c6a:	8c ea       	ldi	r24, 0xAC	; 172
    4c6c:	9d e0       	ldi	r25, 0x0D	; 13
    4c6e:	9f 93       	push	r25
    4c70:	8f 93       	push	r24
    4c72:	5e d6       	rcall	.+3260   	; 0x5930 <printf_P>
    4c74:	0f b6       	in	r0, 0x3f	; 63
    4c76:	f8 94       	cli
    4c78:	de bf       	out	0x3e, r29	; 62
    4c7a:	0f be       	out	0x3f, r0	; 63
    4c7c:	cd bf       	out	0x3d, r28	; 61
    4c7e:	11 c0       	rjmp	.+34     	; 0x4ca2 <csp_twoway_client+0xd4>
        }
        else if (ret == -1) {
    4c80:	01 96       	adiw	r24, 0x01	; 1
    4c82:	41 f4       	brne	.+16     	; 0x4c94 <csp_twoway_client+0xc6>
            printf("Ping -- Timeout\r\n\r\n");
    4c84:	88 e9       	ldi	r24, 0x98	; 152
    4c86:	9d e0       	ldi	r25, 0x0D	; 13
    4c88:	9f 93       	push	r25
    4c8a:	8f 93       	push	r24
    4c8c:	51 d6       	rcall	.+3234   	; 0x5930 <printf_P>
    4c8e:	0f 90       	pop	r0
    4c90:	0f 90       	pop	r0
    4c92:	07 c0       	rjmp	.+14     	; 0x4ca2 <csp_twoway_client+0xd4>
        }
        else {
            printf("Ping -- Failed\r\n\r\n");
    4c94:	85 e8       	ldi	r24, 0x85	; 133
    4c96:	9d e0       	ldi	r25, 0x0D	; 13
    4c98:	9f 93       	push	r25
    4c9a:	8f 93       	push	r24
    4c9c:	49 d6       	rcall	.+3218   	; 0x5930 <printf_P>
    4c9e:	0f 90       	pop	r0
    4ca0:	0f 90       	pop	r0

        //ret = csp_transaction(4, SUBSYS_ADDR, SUBSYS_DATA_PORT, 1000, outgoing_data, strlen(outgoing_data), incoming, -1);
        //if (ret != -1 || ret != 0) printf("Data -- Success\r\nReply: %s\r\n", incoming);
        //else if (ret == -1) printf("Data -- Timeout\r\n");
        //else printf("Data -- Failed\r\n");
        vTaskDelay(10000);
    4ca2:	60 e1       	ldi	r22, 0x10	; 16
    4ca4:	77 e2       	ldi	r23, 0x27	; 39
    4ca6:	80 e0       	ldi	r24, 0x00	; 0
    4ca8:	90 e0       	ldi	r25, 0x00	; 0
    4caa:	0e 94 73 11 	call	0x22e6	; 0x22e6 <vTaskDelay>
    }
    4cae:	b6 cf       	rjmp	.-148    	; 0x4c1c <csp_twoway_client+0x4e>

00004cb0 <send_start>:
        xQueueSendToBack(tx_queue, &frame , timeout);
    }

    printf("\n qaft is %d", uxQueueMessagesWaiting(tx_queue));
    return 0;
}
    4cb0:	ec eb       	ldi	r30, 0xBC	; 188
    4cb2:	f0 e0       	ldi	r31, 0x00	; 0
    4cb4:	80 81       	ld	r24, Z
    4cb6:	8f 7e       	andi	r24, 0xEF	; 239
    4cb8:	80 83       	st	Z, r24
    4cba:	80 81       	ld	r24, Z
    4cbc:	80 6a       	ori	r24, 0xA0	; 160
    4cbe:	80 83       	st	Z, r24
    4cc0:	08 95       	ret

00004cc2 <i2c_init>:
    4cc2:	8f 92       	push	r8
    4cc4:	9f 92       	push	r9
    4cc6:	af 92       	push	r10
    4cc8:	bf 92       	push	r11
    4cca:	cf 92       	push	r12
    4ccc:	df 92       	push	r13
    4cce:	ef 92       	push	r14
    4cd0:	0f 93       	push	r16
    4cd2:	1f 93       	push	r17
    4cd4:	cf 93       	push	r28
    4cd6:	62 30       	cpi	r22, 0x02	; 2
    4cd8:	71 05       	cpc	r23, r1
    4cda:	08 f0       	brcs	.+2      	; 0x4cde <i2c_init+0x1c>
    4cdc:	64 c0       	rjmp	.+200    	; 0x4da6 <i2c_init+0xe4>
    4cde:	80 2f       	mov	r24, r16
    4ce0:	59 01       	movw	r10, r18
    4ce2:	c4 2f       	mov	r28, r20
    4ce4:	4b 01       	movw	r8, r22
    4ce6:	67 2b       	or	r22, r23
    4ce8:	59 f4       	brne	.+22     	; 0x4d00 <i2c_init+0x3e>
    4cea:	40 e0       	ldi	r20, 0x00	; 0
    4cec:	62 e0       	ldi	r22, 0x02	; 2
    4cee:	0e 94 c3 0b 	call	0x1786	; 0x1786 <xQueueGenericCreate>
    4cf2:	90 93 e3 1f 	sts	0x1FE3, r25	; 0x801fe3 <tx_queue+0x1>
    4cf6:	80 93 e2 1f 	sts	0x1FE2, r24	; 0x801fe2 <tx_queue>
    4cfa:	89 2b       	or	r24, r25
    4cfc:	09 f4       	brne	.+2      	; 0x4d00 <i2c_init+0x3e>
    4cfe:	56 c0       	rjmp	.+172    	; 0x4dac <i2c_init+0xea>
    4d00:	c1 14       	cp	r12, r1
    4d02:	d1 04       	cpc	r13, r1
    4d04:	29 f0       	breq	.+10     	; 0x4d10 <i2c_init+0x4e>
    4d06:	d0 92 df 1f 	sts	0x1FDF, r13	; 0x801fdf <rx_callback+0x1>
    4d0a:	c0 92 de 1f 	sts	0x1FDE, r12	; 0x801fde <rx_callback>
    4d0e:	0c c0       	rjmp	.+24     	; 0x4d28 <i2c_init+0x66>
    4d10:	40 e0       	ldi	r20, 0x00	; 0
    4d12:	62 e0       	ldi	r22, 0x02	; 2
    4d14:	8e 2d       	mov	r24, r14
    4d16:	0e 94 c3 0b 	call	0x1786	; 0x1786 <xQueueGenericCreate>
    4d1a:	90 93 e1 1f 	sts	0x1FE1, r25	; 0x801fe1 <rx_queue+0x1>
    4d1e:	80 93 e0 1f 	sts	0x1FE0, r24	; 0x801fe0 <rx_queue>
    4d22:	89 2b       	or	r24, r25
    4d24:	09 f4       	brne	.+2      	; 0x4d28 <i2c_init+0x66>
    4d26:	45 c0       	rjmp	.+138    	; 0x4db2 <i2c_init+0xf0>
    4d28:	90 92 d9 1f 	sts	0x1FD9, r9	; 0x801fd9 <device_mode+0x1>
    4d2c:	80 92 d8 1f 	sts	0x1FD8, r8	; 0x801fd8 <device_mode>
    4d30:	b0 92 d7 1f 	sts	0x1FD7, r11	; 0x801fd7 <i2c_speed+0x1>
    4d34:	a0 92 d6 1f 	sts	0x1FD6, r10	; 0x801fd6 <i2c_speed>
    4d38:	c0 93 d5 1f 	sts	0x1FD5, r28	; 0x801fd5 <i2c_addr>
    4d3c:	0c eb       	ldi	r16, 0xBC	; 188
    4d3e:	10 e0       	ldi	r17, 0x00	; 0
    4d40:	f8 01       	movw	r30, r16
    4d42:	10 82       	st	Z, r1
    4d44:	c0 91 b9 00 	lds	r28, 0x00B9	; 0x8000b9 <__TEXT_REGION_LENGTH__+0x7000b9>
    4d48:	20 91 d6 1f 	lds	r18, 0x1FD6	; 0x801fd6 <i2c_speed>
    4d4c:	30 91 d7 1f 	lds	r19, 0x1FD7	; 0x801fd7 <i2c_speed+0x1>
    4d50:	a0 ed       	ldi	r26, 0xD0	; 208
    4d52:	b7 e0       	ldi	r27, 0x07	; 7
    4d54:	18 d5       	rcall	.+2608   	; 0x5786 <__umulhisi3>
    4d56:	9b 01       	movw	r18, r22
    4d58:	ac 01       	movw	r20, r24
    4d5a:	60 e0       	ldi	r22, 0x00	; 0
    4d5c:	74 e2       	ldi	r23, 0x24	; 36
    4d5e:	84 ef       	ldi	r24, 0xF4	; 244
    4d60:	90 e0       	ldi	r25, 0x00	; 0
    4d62:	e7 d4       	rcall	.+2510   	; 0x5732 <__udivmodsi4>
    4d64:	ca 01       	movw	r24, r20
    4d66:	b9 01       	movw	r22, r18
    4d68:	68 50       	subi	r22, 0x08	; 8
    4d6a:	71 09       	sbc	r23, r1
    4d6c:	81 09       	sbc	r24, r1
    4d6e:	91 09       	sbc	r25, r1
    4d70:	c3 70       	andi	r28, 0x03	; 3
    4d72:	cc 0f       	add	r28, r28
    4d74:	21 e0       	ldi	r18, 0x01	; 1
    4d76:	30 e0       	ldi	r19, 0x00	; 0
    4d78:	02 c0       	rjmp	.+4      	; 0x4d7e <i2c_init+0xbc>
    4d7a:	22 0f       	add	r18, r18
    4d7c:	33 1f       	adc	r19, r19
    4d7e:	ca 95       	dec	r28
    4d80:	e2 f7       	brpl	.-8      	; 0x4d7a <i2c_init+0xb8>
    4d82:	03 2e       	mov	r0, r19
    4d84:	00 0c       	add	r0, r0
    4d86:	44 0b       	sbc	r20, r20
    4d88:	55 0b       	sbc	r21, r21
    4d8a:	d3 d4       	rcall	.+2470   	; 0x5732 <__udivmodsi4>
    4d8c:	20 93 b8 00 	sts	0x00B8, r18	; 0x8000b8 <__TEXT_REGION_LENGTH__+0x7000b8>
    4d90:	80 91 d5 1f 	lds	r24, 0x1FD5	; 0x801fd5 <i2c_addr>
    4d94:	88 0f       	add	r24, r24
    4d96:	80 93 ba 00 	sts	0x00BA, r24	; 0x8000ba <__TEXT_REGION_LENGTH__+0x7000ba>
    4d9a:	85 e4       	ldi	r24, 0x45	; 69
    4d9c:	f8 01       	movw	r30, r16
    4d9e:	80 83       	st	Z, r24
    4da0:	8f ef       	ldi	r24, 0xFF	; 255
    4da2:	9f ef       	ldi	r25, 0xFF	; 255
    4da4:	08 c0       	rjmp	.+16     	; 0x4db6 <i2c_init+0xf4>
    4da6:	89 ef       	ldi	r24, 0xF9	; 249
    4da8:	9f ef       	ldi	r25, 0xFF	; 255
    4daa:	05 c0       	rjmp	.+10     	; 0x4db6 <i2c_init+0xf4>
    4dac:	8e ee       	ldi	r24, 0xEE	; 238
    4dae:	9f ef       	ldi	r25, 0xFF	; 255
    4db0:	02 c0       	rjmp	.+4      	; 0x4db6 <i2c_init+0xf4>
    4db2:	8e ee       	ldi	r24, 0xEE	; 238
    4db4:	9f ef       	ldi	r25, 0xFF	; 255
    4db6:	cf 91       	pop	r28
    4db8:	1f 91       	pop	r17
    4dba:	0f 91       	pop	r16
    4dbc:	ef 90       	pop	r14
    4dbe:	df 90       	pop	r13
    4dc0:	cf 90       	pop	r12
    4dc2:	bf 90       	pop	r11
    4dc4:	af 90       	pop	r10
    4dc6:	9f 90       	pop	r9
    4dc8:	8f 90       	pop	r8
    4dca:	08 95       	ret

00004dcc <i2c_send>:
    4dcc:	0f 93       	push	r16
    4dce:	cf 93       	push	r28
    4dd0:	df 93       	push	r29
    4dd2:	1f 92       	push	r1
    4dd4:	1f 92       	push	r1
    4dd6:	cd b7       	in	r28, 0x3d	; 61
    4dd8:	de b7       	in	r29, 0x3e	; 62
    4dda:	fb 01       	movw	r30, r22
    4ddc:	7a 83       	std	Y+2, r23	; 0x02
    4dde:	69 83       	std	Y+1, r22	; 0x01
    4de0:	80 85       	ldd	r24, Z+8	; 0x08
    4de2:	91 85       	ldd	r25, Z+9	; 0x09
    4de4:	01 97       	sbiw	r24, 0x01	; 1
    4de6:	8f 3f       	cpi	r24, 0xFF	; 255
    4de8:	91 05       	cpc	r25, r1
    4dea:	11 f0       	breq	.+4      	; 0x4df0 <i2c_send+0x24>
    4dec:	08 f0       	brcs	.+2      	; 0x4df0 <i2c_send+0x24>
    4dee:	40 c0       	rjmp	.+128    	; 0x4e70 <i2c_send+0xa4>
    4df0:	80 91 d8 1f 	lds	r24, 0x1FD8	; 0x801fd8 <device_mode>
    4df4:	90 91 d9 1f 	lds	r25, 0x1FD9	; 0x801fd9 <device_mode+0x1>
    4df8:	01 97       	sbiw	r24, 0x01	; 1
    4dfa:	51 f4       	brne	.+20     	; 0x4e10 <i2c_send+0x44>
    4dfc:	8f e0       	ldi	r24, 0x0F	; 15
    4dfe:	9e e0       	ldi	r25, 0x0E	; 14
    4e00:	9f 93       	push	r25
    4e02:	8f 93       	push	r24
    4e04:	95 d5       	rcall	.+2858   	; 0x5930 <printf_P>
    4e06:	0f 90       	pop	r0
    4e08:	0f 90       	pop	r0
    4e0a:	89 ef       	ldi	r24, 0xF9	; 249
    4e0c:	9f ef       	ldi	r25, 0xFF	; 255
    4e0e:	32 c0       	rjmp	.+100    	; 0x4e74 <i2c_send+0xa8>
    4e10:	00 e0       	ldi	r16, 0x00	; 0
    4e12:	20 e0       	ldi	r18, 0x00	; 0
    4e14:	30 e0       	ldi	r19, 0x00	; 0
    4e16:	a9 01       	movw	r20, r18
    4e18:	be 01       	movw	r22, r28
    4e1a:	6f 5f       	subi	r22, 0xFF	; 255
    4e1c:	7f 4f       	sbci	r23, 0xFF	; 255
    4e1e:	80 91 e2 1f 	lds	r24, 0x1FE2	; 0x801fe2 <tx_queue>
    4e22:	90 91 e3 1f 	lds	r25, 0x1FE3	; 0x801fe3 <tx_queue+0x1>
    4e26:	0e 94 f1 0b 	call	0x17e2	; 0x17e2 <xQueueGenericSend>
    4e2a:	81 30       	cpi	r24, 0x01	; 1
    4e2c:	51 f0       	breq	.+20     	; 0x4e42 <i2c_send+0x76>
    4e2e:	8d ef       	ldi	r24, 0xFD	; 253
    4e30:	9d e0       	ldi	r25, 0x0D	; 13
    4e32:	9f 93       	push	r25
    4e34:	8f 93       	push	r24
    4e36:	7c d5       	rcall	.+2808   	; 0x5930 <printf_P>
    4e38:	0f 90       	pop	r0
    4e3a:	0f 90       	pop	r0
    4e3c:	8f ee       	ldi	r24, 0xEF	; 239
    4e3e:	9f ef       	ldi	r25, 0xFF	; 255
    4e40:	19 c0       	rjmp	.+50     	; 0x4e74 <i2c_send+0xa8>
    4e42:	0f b6       	in	r0, 0x3f	; 63
    4e44:	f8 94       	cli
    4e46:	0f 92       	push	r0
    4e48:	80 91 d3 1f 	lds	r24, 0x1FD3	; 0x801fd3 <i2c_busy>
    4e4c:	90 91 d4 1f 	lds	r25, 0x1FD4	; 0x801fd4 <i2c_busy+0x1>
    4e50:	89 2b       	or	r24, r25
    4e52:	49 f4       	brne	.+18     	; 0x4e66 <i2c_send+0x9a>
    4e54:	0e 94 15 10 	call	0x202a	; 0x202a <xTaskGetTickCount>
    4e58:	2b df       	rcall	.-426    	; 0x4cb0 <send_start>
    4e5a:	81 e0       	ldi	r24, 0x01	; 1
    4e5c:	90 e0       	ldi	r25, 0x00	; 0
    4e5e:	90 93 d4 1f 	sts	0x1FD4, r25	; 0x801fd4 <i2c_busy+0x1>
    4e62:	80 93 d3 1f 	sts	0x1FD3, r24	; 0x801fd3 <i2c_busy>
    4e66:	0f 90       	pop	r0
    4e68:	0f be       	out	0x3f, r0	; 63
    4e6a:	8f ef       	ldi	r24, 0xFF	; 255
    4e6c:	9f ef       	ldi	r25, 0xFF	; 255
    4e6e:	02 c0       	rjmp	.+4      	; 0x4e74 <i2c_send+0xa8>
    4e70:	8a ef       	ldi	r24, 0xFA	; 250
    4e72:	9f ef       	ldi	r25, 0xFF	; 255
    4e74:	0f 90       	pop	r0
    4e76:	0f 90       	pop	r0
    4e78:	df 91       	pop	r29
    4e7a:	cf 91       	pop	r28
    4e7c:	0f 91       	pop	r16
    4e7e:	08 95       	ret

00004e80 <__vector_39>:


void TWI_vect(void) __attribute__((signal));
void TWI_vect(void) {
    4e80:	1f 92       	push	r1
    4e82:	0f 92       	push	r0
    4e84:	0f b6       	in	r0, 0x3f	; 63
    4e86:	0f 92       	push	r0
    4e88:	11 24       	eor	r1, r1
    4e8a:	0b b6       	in	r0, 0x3b	; 59
    4e8c:	0f 92       	push	r0
    4e8e:	0f 93       	push	r16
    4e90:	1f 93       	push	r17
    4e92:	2f 93       	push	r18
    4e94:	3f 93       	push	r19
    4e96:	4f 93       	push	r20
    4e98:	5f 93       	push	r21
    4e9a:	6f 93       	push	r22
    4e9c:	7f 93       	push	r23
    4e9e:	8f 93       	push	r24
    4ea0:	9f 93       	push	r25
    4ea2:	af 93       	push	r26
    4ea4:	bf 93       	push	r27
    4ea6:	cf 93       	push	r28
    4ea8:	ef 93       	push	r30
    4eaa:	ff 93       	push	r31
    static uint8_t status;
    static signed portBASE_TYPE xTaskWoken;
    static uint8_t flag;
    static uint8_t flag2;
    status = TWSR & 0xF8;
    4eac:	80 91 b9 00 	lds	r24, 0x00B9	; 0x8000b9 <__TEXT_REGION_LENGTH__+0x7000b9>
    xTaskWoken = pdFALSE;
    4eb0:	10 92 d2 1f 	sts	0x1FD2, r1	; 0x801fd2 <xTaskWoken.3115>
    flag = 0;
    4eb4:	10 92 d1 1f 	sts	0x1FD1, r1	; 0x801fd1 <flag.3116>

    last_tx = 0;

    switch (status) {
    4eb8:	e8 2f       	mov	r30, r24
    4eba:	e8 7f       	andi	r30, 0xF8	; 248
    4ebc:	8e 2f       	mov	r24, r30
    4ebe:	90 e0       	ldi	r25, 0x00	; 0
    4ec0:	fc 01       	movw	r30, r24
    4ec2:	38 97       	sbiw	r30, 0x08	; 8
    4ec4:	e1 3c       	cpi	r30, 0xC1	; 193
    4ec6:	f1 05       	cpc	r31, r1
    4ec8:	08 f0       	brcs	.+2      	; 0x4ecc <__vector_39+0x4c>
    4eca:	0f c2       	rjmp	.+1054   	; 0x52ea <__vector_39+0x46a>
    4ecc:	88 27       	eor	r24, r24
    4ece:	ef 57       	subi	r30, 0x7F	; 127
    4ed0:	ff 4f       	sbci	r31, 0xFF	; 255
    4ed2:	8f 4f       	sbci	r24, 0xFF	; 255
    4ed4:	50 c4       	rjmp	.+2208   	; 0x5776 <__tablejump2__>
    case TW_ST_ARB_LOST_SLA_ACK:			// 0xB0 Arbitration lost in SLA+RW, SLA+R received, ACK returned
    case TW_ST_DATA_ACK:					// 0xB8 Data transmitted, ACK received

        //printf("\nSlave Transmit -- ACK received");

        if (tx_frame == NULL) {
    4ed6:	80 91 e4 1f 	lds	r24, 0x1FE4	; 0x801fe4 <tx_frame>
    4eda:	90 91 e5 1f 	lds	r25, 0x1FE5	; 0x801fe5 <tx_frame+0x1>
    4ede:	89 2b       	or	r24, r25
    4ee0:	b1 f4       	brne	.+44     	; 0x4f0e <__vector_39+0x8e>
            if (xQueueReceiveFromISR(tx_queue, &tx_frame, &xTaskWoken) == pdFALSE) {
    4ee2:	42 ed       	ldi	r20, 0xD2	; 210
    4ee4:	5f e1       	ldi	r21, 0x1F	; 31
    4ee6:	64 ee       	ldi	r22, 0xE4	; 228
    4ee8:	7f e1       	ldi	r23, 0x1F	; 31
    4eea:	80 91 e2 1f 	lds	r24, 0x1FE2	; 0x801fe2 <tx_queue>
    4eee:	90 91 e3 1f 	lds	r25, 0x1FE3	; 0x801fe3 <tx_queue+0x1>
    4ef2:	0e 94 a5 0d 	call	0x1b4a	; 0x1b4a <xQueueReceiveFromISR>
    4ef6:	81 11       	cpse	r24, r1
    4ef8:	06 c0       	rjmp	.+12     	; 0x4f06 <__vector_39+0x86>
                TWCR |= _BV(TWSTO);
    4efa:	ec eb       	ldi	r30, 0xBC	; 188
    4efc:	f0 e0       	ldi	r31, 0x00	; 0
    4efe:	80 81       	ld	r24, Z
    4f00:	80 61       	ori	r24, 0x10	; 16
    4f02:	80 83       	st	Z, r24
                break;
    4f04:	4a c2       	rjmp	.+1172   	; 0x539a <__vector_39+0x51a>
            }

            /* Reset counter */
            tx_cnt = 0;
    4f06:	10 92 dd 1f 	sts	0x1FDD, r1	; 0x801fdd <tx_cnt+0x1>
    4f0a:	10 92 dc 1f 	sts	0x1FDC, r1	; 0x801fdc <tx_cnt>

        }

        /* Send next byte */
        if (tx_cnt < tx_frame->len) {
    4f0e:	e0 91 e4 1f 	lds	r30, 0x1FE4	; 0x801fe4 <tx_frame>
    4f12:	f0 91 e5 1f 	lds	r31, 0x1FE5	; 0x801fe5 <tx_frame+0x1>
    4f16:	80 91 dc 1f 	lds	r24, 0x1FDC	; 0x801fdc <tx_cnt>
    4f1a:	90 91 dd 1f 	lds	r25, 0x1FDD	; 0x801fdd <tx_cnt+0x1>
    4f1e:	20 85       	ldd	r18, Z+8	; 0x08
    4f20:	31 85       	ldd	r19, Z+9	; 0x09
    4f22:	82 17       	cp	r24, r18
    4f24:	93 07       	cpc	r25, r19
    4f26:	88 f4       	brcc	.+34     	; 0x4f4a <__vector_39+0xca>
            TWDR = tx_frame->data[tx_cnt++];
    4f28:	80 91 dc 1f 	lds	r24, 0x1FDC	; 0x801fdc <tx_cnt>
    4f2c:	90 91 dd 1f 	lds	r25, 0x1FDD	; 0x801fdd <tx_cnt+0x1>
    4f30:	9c 01       	movw	r18, r24
    4f32:	2f 5f       	subi	r18, 0xFF	; 255
    4f34:	3f 4f       	sbci	r19, 0xFF	; 255
    4f36:	30 93 dd 1f 	sts	0x1FDD, r19	; 0x801fdd <tx_cnt+0x1>
    4f3a:	20 93 dc 1f 	sts	0x1FDC, r18	; 0x801fdc <tx_cnt>
    4f3e:	e8 0f       	add	r30, r24
    4f40:	f9 1f       	adc	r31, r25
    4f42:	82 85       	ldd	r24, Z+10	; 0x0a
    4f44:	80 93 bb 00 	sts	0x00BB, r24	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7000bb>
    4f48:	07 c0       	rjmp	.+14     	; 0x4f58 <__vector_39+0xd8>

        }
        else {
            printf("Error: i2c too long \r\n");
    4f4a:	86 ee       	ldi	r24, 0xE6	; 230
    4f4c:	9d e0       	ldi	r25, 0x0D	; 13
    4f4e:	9f 93       	push	r25
    4f50:	8f 93       	push	r24
    4f52:	ee d4       	rcall	.+2524   	; 0x5930 <printf_P>
    4f54:	0f 90       	pop	r0
    4f56:	0f 90       	pop	r0
        }

        flag2 = _BV(TWEA);
    4f58:	80 e4       	ldi	r24, 0x40	; 64
    4f5a:	80 93 d0 1f 	sts	0x1FD0, r24	; 0x801fd0 <flag2.3117>
        break;
    4f5e:	1d c2       	rjmp	.+1082   	; 0x539a <__vector_39+0x51a>

    case TW_ST_DATA_NACK:				// 0xC0 Data transmitted, NACK received
    case TW_ST_LAST_DATA:				// 0xC8 Last data byte transmitted, ACK received
        //printf("\nSlave Transmit -- NACK/ACK received");

        csp_buffer_free_isr(tx_frame);
    4f60:	80 91 e4 1f 	lds	r24, 0x1FE4	; 0x801fe4 <tx_frame>
    4f64:	90 91 e5 1f 	lds	r25, 0x1FE5	; 0x801fe5 <tx_frame+0x1>
    4f68:	0e 94 5d 16 	call	0x2cba	; 0x2cba <csp_buffer_free_isr>
        tx_frame = NULL;
    4f6c:	10 92 e5 1f 	sts	0x1FE5, r1	; 0x801fe5 <tx_frame+0x1>
    4f70:	10 92 e4 1f 	sts	0x1FE4, r1	; 0x801fe4 <tx_frame>
        flag2 = _BV(TWEA);
    4f74:	80 e4       	ldi	r24, 0x40	; 64
    4f76:	80 93 d0 1f 	sts	0x1FD0, r24	; 0x801fd0 <flag2.3117>

        break;
    4f7a:	0f c2       	rjmp	.+1054   	; 0x539a <__vector_39+0x51a>

    /* Beginning of new RX Frame */
    case TW_SR_SLA_ACK: 					// 0x60 SLA+W received, ACK returned
    case TW_SR_ARB_LOST_SLA_ACK:			// 0x68 Arbitration lost (in master mode) and addressed as slave, ACK returned
        //printf("\nSlave Receive -- ACK received");
        i2c_busy = 1;
    4f7c:	81 e0       	ldi	r24, 0x01	; 1
    4f7e:	90 e0       	ldi	r25, 0x00	; 0
    4f80:	90 93 d4 1f 	sts	0x1FD4, r25	; 0x801fd4 <i2c_busy+0x1>
    4f84:	80 93 d3 1f 	sts	0x1FD3, r24	; 0x801fd3 <i2c_busy>
        flag2 = _BV(TWEA);
    4f88:	80 e4       	ldi	r24, 0x40	; 64
    4f8a:	80 93 d0 1f 	sts	0x1FD0, r24	; 0x801fd0 <flag2.3117>

        break;
    4f8e:	05 c2       	rjmp	.+1034   	; 0x539a <__vector_39+0x51a>
    /* DATA received */
    case TW_SR_DATA_ACK: 					// 0x80 Data received, ACK returned
    case TW_SR_DATA_NACK: 					// 0x88 Data received, NACK returned
        //printf("\nSlave Received -- ACK return");

        i2c_busy = 1;
    4f90:	81 e0       	ldi	r24, 0x01	; 1
    4f92:	90 e0       	ldi	r25, 0x00	; 0
    4f94:	90 93 d4 1f 	sts	0x1FD4, r25	; 0x801fd4 <i2c_busy+0x1>
    4f98:	80 93 d3 1f 	sts	0x1FD3, r24	; 0x801fd3 <i2c_busy>

        /* Get buffer */
        if (rx_frame == NULL) {
    4f9c:	e0 91 e6 1f 	lds	r30, 0x1FE6	; 0x801fe6 <rx_frame>
    4fa0:	f0 91 e7 1f 	lds	r31, 0x1FE7	; 0x801fe7 <rx_frame+0x1>
    4fa4:	30 97       	sbiw	r30, 0x00	; 0
    4fa6:	a9 f4       	brne	.+42     	; 0x4fd2 <__vector_39+0x152>
            rx_frame = csp_buffer_get_isr(I2C_MTU);
    4fa8:	80 e0       	ldi	r24, 0x00	; 0
    4faa:	91 e0       	ldi	r25, 0x01	; 1
    4fac:	0e 94 61 15 	call	0x2ac2	; 0x2ac2 <csp_buffer_get_isr>
    4fb0:	fc 01       	movw	r30, r24
    4fb2:	90 93 e7 1f 	sts	0x1FE7, r25	; 0x801fe7 <rx_frame+0x1>
    4fb6:	80 93 e6 1f 	sts	0x1FE6, r24	; 0x801fe6 <rx_frame>

            //printf("\nSlave Receive -- Getting buffer");

            if (rx_frame == NULL) {
    4fba:	89 2b       	or	r24, r25
    4fbc:	09 f4       	brne	.+2      	; 0x4fc0 <__vector_39+0x140>
    4fbe:	ed c1       	rjmp	.+986    	; 0x539a <__vector_39+0x51a>
                //printf("\nSlave Receive -- no buffer found\r\n");
                break;
            }

            rx_frame->len_rx = 0;
    4fc0:	17 82       	std	Z+7, r1	; 0x07
            rx_frame->len = 0;
    4fc2:	11 86       	std	Z+9, r1	; 0x09
    4fc4:	10 86       	std	Z+8, r1	; 0x08
            rx_frame->dest = i2c_addr;
    4fc6:	80 91 d5 1f 	lds	r24, 0x1FD5	; 0x801fd5 <i2c_addr>
    4fca:	86 83       	std	Z+6, r24	; 0x06
        }

        /* Store data */
        if (rx_frame->len < I2C_MTU) {
    4fcc:	80 e0       	ldi	r24, 0x00	; 0
    4fce:	90 e0       	ldi	r25, 0x00	; 0
    4fd0:	06 c0       	rjmp	.+12     	; 0x4fde <__vector_39+0x15e>
    4fd2:	80 85       	ldd	r24, Z+8	; 0x08
    4fd4:	91 85       	ldd	r25, Z+9	; 0x09
    4fd6:	8f 3f       	cpi	r24, 0xFF	; 255
    4fd8:	91 05       	cpc	r25, r1
    4fda:	09 f0       	breq	.+2      	; 0x4fde <__vector_39+0x15e>
    4fdc:	50 f4       	brcc	.+20     	; 0x4ff2 <__vector_39+0x172>
            rx_frame->data[rx_frame->len++] = TWDR;
    4fde:	9c 01       	movw	r18, r24
    4fe0:	2f 5f       	subi	r18, 0xFF	; 255
    4fe2:	3f 4f       	sbci	r19, 0xFF	; 255
    4fe4:	31 87       	std	Z+9, r19	; 0x09
    4fe6:	20 87       	std	Z+8, r18	; 0x08
    4fe8:	20 91 bb 00 	lds	r18, 0x00BB	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7000bb>
    4fec:	e8 0f       	add	r30, r24
    4fee:	f9 1f       	adc	r31, r25
    4ff0:	22 87       	std	Z+10, r18	; 0x0a
        }

        flag2 = _BV(TWEA);
    4ff2:	80 e4       	ldi	r24, 0x40	; 64
    4ff4:	80 93 d0 1f 	sts	0x1FD0, r24	; 0x801fd0 <flag2.3117>

        break;
    4ff8:	d0 c1       	rjmp	.+928    	; 0x539a <__vector_39+0x51a>

    /* End of frame */
    case TW_SR_STOP: 						// 0xA0 Stop condition received or repeated start
        //printf("\nSlave Receive -- Stop");
        i2c_busy = 0;
    4ffa:	10 92 d4 1f 	sts	0x1FD4, r1	; 0x801fd4 <i2c_busy+0x1>
    4ffe:	10 92 d3 1f 	sts	0x1FD3, r1	; 0x801fd3 <i2c_busy>

        /* Break if no RX frame */
        if (rx_frame == NULL) {
    5002:	80 91 e6 1f 	lds	r24, 0x1FE6	; 0x801fe6 <rx_frame>
    5006:	90 91 e7 1f 	lds	r25, 0x1FE7	; 0x801fe7 <rx_frame+0x1>
    500a:	00 97       	sbiw	r24, 0x00	; 0
    500c:	21 f4       	brne	.+8      	; 0x5016 <__vector_39+0x196>
            flag2 = _BV(TWEA);
    500e:	80 e4       	ldi	r24, 0x40	; 64
    5010:	80 93 d0 1f 	sts	0x1FD0, r24	; 0x801fd0 <flag2.3117>
            break;
    5014:	c2 c1       	rjmp	.+900    	; 0x539a <__vector_39+0x51a>
        }

        /* Deliver frame */
        if (rx_callback != NULL) {
    5016:	e0 91 de 1f 	lds	r30, 0x1FDE	; 0x801fde <rx_callback>
    501a:	f0 91 df 1f 	lds	r31, 0x1FDF	; 0x801fdf <rx_callback+0x1>
    501e:	30 97       	sbiw	r30, 0x00	; 0
    5020:	21 f0       	breq	.+8      	; 0x502a <__vector_39+0x1aa>
            //for(int i = 0 ; i<3; i++)
            //receive_frame.data[i]=rx_frame->data[i];
            (*rx_callback)(rx_frame, &xTaskWoken);
    5022:	62 ed       	ldi	r22, 0xD2	; 210
    5024:	7f e1       	ldi	r23, 0x1F	; 31
    5026:	19 95       	eicall
    5028:	13 c0       	rjmp	.+38     	; 0x5050 <__vector_39+0x1d0>

        }
        else {
            //printf("\nSlave Receive -- Queue");

            if (xQueueSendFromISR(rx_queue, &rx_frame, (signed portBASE_TYPE *) &xTaskWoken) != pdTRUE) {
    502a:	20 e0       	ldi	r18, 0x00	; 0
    502c:	42 ed       	ldi	r20, 0xD2	; 210
    502e:	5f e1       	ldi	r21, 0x1F	; 31
    5030:	66 ee       	ldi	r22, 0xE6	; 230
    5032:	7f e1       	ldi	r23, 0x1F	; 31
    5034:	80 91 e0 1f 	lds	r24, 0x1FE0	; 0x801fe0 <rx_queue>
    5038:	90 91 e1 1f 	lds	r25, 0x1FE1	; 0x801fe1 <rx_queue+0x1>
    503c:	0e 94 a8 0c 	call	0x1950	; 0x1950 <xQueueGenericSendFromISR>
    5040:	81 30       	cpi	r24, 0x01	; 1
    5042:	31 f0       	breq	.+12     	; 0x5050 <__vector_39+0x1d0>
                csp_buffer_free_isr(rx_frame);
    5044:	80 91 e6 1f 	lds	r24, 0x1FE6	; 0x801fe6 <rx_frame>
    5048:	90 91 e7 1f 	lds	r25, 0x1FE7	; 0x801fe7 <rx_frame+0x1>
    504c:	0e 94 5d 16 	call	0x2cba	; 0x2cba <csp_buffer_free_isr>

            //printf("\n q has %d", uxQueueMessagesWaitingFromISR(rx_queue));
        }

        /* Prepare reply or next frame */
        if (device_mode == I2C_SLAVE) {
    5050:	80 91 d8 1f 	lds	r24, 0x1FD8	; 0x801fd8 <device_mode>
    5054:	90 91 d9 1f 	lds	r25, 0x1FD9	; 0x801fd9 <device_mode+0x1>
    5058:	01 97       	sbiw	r24, 0x01	; 1
    505a:	29 f5       	brne	.+74     	; 0x50a6 <__vector_39+0x226>
            //printf("\nSlave");

            if (tx_frame != NULL) {
    505c:	80 91 e4 1f 	lds	r24, 0x1FE4	; 0x801fe4 <tx_frame>
    5060:	90 91 e5 1f 	lds	r25, 0x1FE5	; 0x801fe5 <tx_frame+0x1>
    5064:	00 97       	sbiw	r24, 0x00	; 0
    5066:	31 f0       	breq	.+12     	; 0x5074 <__vector_39+0x1f4>
                //printf("\ntxnotempty");
                csp_buffer_free_isr(tx_frame);
    5068:	0e 94 5d 16 	call	0x2cba	; 0x2cba <csp_buffer_free_isr>
                tx_frame = NULL;
    506c:	10 92 e5 1f 	sts	0x1FE5, r1	; 0x801fe5 <tx_frame+0x1>
    5070:	10 92 e4 1f 	sts	0x1FE4, r1	; 0x801fe4 <tx_frame>
            }

            if (rx_frame->len == 0) {
    5074:	e0 91 e6 1f 	lds	r30, 0x1FE6	; 0x801fe6 <rx_frame>
    5078:	f0 91 e7 1f 	lds	r31, 0x1FE7	; 0x801fe7 <rx_frame+0x1>
    507c:	80 85       	ldd	r24, Z+8	; 0x08
    507e:	91 85       	ldd	r25, Z+9	; 0x09
    5080:	89 2b       	or	r24, r25
    5082:	41 f4       	brne	.+16     	; 0x5094 <__vector_39+0x214>
                //printf("\nrxlennot0");
                csp_buffer_free_isr(rx_frame);
    5084:	cf 01       	movw	r24, r30
    5086:	0e 94 5d 16 	call	0x2cba	; 0x2cba <csp_buffer_free_isr>
                rx_frame = NULL;
    508a:	10 92 e7 1f 	sts	0x1FE7, r1	; 0x801fe7 <rx_frame+0x1>
    508e:	10 92 e6 1f 	sts	0x1FE6, r1	; 0x801fe6 <rx_frame>
    5092:	04 c0       	rjmp	.+8      	; 0x509c <__vector_39+0x21c>
            }
            else {
                //printf("\ntxisrx");
                tx_frame = rx_frame;
    5094:	f0 93 e5 1f 	sts	0x1FE5, r31	; 0x801fe5 <tx_frame+0x1>
    5098:	e0 93 e4 1f 	sts	0x1FE4, r30	; 0x801fe4 <tx_frame>
            }

            tx_cnt = 0;
    509c:	10 92 dd 1f 	sts	0x1FDD, r1	; 0x801fdd <tx_cnt+0x1>
    50a0:	10 92 dc 1f 	sts	0x1FDC, r1	; 0x801fdc <tx_cnt>
    50a4:	19 c0       	rjmp	.+50     	; 0x50d8 <__vector_39+0x258>
        }
        else {
            /* Try new transmission */
            if (uxQueueMessagesWaitingFromISR(tx_queue) > 0 || tx_frame != NULL) {
    50a6:	80 91 e2 1f 	lds	r24, 0x1FE2	; 0x801fe2 <tx_queue>
    50aa:	90 91 e3 1f 	lds	r25, 0x1FE3	; 0x801fe3 <tx_queue+0x1>
    50ae:	0e 94 e2 0d 	call	0x1bc4	; 0x1bc4 <uxQueueMessagesWaitingFromISR>
    50b2:	81 11       	cpse	r24, r1
    50b4:	06 c0       	rjmp	.+12     	; 0x50c2 <__vector_39+0x242>
    50b6:	80 91 e4 1f 	lds	r24, 0x1FE4	; 0x801fe4 <tx_frame>
    50ba:	90 91 e5 1f 	lds	r25, 0x1FE5	; 0x801fe5 <tx_frame+0x1>
    50be:	89 2b       	or	r24, r25
    50c0:	59 f0       	breq	.+22     	; 0x50d8 <__vector_39+0x258>
                //printf("\nnewtrans");
                flag |= _BV(TWSTA);
    50c2:	80 91 d1 1f 	lds	r24, 0x1FD1	; 0x801fd1 <flag.3116>
    50c6:	80 62       	ori	r24, 0x20	; 32
    50c8:	80 93 d1 1f 	sts	0x1FD1, r24	; 0x801fd1 <flag.3116>
                i2c_busy = 1;
    50cc:	81 e0       	ldi	r24, 0x01	; 1
    50ce:	90 e0       	ldi	r25, 0x00	; 0
    50d0:	90 93 d4 1f 	sts	0x1FD4, r25	; 0x801fd4 <i2c_busy+0x1>
    50d4:	80 93 d3 1f 	sts	0x1FD3, r24	; 0x801fd3 <i2c_busy>
            }

        }

        if (i2cflag == 0) {
    50d8:	80 91 e8 1f 	lds	r24, 0x1FE8	; 0x801fe8 <i2cflag>
    50dc:	90 91 e9 1f 	lds	r25, 0x1FE9	; 0x801fe9 <i2cflag+0x1>
    50e0:	89 2b       	or	r24, r25
    50e2:	71 f4       	brne	.+28     	; 0x5100 <__vector_39+0x280>
            //printf("\nwake");
            //printf("--- I2C interrupt done ---\r\n\r\n");

            xTaskWoken = xTaskResumeFromISR(I2C_task);
    50e4:	80 91 3c 20 	lds	r24, 0x203C	; 0x80203c <I2C_task>
    50e8:	90 91 3d 20 	lds	r25, 0x203D	; 0x80203d <I2C_task+0x1>
    50ec:	0e 94 8f 0f 	call	0x1f1e	; 0x1f1e <xTaskResumeFromISR>
    50f0:	80 93 d2 1f 	sts	0x1FD2, r24	; 0x801fd2 <xTaskWoken.3115>
            i2cflag = 1;
    50f4:	81 e0       	ldi	r24, 0x01	; 1
    50f6:	90 e0       	ldi	r25, 0x00	; 0
    50f8:	90 93 e9 1f 	sts	0x1FE9, r25	; 0x801fe9 <i2cflag+0x1>
    50fc:	80 93 e8 1f 	sts	0x1FE8, r24	; 0x801fe8 <i2cflag>
        }

        rx_frame = NULL;
    5100:	10 92 e7 1f 	sts	0x1FE7, r1	; 0x801fe7 <rx_frame+0x1>
    5104:	10 92 e6 1f 	sts	0x1FE6, r1	; 0x801fe6 <rx_frame>
        flag2 = _BV(TWEA);
    5108:	80 e4       	ldi	r24, 0x40	; 64
    510a:	80 93 d0 1f 	sts	0x1FD0, r24	; 0x801fd0 <flag2.3117>

        break;
    510e:	45 c1       	rjmp	.+650    	; 0x539a <__vector_39+0x51a>
    /* Frame START has been signalled */
    case TW_START: 							// 0x08 START has been transmitted
    case TW_REP_START: 				// 0x10 Repeated START has been transmitted
        //printf("\nMaster Transmit -- Start");

        i2c_busy = 1;
    5110:	81 e0       	ldi	r24, 0x01	; 1
    5112:	90 e0       	ldi	r25, 0x00	; 0
    5114:	90 93 d4 1f 	sts	0x1FD4, r25	; 0x801fd4 <i2c_busy+0x1>
    5118:	80 93 d3 1f 	sts	0x1FD3, r24	; 0x801fd3 <i2c_busy>

        /* First check if the previous frame was completed */
        if (tx_frame == NULL) {
    511c:	80 91 e4 1f 	lds	r24, 0x1FE4	; 0x801fe4 <tx_frame>
    5120:	90 91 e5 1f 	lds	r25, 0x1FE5	; 0x801fe5 <tx_frame+0x1>
    5124:	89 2b       	or	r24, r25
    5126:	b1 f4       	brne	.+44     	; 0x5154 <__vector_39+0x2d4>

            /* Receive next frame for transmission */
            if (xQueueReceiveFromISR(tx_queue, &tx_frame,
    5128:	42 ed       	ldi	r20, 0xD2	; 210
    512a:	5f e1       	ldi	r21, 0x1F	; 31
    512c:	64 ee       	ldi	r22, 0xE4	; 228
    512e:	7f e1       	ldi	r23, 0x1F	; 31
    5130:	80 91 e2 1f 	lds	r24, 0x1FE2	; 0x801fe2 <tx_queue>
    5134:	90 91 e3 1f 	lds	r25, 0x1FE3	; 0x801fe3 <tx_queue+0x1>
    5138:	0e 94 a5 0d 	call	0x1b4a	; 0x1b4a <xQueueReceiveFromISR>
    513c:	81 11       	cpse	r24, r1
    513e:	06 c0       	rjmp	.+12     	; 0x514c <__vector_39+0x2cc>
                                     &xTaskWoken) == pdFALSE) {

                TWCR |= _BV(TWSTO);
    5140:	ec eb       	ldi	r30, 0xBC	; 188
    5142:	f0 e0       	ldi	r31, 0x00	; 0
    5144:	80 81       	ld	r24, Z
    5146:	80 61       	ori	r24, 0x10	; 16
    5148:	80 83       	st	Z, r24
                break;
    514a:	27 c1       	rjmp	.+590    	; 0x539a <__vector_39+0x51a>
            }

            /* Reset counter */
            tx_cnt = 0;
    514c:	10 92 dd 1f 	sts	0x1FDD, r1	; 0x801fdd <tx_cnt+0x1>
    5150:	10 92 dc 1f 	sts	0x1FDC, r1	; 0x801fdc <tx_cnt>

        }

        /* Send destination addr */
        TWDR = tx_frame->dest << 1;
    5154:	e0 91 e4 1f 	lds	r30, 0x1FE4	; 0x801fe4 <tx_frame>
    5158:	f0 91 e5 1f 	lds	r31, 0x1FE5	; 0x801fe5 <tx_frame+0x1>
    515c:	86 81       	ldd	r24, Z+6	; 0x06
    515e:	88 0f       	add	r24, r24
    5160:	80 93 bb 00 	sts	0x00BB, r24	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7000bb>
        flag2 = _BV(TWEA);
    5164:	80 e4       	ldi	r24, 0x40	; 64
    5166:	80 93 d0 1f 	sts	0x1FD0, r24	; 0x801fd0 <flag2.3117>

        break;
    516a:	17 c1       	rjmp	.+558    	; 0x539a <__vector_39+0x51a>
    /* Data ACK */
    case TW_MT_SLA_ACK: 		// 0x18 SLA+W has been transmitted, ACK received
    case TW_MT_DATA_ACK: // 0x28 Data byte has been transmitted,  ACK received
        //printf("\nMaster Transmit -- ACK received");

        i2c_busy = 1;
    516c:	81 e0       	ldi	r24, 0x01	; 1
    516e:	90 e0       	ldi	r25, 0x00	; 0
    5170:	90 93 d4 1f 	sts	0x1FD4, r25	; 0x801fd4 <i2c_busy+0x1>
    5174:	80 93 d3 1f 	sts	0x1FD3, r24	; 0x801fd3 <i2c_busy>

        /* If there is data left in the tx_frame */
        if (tx_frame != NULL && tx_cnt < tx_frame->len) {
    5178:	80 91 e4 1f 	lds	r24, 0x1FE4	; 0x801fe4 <tx_frame>
    517c:	90 91 e5 1f 	lds	r25, 0x1FE5	; 0x801fe5 <tx_frame+0x1>
    5180:	00 97       	sbiw	r24, 0x00	; 0
    5182:	61 f1       	breq	.+88     	; 0x51dc <__vector_39+0x35c>
    5184:	20 91 dc 1f 	lds	r18, 0x1FDC	; 0x801fdc <tx_cnt>
    5188:	30 91 dd 1f 	lds	r19, 0x1FDD	; 0x801fdd <tx_cnt+0x1>
    518c:	fc 01       	movw	r30, r24
    518e:	40 85       	ldd	r20, Z+8	; 0x08
    5190:	51 85       	ldd	r21, Z+9	; 0x09
    5192:	24 17       	cp	r18, r20
    5194:	35 07       	cpc	r19, r21
    5196:	e0 f4       	brcc	.+56     	; 0x51d0 <__vector_39+0x350>
            TWDR = *(tx_frame->data + tx_cnt);
    5198:	20 91 dc 1f 	lds	r18, 0x1FDC	; 0x801fdc <tx_cnt>
    519c:	30 91 dd 1f 	lds	r19, 0x1FDD	; 0x801fdd <tx_cnt+0x1>
    51a0:	e2 0f       	add	r30, r18
    51a2:	f3 1f       	adc	r31, r19
    51a4:	82 85       	ldd	r24, Z+10	; 0x0a
    51a6:	80 93 bb 00 	sts	0x00BB, r24	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7000bb>
            tx_cnt++;
    51aa:	80 91 dc 1f 	lds	r24, 0x1FDC	; 0x801fdc <tx_cnt>
    51ae:	90 91 dd 1f 	lds	r25, 0x1FDD	; 0x801fdd <tx_cnt+0x1>
    51b2:	01 96       	adiw	r24, 0x01	; 1
    51b4:	90 93 dd 1f 	sts	0x1FDD, r25	; 0x801fdd <tx_cnt+0x1>
    51b8:	80 93 dc 1f 	sts	0x1FDC, r24	; 0x801fdc <tx_cnt>
            flag2 = _BV(TWEA);
    51bc:	80 e4       	ldi	r24, 0x40	; 64
    51be:	80 93 d0 1f 	sts	0x1FD0, r24	; 0x801fd0 <flag2.3117>

            break;
    51c2:	eb c0       	rjmp	.+470    	; 0x539a <__vector_39+0x51a>
    case TW_MT_DATA_NACK: 				// 0x30 Data transmitted, NACK returned

        //printf("\nMaster Transmit -- NACK return");

        /* Clear TX frame */
        if (tx_frame != NULL) {
    51c4:	80 91 e4 1f 	lds	r24, 0x1FE4	; 0x801fe4 <tx_frame>
    51c8:	90 91 e5 1f 	lds	r25, 0x1FE5	; 0x801fe5 <tx_frame+0x1>
    51cc:	00 97       	sbiw	r24, 0x00	; 0
    51ce:	31 f0       	breq	.+12     	; 0x51dc <__vector_39+0x35c>
            //printf("\nMaster Transmit -- NACK returned, clear tx frame");

            csp_buffer_free_isr(tx_frame);
    51d0:	0e 94 5d 16 	call	0x2cba	; 0x2cba <csp_buffer_free_isr>

            tx_frame = NULL;
    51d4:	10 92 e5 1f 	sts	0x1FE5, r1	; 0x801fe5 <tx_frame+0x1>
    51d8:	10 92 e4 1f 	sts	0x1FE4, r1	; 0x801fe4 <tx_frame>
        }

        /* Try new transmission */
        if (uxQueueMessagesWaitingFromISR(tx_queue) > 0) {
    51dc:	80 91 e2 1f 	lds	r24, 0x1FE2	; 0x801fe2 <tx_queue>
    51e0:	90 91 e3 1f 	lds	r25, 0x1FE3	; 0x801fe3 <tx_queue+0x1>
    51e4:	0e 94 e2 0d 	call	0x1bc4	; 0x1bc4 <uxQueueMessagesWaitingFromISR>
    51e8:	88 23       	and	r24, r24
    51ea:	61 f0       	breq	.+24     	; 0x5204 <__vector_39+0x384>

            /* Set START condition */
            flag |= _BV(TWSTA);
            flag |= _BV(TWSTO);
    51ec:	80 91 d1 1f 	lds	r24, 0x1FD1	; 0x801fd1 <flag.3116>
    51f0:	80 63       	ori	r24, 0x30	; 48
    51f2:	80 93 d1 1f 	sts	0x1FD1, r24	; 0x801fd1 <flag.3116>
            i2c_busy = 1;
    51f6:	81 e0       	ldi	r24, 0x01	; 1
    51f8:	90 e0       	ldi	r25, 0x00	; 0
    51fa:	90 93 d4 1f 	sts	0x1FD4, r25	; 0x801fd4 <i2c_busy+0x1>
    51fe:	80 93 d3 1f 	sts	0x1FD3, r24	; 0x801fd3 <i2c_busy>
    5202:	09 c0       	rjmp	.+18     	; 0x5216 <__vector_39+0x396>
        }
        else {
            /* Set STOP condition */
            flag |= _BV(TWSTO);
    5204:	80 91 d1 1f 	lds	r24, 0x1FD1	; 0x801fd1 <flag.3116>
    5208:	80 61       	ori	r24, 0x10	; 16
    520a:	80 93 d1 1f 	sts	0x1FD1, r24	; 0x801fd1 <flag.3116>
            i2c_busy = 0;
    520e:	10 92 d4 1f 	sts	0x1FD4, r1	; 0x801fd4 <i2c_busy+0x1>
    5212:	10 92 d3 1f 	sts	0x1FD3, r1	; 0x801fd3 <i2c_busy>
        }

        flag2 = _BV(TWEA);
    5216:	80 e4       	ldi	r24, 0x40	; 64
    5218:	80 93 d0 1f 	sts	0x1FD0, r24	; 0x801fd0 <flag2.3117>

        break;
    521c:	be c0       	rjmp	.+380    	; 0x539a <__vector_39+0x51a>

    case TW_MT_ARB_LOST: 		// 0x38 Arbitration lost, return to slave mode.
        //printf("\nf");


        tx_cnt = 0;
    521e:	10 92 dd 1f 	sts	0x1FDD, r1	; 0x801fdd <tx_cnt+0x1>
    5222:	10 92 dc 1f 	sts	0x1FDC, r1	; 0x801fdc <tx_cnt>
        flag |= _BV(TWSTA);
    5226:	80 e2       	ldi	r24, 0x20	; 32
    5228:	80 93 d1 1f 	sts	0x1FD1, r24	; 0x801fd1 <flag.3116>
        i2c_busy = 1;
    522c:	81 e0       	ldi	r24, 0x01	; 1
    522e:	90 e0       	ldi	r25, 0x00	; 0
    5230:	90 93 d4 1f 	sts	0x1FD4, r25	; 0x801fd4 <i2c_busy+0x1>
    5234:	80 93 d3 1f 	sts	0x1FD3, r24	; 0x801fd3 <i2c_busy>
        flag2 = _BV(TWEA);
    5238:	80 e4       	ldi	r24, 0x40	; 64
    523a:	80 93 d0 1f 	sts	0x1FD0, r24	; 0x801fd0 <flag2.3117>

        break;
    523e:	ad c0       	rjmp	.+346    	; 0x539a <__vector_39+0x51a>


    case TW_MR_SLA_ACK:					// 0x40 SLA+R transmitted, ACK received
        //printf("\nslark");

        i2c_busy = 1;
    5240:	81 e0       	ldi	r24, 0x01	; 1
    5242:	90 e0       	ldi	r25, 0x00	; 0
    5244:	90 93 d4 1f 	sts	0x1FD4, r25	; 0x801fd4 <i2c_busy+0x1>
    5248:	80 93 d3 1f 	sts	0x1FD3, r24	; 0x801fd3 <i2c_busy>
        flag &= ~((1 << TWSTA) | (1 << TWSTO));
        flag2 = _BV(TWEA);
    524c:	80 e4       	ldi	r24, 0x40	; 64
    524e:	80 93 d0 1f 	sts	0x1FD0, r24	; 0x801fd0 <flag2.3117>

        break;
    5252:	a3 c0       	rjmp	.+326    	; 0x539a <__vector_39+0x51a>

    case TW_MR_DATA_ACK:					// 0x50 Data received, ACK returned
        //printf("\ndark");

        i2c_busy = 1;
    5254:	81 e0       	ldi	r24, 0x01	; 1
    5256:	90 e0       	ldi	r25, 0x00	; 0
    5258:	90 93 d4 1f 	sts	0x1FD4, r25	; 0x801fd4 <i2c_busy+0x1>
    525c:	80 93 d3 1f 	sts	0x1FD3, r24	; 0x801fd3 <i2c_busy>


        if (rx_frame != NULL && rx_cnt < rx_frame->len) {
    5260:	e0 91 e6 1f 	lds	r30, 0x1FE6	; 0x801fe6 <rx_frame>
    5264:	f0 91 e7 1f 	lds	r31, 0x1FE7	; 0x801fe7 <rx_frame+0x1>
    5268:	30 97       	sbiw	r30, 0x00	; 0
    526a:	f9 f0       	breq	.+62     	; 0x52aa <__vector_39+0x42a>
    526c:	80 91 da 1f 	lds	r24, 0x1FDA	; 0x801fda <rx_cnt>
    5270:	90 91 db 1f 	lds	r25, 0x1FDB	; 0x801fdb <rx_cnt+0x1>
    5274:	20 85       	ldd	r18, Z+8	; 0x08
    5276:	31 85       	ldd	r19, Z+9	; 0x09
    5278:	82 17       	cp	r24, r18
    527a:	93 07       	cpc	r25, r19
    527c:	b0 f4       	brcc	.+44     	; 0x52aa <__vector_39+0x42a>
            *(rx_frame->data + rx_cnt) = TWDR;
    527e:	80 91 da 1f 	lds	r24, 0x1FDA	; 0x801fda <rx_cnt>
    5282:	90 91 db 1f 	lds	r25, 0x1FDB	; 0x801fdb <rx_cnt+0x1>
    5286:	20 91 bb 00 	lds	r18, 0x00BB	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7000bb>
    528a:	e8 0f       	add	r30, r24
    528c:	f9 1f       	adc	r31, r25
    528e:	22 87       	std	Z+10, r18	; 0x0a
            rx_cnt++;
    5290:	80 91 da 1f 	lds	r24, 0x1FDA	; 0x801fda <rx_cnt>
    5294:	90 91 db 1f 	lds	r25, 0x1FDB	; 0x801fdb <rx_cnt+0x1>
    5298:	01 96       	adiw	r24, 0x01	; 1
    529a:	90 93 db 1f 	sts	0x1FDB, r25	; 0x801fdb <rx_cnt+0x1>
    529e:	80 93 da 1f 	sts	0x1FDA, r24	; 0x801fda <rx_cnt>
            flag2 = _BV(TWEA);
    52a2:	80 e4       	ldi	r24, 0x40	; 64
    52a4:	80 93 d0 1f 	sts	0x1FD0, r24	; 0x801fd0 <flag2.3117>

            break;
    52a8:	78 c0       	rjmp	.+240    	; 0x539a <__vector_39+0x51a>
//		}


    case TW_MR_SLA_NACK:				// 0x48 SLA+R transmitted, NACK received
        //printf("\nslnak");
        flag |= _BV(TWSTA);
    52aa:	80 e2       	ldi	r24, 0x20	; 32
    52ac:	80 93 d1 1f 	sts	0x1FD1, r24	; 0x801fd1 <flag.3116>
        flag2 = _BV(TWEA);
    52b0:	80 e4       	ldi	r24, 0x40	; 64
    52b2:	80 93 d0 1f 	sts	0x1FD0, r24	; 0x801fd0 <flag2.3117>

        break;
    52b6:	71 c0       	rjmp	.+226    	; 0x539a <__vector_39+0x51a>
    case TW_MR_DATA_NACK:					// 0x58 Data received, NACK returned

//		/* Clear TX frame */
        //printf("\ndatnak");

        if (rx_frame != NULL) {
    52b8:	80 91 e6 1f 	lds	r24, 0x1FE6	; 0x801fe6 <rx_frame>
    52bc:	90 91 e7 1f 	lds	r25, 0x1FE7	; 0x801fe7 <rx_frame+0x1>
    52c0:	89 2b       	or	r24, r25
    52c2:	41 f0       	breq	.+16     	; 0x52d4 <__vector_39+0x454>
//			for(int i=0; i<rx_cnt; i++){
//				receive_frame.data[i]= rx_frame->data[i];
//			}
            //printf("\ntried");
            rx_frame = NULL;
    52c4:	10 92 e7 1f 	sts	0x1FE7, r1	; 0x801fe7 <rx_frame+0x1>
    52c8:	10 92 e6 1f 	sts	0x1FE6, r1	; 0x801fe6 <rx_frame>
            rx_cnt = 0;
    52cc:	10 92 db 1f 	sts	0x1FDB, r1	; 0x801fdb <rx_cnt+0x1>
    52d0:	10 92 da 1f 	sts	0x1FDA, r1	; 0x801fda <rx_cnt>
        }

        /* Set STOP condition */
        flag |= _BV(TWSTO);
    52d4:	80 e1       	ldi	r24, 0x10	; 16
    52d6:	80 93 d1 1f 	sts	0x1FD1, r24	; 0x801fd1 <flag.3116>
        i2c_busy = 0;
    52da:	10 92 d4 1f 	sts	0x1FD4, r1	; 0x801fd4 <i2c_busy+0x1>
    52de:	10 92 d3 1f 	sts	0x1FD3, r1	; 0x801fd3 <i2c_busy>
        flag2 = _BV(TWEA);
    52e2:	80 e4       	ldi	r24, 0x40	; 64
    52e4:	80 93 d0 1f 	sts	0x1FD0, r24	; 0x801fd0 <flag2.3117>

        break;
    52e8:	58 c0       	rjmp	.+176    	; 0x539a <__vector_39+0x51a>
        TWI ERROR EVENTS
    */
    case TW_BUS_ERROR: 								// 0x00 Bus error

    default:
        printf("\nh");
    52ea:	83 ee       	ldi	r24, 0xE3	; 227
    52ec:	9d e0       	ldi	r25, 0x0D	; 13
    52ee:	9f 93       	push	r25
    52f0:	8f 93       	push	r24
    52f2:	1e d3       	rcall	.+1596   	; 0x5930 <printf_P>

        if (tx_frame != NULL) {
    52f4:	80 91 e4 1f 	lds	r24, 0x1FE4	; 0x801fe4 <tx_frame>
    52f8:	90 91 e5 1f 	lds	r25, 0x1FE5	; 0x801fe5 <tx_frame+0x1>
    52fc:	0f 90       	pop	r0
    52fe:	0f 90       	pop	r0
    5300:	00 97       	sbiw	r24, 0x00	; 0
    5302:	31 f0       	breq	.+12     	; 0x5310 <__vector_39+0x490>
            //printf("\ntried");

            csp_buffer_free_isr(tx_frame);
    5304:	0e 94 5d 16 	call	0x2cba	; 0x2cba <csp_buffer_free_isr>
            tx_frame = NULL;
    5308:	10 92 e5 1f 	sts	0x1FE5, r1	; 0x801fe5 <tx_frame+0x1>
    530c:	10 92 e4 1f 	sts	0x1FE4, r1	; 0x801fe4 <tx_frame>
        }

        if (rx_frame != NULL) {
    5310:	80 91 e6 1f 	lds	r24, 0x1FE6	; 0x801fe6 <rx_frame>
    5314:	90 91 e7 1f 	lds	r25, 0x1FE7	; 0x801fe7 <rx_frame+0x1>
    5318:	00 97       	sbiw	r24, 0x00	; 0
    531a:	31 f0       	breq	.+12     	; 0x5328 <__vector_39+0x4a8>
            //printf("\ntried");

            csp_buffer_free_isr(rx_frame);
    531c:	0e 94 5d 16 	call	0x2cba	; 0x2cba <csp_buffer_free_isr>
            rx_frame = NULL;
    5320:	10 92 e7 1f 	sts	0x1FE7, r1	; 0x801fe7 <rx_frame+0x1>
    5324:	10 92 e6 1f 	sts	0x1FE6, r1	; 0x801fe6 <rx_frame>
        }

        TWCR = 0; // Reset TWI hardware
    5328:	0c eb       	ldi	r16, 0xBC	; 188
    532a:	10 e0       	ldi	r17, 0x00	; 0
    532c:	f8 01       	movw	r30, r16
    532e:	10 82       	st	Z, r1
        TWBR = BITRATE(i2c_speed); // Set bit rate register
    5330:	c0 91 b9 00 	lds	r28, 0x00B9	; 0x8000b9 <__TEXT_REGION_LENGTH__+0x7000b9>
    5334:	20 91 d6 1f 	lds	r18, 0x1FD6	; 0x801fd6 <i2c_speed>
    5338:	30 91 d7 1f 	lds	r19, 0x1FD7	; 0x801fd7 <i2c_speed+0x1>
    533c:	a0 ed       	ldi	r26, 0xD0	; 208
    533e:	b7 e0       	ldi	r27, 0x07	; 7
    5340:	22 d2       	rcall	.+1092   	; 0x5786 <__umulhisi3>
    5342:	9b 01       	movw	r18, r22
    5344:	ac 01       	movw	r20, r24
    5346:	60 e0       	ldi	r22, 0x00	; 0
    5348:	74 e2       	ldi	r23, 0x24	; 36
    534a:	84 ef       	ldi	r24, 0xF4	; 244
    534c:	90 e0       	ldi	r25, 0x00	; 0
    534e:	f1 d1       	rcall	.+994    	; 0x5732 <__udivmodsi4>
    5350:	ca 01       	movw	r24, r20
    5352:	b9 01       	movw	r22, r18
    5354:	68 50       	subi	r22, 0x08	; 8
    5356:	71 09       	sbc	r23, r1
    5358:	81 09       	sbc	r24, r1
    535a:	91 09       	sbc	r25, r1
    535c:	c3 70       	andi	r28, 0x03	; 3
    535e:	cc 0f       	add	r28, r28
    5360:	21 e0       	ldi	r18, 0x01	; 1
    5362:	30 e0       	ldi	r19, 0x00	; 0
    5364:	02 c0       	rjmp	.+4      	; 0x536a <__vector_39+0x4ea>
    5366:	22 0f       	add	r18, r18
    5368:	33 1f       	adc	r19, r19
    536a:	ca 95       	dec	r28
    536c:	e2 f7       	brpl	.-8      	; 0x5366 <__vector_39+0x4e6>
    536e:	03 2e       	mov	r0, r19
    5370:	00 0c       	add	r0, r0
    5372:	44 0b       	sbc	r20, r20
    5374:	55 0b       	sbc	r21, r21
    5376:	dd d1       	rcall	.+954    	; 0x5732 <__udivmodsi4>
    5378:	20 93 b8 00 	sts	0x00B8, r18	; 0x8000b8 <__TEXT_REGION_LENGTH__+0x7000b8>
        TWAR = i2c_addr << 1; // Set slave address in the two wire address register
    537c:	80 91 d5 1f 	lds	r24, 0x1FD5	; 0x801fd5 <i2c_addr>
    5380:	88 0f       	add	r24, r24
    5382:	80 93 ba 00 	sts	0x00BA, r24	; 0x8000ba <__TEXT_REGION_LENGTH__+0x7000ba>
        TWCR = _BV(TWEA) | _BV(TWEN) | _BV(TWIE); // Enable acknowledge, twi and interrupts
    5386:	85 e4       	ldi	r24, 0x45	; 69
    5388:	f8 01       	movw	r30, r16
    538a:	80 83       	st	Z, r24
        flag2 = _BV(TWEA);
    538c:	80 e4       	ldi	r24, 0x40	; 64
    538e:	80 93 d0 1f 	sts	0x1FD0, r24	; 0x801fd0 <flag2.3117>
        i2c_busy = 0;
    5392:	10 92 d4 1f 	sts	0x1FD4, r1	; 0x801fd4 <i2c_busy+0x1>
    5396:	10 92 d3 1f 	sts	0x1FD3, r1	; 0x801fd3 <i2c_busy>
        break;
    }



    TWCR = flag | _BV(TWEN) | _BV(TWIE) | _BV(TWINT);
    539a:	80 91 d1 1f 	lds	r24, 0x1FD1	; 0x801fd1 <flag.3116>
    539e:	85 68       	ori	r24, 0x85	; 133
    53a0:	ec eb       	ldi	r30, 0xBC	; 188
    53a2:	f0 e0       	ldi	r31, 0x00	; 0
    53a4:	80 83       	st	Z, r24
    TWCR |= flag2;
    53a6:	90 81       	ld	r25, Z
    53a8:	80 91 d0 1f 	lds	r24, 0x1FD0	; 0x801fd0 <flag2.3117>
    53ac:	89 2b       	or	r24, r25
    53ae:	80 83       	st	Z, r24

    if (xTaskWoken == pdTRUE) {
    53b0:	80 91 d2 1f 	lds	r24, 0x1FD2	; 0x801fd2 <xTaskWoken.3115>
    53b4:	81 30       	cpi	r24, 0x01	; 1
    53b6:	11 f4       	brne	.+4      	; 0x53bc <__vector_39+0x53c>
        taskYIELD();
    53b8:	0e 94 04 0a 	call	0x1408	; 0x1408 <vPortYield>
    }
}
    53bc:	ff 91       	pop	r31
    53be:	ef 91       	pop	r30
    53c0:	cf 91       	pop	r28
    53c2:	bf 91       	pop	r27
    53c4:	af 91       	pop	r26
    53c6:	9f 91       	pop	r25
    53c8:	8f 91       	pop	r24
    53ca:	7f 91       	pop	r23
    53cc:	6f 91       	pop	r22
    53ce:	5f 91       	pop	r21
    53d0:	4f 91       	pop	r20
    53d2:	3f 91       	pop	r19
    53d4:	2f 91       	pop	r18
    53d6:	1f 91       	pop	r17
    53d8:	0f 91       	pop	r16
    53da:	0f 90       	pop	r0
    53dc:	0b be       	out	0x3b, r0	; 59
    53de:	0f 90       	pop	r0
    53e0:	0f be       	out	0x3f, r0	; 63
    53e2:	0f 90       	pop	r0
    53e4:	1f 90       	pop	r1
    53e6:	18 95       	reti

000053e8 <uart_putchar>:
 * Send character c down the UART Tx, wait until tx holding register
 * is empty.
 */
int
uart_putchar(char c, FILE *stream)
{
    53e8:	cf 93       	push	r28
    53ea:	c8 2f       	mov	r28, r24

  if (c == '\a')
    53ec:	87 30       	cpi	r24, 0x07	; 7
    53ee:	61 f4       	brne	.+24     	; 0x5408 <uart_putchar+0x20>
    {
      fputs("*ring*\n", stderr);
    53f0:	20 91 42 20 	lds	r18, 0x2042	; 0x802042 <__iob+0x4>
    53f4:	30 91 43 20 	lds	r19, 0x2043	; 0x802043 <__iob+0x5>
    53f8:	47 e0       	ldi	r20, 0x07	; 7
    53fa:	50 e0       	ldi	r21, 0x00	; 0
    53fc:	61 e0       	ldi	r22, 0x01	; 1
    53fe:	70 e0       	ldi	r23, 0x00	; 0
    5400:	82 ed       	ldi	r24, 0xD2	; 210
    5402:	93 e0       	ldi	r25, 0x03	; 3
    5404:	53 d2       	rcall	.+1190   	; 0x58ac <fwrite>
      return 0;
    5406:	0b c0       	rjmp	.+22     	; 0x541e <uart_putchar+0x36>
    }

  if (c == '\n')
    5408:	8a 30       	cpi	r24, 0x0A	; 10
    540a:	11 f4       	brne	.+4      	; 0x5410 <uart_putchar+0x28>
    uart_putchar('\r', stream);
    540c:	8d e0       	ldi	r24, 0x0D	; 13
    540e:	ec df       	rcall	.-40     	; 0x53e8 <uart_putchar>
  loop_until_bit_is_set(UCSR0A, UDRE0);
    5410:	e0 ec       	ldi	r30, 0xC0	; 192
    5412:	f0 e0       	ldi	r31, 0x00	; 0
    5414:	80 81       	ld	r24, Z
    5416:	85 ff       	sbrs	r24, 5
    5418:	fd cf       	rjmp	.-6      	; 0x5414 <uart_putchar+0x2c>
  UDR0 = c;
    541a:	c0 93 c6 00 	sts	0x00C6, r28	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7000c6>

  return 0;
}
    541e:	80 e0       	ldi	r24, 0x00	; 0
    5420:	90 e0       	ldi	r25, 0x00	; 0
    5422:	cf 91       	pop	r28
    5424:	08 95       	ret

00005426 <uart_getchar>:
 * Successive calls to uart_getchar() will be satisfied from the
 * internal buffer until that buffer is emptied again.
 */
int
uart_getchar(FILE *stream)
{
    5426:	6f 92       	push	r6
    5428:	7f 92       	push	r7
    542a:	8f 92       	push	r8
    542c:	9f 92       	push	r9
    542e:	af 92       	push	r10
    5430:	bf 92       	push	r11
    5432:	cf 92       	push	r12
    5434:	df 92       	push	r13
    5436:	ef 92       	push	r14
    5438:	ff 92       	push	r15
    543a:	0f 93       	push	r16
    543c:	1f 93       	push	r17
    543e:	cf 93       	push	r28
    5440:	df 93       	push	r29
  uint8_t c;
  char *cp, *cp2;
  static char b[RX_BUFSIZE];
  static char *rxp;

  if (rxp == 0)
    5442:	20 91 3a 20 	lds	r18, 0x203A	; 0x80203a <rxp.2118>
    5446:	30 91 3b 20 	lds	r19, 0x203B	; 0x80203b <rxp.2118+0x1>
    544a:	23 2b       	or	r18, r19
    544c:	09 f0       	breq	.+2      	; 0x5450 <uart_getchar+0x2a>
    544e:	cc c0       	rjmp	.+408    	; 0x55e8 <uart_getchar+0x1c2>
    5450:	8c 01       	movw	r16, r24
    5452:	0f 2e       	mov	r0, r31
    5454:	fa ee       	ldi	r31, 0xEA	; 234
    5456:	8f 2e       	mov	r8, r31
    5458:	ff e1       	ldi	r31, 0x1F	; 31
    545a:	9f 2e       	mov	r9, r31
    545c:	f0 2d       	mov	r31, r0
    for (cp = b;;)
      {
	loop_until_bit_is_set(UCSR0A, RXC0);
    545e:	c0 ec       	ldi	r28, 0xC0	; 192
    5460:	d0 e0       	ldi	r29, 0x00	; 0
	if (UCSR0A & _BV(FE0))
	  return _FDEV_EOF;
	if (UCSR0A & _BV(DOR0))
	  return _FDEV_ERR;
	c = UDR0;
    5462:	0f 2e       	mov	r0, r31
    5464:	f6 ec       	ldi	r31, 0xC6	; 198
    5466:	cf 2e       	mov	r12, r31
    5468:	d1 2c       	mov	r13, r1
    546a:	f0 2d       	mov	r31, r0
    546c:	54 01       	movw	r10, r8
    546e:	0f 2e       	mov	r0, r31
    5470:	f9 ee       	ldi	r31, 0xE9	; 233
    5472:	6f 2e       	mov	r6, r31
    5474:	ff e1       	ldi	r31, 0x1F	; 31
    5476:	7f 2e       	mov	r7, r31
    5478:	f0 2d       	mov	r31, r0
  static char *rxp;

  if (rxp == 0)
    for (cp = b;;)
      {
	loop_until_bit_is_set(UCSR0A, RXC0);
    547a:	88 81       	ld	r24, Y
    547c:	88 23       	and	r24, r24
    547e:	ec f7       	brge	.-6      	; 0x547a <uart_getchar+0x54>
	if (UCSR0A & _BV(FE0))
    5480:	88 81       	ld	r24, Y
    5482:	84 fd       	sbrc	r24, 4
    5484:	c4 c0       	rjmp	.+392    	; 0x560e <uart_getchar+0x1e8>
	  return _FDEV_EOF;
	if (UCSR0A & _BV(DOR0))
    5486:	88 81       	ld	r24, Y
    5488:	83 fd       	sbrc	r24, 3
    548a:	c4 c0       	rjmp	.+392    	; 0x5614 <uart_getchar+0x1ee>
	  return _FDEV_ERR;
	c = UDR0;
    548c:	f6 01       	movw	r30, r12
    548e:	80 81       	ld	r24, Z
	/* behaviour similar to Unix stty ICRNL */
	if (c == '\r')
    5490:	8d 30       	cpi	r24, 0x0D	; 13
    5492:	11 f0       	breq	.+4      	; 0x5498 <uart_getchar+0x72>
	  c = '\n';
	if (c == '\n')
    5494:	8a 30       	cpi	r24, 0x0A	; 10
    5496:	61 f4       	brne	.+24     	; 0x54b0 <uart_getchar+0x8a>
	  {
	    *cp = c;
    5498:	8a e0       	ldi	r24, 0x0A	; 10
    549a:	f4 01       	movw	r30, r8
    549c:	80 83       	st	Z, r24
	    uart_putchar(c, stream);
    549e:	b8 01       	movw	r22, r16
    54a0:	a3 df       	rcall	.-186    	; 0x53e8 <uart_putchar>
	    rxp = b;
    54a2:	8a ee       	ldi	r24, 0xEA	; 234
    54a4:	9f e1       	ldi	r25, 0x1F	; 31
    54a6:	90 93 3b 20 	sts	0x203B, r25	; 0x80203b <rxp.2118+0x1>
    54aa:	80 93 3a 20 	sts	0x203A, r24	; 0x80203a <rxp.2118>
	    break;
    54ae:	9c c0       	rjmp	.+312    	; 0x55e8 <uart_getchar+0x1c2>
	  }
	else if (c == '\t')
    54b0:	89 30       	cpi	r24, 0x09	; 9
    54b2:	39 f0       	breq	.+14     	; 0x54c2 <uart_getchar+0x9c>
	  c = ' ';

	if ((c >= (uint8_t)' ' && c <= (uint8_t)'\x7e') ||
    54b4:	90 ee       	ldi	r25, 0xE0	; 224
    54b6:	98 0f       	add	r25, r24
    54b8:	9f 35       	cpi	r25, 0x5F	; 95
    54ba:	20 f0       	brcs	.+8      	; 0x54c4 <uart_getchar+0x9e>
    54bc:	80 3a       	cpi	r24, 0xA0	; 160
    54be:	a8 f0       	brcs	.+42     	; 0x54ea <uart_getchar+0xc4>
    54c0:	01 c0       	rjmp	.+2      	; 0x54c4 <uart_getchar+0x9e>
	    uart_putchar(c, stream);
	    rxp = b;
	    break;
	  }
	else if (c == '\t')
	  c = ' ';
    54c2:	80 e2       	ldi	r24, 0x20	; 32

	if ((c >= (uint8_t)' ' && c <= (uint8_t)'\x7e') ||
	    c >= (uint8_t)'\xa0')
	  {
	    if (cp == b + RX_BUFSIZE - 1)
    54c4:	f9 e3       	ldi	r31, 0x39	; 57
    54c6:	8f 16       	cp	r8, r31
    54c8:	f0 e2       	ldi	r31, 0x20	; 32
    54ca:	9f 06       	cpc	r9, r31
    54cc:	21 f4       	brne	.+8      	; 0x54d6 <uart_getchar+0xb0>
	      uart_putchar('\a', stream);
    54ce:	b8 01       	movw	r22, r16
    54d0:	87 e0       	ldi	r24, 0x07	; 7
    54d2:	8a df       	rcall	.-236    	; 0x53e8 <uart_putchar>
    54d4:	d2 cf       	rjmp	.-92     	; 0x547a <uart_getchar+0x54>
	    else
	      {
		*cp++ = c;
    54d6:	74 01       	movw	r14, r8
    54d8:	9f ef       	ldi	r25, 0xFF	; 255
    54da:	e9 1a       	sub	r14, r25
    54dc:	f9 0a       	sbc	r15, r25
    54de:	f4 01       	movw	r30, r8
		uart_putchar(c, stream);
    54e0:	80 83       	st	Z, r24
    54e2:	b8 01       	movw	r22, r16
    54e4:	81 df       	rcall	.-254    	; 0x53e8 <uart_putchar>
	  {
	    if (cp == b + RX_BUFSIZE - 1)
	      uart_putchar('\a', stream);
	    else
	      {
		*cp++ = c;
    54e6:	47 01       	movw	r8, r14
    54e8:	c8 cf       	rjmp	.-112    	; 0x547a <uart_getchar+0x54>
		uart_putchar(c, stream);
	      }
	    continue;
	  }

	switch (c)
    54ea:	82 31       	cpi	r24, 0x12	; 18
    54ec:	b9 f1       	breq	.+110    	; 0x555c <uart_getchar+0x136>
    54ee:	30 f4       	brcc	.+12     	; 0x54fc <uart_getchar+0xd6>
    54f0:	83 30       	cpi	r24, 0x03	; 3
    54f2:	09 f4       	brne	.+2      	; 0x54f6 <uart_getchar+0xd0>
    54f4:	92 c0       	rjmp	.+292    	; 0x561a <uart_getchar+0x1f4>
    54f6:	88 30       	cpi	r24, 0x08	; 8
    54f8:	e9 f0       	breq	.+58     	; 0x5534 <uart_getchar+0x10e>
    54fa:	bf cf       	rjmp	.-130    	; 0x547a <uart_getchar+0x54>
    54fc:	87 31       	cpi	r24, 0x17	; 23
    54fe:	29 f0       	breq	.+10     	; 0x550a <uart_getchar+0xe4>
    5500:	8f 37       	cpi	r24, 0x7F	; 127
    5502:	c1 f0       	breq	.+48     	; 0x5534 <uart_getchar+0x10e>
    5504:	85 31       	cpi	r24, 0x15	; 21
    5506:	79 f0       	breq	.+30     	; 0x5526 <uart_getchar+0x100>
    5508:	b8 cf       	rjmp	.-144    	; 0x547a <uart_getchar+0x54>
		cp--;
	      }
	    break;

	  case 'w' & 0x1f:
	    while (cp > b && cp[-1] != ' ')
    550a:	fa ee       	ldi	r31, 0xEA	; 234
    550c:	8f 16       	cp	r8, r31
    550e:	ff e1       	ldi	r31, 0x1F	; 31
    5510:	9f 06       	cpc	r9, r31
    5512:	09 f0       	breq	.+2      	; 0x5516 <uart_getchar+0xf0>
    5514:	08 f4       	brcc	.+2      	; 0x5518 <uart_getchar+0xf2>
    5516:	b1 cf       	rjmp	.-158    	; 0x547a <uart_getchar+0x54>
    5518:	f4 01       	movw	r30, r8
    551a:	31 97       	sbiw	r30, 0x01	; 1
    551c:	80 81       	ld	r24, Z
    551e:	80 32       	cpi	r24, 0x20	; 32
    5520:	09 f0       	breq	.+2      	; 0x5524 <uart_getchar+0xfe>
    5522:	4a c0       	rjmp	.+148    	; 0x55b8 <uart_getchar+0x192>
    5524:	aa cf       	rjmp	.-172    	; 0x547a <uart_getchar+0x54>
	    for (cp2 = b; cp2 < cp; cp2++)
	      uart_putchar(*cp2, stream);
	    break;

	  case 'u' & 0x1f:
	    while (cp > b)
    5526:	8a ee       	ldi	r24, 0xEA	; 234
    5528:	88 16       	cp	r8, r24
    552a:	8f e1       	ldi	r24, 0x1F	; 31
    552c:	98 06       	cpc	r9, r24
    552e:	09 f0       	breq	.+2      	; 0x5532 <uart_getchar+0x10c>
    5530:	70 f5       	brcc	.+92     	; 0x558e <uart_getchar+0x168>
    5532:	a3 cf       	rjmp	.-186    	; 0x547a <uart_getchar+0x54>
	  case 'c' & 0x1f:
	    return -1;

	  case '\b':
	  case '\x7f':
	    if (cp > b)
    5534:	9a ee       	ldi	r25, 0xEA	; 234
    5536:	89 16       	cp	r8, r25
    5538:	9f e1       	ldi	r25, 0x1F	; 31
    553a:	99 06       	cpc	r9, r25
    553c:	09 f0       	breq	.+2      	; 0x5540 <uart_getchar+0x11a>
    553e:	08 f4       	brcc	.+2      	; 0x5542 <uart_getchar+0x11c>
	      {
		uart_putchar('\b', stream);
    5540:	9c cf       	rjmp	.-200    	; 0x547a <uart_getchar+0x54>
    5542:	b8 01       	movw	r22, r16
    5544:	88 e0       	ldi	r24, 0x08	; 8
		uart_putchar(' ', stream);
    5546:	50 df       	rcall	.-352    	; 0x53e8 <uart_putchar>
    5548:	b8 01       	movw	r22, r16
    554a:	80 e2       	ldi	r24, 0x20	; 32
		uart_putchar('\b', stream);
    554c:	4d df       	rcall	.-358    	; 0x53e8 <uart_putchar>
    554e:	b8 01       	movw	r22, r16
    5550:	88 e0       	ldi	r24, 0x08	; 8
    5552:	4a df       	rcall	.-364    	; 0x53e8 <uart_putchar>
		cp--;
    5554:	e1 e0       	ldi	r30, 0x01	; 1
    5556:	8e 1a       	sub	r8, r30
    5558:	91 08       	sbc	r9, r1
	      }
	    break;

	  case 'r' & 0x1f:
	    uart_putchar('\r', stream);
    555a:	8f cf       	rjmp	.-226    	; 0x547a <uart_getchar+0x54>
    555c:	b8 01       	movw	r22, r16
    555e:	8d e0       	ldi	r24, 0x0D	; 13
    5560:	43 df       	rcall	.-378    	; 0x53e8 <uart_putchar>
	    for (cp2 = b; cp2 < cp; cp2++)
    5562:	fa ee       	ldi	r31, 0xEA	; 234
    5564:	8f 16       	cp	r8, r31
    5566:	ff e1       	ldi	r31, 0x1F	; 31
    5568:	9f 06       	cpc	r9, r31
    556a:	09 f0       	breq	.+2      	; 0x556e <uart_getchar+0x148>
    556c:	08 f4       	brcc	.+2      	; 0x5570 <uart_getchar+0x14a>
    556e:	85 cf       	rjmp	.-246    	; 0x547a <uart_getchar+0x54>
    5570:	0f 2e       	mov	r0, r31
    5572:	fa ee       	ldi	r31, 0xEA	; 234
    5574:	ef 2e       	mov	r14, r31
    5576:	ff e1       	ldi	r31, 0x1F	; 31
    5578:	ff 2e       	mov	r15, r31
	      uart_putchar(*cp2, stream);
    557a:	f0 2d       	mov	r31, r0
    557c:	b8 01       	movw	r22, r16
    557e:	f7 01       	movw	r30, r14
    5580:	81 91       	ld	r24, Z+
    5582:	7f 01       	movw	r14, r30
	      }
	    break;

	  case 'r' & 0x1f:
	    uart_putchar('\r', stream);
	    for (cp2 = b; cp2 < cp; cp2++)
    5584:	31 df       	rcall	.-414    	; 0x53e8 <uart_putchar>
    5586:	8e 14       	cp	r8, r14
    5588:	9f 04       	cpc	r9, r15
	    break;

	  case 'u' & 0x1f:
	    while (cp > b)
	      {
		uart_putchar('\b', stream);
    558a:	c1 f7       	brne	.-16     	; 0x557c <uart_getchar+0x156>
    558c:	76 cf       	rjmp	.-276    	; 0x547a <uart_getchar+0x54>
    558e:	b8 01       	movw	r22, r16
		uart_putchar(' ', stream);
    5590:	88 e0       	ldi	r24, 0x08	; 8
    5592:	2a df       	rcall	.-428    	; 0x53e8 <uart_putchar>
    5594:	b8 01       	movw	r22, r16
    5596:	80 e2       	ldi	r24, 0x20	; 32
		uart_putchar('\b', stream);
    5598:	27 df       	rcall	.-434    	; 0x53e8 <uart_putchar>
    559a:	b8 01       	movw	r22, r16
    559c:	88 e0       	ldi	r24, 0x08	; 8
    559e:	24 df       	rcall	.-440    	; 0x53e8 <uart_putchar>
		cp--;
    55a0:	f1 e0       	ldi	r31, 0x01	; 1
    55a2:	8f 1a       	sub	r8, r31
    55a4:	91 08       	sbc	r9, r1
	    for (cp2 = b; cp2 < cp; cp2++)
	      uart_putchar(*cp2, stream);
	    break;

	  case 'u' & 0x1f:
	    while (cp > b)
    55a6:	8a ee       	ldi	r24, 0xEA	; 234
    55a8:	88 16       	cp	r8, r24
    55aa:	8f e1       	ldi	r24, 0x1F	; 31
    55ac:	98 06       	cpc	r9, r24
    55ae:	79 f7       	brne	.-34     	; 0x558e <uart_getchar+0x168>
    55b0:	f3 01       	movw	r30, r6
    55b2:	31 96       	adiw	r30, 0x01	; 1
    55b4:	4f 01       	movw	r8, r30
    55b6:	61 cf       	rjmp	.-318    	; 0x547a <uart_getchar+0x54>
    55b8:	74 01       	movw	r14, r8
	    break;

	  case 'w' & 0x1f:
	    while (cp > b && cp[-1] != ' ')
	      {
		uart_putchar('\b', stream);
    55ba:	f1 e0       	ldi	r31, 0x01	; 1
    55bc:	ef 1a       	sub	r14, r31
    55be:	f1 08       	sbc	r15, r1
    55c0:	b8 01       	movw	r22, r16
		uart_putchar(' ', stream);
    55c2:	88 e0       	ldi	r24, 0x08	; 8
    55c4:	11 df       	rcall	.-478    	; 0x53e8 <uart_putchar>
    55c6:	b8 01       	movw	r22, r16
    55c8:	80 e2       	ldi	r24, 0x20	; 32
		uart_putchar('\b', stream);
    55ca:	0e df       	rcall	.-484    	; 0x53e8 <uart_putchar>
    55cc:	b8 01       	movw	r22, r16
    55ce:	88 e0       	ldi	r24, 0x08	; 8
    55d0:	0b df       	rcall	.-490    	; 0x53e8 <uart_putchar>
		cp--;
    55d2:	47 01       	movw	r8, r14
		cp--;
	      }
	    break;

	  case 'w' & 0x1f:
	    while (cp > b && cp[-1] != ' ')
    55d4:	ea 14       	cp	r14, r10
    55d6:	fb 04       	cpc	r15, r11
    55d8:	09 f4       	brne	.+2      	; 0x55dc <uart_getchar+0x1b6>
    55da:	4f cf       	rjmp	.-354    	; 0x547a <uart_getchar+0x54>
    55dc:	f7 01       	movw	r30, r14
    55de:	82 91       	ld	r24, -Z
    55e0:	7f 01       	movw	r14, r30
    55e2:	80 32       	cpi	r24, 0x20	; 32
    55e4:	69 f7       	brne	.-38     	; 0x55c0 <uart_getchar+0x19a>
    55e6:	49 cf       	rjmp	.-366    	; 0x547a <uart_getchar+0x54>
	      }
	    break;
	  }
      }

  c = *rxp++;
    55e8:	e0 91 3a 20 	lds	r30, 0x203A	; 0x80203a <rxp.2118>
    55ec:	f0 91 3b 20 	lds	r31, 0x203B	; 0x80203b <rxp.2118+0x1>
    55f0:	cf 01       	movw	r24, r30
    55f2:	01 96       	adiw	r24, 0x01	; 1
    55f4:	90 93 3b 20 	sts	0x203B, r25	; 0x80203b <rxp.2118+0x1>
    55f8:	80 93 3a 20 	sts	0x203A, r24	; 0x80203a <rxp.2118>
    55fc:	80 81       	ld	r24, Z
  if (c == '\n')
    55fe:	8a 30       	cpi	r24, 0x0A	; 10
    5600:	21 f4       	brne	.+8      	; 0x560a <uart_getchar+0x1e4>
    rxp = 0;
    5602:	10 92 3b 20 	sts	0x203B, r1	; 0x80203b <rxp.2118+0x1>
    5606:	10 92 3a 20 	sts	0x203A, r1	; 0x80203a <rxp.2118>

  return c;
    560a:	90 e0       	ldi	r25, 0x00	; 0
    560c:	08 c0       	rjmp	.+16     	; 0x561e <uart_getchar+0x1f8>
  if (rxp == 0)
    for (cp = b;;)
      {
	loop_until_bit_is_set(UCSR0A, RXC0);
	if (UCSR0A & _BV(FE0))
	  return _FDEV_EOF;
    560e:	8e ef       	ldi	r24, 0xFE	; 254
    5610:	9f ef       	ldi	r25, 0xFF	; 255
    5612:	05 c0       	rjmp	.+10     	; 0x561e <uart_getchar+0x1f8>
	if (UCSR0A & _BV(DOR0))
	  return _FDEV_ERR;
    5614:	8f ef       	ldi	r24, 0xFF	; 255
    5616:	9f ef       	ldi	r25, 0xFF	; 255
    5618:	02 c0       	rjmp	.+4      	; 0x561e <uart_getchar+0x1f8>
	  }

	switch (c)
	  {
	  case 'c' & 0x1f:
	    return -1;
    561a:	8f ef       	ldi	r24, 0xFF	; 255
    561c:	9f ef       	ldi	r25, 0xFF	; 255
  c = *rxp++;
  if (c == '\n')
    rxp = 0;

  return c;
}
    561e:	df 91       	pop	r29
    5620:	cf 91       	pop	r28
    5622:	1f 91       	pop	r17
    5624:	0f 91       	pop	r16
    5626:	ff 90       	pop	r15
    5628:	ef 90       	pop	r14
    562a:	df 90       	pop	r13
    562c:	cf 90       	pop	r12
    562e:	bf 90       	pop	r11
    5630:	af 90       	pop	r10
    5632:	9f 90       	pop	r9
    5634:	8f 90       	pop	r8
    5636:	7f 90       	pop	r7
    5638:	6f 90       	pop	r6
    563a:	08 95       	ret

0000563c <uart_init>:
{
#if F_CPU < 2000000UL && defined(U2X)
  UCSRA = _BV(U2X);             /* improve baud rate error by using 2x clk */
  UBRRL = (F_CPU / (8UL * UART_BAUD)) - 1;
#else
	UBRR0H = (uint8_t) (MYUBRR >> 8);
    563c:	10 92 c5 00 	sts	0x00C5, r1	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7000c5>
	UBRR0L = (uint8_t) MYUBRR;
    5640:	80 e1       	ldi	r24, 0x10	; 16
    5642:	80 93 c4 00 	sts	0x00C4, r24	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7000c4>
#endif
	UCSR0B = (1 << RXEN0) | (1 << TXEN0); /* tx/rx enable */
    5646:	88 e1       	ldi	r24, 0x18	; 24
    5648:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7000c1>
	UCSR0C = (3 << UCSZ00);
    564c:	86 e0       	ldi	r24, 0x06	; 6
    564e:	80 93 c2 00 	sts	0x00C2, r24	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7000c2>
	stdout = stdin = &usart0_str;
    5652:	ee e3       	ldi	r30, 0x3E	; 62
    5654:	f0 e2       	ldi	r31, 0x20	; 32
    5656:	81 e7       	ldi	r24, 0x71	; 113
    5658:	92 e0       	ldi	r25, 0x02	; 2
    565a:	91 83       	std	Z+1, r25	; 0x01
    565c:	80 83       	st	Z, r24
    565e:	93 83       	std	Z+3, r25	; 0x03
    5660:	82 83       	std	Z+2, r24	; 0x02
    5662:	08 95       	ret

00005664 <main>:
extern TaskHandle_t I2C_task;

int main(void) {
    /* Initialization Mode */
    // Initialize board
    board_init();
    5664:	52 d0       	rcall	.+164    	; 0x570a <board_init>

    // Initialize UART
    // Baud Rate: 57600
    uart_init();
    5666:	ea df       	rcall	.-44     	; 0x563c <uart_init>
    5668:	8a e7       	ldi	r24, 0x7A	; 122
    printf("----------- OBC: Initialization Mode -----------\r\n");
    566a:	9e e0       	ldi	r25, 0x0E	; 14
    566c:	9f 93       	push	r25
    566e:	8f 93       	push	r24
    5670:	5f d1       	rcall	.+702    	; 0x5930 <printf_P>
    5672:	6c e2       	ldi	r22, 0x2C	; 44
    ioport_init();

    // Initialize CSP
    // 300 bytes per buffer --> I2C MTU = 256 bytes
    // Buffer = MTU + 2 Sync flag + 2 Length field
    csp_buffer_init(2, 300);
    5674:	71 e0       	ldi	r23, 0x01	; 1
    5676:	82 e0       	ldi	r24, 0x02	; 2
    5678:	90 e0       	ldi	r25, 0x00	; 0
    567a:	0e 94 d6 14 	call	0x29ac	; 0x29ac <csp_buffer_init>
    567e:	81 e0       	ldi	r24, 0x01	; 1
    csp_init(OBC_ADDR);
    5680:	0e 94 6e 1c 	call	0x38dc	; 0x38dc <csp_init>
    5684:	40 e9       	ldi	r20, 0x90	; 144
    csp_i2c_init(OBC_ADDR, 0, 400);
    5686:	51 e0       	ldi	r21, 0x01	; 1
    5688:	60 e0       	ldi	r22, 0x00	; 0
    568a:	70 e0       	ldi	r23, 0x00	; 0
    568c:	81 e0       	ldi	r24, 0x01	; 1
    568e:	e4 d8       	rcall	.-3640   	; 0x4858 <csp_i2c_init>
    5690:	2f ef       	ldi	r18, 0xFF	; 255
    csp_route_set(EPS_ADDR, &csp_if_i2c, CSP_NODE_MAC);
    5692:	4b e0       	ldi	r20, 0x0B	; 11
    5694:	52 e0       	ldi	r21, 0x02	; 2
    5696:	65 e0       	ldi	r22, 0x05	; 5
    5698:	82 e0       	ldi	r24, 0x02	; 2
    569a:	76 d9       	rcall	.-3348   	; 0x4988 <csp_rtable_set>
    569c:	61 e0       	ldi	r22, 0x01	; 1
    csp_route_start_task(500, 1);
    569e:	70 e0       	ldi	r23, 0x00	; 0
    56a0:	84 ef       	ldi	r24, 0xF4	; 244
    56a2:	91 e0       	ldi	r25, 0x01	; 1
    56a4:	0e d8       	rcall	.-4068   	; 0x46c2 <csp_route_start_task>
    56a6:	bb d9       	rcall	.-3210   	; 0x4a1e <csp_rtable_print>
    csp_rtable_print();	// For debugging purposes
    56a8:	87 e7       	ldi	r24, 0x77	; 119
    printf("\r\n");
    56aa:	9e e0       	ldi	r25, 0x0E	; 14
    56ac:	9f 93       	push	r25
    56ae:	8f 93       	push	r24
    56b0:	3f d1       	rcall	.+638    	; 0x5930 <printf_P>
    56b2:	e1 2c       	mov	r14, r1
    56b4:	f1 2c       	mov	r15, r1

    // Create FreeRTOS tasks
    // Placeholder blinky task
    extern void led_blinky(void *pvParameters);
    xTaskCreate(led_blinky, "Task to blink led pin 13", 100, NULL, OBC_NORM_PRIO, NULL);
    56b6:	01 e0       	ldi	r16, 0x01	; 1
    56b8:	20 e0       	ldi	r18, 0x00	; 0
    56ba:	30 e0       	ldi	r19, 0x00	; 0
    56bc:	44 e6       	ldi	r20, 0x64	; 100
    56be:	50 e0       	ldi	r21, 0x00	; 0
    56c0:	6a ed       	ldi	r22, 0xDA	; 218
    56c2:	73 e0       	ldi	r23, 0x03	; 3
    56c4:	8f ed       	ldi	r24, 0xDF	; 223
    56c6:	95 e2       	ldi	r25, 0x25	; 37
    56c8:	0e 94 82 0e 	call	0x1d04	; 0x1d04 <xTaskCreate>
    56cc:	0f 2e       	mov	r0, r31
    56ce:	fc e3       	ldi	r31, 0x3C	; 60

    // Task for the csp server to be loaded
    extern void csp_twoway_client(void *pvParameters);
    xTaskCreate(csp_twoway_client, "Task for CSP server", 250, NULL, OBC_CSP_PRIO, &I2C_task);
    56d0:	ef 2e       	mov	r14, r31
    56d2:	f0 e2       	ldi	r31, 0x20	; 32
    56d4:	ff 2e       	mov	r15, r31
    56d6:	f0 2d       	mov	r31, r0
    56d8:	05 e0       	ldi	r16, 0x05	; 5
    56da:	20 e0       	ldi	r18, 0x00	; 0
    56dc:	30 e0       	ldi	r19, 0x00	; 0
    56de:	4a ef       	ldi	r20, 0xFA	; 250
    56e0:	50 e0       	ldi	r21, 0x00	; 0
    56e2:	63 ef       	ldi	r22, 0xF3	; 243
    56e4:	73 e0       	ldi	r23, 0x03	; 3
    56e6:	87 ee       	ldi	r24, 0xE7	; 231
    56e8:	95 e2       	ldi	r25, 0x25	; 37
    56ea:	0e 94 82 0e 	call	0x1d04	; 0x1d04 <xTaskCreate>
    56ee:	88 e4       	ldi	r24, 0x48	; 72

    /*-----------------------------------------------------------------------------*/


    /* Autonomous Mode */
    printf("----------- OBC: Autonomous Mode -----------\r\n");
    56f0:	9e e0       	ldi	r25, 0x0E	; 14
    56f2:	9f 93       	push	r25
    56f4:	8f 93       	push	r24
    56f6:	1c d1       	rcall	.+568    	; 0x5930 <printf_P>
    56f8:	0e 94 de 0f 	call	0x1fbc	; 0x1fbc <vTaskStartScheduler>
    // Start Scheduler
    vTaskStartScheduler();
    56fc:	0f 90       	pop	r0
    56fe:	0f 90       	pop	r0
    5700:	0f 90       	pop	r0
    5702:	0f 90       	pop	r0
    5704:	0f 90       	pop	r0
    5706:	0f 90       	pop	r0
    5708:	ff cf       	rjmp	.-2      	; 0x5708 <main+0xa4>

0000570a <board_init>:
#include <compiler.h>
#include <conf_board.h>


void board_init(void)
{
    570a:	08 95       	ret

0000570c <__divmodhi4>:
    570c:	97 fb       	bst	r25, 7
    570e:	07 2e       	mov	r0, r23
    5710:	16 f4       	brtc	.+4      	; 0x5716 <__divmodhi4+0xa>
    5712:	00 94       	com	r0
    5714:	06 d0       	rcall	.+12     	; 0x5722 <__divmodhi4_neg1>
    5716:	77 fd       	sbrc	r23, 7
    5718:	08 d0       	rcall	.+16     	; 0x572a <__divmodhi4_neg2>
    571a:	44 d0       	rcall	.+136    	; 0x57a4 <__udivmodhi4>
    571c:	07 fc       	sbrc	r0, 7
    571e:	05 d0       	rcall	.+10     	; 0x572a <__divmodhi4_neg2>
    5720:	3e f4       	brtc	.+14     	; 0x5730 <__divmodhi4_exit>

00005722 <__divmodhi4_neg1>:
    5722:	90 95       	com	r25
    5724:	81 95       	neg	r24
    5726:	9f 4f       	sbci	r25, 0xFF	; 255
    5728:	08 95       	ret

0000572a <__divmodhi4_neg2>:
    572a:	70 95       	com	r23
    572c:	61 95       	neg	r22
    572e:	7f 4f       	sbci	r23, 0xFF	; 255

00005730 <__divmodhi4_exit>:
    5730:	08 95       	ret

00005732 <__udivmodsi4>:
    5732:	a1 e2       	ldi	r26, 0x21	; 33
    5734:	1a 2e       	mov	r1, r26
    5736:	aa 1b       	sub	r26, r26
    5738:	bb 1b       	sub	r27, r27
    573a:	fd 01       	movw	r30, r26
    573c:	0d c0       	rjmp	.+26     	; 0x5758 <__udivmodsi4_ep>

0000573e <__udivmodsi4_loop>:
    573e:	aa 1f       	adc	r26, r26
    5740:	bb 1f       	adc	r27, r27
    5742:	ee 1f       	adc	r30, r30
    5744:	ff 1f       	adc	r31, r31
    5746:	a2 17       	cp	r26, r18
    5748:	b3 07       	cpc	r27, r19
    574a:	e4 07       	cpc	r30, r20
    574c:	f5 07       	cpc	r31, r21
    574e:	20 f0       	brcs	.+8      	; 0x5758 <__udivmodsi4_ep>
    5750:	a2 1b       	sub	r26, r18
    5752:	b3 0b       	sbc	r27, r19
    5754:	e4 0b       	sbc	r30, r20
    5756:	f5 0b       	sbc	r31, r21

00005758 <__udivmodsi4_ep>:
    5758:	66 1f       	adc	r22, r22
    575a:	77 1f       	adc	r23, r23
    575c:	88 1f       	adc	r24, r24
    575e:	99 1f       	adc	r25, r25
    5760:	1a 94       	dec	r1
    5762:	69 f7       	brne	.-38     	; 0x573e <__udivmodsi4_loop>
    5764:	60 95       	com	r22
    5766:	70 95       	com	r23
    5768:	80 95       	com	r24
    576a:	90 95       	com	r25
    576c:	9b 01       	movw	r18, r22
    576e:	ac 01       	movw	r20, r24
    5770:	bd 01       	movw	r22, r26
    5772:	cf 01       	movw	r24, r30
    5774:	08 95       	ret

00005776 <__tablejump2__>:
    5776:	ee 0f       	add	r30, r30
    5778:	ff 1f       	adc	r31, r31
    577a:	88 1f       	adc	r24, r24
    577c:	8b bf       	out	0x3b, r24	; 59
    577e:	07 90       	elpm	r0, Z+
    5780:	f6 91       	elpm	r31, Z
    5782:	e0 2d       	mov	r30, r0
    5784:	19 94       	eijmp

00005786 <__umulhisi3>:
    5786:	a2 9f       	mul	r26, r18
    5788:	b0 01       	movw	r22, r0
    578a:	b3 9f       	mul	r27, r19
    578c:	c0 01       	movw	r24, r0
    578e:	a3 9f       	mul	r26, r19
    5790:	70 0d       	add	r23, r0
    5792:	81 1d       	adc	r24, r1
    5794:	11 24       	eor	r1, r1
    5796:	91 1d       	adc	r25, r1
    5798:	b2 9f       	mul	r27, r18
    579a:	70 0d       	add	r23, r0
    579c:	81 1d       	adc	r24, r1
    579e:	11 24       	eor	r1, r1
    57a0:	91 1d       	adc	r25, r1
    57a2:	08 95       	ret

000057a4 <__udivmodhi4>:
    57a4:	aa 1b       	sub	r26, r26
    57a6:	bb 1b       	sub	r27, r27
    57a8:	51 e1       	ldi	r21, 0x11	; 17
    57aa:	07 c0       	rjmp	.+14     	; 0x57ba <__udivmodhi4_ep>

000057ac <__udivmodhi4_loop>:
    57ac:	aa 1f       	adc	r26, r26
    57ae:	bb 1f       	adc	r27, r27
    57b0:	a6 17       	cp	r26, r22
    57b2:	b7 07       	cpc	r27, r23
    57b4:	10 f0       	brcs	.+4      	; 0x57ba <__udivmodhi4_ep>
    57b6:	a6 1b       	sub	r26, r22
    57b8:	b7 0b       	sbc	r27, r23

000057ba <__udivmodhi4_ep>:
    57ba:	88 1f       	adc	r24, r24
    57bc:	99 1f       	adc	r25, r25
    57be:	5a 95       	dec	r21
    57c0:	a9 f7       	brne	.-22     	; 0x57ac <__udivmodhi4_loop>
    57c2:	80 95       	com	r24
    57c4:	90 95       	com	r25
    57c6:	bc 01       	movw	r22, r24
    57c8:	cd 01       	movw	r24, r26
    57ca:	08 95       	ret

000057cc <do_rand>:
    57cc:	8f 92       	push	r8
    57ce:	9f 92       	push	r9
    57d0:	af 92       	push	r10
    57d2:	bf 92       	push	r11
    57d4:	cf 92       	push	r12
    57d6:	df 92       	push	r13
    57d8:	ef 92       	push	r14
    57da:	ff 92       	push	r15
    57dc:	cf 93       	push	r28
    57de:	df 93       	push	r29
    57e0:	ec 01       	movw	r28, r24
    57e2:	68 81       	ld	r22, Y
    57e4:	79 81       	ldd	r23, Y+1	; 0x01
    57e6:	8a 81       	ldd	r24, Y+2	; 0x02
    57e8:	9b 81       	ldd	r25, Y+3	; 0x03
    57ea:	61 15       	cp	r22, r1
    57ec:	71 05       	cpc	r23, r1
    57ee:	81 05       	cpc	r24, r1
    57f0:	91 05       	cpc	r25, r1
    57f2:	21 f4       	brne	.+8      	; 0x57fc <do_rand+0x30>
    57f4:	64 e2       	ldi	r22, 0x24	; 36
    57f6:	79 ed       	ldi	r23, 0xD9	; 217
    57f8:	8b e5       	ldi	r24, 0x5B	; 91
    57fa:	97 e0       	ldi	r25, 0x07	; 7
    57fc:	2d e1       	ldi	r18, 0x1D	; 29
    57fe:	33 ef       	ldi	r19, 0xF3	; 243
    5800:	41 e0       	ldi	r20, 0x01	; 1
    5802:	50 e0       	ldi	r21, 0x00	; 0
    5804:	6c d3       	rcall	.+1752   	; 0x5ede <__divmodsi4>
    5806:	49 01       	movw	r8, r18
    5808:	5a 01       	movw	r10, r20
    580a:	9b 01       	movw	r18, r22
    580c:	ac 01       	movw	r20, r24
    580e:	a7 ea       	ldi	r26, 0xA7	; 167
    5810:	b1 e4       	ldi	r27, 0x41	; 65
    5812:	81 d3       	rcall	.+1794   	; 0x5f16 <__muluhisi3>
    5814:	6b 01       	movw	r12, r22
    5816:	7c 01       	movw	r14, r24
    5818:	ac ee       	ldi	r26, 0xEC	; 236
    581a:	b4 ef       	ldi	r27, 0xF4	; 244
    581c:	a5 01       	movw	r20, r10
    581e:	94 01       	movw	r18, r8
    5820:	86 d3       	rcall	.+1804   	; 0x5f2e <__mulohisi3>
    5822:	dc 01       	movw	r26, r24
    5824:	cb 01       	movw	r24, r22
    5826:	8c 0d       	add	r24, r12
    5828:	9d 1d       	adc	r25, r13
    582a:	ae 1d       	adc	r26, r14
    582c:	bf 1d       	adc	r27, r15
    582e:	b7 ff       	sbrs	r27, 7
    5830:	03 c0       	rjmp	.+6      	; 0x5838 <do_rand+0x6c>
    5832:	01 97       	sbiw	r24, 0x01	; 1
    5834:	a1 09       	sbc	r26, r1
    5836:	b0 48       	sbci	r27, 0x80	; 128
    5838:	88 83       	st	Y, r24
    583a:	99 83       	std	Y+1, r25	; 0x01
    583c:	aa 83       	std	Y+2, r26	; 0x02
    583e:	bb 83       	std	Y+3, r27	; 0x03
    5840:	9f 77       	andi	r25, 0x7F	; 127
    5842:	df 91       	pop	r29
    5844:	cf 91       	pop	r28
    5846:	ff 90       	pop	r15
    5848:	ef 90       	pop	r14
    584a:	df 90       	pop	r13
    584c:	cf 90       	pop	r12
    584e:	bf 90       	pop	r11
    5850:	af 90       	pop	r10
    5852:	9f 90       	pop	r9
    5854:	8f 90       	pop	r8
    5856:	08 95       	ret

00005858 <rand_r>:
    5858:	b9 cf       	rjmp	.-142    	; 0x57cc <do_rand>

0000585a <rand>:
    585a:	80 e0       	ldi	r24, 0x00	; 0
    585c:	92 e0       	ldi	r25, 0x02	; 2
    585e:	b6 cf       	rjmp	.-148    	; 0x57cc <do_rand>

00005860 <srand>:
    5860:	a0 e0       	ldi	r26, 0x00	; 0
    5862:	b0 e0       	ldi	r27, 0x00	; 0
    5864:	80 93 00 02 	sts	0x0200, r24	; 0x800200 <__DATA_REGION_ORIGIN__>
    5868:	90 93 01 02 	sts	0x0201, r25	; 0x800201 <__DATA_REGION_ORIGIN__+0x1>
    586c:	a0 93 02 02 	sts	0x0202, r26	; 0x800202 <__DATA_REGION_ORIGIN__+0x2>
    5870:	b0 93 03 02 	sts	0x0203, r27	; 0x800203 <__DATA_REGION_ORIGIN__+0x3>
    5874:	08 95       	ret

00005876 <memcpy>:
    5876:	fb 01       	movw	r30, r22
    5878:	dc 01       	movw	r26, r24
    587a:	02 c0       	rjmp	.+4      	; 0x5880 <memcpy+0xa>
    587c:	01 90       	ld	r0, Z+
    587e:	0d 92       	st	X+, r0
    5880:	41 50       	subi	r20, 0x01	; 1
    5882:	50 40       	sbci	r21, 0x00	; 0
    5884:	d8 f7       	brcc	.-10     	; 0x587c <memcpy+0x6>
    5886:	08 95       	ret

00005888 <memset>:
    5888:	dc 01       	movw	r26, r24
    588a:	01 c0       	rjmp	.+2      	; 0x588e <memset+0x6>
    588c:	6d 93       	st	X+, r22
    588e:	41 50       	subi	r20, 0x01	; 1
    5890:	50 40       	sbci	r21, 0x00	; 0
    5892:	e0 f7       	brcc	.-8      	; 0x588c <memset+0x4>
    5894:	08 95       	ret

00005896 <strnlen>:
    5896:	fc 01       	movw	r30, r24
    5898:	61 50       	subi	r22, 0x01	; 1
    589a:	70 40       	sbci	r23, 0x00	; 0
    589c:	01 90       	ld	r0, Z+
    589e:	01 10       	cpse	r0, r1
    58a0:	d8 f7       	brcc	.-10     	; 0x5898 <strnlen+0x2>
    58a2:	80 95       	com	r24
    58a4:	90 95       	com	r25
    58a6:	8e 0f       	add	r24, r30
    58a8:	9f 1f       	adc	r25, r31
    58aa:	08 95       	ret

000058ac <fwrite>:
    58ac:	8f 92       	push	r8
    58ae:	9f 92       	push	r9
    58b0:	af 92       	push	r10
    58b2:	bf 92       	push	r11
    58b4:	cf 92       	push	r12
    58b6:	df 92       	push	r13
    58b8:	ef 92       	push	r14
    58ba:	ff 92       	push	r15
    58bc:	0f 93       	push	r16
    58be:	1f 93       	push	r17
    58c0:	cf 93       	push	r28
    58c2:	df 93       	push	r29
    58c4:	5b 01       	movw	r10, r22
    58c6:	4a 01       	movw	r8, r20
    58c8:	79 01       	movw	r14, r18
    58ca:	d9 01       	movw	r26, r18
    58cc:	13 96       	adiw	r26, 0x03	; 3
    58ce:	2c 91       	ld	r18, X
    58d0:	21 ff       	sbrs	r18, 1
    58d2:	1d c0       	rjmp	.+58     	; 0x590e <fwrite+0x62>
    58d4:	c0 e0       	ldi	r28, 0x00	; 0
    58d6:	d0 e0       	ldi	r29, 0x00	; 0
    58d8:	c8 15       	cp	r28, r8
    58da:	d9 05       	cpc	r29, r9
    58dc:	d9 f0       	breq	.+54     	; 0x5914 <fwrite+0x68>
    58de:	8c 01       	movw	r16, r24
    58e0:	6c 01       	movw	r12, r24
    58e2:	ca 0c       	add	r12, r10
    58e4:	db 1c       	adc	r13, r11
    58e6:	c8 01       	movw	r24, r16
    58e8:	0c 15       	cp	r16, r12
    58ea:	1d 05       	cpc	r17, r13
    58ec:	71 f0       	breq	.+28     	; 0x590a <fwrite+0x5e>
    58ee:	0f 5f       	subi	r16, 0xFF	; 255
    58f0:	1f 4f       	sbci	r17, 0xFF	; 255
    58f2:	d7 01       	movw	r26, r14
    58f4:	18 96       	adiw	r26, 0x08	; 8
    58f6:	ed 91       	ld	r30, X+
    58f8:	fc 91       	ld	r31, X
    58fa:	19 97       	sbiw	r26, 0x09	; 9
    58fc:	b7 01       	movw	r22, r14
    58fe:	dc 01       	movw	r26, r24
    5900:	8c 91       	ld	r24, X
    5902:	19 95       	eicall
    5904:	89 2b       	or	r24, r25
    5906:	79 f3       	breq	.-34     	; 0x58e6 <fwrite+0x3a>
    5908:	05 c0       	rjmp	.+10     	; 0x5914 <fwrite+0x68>
    590a:	21 96       	adiw	r28, 0x01	; 1
    590c:	e5 cf       	rjmp	.-54     	; 0x58d8 <fwrite+0x2c>
    590e:	80 e0       	ldi	r24, 0x00	; 0
    5910:	90 e0       	ldi	r25, 0x00	; 0
    5912:	01 c0       	rjmp	.+2      	; 0x5916 <fwrite+0x6a>
    5914:	ce 01       	movw	r24, r28
    5916:	df 91       	pop	r29
    5918:	cf 91       	pop	r28
    591a:	1f 91       	pop	r17
    591c:	0f 91       	pop	r16
    591e:	ff 90       	pop	r15
    5920:	ef 90       	pop	r14
    5922:	df 90       	pop	r13
    5924:	cf 90       	pop	r12
    5926:	bf 90       	pop	r11
    5928:	af 90       	pop	r10
    592a:	9f 90       	pop	r9
    592c:	8f 90       	pop	r8
    592e:	08 95       	ret

00005930 <printf_P>:
    5930:	0f 93       	push	r16
    5932:	1f 93       	push	r17
    5934:	cf 93       	push	r28
    5936:	df 93       	push	r29
    5938:	cd b7       	in	r28, 0x3d	; 61
    593a:	de b7       	in	r29, 0x3e	; 62
    593c:	ae 01       	movw	r20, r28
    593e:	48 5f       	subi	r20, 0xF8	; 248
    5940:	5f 4f       	sbci	r21, 0xFF	; 255
    5942:	da 01       	movw	r26, r20
    5944:	6d 91       	ld	r22, X+
    5946:	7d 91       	ld	r23, X+
    5948:	ad 01       	movw	r20, r26
    594a:	0e e3       	ldi	r16, 0x3E	; 62
    594c:	10 e2       	ldi	r17, 0x20	; 32
    594e:	f8 01       	movw	r30, r16
    5950:	82 81       	ldd	r24, Z+2	; 0x02
    5952:	93 81       	ldd	r25, Z+3	; 0x03
    5954:	dc 01       	movw	r26, r24
    5956:	13 96       	adiw	r26, 0x03	; 3
    5958:	2c 91       	ld	r18, X
    595a:	13 97       	sbiw	r26, 0x03	; 3
    595c:	28 60       	ori	r18, 0x08	; 8
    595e:	13 96       	adiw	r26, 0x03	; 3
    5960:	2c 93       	st	X, r18
    5962:	1b d0       	rcall	.+54     	; 0x599a <vfprintf>
    5964:	d8 01       	movw	r26, r16
    5966:	12 96       	adiw	r26, 0x02	; 2
    5968:	ed 91       	ld	r30, X+
    596a:	fc 91       	ld	r31, X
    596c:	13 97       	sbiw	r26, 0x03	; 3
    596e:	23 81       	ldd	r18, Z+3	; 0x03
    5970:	27 7f       	andi	r18, 0xF7	; 247
    5972:	23 83       	std	Z+3, r18	; 0x03
    5974:	df 91       	pop	r29
    5976:	cf 91       	pop	r28
    5978:	1f 91       	pop	r17
    597a:	0f 91       	pop	r16
    597c:	08 95       	ret

0000597e <vfprintf_P>:
    597e:	cf 93       	push	r28
    5980:	df 93       	push	r29
    5982:	ec 01       	movw	r28, r24
    5984:	8b 81       	ldd	r24, Y+3	; 0x03
    5986:	88 60       	ori	r24, 0x08	; 8
    5988:	8b 83       	std	Y+3, r24	; 0x03
    598a:	ce 01       	movw	r24, r28
    598c:	06 d0       	rcall	.+12     	; 0x599a <vfprintf>
    598e:	2b 81       	ldd	r18, Y+3	; 0x03
    5990:	27 7f       	andi	r18, 0xF7	; 247
    5992:	2b 83       	std	Y+3, r18	; 0x03
    5994:	df 91       	pop	r29
    5996:	cf 91       	pop	r28
    5998:	08 95       	ret

0000599a <vfprintf>:
    599a:	2f 92       	push	r2
    599c:	3f 92       	push	r3
    599e:	4f 92       	push	r4
    59a0:	5f 92       	push	r5
    59a2:	6f 92       	push	r6
    59a4:	7f 92       	push	r7
    59a6:	8f 92       	push	r8
    59a8:	9f 92       	push	r9
    59aa:	af 92       	push	r10
    59ac:	bf 92       	push	r11
    59ae:	cf 92       	push	r12
    59b0:	df 92       	push	r13
    59b2:	ef 92       	push	r14
    59b4:	ff 92       	push	r15
    59b6:	0f 93       	push	r16
    59b8:	1f 93       	push	r17
    59ba:	cf 93       	push	r28
    59bc:	df 93       	push	r29
    59be:	cd b7       	in	r28, 0x3d	; 61
    59c0:	de b7       	in	r29, 0x3e	; 62
    59c2:	2b 97       	sbiw	r28, 0x0b	; 11
    59c4:	0f b6       	in	r0, 0x3f	; 63
    59c6:	f8 94       	cli
    59c8:	de bf       	out	0x3e, r29	; 62
    59ca:	0f be       	out	0x3f, r0	; 63
    59cc:	cd bf       	out	0x3d, r28	; 61
    59ce:	6c 01       	movw	r12, r24
    59d0:	7b 01       	movw	r14, r22
    59d2:	8a 01       	movw	r16, r20
    59d4:	fc 01       	movw	r30, r24
    59d6:	17 82       	std	Z+7, r1	; 0x07
    59d8:	16 82       	std	Z+6, r1	; 0x06
    59da:	83 81       	ldd	r24, Z+3	; 0x03
    59dc:	81 ff       	sbrs	r24, 1
    59de:	bf c1       	rjmp	.+894    	; 0x5d5e <vfprintf+0x3c4>
    59e0:	ce 01       	movw	r24, r28
    59e2:	01 96       	adiw	r24, 0x01	; 1
    59e4:	3c 01       	movw	r6, r24
    59e6:	f6 01       	movw	r30, r12
    59e8:	93 81       	ldd	r25, Z+3	; 0x03
    59ea:	f7 01       	movw	r30, r14
    59ec:	93 fd       	sbrc	r25, 3
    59ee:	85 91       	lpm	r24, Z+
    59f0:	93 ff       	sbrs	r25, 3
    59f2:	81 91       	ld	r24, Z+
    59f4:	7f 01       	movw	r14, r30
    59f6:	88 23       	and	r24, r24
    59f8:	09 f4       	brne	.+2      	; 0x59fc <vfprintf+0x62>
    59fa:	ad c1       	rjmp	.+858    	; 0x5d56 <vfprintf+0x3bc>
    59fc:	85 32       	cpi	r24, 0x25	; 37
    59fe:	39 f4       	brne	.+14     	; 0x5a0e <vfprintf+0x74>
    5a00:	93 fd       	sbrc	r25, 3
    5a02:	85 91       	lpm	r24, Z+
    5a04:	93 ff       	sbrs	r25, 3
    5a06:	81 91       	ld	r24, Z+
    5a08:	7f 01       	movw	r14, r30
    5a0a:	85 32       	cpi	r24, 0x25	; 37
    5a0c:	21 f4       	brne	.+8      	; 0x5a16 <vfprintf+0x7c>
    5a0e:	b6 01       	movw	r22, r12
    5a10:	90 e0       	ldi	r25, 0x00	; 0
    5a12:	cb d1       	rcall	.+918    	; 0x5daa <fputc>
    5a14:	e8 cf       	rjmp	.-48     	; 0x59e6 <vfprintf+0x4c>
    5a16:	91 2c       	mov	r9, r1
    5a18:	21 2c       	mov	r2, r1
    5a1a:	31 2c       	mov	r3, r1
    5a1c:	ff e1       	ldi	r31, 0x1F	; 31
    5a1e:	f3 15       	cp	r31, r3
    5a20:	d8 f0       	brcs	.+54     	; 0x5a58 <vfprintf+0xbe>
    5a22:	8b 32       	cpi	r24, 0x2B	; 43
    5a24:	79 f0       	breq	.+30     	; 0x5a44 <vfprintf+0xaa>
    5a26:	38 f4       	brcc	.+14     	; 0x5a36 <vfprintf+0x9c>
    5a28:	80 32       	cpi	r24, 0x20	; 32
    5a2a:	79 f0       	breq	.+30     	; 0x5a4a <vfprintf+0xb0>
    5a2c:	83 32       	cpi	r24, 0x23	; 35
    5a2e:	a1 f4       	brne	.+40     	; 0x5a58 <vfprintf+0xbe>
    5a30:	23 2d       	mov	r18, r3
    5a32:	20 61       	ori	r18, 0x10	; 16
    5a34:	1d c0       	rjmp	.+58     	; 0x5a70 <vfprintf+0xd6>
    5a36:	8d 32       	cpi	r24, 0x2D	; 45
    5a38:	61 f0       	breq	.+24     	; 0x5a52 <vfprintf+0xb8>
    5a3a:	80 33       	cpi	r24, 0x30	; 48
    5a3c:	69 f4       	brne	.+26     	; 0x5a58 <vfprintf+0xbe>
    5a3e:	23 2d       	mov	r18, r3
    5a40:	21 60       	ori	r18, 0x01	; 1
    5a42:	16 c0       	rjmp	.+44     	; 0x5a70 <vfprintf+0xd6>
    5a44:	83 2d       	mov	r24, r3
    5a46:	82 60       	ori	r24, 0x02	; 2
    5a48:	38 2e       	mov	r3, r24
    5a4a:	e3 2d       	mov	r30, r3
    5a4c:	e4 60       	ori	r30, 0x04	; 4
    5a4e:	3e 2e       	mov	r3, r30
    5a50:	2a c0       	rjmp	.+84     	; 0x5aa6 <vfprintf+0x10c>
    5a52:	f3 2d       	mov	r31, r3
    5a54:	f8 60       	ori	r31, 0x08	; 8
    5a56:	1d c0       	rjmp	.+58     	; 0x5a92 <vfprintf+0xf8>
    5a58:	37 fc       	sbrc	r3, 7
    5a5a:	2d c0       	rjmp	.+90     	; 0x5ab6 <vfprintf+0x11c>
    5a5c:	20 ed       	ldi	r18, 0xD0	; 208
    5a5e:	28 0f       	add	r18, r24
    5a60:	2a 30       	cpi	r18, 0x0A	; 10
    5a62:	40 f0       	brcs	.+16     	; 0x5a74 <vfprintf+0xda>
    5a64:	8e 32       	cpi	r24, 0x2E	; 46
    5a66:	b9 f4       	brne	.+46     	; 0x5a96 <vfprintf+0xfc>
    5a68:	36 fc       	sbrc	r3, 6
    5a6a:	75 c1       	rjmp	.+746    	; 0x5d56 <vfprintf+0x3bc>
    5a6c:	23 2d       	mov	r18, r3
    5a6e:	20 64       	ori	r18, 0x40	; 64
    5a70:	32 2e       	mov	r3, r18
    5a72:	19 c0       	rjmp	.+50     	; 0x5aa6 <vfprintf+0x10c>
    5a74:	36 fe       	sbrs	r3, 6
    5a76:	06 c0       	rjmp	.+12     	; 0x5a84 <vfprintf+0xea>
    5a78:	8a e0       	ldi	r24, 0x0A	; 10
    5a7a:	98 9e       	mul	r9, r24
    5a7c:	20 0d       	add	r18, r0
    5a7e:	11 24       	eor	r1, r1
    5a80:	92 2e       	mov	r9, r18
    5a82:	11 c0       	rjmp	.+34     	; 0x5aa6 <vfprintf+0x10c>
    5a84:	ea e0       	ldi	r30, 0x0A	; 10
    5a86:	2e 9e       	mul	r2, r30
    5a88:	20 0d       	add	r18, r0
    5a8a:	11 24       	eor	r1, r1
    5a8c:	22 2e       	mov	r2, r18
    5a8e:	f3 2d       	mov	r31, r3
    5a90:	f0 62       	ori	r31, 0x20	; 32
    5a92:	3f 2e       	mov	r3, r31
    5a94:	08 c0       	rjmp	.+16     	; 0x5aa6 <vfprintf+0x10c>
    5a96:	8c 36       	cpi	r24, 0x6C	; 108
    5a98:	21 f4       	brne	.+8      	; 0x5aa2 <vfprintf+0x108>
    5a9a:	83 2d       	mov	r24, r3
    5a9c:	80 68       	ori	r24, 0x80	; 128
    5a9e:	38 2e       	mov	r3, r24
    5aa0:	02 c0       	rjmp	.+4      	; 0x5aa6 <vfprintf+0x10c>
    5aa2:	88 36       	cpi	r24, 0x68	; 104
    5aa4:	41 f4       	brne	.+16     	; 0x5ab6 <vfprintf+0x11c>
    5aa6:	f7 01       	movw	r30, r14
    5aa8:	93 fd       	sbrc	r25, 3
    5aaa:	85 91       	lpm	r24, Z+
    5aac:	93 ff       	sbrs	r25, 3
    5aae:	81 91       	ld	r24, Z+
    5ab0:	7f 01       	movw	r14, r30
    5ab2:	81 11       	cpse	r24, r1
    5ab4:	b3 cf       	rjmp	.-154    	; 0x5a1c <vfprintf+0x82>
    5ab6:	98 2f       	mov	r25, r24
    5ab8:	9f 7d       	andi	r25, 0xDF	; 223
    5aba:	95 54       	subi	r25, 0x45	; 69
    5abc:	93 30       	cpi	r25, 0x03	; 3
    5abe:	28 f4       	brcc	.+10     	; 0x5aca <vfprintf+0x130>
    5ac0:	0c 5f       	subi	r16, 0xFC	; 252
    5ac2:	1f 4f       	sbci	r17, 0xFF	; 255
    5ac4:	9f e3       	ldi	r25, 0x3F	; 63
    5ac6:	99 83       	std	Y+1, r25	; 0x01
    5ac8:	0d c0       	rjmp	.+26     	; 0x5ae4 <vfprintf+0x14a>
    5aca:	83 36       	cpi	r24, 0x63	; 99
    5acc:	31 f0       	breq	.+12     	; 0x5ada <vfprintf+0x140>
    5ace:	83 37       	cpi	r24, 0x73	; 115
    5ad0:	71 f0       	breq	.+28     	; 0x5aee <vfprintf+0x154>
    5ad2:	83 35       	cpi	r24, 0x53	; 83
    5ad4:	09 f0       	breq	.+2      	; 0x5ad8 <vfprintf+0x13e>
    5ad6:	55 c0       	rjmp	.+170    	; 0x5b82 <vfprintf+0x1e8>
    5ad8:	20 c0       	rjmp	.+64     	; 0x5b1a <vfprintf+0x180>
    5ada:	f8 01       	movw	r30, r16
    5adc:	80 81       	ld	r24, Z
    5ade:	89 83       	std	Y+1, r24	; 0x01
    5ae0:	0e 5f       	subi	r16, 0xFE	; 254
    5ae2:	1f 4f       	sbci	r17, 0xFF	; 255
    5ae4:	88 24       	eor	r8, r8
    5ae6:	83 94       	inc	r8
    5ae8:	91 2c       	mov	r9, r1
    5aea:	53 01       	movw	r10, r6
    5aec:	12 c0       	rjmp	.+36     	; 0x5b12 <vfprintf+0x178>
    5aee:	28 01       	movw	r4, r16
    5af0:	f2 e0       	ldi	r31, 0x02	; 2
    5af2:	4f 0e       	add	r4, r31
    5af4:	51 1c       	adc	r5, r1
    5af6:	f8 01       	movw	r30, r16
    5af8:	a0 80       	ld	r10, Z
    5afa:	b1 80       	ldd	r11, Z+1	; 0x01
    5afc:	36 fe       	sbrs	r3, 6
    5afe:	03 c0       	rjmp	.+6      	; 0x5b06 <vfprintf+0x16c>
    5b00:	69 2d       	mov	r22, r9
    5b02:	70 e0       	ldi	r23, 0x00	; 0
    5b04:	02 c0       	rjmp	.+4      	; 0x5b0a <vfprintf+0x170>
    5b06:	6f ef       	ldi	r22, 0xFF	; 255
    5b08:	7f ef       	ldi	r23, 0xFF	; 255
    5b0a:	c5 01       	movw	r24, r10
    5b0c:	c4 de       	rcall	.-632    	; 0x5896 <strnlen>
    5b0e:	4c 01       	movw	r8, r24
    5b10:	82 01       	movw	r16, r4
    5b12:	f3 2d       	mov	r31, r3
    5b14:	ff 77       	andi	r31, 0x7F	; 127
    5b16:	3f 2e       	mov	r3, r31
    5b18:	15 c0       	rjmp	.+42     	; 0x5b44 <vfprintf+0x1aa>
    5b1a:	28 01       	movw	r4, r16
    5b1c:	22 e0       	ldi	r18, 0x02	; 2
    5b1e:	42 0e       	add	r4, r18
    5b20:	51 1c       	adc	r5, r1
    5b22:	f8 01       	movw	r30, r16
    5b24:	a0 80       	ld	r10, Z
    5b26:	b1 80       	ldd	r11, Z+1	; 0x01
    5b28:	36 fe       	sbrs	r3, 6
    5b2a:	03 c0       	rjmp	.+6      	; 0x5b32 <vfprintf+0x198>
    5b2c:	69 2d       	mov	r22, r9
    5b2e:	70 e0       	ldi	r23, 0x00	; 0
    5b30:	02 c0       	rjmp	.+4      	; 0x5b36 <vfprintf+0x19c>
    5b32:	6f ef       	ldi	r22, 0xFF	; 255
    5b34:	7f ef       	ldi	r23, 0xFF	; 255
    5b36:	c5 01       	movw	r24, r10
    5b38:	2d d1       	rcall	.+602    	; 0x5d94 <strnlen_P>
    5b3a:	4c 01       	movw	r8, r24
    5b3c:	f3 2d       	mov	r31, r3
    5b3e:	f0 68       	ori	r31, 0x80	; 128
    5b40:	3f 2e       	mov	r3, r31
    5b42:	82 01       	movw	r16, r4
    5b44:	33 fc       	sbrc	r3, 3
    5b46:	19 c0       	rjmp	.+50     	; 0x5b7a <vfprintf+0x1e0>
    5b48:	82 2d       	mov	r24, r2
    5b4a:	90 e0       	ldi	r25, 0x00	; 0
    5b4c:	88 16       	cp	r8, r24
    5b4e:	99 06       	cpc	r9, r25
    5b50:	a0 f4       	brcc	.+40     	; 0x5b7a <vfprintf+0x1e0>
    5b52:	b6 01       	movw	r22, r12
    5b54:	80 e2       	ldi	r24, 0x20	; 32
    5b56:	90 e0       	ldi	r25, 0x00	; 0
    5b58:	28 d1       	rcall	.+592    	; 0x5daa <fputc>
    5b5a:	2a 94       	dec	r2
    5b5c:	f5 cf       	rjmp	.-22     	; 0x5b48 <vfprintf+0x1ae>
    5b5e:	f5 01       	movw	r30, r10
    5b60:	37 fc       	sbrc	r3, 7
    5b62:	85 91       	lpm	r24, Z+
    5b64:	37 fe       	sbrs	r3, 7
    5b66:	81 91       	ld	r24, Z+
    5b68:	5f 01       	movw	r10, r30
    5b6a:	b6 01       	movw	r22, r12
    5b6c:	90 e0       	ldi	r25, 0x00	; 0
    5b6e:	1d d1       	rcall	.+570    	; 0x5daa <fputc>
    5b70:	21 10       	cpse	r2, r1
    5b72:	2a 94       	dec	r2
    5b74:	21 e0       	ldi	r18, 0x01	; 1
    5b76:	82 1a       	sub	r8, r18
    5b78:	91 08       	sbc	r9, r1
    5b7a:	81 14       	cp	r8, r1
    5b7c:	91 04       	cpc	r9, r1
    5b7e:	79 f7       	brne	.-34     	; 0x5b5e <vfprintf+0x1c4>
    5b80:	e1 c0       	rjmp	.+450    	; 0x5d44 <vfprintf+0x3aa>
    5b82:	84 36       	cpi	r24, 0x64	; 100
    5b84:	11 f0       	breq	.+4      	; 0x5b8a <vfprintf+0x1f0>
    5b86:	89 36       	cpi	r24, 0x69	; 105
    5b88:	39 f5       	brne	.+78     	; 0x5bd8 <vfprintf+0x23e>
    5b8a:	f8 01       	movw	r30, r16
    5b8c:	37 fe       	sbrs	r3, 7
    5b8e:	07 c0       	rjmp	.+14     	; 0x5b9e <vfprintf+0x204>
    5b90:	60 81       	ld	r22, Z
    5b92:	71 81       	ldd	r23, Z+1	; 0x01
    5b94:	82 81       	ldd	r24, Z+2	; 0x02
    5b96:	93 81       	ldd	r25, Z+3	; 0x03
    5b98:	0c 5f       	subi	r16, 0xFC	; 252
    5b9a:	1f 4f       	sbci	r17, 0xFF	; 255
    5b9c:	08 c0       	rjmp	.+16     	; 0x5bae <vfprintf+0x214>
    5b9e:	60 81       	ld	r22, Z
    5ba0:	71 81       	ldd	r23, Z+1	; 0x01
    5ba2:	07 2e       	mov	r0, r23
    5ba4:	00 0c       	add	r0, r0
    5ba6:	88 0b       	sbc	r24, r24
    5ba8:	99 0b       	sbc	r25, r25
    5baa:	0e 5f       	subi	r16, 0xFE	; 254
    5bac:	1f 4f       	sbci	r17, 0xFF	; 255
    5bae:	f3 2d       	mov	r31, r3
    5bb0:	ff 76       	andi	r31, 0x6F	; 111
    5bb2:	3f 2e       	mov	r3, r31
    5bb4:	97 ff       	sbrs	r25, 7
    5bb6:	09 c0       	rjmp	.+18     	; 0x5bca <vfprintf+0x230>
    5bb8:	90 95       	com	r25
    5bba:	80 95       	com	r24
    5bbc:	70 95       	com	r23
    5bbe:	61 95       	neg	r22
    5bc0:	7f 4f       	sbci	r23, 0xFF	; 255
    5bc2:	8f 4f       	sbci	r24, 0xFF	; 255
    5bc4:	9f 4f       	sbci	r25, 0xFF	; 255
    5bc6:	f0 68       	ori	r31, 0x80	; 128
    5bc8:	3f 2e       	mov	r3, r31
    5bca:	2a e0       	ldi	r18, 0x0A	; 10
    5bcc:	30 e0       	ldi	r19, 0x00	; 0
    5bce:	a3 01       	movw	r20, r6
    5bd0:	28 d1       	rcall	.+592    	; 0x5e22 <__ultoa_invert>
    5bd2:	88 2e       	mov	r8, r24
    5bd4:	86 18       	sub	r8, r6
    5bd6:	44 c0       	rjmp	.+136    	; 0x5c60 <vfprintf+0x2c6>
    5bd8:	85 37       	cpi	r24, 0x75	; 117
    5bda:	31 f4       	brne	.+12     	; 0x5be8 <vfprintf+0x24e>
    5bdc:	23 2d       	mov	r18, r3
    5bde:	2f 7e       	andi	r18, 0xEF	; 239
    5be0:	b2 2e       	mov	r11, r18
    5be2:	2a e0       	ldi	r18, 0x0A	; 10
    5be4:	30 e0       	ldi	r19, 0x00	; 0
    5be6:	25 c0       	rjmp	.+74     	; 0x5c32 <vfprintf+0x298>
    5be8:	93 2d       	mov	r25, r3
    5bea:	99 7f       	andi	r25, 0xF9	; 249
    5bec:	b9 2e       	mov	r11, r25
    5bee:	8f 36       	cpi	r24, 0x6F	; 111
    5bf0:	c1 f0       	breq	.+48     	; 0x5c22 <vfprintf+0x288>
    5bf2:	18 f4       	brcc	.+6      	; 0x5bfa <vfprintf+0x260>
    5bf4:	88 35       	cpi	r24, 0x58	; 88
    5bf6:	79 f0       	breq	.+30     	; 0x5c16 <vfprintf+0x27c>
    5bf8:	ae c0       	rjmp	.+348    	; 0x5d56 <vfprintf+0x3bc>
    5bfa:	80 37       	cpi	r24, 0x70	; 112
    5bfc:	19 f0       	breq	.+6      	; 0x5c04 <vfprintf+0x26a>
    5bfe:	88 37       	cpi	r24, 0x78	; 120
    5c00:	21 f0       	breq	.+8      	; 0x5c0a <vfprintf+0x270>
    5c02:	a9 c0       	rjmp	.+338    	; 0x5d56 <vfprintf+0x3bc>
    5c04:	e9 2f       	mov	r30, r25
    5c06:	e0 61       	ori	r30, 0x10	; 16
    5c08:	be 2e       	mov	r11, r30
    5c0a:	b4 fe       	sbrs	r11, 4
    5c0c:	0d c0       	rjmp	.+26     	; 0x5c28 <vfprintf+0x28e>
    5c0e:	fb 2d       	mov	r31, r11
    5c10:	f4 60       	ori	r31, 0x04	; 4
    5c12:	bf 2e       	mov	r11, r31
    5c14:	09 c0       	rjmp	.+18     	; 0x5c28 <vfprintf+0x28e>
    5c16:	34 fe       	sbrs	r3, 4
    5c18:	0a c0       	rjmp	.+20     	; 0x5c2e <vfprintf+0x294>
    5c1a:	29 2f       	mov	r18, r25
    5c1c:	26 60       	ori	r18, 0x06	; 6
    5c1e:	b2 2e       	mov	r11, r18
    5c20:	06 c0       	rjmp	.+12     	; 0x5c2e <vfprintf+0x294>
    5c22:	28 e0       	ldi	r18, 0x08	; 8
    5c24:	30 e0       	ldi	r19, 0x00	; 0
    5c26:	05 c0       	rjmp	.+10     	; 0x5c32 <vfprintf+0x298>
    5c28:	20 e1       	ldi	r18, 0x10	; 16
    5c2a:	30 e0       	ldi	r19, 0x00	; 0
    5c2c:	02 c0       	rjmp	.+4      	; 0x5c32 <vfprintf+0x298>
    5c2e:	20 e1       	ldi	r18, 0x10	; 16
    5c30:	32 e0       	ldi	r19, 0x02	; 2
    5c32:	f8 01       	movw	r30, r16
    5c34:	b7 fe       	sbrs	r11, 7
    5c36:	07 c0       	rjmp	.+14     	; 0x5c46 <vfprintf+0x2ac>
    5c38:	60 81       	ld	r22, Z
    5c3a:	71 81       	ldd	r23, Z+1	; 0x01
    5c3c:	82 81       	ldd	r24, Z+2	; 0x02
    5c3e:	93 81       	ldd	r25, Z+3	; 0x03
    5c40:	0c 5f       	subi	r16, 0xFC	; 252
    5c42:	1f 4f       	sbci	r17, 0xFF	; 255
    5c44:	06 c0       	rjmp	.+12     	; 0x5c52 <vfprintf+0x2b8>
    5c46:	60 81       	ld	r22, Z
    5c48:	71 81       	ldd	r23, Z+1	; 0x01
    5c4a:	80 e0       	ldi	r24, 0x00	; 0
    5c4c:	90 e0       	ldi	r25, 0x00	; 0
    5c4e:	0e 5f       	subi	r16, 0xFE	; 254
    5c50:	1f 4f       	sbci	r17, 0xFF	; 255
    5c52:	a3 01       	movw	r20, r6
    5c54:	e6 d0       	rcall	.+460    	; 0x5e22 <__ultoa_invert>
    5c56:	88 2e       	mov	r8, r24
    5c58:	86 18       	sub	r8, r6
    5c5a:	fb 2d       	mov	r31, r11
    5c5c:	ff 77       	andi	r31, 0x7F	; 127
    5c5e:	3f 2e       	mov	r3, r31
    5c60:	36 fe       	sbrs	r3, 6
    5c62:	0d c0       	rjmp	.+26     	; 0x5c7e <vfprintf+0x2e4>
    5c64:	23 2d       	mov	r18, r3
    5c66:	2e 7f       	andi	r18, 0xFE	; 254
    5c68:	a2 2e       	mov	r10, r18
    5c6a:	89 14       	cp	r8, r9
    5c6c:	58 f4       	brcc	.+22     	; 0x5c84 <vfprintf+0x2ea>
    5c6e:	34 fe       	sbrs	r3, 4
    5c70:	0b c0       	rjmp	.+22     	; 0x5c88 <vfprintf+0x2ee>
    5c72:	32 fc       	sbrc	r3, 2
    5c74:	09 c0       	rjmp	.+18     	; 0x5c88 <vfprintf+0x2ee>
    5c76:	83 2d       	mov	r24, r3
    5c78:	8e 7e       	andi	r24, 0xEE	; 238
    5c7a:	a8 2e       	mov	r10, r24
    5c7c:	05 c0       	rjmp	.+10     	; 0x5c88 <vfprintf+0x2ee>
    5c7e:	b8 2c       	mov	r11, r8
    5c80:	a3 2c       	mov	r10, r3
    5c82:	03 c0       	rjmp	.+6      	; 0x5c8a <vfprintf+0x2f0>
    5c84:	b8 2c       	mov	r11, r8
    5c86:	01 c0       	rjmp	.+2      	; 0x5c8a <vfprintf+0x2f0>
    5c88:	b9 2c       	mov	r11, r9
    5c8a:	a4 fe       	sbrs	r10, 4
    5c8c:	0f c0       	rjmp	.+30     	; 0x5cac <vfprintf+0x312>
    5c8e:	fe 01       	movw	r30, r28
    5c90:	e8 0d       	add	r30, r8
    5c92:	f1 1d       	adc	r31, r1
    5c94:	80 81       	ld	r24, Z
    5c96:	80 33       	cpi	r24, 0x30	; 48
    5c98:	21 f4       	brne	.+8      	; 0x5ca2 <vfprintf+0x308>
    5c9a:	9a 2d       	mov	r25, r10
    5c9c:	99 7e       	andi	r25, 0xE9	; 233
    5c9e:	a9 2e       	mov	r10, r25
    5ca0:	09 c0       	rjmp	.+18     	; 0x5cb4 <vfprintf+0x31a>
    5ca2:	a2 fe       	sbrs	r10, 2
    5ca4:	06 c0       	rjmp	.+12     	; 0x5cb2 <vfprintf+0x318>
    5ca6:	b3 94       	inc	r11
    5ca8:	b3 94       	inc	r11
    5caa:	04 c0       	rjmp	.+8      	; 0x5cb4 <vfprintf+0x31a>
    5cac:	8a 2d       	mov	r24, r10
    5cae:	86 78       	andi	r24, 0x86	; 134
    5cb0:	09 f0       	breq	.+2      	; 0x5cb4 <vfprintf+0x31a>
    5cb2:	b3 94       	inc	r11
    5cb4:	a3 fc       	sbrc	r10, 3
    5cb6:	10 c0       	rjmp	.+32     	; 0x5cd8 <vfprintf+0x33e>
    5cb8:	a0 fe       	sbrs	r10, 0
    5cba:	06 c0       	rjmp	.+12     	; 0x5cc8 <vfprintf+0x32e>
    5cbc:	b2 14       	cp	r11, r2
    5cbe:	80 f4       	brcc	.+32     	; 0x5ce0 <vfprintf+0x346>
    5cc0:	28 0c       	add	r2, r8
    5cc2:	92 2c       	mov	r9, r2
    5cc4:	9b 18       	sub	r9, r11
    5cc6:	0d c0       	rjmp	.+26     	; 0x5ce2 <vfprintf+0x348>
    5cc8:	b2 14       	cp	r11, r2
    5cca:	58 f4       	brcc	.+22     	; 0x5ce2 <vfprintf+0x348>
    5ccc:	b6 01       	movw	r22, r12
    5cce:	80 e2       	ldi	r24, 0x20	; 32
    5cd0:	90 e0       	ldi	r25, 0x00	; 0
    5cd2:	6b d0       	rcall	.+214    	; 0x5daa <fputc>
    5cd4:	b3 94       	inc	r11
    5cd6:	f8 cf       	rjmp	.-16     	; 0x5cc8 <vfprintf+0x32e>
    5cd8:	b2 14       	cp	r11, r2
    5cda:	18 f4       	brcc	.+6      	; 0x5ce2 <vfprintf+0x348>
    5cdc:	2b 18       	sub	r2, r11
    5cde:	02 c0       	rjmp	.+4      	; 0x5ce4 <vfprintf+0x34a>
    5ce0:	98 2c       	mov	r9, r8
    5ce2:	21 2c       	mov	r2, r1
    5ce4:	a4 fe       	sbrs	r10, 4
    5ce6:	0f c0       	rjmp	.+30     	; 0x5d06 <vfprintf+0x36c>
    5ce8:	b6 01       	movw	r22, r12
    5cea:	80 e3       	ldi	r24, 0x30	; 48
    5cec:	90 e0       	ldi	r25, 0x00	; 0
    5cee:	5d d0       	rcall	.+186    	; 0x5daa <fputc>
    5cf0:	a2 fe       	sbrs	r10, 2
    5cf2:	16 c0       	rjmp	.+44     	; 0x5d20 <vfprintf+0x386>
    5cf4:	a1 fc       	sbrc	r10, 1
    5cf6:	03 c0       	rjmp	.+6      	; 0x5cfe <vfprintf+0x364>
    5cf8:	88 e7       	ldi	r24, 0x78	; 120
    5cfa:	90 e0       	ldi	r25, 0x00	; 0
    5cfc:	02 c0       	rjmp	.+4      	; 0x5d02 <vfprintf+0x368>
    5cfe:	88 e5       	ldi	r24, 0x58	; 88
    5d00:	90 e0       	ldi	r25, 0x00	; 0
    5d02:	b6 01       	movw	r22, r12
    5d04:	0c c0       	rjmp	.+24     	; 0x5d1e <vfprintf+0x384>
    5d06:	8a 2d       	mov	r24, r10
    5d08:	86 78       	andi	r24, 0x86	; 134
    5d0a:	51 f0       	breq	.+20     	; 0x5d20 <vfprintf+0x386>
    5d0c:	a1 fe       	sbrs	r10, 1
    5d0e:	02 c0       	rjmp	.+4      	; 0x5d14 <vfprintf+0x37a>
    5d10:	8b e2       	ldi	r24, 0x2B	; 43
    5d12:	01 c0       	rjmp	.+2      	; 0x5d16 <vfprintf+0x37c>
    5d14:	80 e2       	ldi	r24, 0x20	; 32
    5d16:	a7 fc       	sbrc	r10, 7
    5d18:	8d e2       	ldi	r24, 0x2D	; 45
    5d1a:	b6 01       	movw	r22, r12
    5d1c:	90 e0       	ldi	r25, 0x00	; 0
    5d1e:	45 d0       	rcall	.+138    	; 0x5daa <fputc>
    5d20:	89 14       	cp	r8, r9
    5d22:	30 f4       	brcc	.+12     	; 0x5d30 <vfprintf+0x396>
    5d24:	b6 01       	movw	r22, r12
    5d26:	80 e3       	ldi	r24, 0x30	; 48
    5d28:	90 e0       	ldi	r25, 0x00	; 0
    5d2a:	3f d0       	rcall	.+126    	; 0x5daa <fputc>
    5d2c:	9a 94       	dec	r9
    5d2e:	f8 cf       	rjmp	.-16     	; 0x5d20 <vfprintf+0x386>
    5d30:	8a 94       	dec	r8
    5d32:	f3 01       	movw	r30, r6
    5d34:	e8 0d       	add	r30, r8
    5d36:	f1 1d       	adc	r31, r1
    5d38:	80 81       	ld	r24, Z
    5d3a:	b6 01       	movw	r22, r12
    5d3c:	90 e0       	ldi	r25, 0x00	; 0
    5d3e:	35 d0       	rcall	.+106    	; 0x5daa <fputc>
    5d40:	81 10       	cpse	r8, r1
    5d42:	f6 cf       	rjmp	.-20     	; 0x5d30 <vfprintf+0x396>
    5d44:	22 20       	and	r2, r2
    5d46:	09 f4       	brne	.+2      	; 0x5d4a <vfprintf+0x3b0>
    5d48:	4e ce       	rjmp	.-868    	; 0x59e6 <vfprintf+0x4c>
    5d4a:	b6 01       	movw	r22, r12
    5d4c:	80 e2       	ldi	r24, 0x20	; 32
    5d4e:	90 e0       	ldi	r25, 0x00	; 0
    5d50:	2c d0       	rcall	.+88     	; 0x5daa <fputc>
    5d52:	2a 94       	dec	r2
    5d54:	f7 cf       	rjmp	.-18     	; 0x5d44 <vfprintf+0x3aa>
    5d56:	f6 01       	movw	r30, r12
    5d58:	86 81       	ldd	r24, Z+6	; 0x06
    5d5a:	97 81       	ldd	r25, Z+7	; 0x07
    5d5c:	02 c0       	rjmp	.+4      	; 0x5d62 <vfprintf+0x3c8>
    5d5e:	8f ef       	ldi	r24, 0xFF	; 255
    5d60:	9f ef       	ldi	r25, 0xFF	; 255
    5d62:	2b 96       	adiw	r28, 0x0b	; 11
    5d64:	0f b6       	in	r0, 0x3f	; 63
    5d66:	f8 94       	cli
    5d68:	de bf       	out	0x3e, r29	; 62
    5d6a:	0f be       	out	0x3f, r0	; 63
    5d6c:	cd bf       	out	0x3d, r28	; 61
    5d6e:	df 91       	pop	r29
    5d70:	cf 91       	pop	r28
    5d72:	1f 91       	pop	r17
    5d74:	0f 91       	pop	r16
    5d76:	ff 90       	pop	r15
    5d78:	ef 90       	pop	r14
    5d7a:	df 90       	pop	r13
    5d7c:	cf 90       	pop	r12
    5d7e:	bf 90       	pop	r11
    5d80:	af 90       	pop	r10
    5d82:	9f 90       	pop	r9
    5d84:	8f 90       	pop	r8
    5d86:	7f 90       	pop	r7
    5d88:	6f 90       	pop	r6
    5d8a:	5f 90       	pop	r5
    5d8c:	4f 90       	pop	r4
    5d8e:	3f 90       	pop	r3
    5d90:	2f 90       	pop	r2
    5d92:	08 95       	ret

00005d94 <strnlen_P>:
    5d94:	fc 01       	movw	r30, r24
    5d96:	05 90       	lpm	r0, Z+
    5d98:	61 50       	subi	r22, 0x01	; 1
    5d9a:	70 40       	sbci	r23, 0x00	; 0
    5d9c:	01 10       	cpse	r0, r1
    5d9e:	d8 f7       	brcc	.-10     	; 0x5d96 <strnlen_P+0x2>
    5da0:	80 95       	com	r24
    5da2:	90 95       	com	r25
    5da4:	8e 0f       	add	r24, r30
    5da6:	9f 1f       	adc	r25, r31
    5da8:	08 95       	ret

00005daa <fputc>:
    5daa:	0f 93       	push	r16
    5dac:	1f 93       	push	r17
    5dae:	cf 93       	push	r28
    5db0:	df 93       	push	r29
    5db2:	fb 01       	movw	r30, r22
    5db4:	23 81       	ldd	r18, Z+3	; 0x03
    5db6:	21 fd       	sbrc	r18, 1
    5db8:	03 c0       	rjmp	.+6      	; 0x5dc0 <fputc+0x16>
    5dba:	8f ef       	ldi	r24, 0xFF	; 255
    5dbc:	9f ef       	ldi	r25, 0xFF	; 255
    5dbe:	2c c0       	rjmp	.+88     	; 0x5e18 <fputc+0x6e>
    5dc0:	22 ff       	sbrs	r18, 2
    5dc2:	16 c0       	rjmp	.+44     	; 0x5df0 <fputc+0x46>
    5dc4:	46 81       	ldd	r20, Z+6	; 0x06
    5dc6:	57 81       	ldd	r21, Z+7	; 0x07
    5dc8:	24 81       	ldd	r18, Z+4	; 0x04
    5dca:	35 81       	ldd	r19, Z+5	; 0x05
    5dcc:	42 17       	cp	r20, r18
    5dce:	53 07       	cpc	r21, r19
    5dd0:	44 f4       	brge	.+16     	; 0x5de2 <fputc+0x38>
    5dd2:	a0 81       	ld	r26, Z
    5dd4:	b1 81       	ldd	r27, Z+1	; 0x01
    5dd6:	9d 01       	movw	r18, r26
    5dd8:	2f 5f       	subi	r18, 0xFF	; 255
    5dda:	3f 4f       	sbci	r19, 0xFF	; 255
    5ddc:	31 83       	std	Z+1, r19	; 0x01
    5dde:	20 83       	st	Z, r18
    5de0:	8c 93       	st	X, r24
    5de2:	26 81       	ldd	r18, Z+6	; 0x06
    5de4:	37 81       	ldd	r19, Z+7	; 0x07
    5de6:	2f 5f       	subi	r18, 0xFF	; 255
    5de8:	3f 4f       	sbci	r19, 0xFF	; 255
    5dea:	37 83       	std	Z+7, r19	; 0x07
    5dec:	26 83       	std	Z+6, r18	; 0x06
    5dee:	14 c0       	rjmp	.+40     	; 0x5e18 <fputc+0x6e>
    5df0:	8b 01       	movw	r16, r22
    5df2:	ec 01       	movw	r28, r24
    5df4:	fb 01       	movw	r30, r22
    5df6:	00 84       	ldd	r0, Z+8	; 0x08
    5df8:	f1 85       	ldd	r31, Z+9	; 0x09
    5dfa:	e0 2d       	mov	r30, r0
    5dfc:	19 95       	eicall
    5dfe:	89 2b       	or	r24, r25
    5e00:	e1 f6       	brne	.-72     	; 0x5dba <fputc+0x10>
    5e02:	d8 01       	movw	r26, r16
    5e04:	16 96       	adiw	r26, 0x06	; 6
    5e06:	8d 91       	ld	r24, X+
    5e08:	9c 91       	ld	r25, X
    5e0a:	17 97       	sbiw	r26, 0x07	; 7
    5e0c:	01 96       	adiw	r24, 0x01	; 1
    5e0e:	17 96       	adiw	r26, 0x07	; 7
    5e10:	9c 93       	st	X, r25
    5e12:	8e 93       	st	-X, r24
    5e14:	16 97       	sbiw	r26, 0x06	; 6
    5e16:	ce 01       	movw	r24, r28
    5e18:	df 91       	pop	r29
    5e1a:	cf 91       	pop	r28
    5e1c:	1f 91       	pop	r17
    5e1e:	0f 91       	pop	r16
    5e20:	08 95       	ret

00005e22 <__ultoa_invert>:
    5e22:	fa 01       	movw	r30, r20
    5e24:	aa 27       	eor	r26, r26
    5e26:	28 30       	cpi	r18, 0x08	; 8
    5e28:	51 f1       	breq	.+84     	; 0x5e7e <__ultoa_invert+0x5c>
    5e2a:	20 31       	cpi	r18, 0x10	; 16
    5e2c:	81 f1       	breq	.+96     	; 0x5e8e <__ultoa_invert+0x6c>
    5e2e:	e8 94       	clt
    5e30:	6f 93       	push	r22
    5e32:	6e 7f       	andi	r22, 0xFE	; 254
    5e34:	6e 5f       	subi	r22, 0xFE	; 254
    5e36:	7f 4f       	sbci	r23, 0xFF	; 255
    5e38:	8f 4f       	sbci	r24, 0xFF	; 255
    5e3a:	9f 4f       	sbci	r25, 0xFF	; 255
    5e3c:	af 4f       	sbci	r26, 0xFF	; 255
    5e3e:	b1 e0       	ldi	r27, 0x01	; 1
    5e40:	3e d0       	rcall	.+124    	; 0x5ebe <__ultoa_invert+0x9c>
    5e42:	b4 e0       	ldi	r27, 0x04	; 4
    5e44:	3c d0       	rcall	.+120    	; 0x5ebe <__ultoa_invert+0x9c>
    5e46:	67 0f       	add	r22, r23
    5e48:	78 1f       	adc	r23, r24
    5e4a:	89 1f       	adc	r24, r25
    5e4c:	9a 1f       	adc	r25, r26
    5e4e:	a1 1d       	adc	r26, r1
    5e50:	68 0f       	add	r22, r24
    5e52:	79 1f       	adc	r23, r25
    5e54:	8a 1f       	adc	r24, r26
    5e56:	91 1d       	adc	r25, r1
    5e58:	a1 1d       	adc	r26, r1
    5e5a:	6a 0f       	add	r22, r26
    5e5c:	71 1d       	adc	r23, r1
    5e5e:	81 1d       	adc	r24, r1
    5e60:	91 1d       	adc	r25, r1
    5e62:	a1 1d       	adc	r26, r1
    5e64:	20 d0       	rcall	.+64     	; 0x5ea6 <__ultoa_invert+0x84>
    5e66:	09 f4       	brne	.+2      	; 0x5e6a <__ultoa_invert+0x48>
    5e68:	68 94       	set
    5e6a:	3f 91       	pop	r19
    5e6c:	2a e0       	ldi	r18, 0x0A	; 10
    5e6e:	26 9f       	mul	r18, r22
    5e70:	11 24       	eor	r1, r1
    5e72:	30 19       	sub	r19, r0
    5e74:	30 5d       	subi	r19, 0xD0	; 208
    5e76:	31 93       	st	Z+, r19
    5e78:	de f6       	brtc	.-74     	; 0x5e30 <__ultoa_invert+0xe>
    5e7a:	cf 01       	movw	r24, r30
    5e7c:	08 95       	ret
    5e7e:	46 2f       	mov	r20, r22
    5e80:	47 70       	andi	r20, 0x07	; 7
    5e82:	40 5d       	subi	r20, 0xD0	; 208
    5e84:	41 93       	st	Z+, r20
    5e86:	b3 e0       	ldi	r27, 0x03	; 3
    5e88:	0f d0       	rcall	.+30     	; 0x5ea8 <__ultoa_invert+0x86>
    5e8a:	c9 f7       	brne	.-14     	; 0x5e7e <__ultoa_invert+0x5c>
    5e8c:	f6 cf       	rjmp	.-20     	; 0x5e7a <__ultoa_invert+0x58>
    5e8e:	46 2f       	mov	r20, r22
    5e90:	4f 70       	andi	r20, 0x0F	; 15
    5e92:	40 5d       	subi	r20, 0xD0	; 208
    5e94:	4a 33       	cpi	r20, 0x3A	; 58
    5e96:	18 f0       	brcs	.+6      	; 0x5e9e <__ultoa_invert+0x7c>
    5e98:	49 5d       	subi	r20, 0xD9	; 217
    5e9a:	31 fd       	sbrc	r19, 1
    5e9c:	40 52       	subi	r20, 0x20	; 32
    5e9e:	41 93       	st	Z+, r20
    5ea0:	02 d0       	rcall	.+4      	; 0x5ea6 <__ultoa_invert+0x84>
    5ea2:	a9 f7       	brne	.-22     	; 0x5e8e <__ultoa_invert+0x6c>
    5ea4:	ea cf       	rjmp	.-44     	; 0x5e7a <__ultoa_invert+0x58>
    5ea6:	b4 e0       	ldi	r27, 0x04	; 4
    5ea8:	a6 95       	lsr	r26
    5eaa:	97 95       	ror	r25
    5eac:	87 95       	ror	r24
    5eae:	77 95       	ror	r23
    5eb0:	67 95       	ror	r22
    5eb2:	ba 95       	dec	r27
    5eb4:	c9 f7       	brne	.-14     	; 0x5ea8 <__ultoa_invert+0x86>
    5eb6:	00 97       	sbiw	r24, 0x00	; 0
    5eb8:	61 05       	cpc	r22, r1
    5eba:	71 05       	cpc	r23, r1
    5ebc:	08 95       	ret
    5ebe:	9b 01       	movw	r18, r22
    5ec0:	ac 01       	movw	r20, r24
    5ec2:	0a 2e       	mov	r0, r26
    5ec4:	06 94       	lsr	r0
    5ec6:	57 95       	ror	r21
    5ec8:	47 95       	ror	r20
    5eca:	37 95       	ror	r19
    5ecc:	27 95       	ror	r18
    5ece:	ba 95       	dec	r27
    5ed0:	c9 f7       	brne	.-14     	; 0x5ec4 <__ultoa_invert+0xa2>
    5ed2:	62 0f       	add	r22, r18
    5ed4:	73 1f       	adc	r23, r19
    5ed6:	84 1f       	adc	r24, r20
    5ed8:	95 1f       	adc	r25, r21
    5eda:	a0 1d       	adc	r26, r0
    5edc:	08 95       	ret

00005ede <__divmodsi4>:
    5ede:	05 2e       	mov	r0, r21
    5ee0:	97 fb       	bst	r25, 7
    5ee2:	16 f4       	brtc	.+4      	; 0x5ee8 <__divmodsi4+0xa>
    5ee4:	00 94       	com	r0
    5ee6:	0f d0       	rcall	.+30     	; 0x5f06 <__negsi2>
    5ee8:	57 fd       	sbrc	r21, 7
    5eea:	05 d0       	rcall	.+10     	; 0x5ef6 <__divmodsi4_neg2>
    5eec:	22 dc       	rcall	.-1980   	; 0x5732 <__udivmodsi4>
    5eee:	07 fc       	sbrc	r0, 7
    5ef0:	02 d0       	rcall	.+4      	; 0x5ef6 <__divmodsi4_neg2>
    5ef2:	46 f4       	brtc	.+16     	; 0x5f04 <__divmodsi4_exit>
    5ef4:	08 c0       	rjmp	.+16     	; 0x5f06 <__negsi2>

00005ef6 <__divmodsi4_neg2>:
    5ef6:	50 95       	com	r21
    5ef8:	40 95       	com	r20
    5efa:	30 95       	com	r19
    5efc:	21 95       	neg	r18
    5efe:	3f 4f       	sbci	r19, 0xFF	; 255
    5f00:	4f 4f       	sbci	r20, 0xFF	; 255
    5f02:	5f 4f       	sbci	r21, 0xFF	; 255

00005f04 <__divmodsi4_exit>:
    5f04:	08 95       	ret

00005f06 <__negsi2>:
    5f06:	90 95       	com	r25
    5f08:	80 95       	com	r24
    5f0a:	70 95       	com	r23
    5f0c:	61 95       	neg	r22
    5f0e:	7f 4f       	sbci	r23, 0xFF	; 255
    5f10:	8f 4f       	sbci	r24, 0xFF	; 255
    5f12:	9f 4f       	sbci	r25, 0xFF	; 255
    5f14:	08 95       	ret

00005f16 <__muluhisi3>:
    5f16:	37 dc       	rcall	.-1938   	; 0x5786 <__umulhisi3>
    5f18:	a5 9f       	mul	r26, r21
    5f1a:	90 0d       	add	r25, r0
    5f1c:	b4 9f       	mul	r27, r20
    5f1e:	90 0d       	add	r25, r0
    5f20:	a4 9f       	mul	r26, r20
    5f22:	80 0d       	add	r24, r0
    5f24:	91 1d       	adc	r25, r1
    5f26:	11 24       	eor	r1, r1
    5f28:	08 95       	ret

00005f2a <__mulshisi3>:
    5f2a:	b7 ff       	sbrs	r27, 7
    5f2c:	f4 cf       	rjmp	.-24     	; 0x5f16 <__muluhisi3>

00005f2e <__mulohisi3>:
    5f2e:	f3 df       	rcall	.-26     	; 0x5f16 <__muluhisi3>
    5f30:	82 1b       	sub	r24, r18
    5f32:	93 0b       	sbc	r25, r19
    5f34:	08 95       	ret

00005f36 <_exit>:
    5f36:	f8 94       	cli

00005f38 <__stop_program>:
    5f38:	ff cf       	rjmp	.-2      	; 0x5f38 <__stop_program>
