
obc.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         000001f2  00800200  00005f24  00005fb8  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00005f24  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00001c3c  008003f2  008003f2  000061aa  2**0
                  ALLOC
  3 .comment      0000005c  00000000  00000000  000061aa  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00006208  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000a40  00000000  00000000  00006248  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000ce93  00000000  00000000  00006c88  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00003fb8  00000000  00000000  00013b1b  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000720c  00000000  00000000  00017ad3  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000027e8  00000000  00000000  0001ece0  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    0000311b  00000000  00000000  000214c8  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000bc3a  00000000  00000000  000245e3  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000990  00000000  00000000  0003021d  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	4d c7       	rjmp	.+3738   	; 0xe9c <__ctors_end>
       2:	00 00       	nop
       4:	6c c7       	rjmp	.+3800   	; 0xede <__bad_interrupt>
       6:	00 00       	nop
       8:	6a c7       	rjmp	.+3796   	; 0xede <__bad_interrupt>
       a:	00 00       	nop
       c:	68 c7       	rjmp	.+3792   	; 0xede <__bad_interrupt>
       e:	00 00       	nop
      10:	66 c7       	rjmp	.+3788   	; 0xede <__bad_interrupt>
      12:	00 00       	nop
      14:	64 c7       	rjmp	.+3784   	; 0xede <__bad_interrupt>
      16:	00 00       	nop
      18:	62 c7       	rjmp	.+3780   	; 0xede <__bad_interrupt>
      1a:	00 00       	nop
      1c:	60 c7       	rjmp	.+3776   	; 0xede <__bad_interrupt>
      1e:	00 00       	nop
      20:	5e c7       	rjmp	.+3772   	; 0xede <__bad_interrupt>
      22:	00 00       	nop
      24:	5c c7       	rjmp	.+3768   	; 0xede <__bad_interrupt>
      26:	00 00       	nop
      28:	5a c7       	rjmp	.+3764   	; 0xede <__bad_interrupt>
      2a:	00 00       	nop
      2c:	58 c7       	rjmp	.+3760   	; 0xede <__bad_interrupt>
      2e:	00 00       	nop
      30:	56 c7       	rjmp	.+3756   	; 0xede <__bad_interrupt>
      32:	00 00       	nop
      34:	54 c7       	rjmp	.+3752   	; 0xede <__bad_interrupt>
      36:	00 00       	nop
      38:	52 c7       	rjmp	.+3748   	; 0xede <__bad_interrupt>
      3a:	00 00       	nop
      3c:	50 c7       	rjmp	.+3744   	; 0xede <__bad_interrupt>
      3e:	00 00       	nop
      40:	4e c7       	rjmp	.+3740   	; 0xede <__bad_interrupt>
      42:	00 00       	nop
      44:	0c 94 bd 0a 	jmp	0x157a	; 0x157a <__vector_17>
      48:	4a c7       	rjmp	.+3732   	; 0xede <__bad_interrupt>
      4a:	00 00       	nop
      4c:	48 c7       	rjmp	.+3728   	; 0xede <__bad_interrupt>
      4e:	00 00       	nop
      50:	46 c7       	rjmp	.+3724   	; 0xede <__bad_interrupt>
      52:	00 00       	nop
      54:	44 c7       	rjmp	.+3720   	; 0xede <__bad_interrupt>
      56:	00 00       	nop
      58:	42 c7       	rjmp	.+3716   	; 0xede <__bad_interrupt>
      5a:	00 00       	nop
      5c:	40 c7       	rjmp	.+3712   	; 0xede <__bad_interrupt>
      5e:	00 00       	nop
      60:	3e c7       	rjmp	.+3708   	; 0xede <__bad_interrupt>
      62:	00 00       	nop
      64:	3c c7       	rjmp	.+3704   	; 0xede <__bad_interrupt>
      66:	00 00       	nop
      68:	3a c7       	rjmp	.+3700   	; 0xede <__bad_interrupt>
      6a:	00 00       	nop
      6c:	38 c7       	rjmp	.+3696   	; 0xede <__bad_interrupt>
      6e:	00 00       	nop
      70:	36 c7       	rjmp	.+3692   	; 0xede <__bad_interrupt>
      72:	00 00       	nop
      74:	34 c7       	rjmp	.+3688   	; 0xede <__bad_interrupt>
      76:	00 00       	nop
      78:	32 c7       	rjmp	.+3684   	; 0xede <__bad_interrupt>
      7a:	00 00       	nop
      7c:	30 c7       	rjmp	.+3680   	; 0xede <__bad_interrupt>
      7e:	00 00       	nop
      80:	2e c7       	rjmp	.+3676   	; 0xede <__bad_interrupt>
      82:	00 00       	nop
      84:	2c c7       	rjmp	.+3672   	; 0xede <__bad_interrupt>
      86:	00 00       	nop
      88:	2a c7       	rjmp	.+3668   	; 0xede <__bad_interrupt>
      8a:	00 00       	nop
      8c:	28 c7       	rjmp	.+3664   	; 0xede <__bad_interrupt>
      8e:	00 00       	nop
      90:	26 c7       	rjmp	.+3660   	; 0xede <__bad_interrupt>
      92:	00 00       	nop
      94:	24 c7       	rjmp	.+3656   	; 0xede <__bad_interrupt>
      96:	00 00       	nop
      98:	22 c7       	rjmp	.+3652   	; 0xede <__bad_interrupt>
      9a:	00 00       	nop
      9c:	0c 94 35 27 	jmp	0x4e6a	; 0x4e6a <__vector_39>
      a0:	1e c7       	rjmp	.+3644   	; 0xede <__bad_interrupt>
      a2:	00 00       	nop
      a4:	1c c7       	rjmp	.+3640   	; 0xede <__bad_interrupt>
      a6:	00 00       	nop
      a8:	1a c7       	rjmp	.+3636   	; 0xede <__bad_interrupt>
      aa:	00 00       	nop
      ac:	18 c7       	rjmp	.+3632   	; 0xede <__bad_interrupt>
      ae:	00 00       	nop
      b0:	16 c7       	rjmp	.+3628   	; 0xede <__bad_interrupt>
      b2:	00 00       	nop
      b4:	14 c7       	rjmp	.+3624   	; 0xede <__bad_interrupt>
      b6:	00 00       	nop
      b8:	12 c7       	rjmp	.+3620   	; 0xede <__bad_interrupt>
      ba:	00 00       	nop
      bc:	10 c7       	rjmp	.+3616   	; 0xede <__bad_interrupt>
      be:	00 00       	nop
      c0:	0e c7       	rjmp	.+3612   	; 0xede <__bad_interrupt>
      c2:	00 00       	nop
      c4:	0c c7       	rjmp	.+3608   	; 0xede <__bad_interrupt>
      c6:	00 00       	nop
      c8:	0a c7       	rjmp	.+3604   	; 0xede <__bad_interrupt>
      ca:	00 00       	nop
      cc:	08 c7       	rjmp	.+3600   	; 0xede <__bad_interrupt>
      ce:	00 00       	nop
      d0:	06 c7       	rjmp	.+3596   	; 0xede <__bad_interrupt>
      d2:	00 00       	nop
      d4:	04 c7       	rjmp	.+3592   	; 0xede <__bad_interrupt>
      d6:	00 00       	nop
      d8:	02 c7       	rjmp	.+3588   	; 0xede <__bad_interrupt>
      da:	00 00       	nop
      dc:	00 c7       	rjmp	.+3584   	; 0xede <__bad_interrupt>
      de:	00 00       	nop
      e0:	fe c6       	rjmp	.+3580   	; 0xede <__bad_interrupt>
      e2:	00 00       	nop
      e4:	8b 14       	cp	r8, r11
      e6:	73 14       	cp	r7, r3
      e8:	76 14       	cp	r7, r6
      ea:	79 14       	cp	r7, r9
      ec:	7c 14       	cp	r7, r12
      ee:	7f 14       	cp	r7, r15
      f0:	82 14       	cp	r8, r2
      f2:	85 14       	cp	r8, r5
      f4:	98 1b       	sub	r25, r24
      f6:	9a 1b       	sub	r25, r26
      f8:	a4 1b       	sub	r26, r20
      fa:	9c 1b       	sub	r25, r28
      fc:	9e 1b       	sub	r25, r30
      fe:	a0 1b       	sub	r26, r16
     100:	a2 1b       	sub	r26, r18
     102:	7d 28       	or	r7, r13
     104:	6a 29       	or	r22, r10
     106:	6a 29       	or	r22, r10
     108:	6a 29       	or	r22, r10
     10a:	6a 29       	or	r22, r10
     10c:	6a 29       	or	r22, r10
     10e:	6a 29       	or	r22, r10
     110:	6a 29       	or	r22, r10
     112:	7d 28       	or	r7, r13
     114:	6a 29       	or	r22, r10
     116:	6a 29       	or	r22, r10
     118:	6a 29       	or	r22, r10
     11a:	6a 29       	or	r22, r10
     11c:	6a 29       	or	r22, r10
     11e:	6a 29       	or	r22, r10
     120:	6a 29       	or	r22, r10
     122:	ab 28       	or	r10, r11
     124:	6a 29       	or	r22, r10
     126:	6a 29       	or	r22, r10
     128:	6a 29       	or	r22, r10
     12a:	6a 29       	or	r22, r10
     12c:	6a 29       	or	r22, r10
     12e:	6a 29       	or	r22, r10
     130:	6a 29       	or	r22, r10
     132:	d7 28       	or	r13, r7
     134:	6a 29       	or	r22, r10
     136:	6a 29       	or	r22, r10
     138:	6a 29       	or	r22, r10
     13a:	6a 29       	or	r22, r10
     13c:	6a 29       	or	r22, r10
     13e:	6a 29       	or	r22, r10
     140:	6a 29       	or	r22, r10
     142:	ab 28       	or	r10, r11
     144:	6a 29       	or	r22, r10
     146:	6a 29       	or	r22, r10
     148:	6a 29       	or	r22, r10
     14a:	6a 29       	or	r22, r10
     14c:	6a 29       	or	r22, r10
     14e:	6a 29       	or	r22, r10
     150:	6a 29       	or	r22, r10
     152:	d7 28       	or	r13, r7
     154:	6a 29       	or	r22, r10
     156:	6a 29       	or	r22, r10
     158:	6a 29       	or	r22, r10
     15a:	6a 29       	or	r22, r10
     15c:	6a 29       	or	r22, r10
     15e:	6a 29       	or	r22, r10
     160:	6a 29       	or	r22, r10
     162:	04 29       	or	r16, r4
     164:	6a 29       	or	r22, r10
     166:	6a 29       	or	r22, r10
     168:	6a 29       	or	r22, r10
     16a:	6a 29       	or	r22, r10
     16c:	6a 29       	or	r22, r10
     16e:	6a 29       	or	r22, r10
     170:	6a 29       	or	r22, r10
     172:	15 29       	or	r17, r5
     174:	6a 29       	or	r22, r10
     176:	6a 29       	or	r22, r10
     178:	6a 29       	or	r22, r10
     17a:	6a 29       	or	r22, r10
     17c:	6a 29       	or	r22, r10
     17e:	6a 29       	or	r22, r10
     180:	6a 29       	or	r22, r10
     182:	4a 29       	or	r20, r10
     184:	6a 29       	or	r22, r10
     186:	6a 29       	or	r22, r10
     188:	6a 29       	or	r22, r10
     18a:	6a 29       	or	r22, r10
     18c:	6a 29       	or	r22, r10
     18e:	6a 29       	or	r22, r10
     190:	6a 29       	or	r22, r10
     192:	1f 29       	or	r17, r15
     194:	6a 29       	or	r22, r10
     196:	6a 29       	or	r22, r10
     198:	6a 29       	or	r22, r10
     19a:	6a 29       	or	r22, r10
     19c:	6a 29       	or	r22, r10
     19e:	6a 29       	or	r22, r10
     1a0:	6a 29       	or	r22, r10
     1a2:	51 29       	or	r21, r1
     1a4:	6a 29       	or	r22, r10
     1a6:	6a 29       	or	r22, r10
     1a8:	6a 29       	or	r22, r10
     1aa:	6a 29       	or	r22, r10
     1ac:	6a 29       	or	r22, r10
     1ae:	6a 29       	or	r22, r10
     1b0:	6a 29       	or	r22, r10
     1b2:	b3 27       	eor	r27, r19
     1b4:	6a 29       	or	r22, r10
     1b6:	6a 29       	or	r22, r10
     1b8:	6a 29       	or	r22, r10
     1ba:	6a 29       	or	r22, r10
     1bc:	6a 29       	or	r22, r10
     1be:	6a 29       	or	r22, r10
     1c0:	6a 29       	or	r22, r10
     1c2:	b3 27       	eor	r27, r19
     1c4:	6a 29       	or	r22, r10
     1c6:	6a 29       	or	r22, r10
     1c8:	6a 29       	or	r22, r10
     1ca:	6a 29       	or	r22, r10
     1cc:	6a 29       	or	r22, r10
     1ce:	6a 29       	or	r22, r10
     1d0:	6a 29       	or	r22, r10
     1d2:	6a 29       	or	r22, r10
     1d4:	6a 29       	or	r22, r10
     1d6:	6a 29       	or	r22, r10
     1d8:	6a 29       	or	r22, r10
     1da:	6a 29       	or	r22, r10
     1dc:	6a 29       	or	r22, r10
     1de:	6a 29       	or	r22, r10
     1e0:	6a 29       	or	r22, r10
     1e2:	6a 29       	or	r22, r10
     1e4:	6a 29       	or	r22, r10
     1e6:	6a 29       	or	r22, r10
     1e8:	6a 29       	or	r22, r10
     1ea:	6a 29       	or	r22, r10
     1ec:	6a 29       	or	r22, r10
     1ee:	6a 29       	or	r22, r10
     1f0:	6a 29       	or	r22, r10
     1f2:	bd 27       	eor	r27, r29
     1f4:	6a 29       	or	r22, r10
     1f6:	6a 29       	or	r22, r10
     1f8:	6a 29       	or	r22, r10
     1fa:	6a 29       	or	r22, r10
     1fc:	6a 29       	or	r22, r10
     1fe:	6a 29       	or	r22, r10
     200:	6a 29       	or	r22, r10
     202:	bd 27       	eor	r27, r29
     204:	6a 29       	or	r22, r10
     206:	6a 29       	or	r22, r10
     208:	6a 29       	or	r22, r10
     20a:	6a 29       	or	r22, r10
     20c:	6a 29       	or	r22, r10
     20e:	6a 29       	or	r22, r10
     210:	6a 29       	or	r22, r10
     212:	6a 29       	or	r22, r10
     214:	6a 29       	or	r22, r10
     216:	6a 29       	or	r22, r10
     218:	6a 29       	or	r22, r10
     21a:	6a 29       	or	r22, r10
     21c:	6a 29       	or	r22, r10
     21e:	6a 29       	or	r22, r10
     220:	6a 29       	or	r22, r10
     222:	6a 29       	or	r22, r10
     224:	6a 29       	or	r22, r10
     226:	6a 29       	or	r22, r10
     228:	6a 29       	or	r22, r10
     22a:	6a 29       	or	r22, r10
     22c:	6a 29       	or	r22, r10
     22e:	6a 29       	or	r22, r10
     230:	6a 29       	or	r22, r10
     232:	f2 27       	eor	r31, r18
     234:	6a 29       	or	r22, r10
     236:	6a 29       	or	r22, r10
     238:	6a 29       	or	r22, r10
     23a:	6a 29       	or	r22, r10
     23c:	6a 29       	or	r22, r10
     23e:	6a 29       	or	r22, r10
     240:	6a 29       	or	r22, r10
     242:	60 27       	eor	r22, r16
     244:	6a 29       	or	r22, r10
     246:	6a 29       	or	r22, r10
     248:	6a 29       	or	r22, r10
     24a:	6a 29       	or	r22, r10
     24c:	6a 29       	or	r22, r10
     24e:	6a 29       	or	r22, r10
     250:	6a 29       	or	r22, r10
     252:	60 27       	eor	r22, r16
     254:	6a 29       	or	r22, r10
     256:	6a 29       	or	r22, r10
     258:	6a 29       	or	r22, r10
     25a:	6a 29       	or	r22, r10
     25c:	6a 29       	or	r22, r10
     25e:	6a 29       	or	r22, r10
     260:	6a 29       	or	r22, r10
     262:	60 27       	eor	r22, r16
     264:	6a 29       	or	r22, r10
     266:	6a 29       	or	r22, r10
     268:	6a 29       	or	r22, r10
     26a:	6a 29       	or	r22, r10
     26c:	6a 29       	or	r22, r10
     26e:	6a 29       	or	r22, r10
     270:	6a 29       	or	r22, r10
     272:	a5 27       	eor	r26, r21
     274:	6a 29       	or	r22, r10
     276:	6a 29       	or	r22, r10
     278:	6a 29       	or	r22, r10
     27a:	6a 29       	or	r22, r10
     27c:	6a 29       	or	r22, r10
     27e:	6a 29       	or	r22, r10
     280:	6a 29       	or	r22, r10
     282:	a5 27       	eor	r26, r21

00000284 <__trampolines_end>:
     284:	5b 25       	eor	r21, r11
     286:	30 32       	cpi	r19, 0x20	; 32
     288:	75 5d       	subi	r23, 0xD5	; 213
     28a:	20 25       	eor	r18, r0
     28c:	73 3a       	cpi	r23, 0xA3	; 163
     28e:	25 64       	ori	r18, 0x45	; 69
     290:	20 50       	subi	r18, 0x00	; 0
     292:	6f 73       	andi	r22, 0x3F	; 63
     294:	74 3a       	cpi	r23, 0xA4	; 164
     296:	20 25       	eor	r18, r0
     298:	70 00       	.word	0x0070	; ????

0000029a <__c.2849>:
     29a:	5b 25 30 32 75 5d 20 25 73 3a 25 64 20 57 61 69     [%02u] %s:%d Wai
     2aa:	74 3a 20 25 70 00                                   t: %p.

000002b0 <__c.2821>:
     2b0:	1b 5b 25 75 3b 25 75 6d 00                          .[%u;%um.

000002b9 <__c.2885>:
     2b9:	5b 25 30 32 75 5d 20 25 73 3a 25 64 20 46 52 45     [%02u] %s:%d FRE
     2c9:	45 3a 20 25 70 00                                   E: %p.

000002cf <__c.2883>:
     2cf:	5b 25 30 32 75 5d 20 25 73 3a 25 64 20 46 52 45     [%02u] %s:%d FRE
     2df:	45 3a 20 42 75 66 66 65 72 20 25 70 20 69 6e 20     E: Buffer %p in 
     2ef:	75 73 65 20 62 79 20 25 75 20 75 73 65 72 73 00     use by %u users.

000002ff <__c.2881>:
     2ff:	5b 25 30 32 75 5d 20 25 73 3a 25 64 20 46 52 45     [%02u] %s:%d FRE
     30f:	45 3a 20 42 75 66 66 65 72 20 61 6c 72 65 61 64     E: Buffer alread
     31f:	79 20 66 72 65 65 20 25 70 00                       y free %p.

00000329 <__c.2879>:
     329:	5b 25 30 32 75 5d 20 25 73 3a 25 64 20 46 52 45     [%02u] %s:%d FRE
     339:	45 3a 20 49 6e 76 61 6c 69 64 20 43 53 50 20 62     E: Invalid CSP b
     349:	75 66 66 65 72 20 70 6f 69 6e 74 65 72 20 25 70     uffer pointer %p
	...

0000035a <__c.2877>:
     35a:	5b 25 30 32 75 5d 20 25 73 3a 25 64 20 46 52 45     [%02u] %s:%d FRE
     36a:	45 3a 20 55 6e 61 6c 69 67 6e 65 64 20 43 53 50     E: Unaligned CSP
     37a:	20 62 75 66 66 65 72 20 70 6f 69 6e 74 65 72 20      buffer pointer 
     38a:	25 70 00                                            %p.

0000038d <__c.2874>:
     38d:	5b 25 30 32 75 5d 20 25 73 3a 25 64 20 41 74 74     [%02u] %s:%d Att
     39d:	65 6d 70 74 20 74 6f 20 66 72 65 65 20 6e 75 6c     empt to free nul
     3ad:	6c 20 70 6f 69 6e 74 65 72 00                       l pointer.

000003b7 <__c.2864>:
     3b7:	5b 25 30 32 75 5d 20 25 73 3a 25 64 20 43 6f 72     [%02u] %s:%d Cor
     3c7:	72 75 70 74 20 43 53 50 20 62 75 66 66 65 72 00     rupt CSP buffer.

000003d7 <__c.2862>:
     3d7:	5b 25 30 32 75 5d 20 25 73 3a 25 64 20 47 45 54     [%02u] %s:%d GET
     3e7:	3a 20 25 70 20 25 70 00                             : %p %p.

000003ef <__c.2860>:
     3ef:	5b 25 30 32 75 5d 20 25 73 3a 25 64 20 4f 75 74     [%02u] %s:%d Out
     3ff:	20 6f 66 20 62 75 66 66 65 72 73 00                  of buffers.

0000040b <__c.2858>:
     40b:	5b 25 30 32 75 5d 20 25 73 3a 25 64 20 41 74 74     [%02u] %s:%d Att
     41b:	65 6d 70 74 20 74 6f 20 61 6c 6c 6f 63 61 74 65     empt to allocate
     42b:	20 74 6f 6f 20 6c 61 72 67 65 20 62 6c 6f 63 6b      too large block
     43b:	20 25 75 00                                          %u.

0000043f <__c.3263>:
     43f:	5b 25 30 32 75 5d 20 25 73 3a 25 64 20 41 74 74     [%02u] %s:%d Att
     44f:	65 6d 70 74 20 74 6f 20 63 72 65 61 74 65 20 43     empt to create C
     45f:	52 43 33 32 20 76 61 6c 69 64 61 74 65 64 20 63     RC32 validated c
     46f:	6f 6e 6e 65 63 74 69 6f 6e 2c 20 62 75 74 20 43     onnection, but C
     47f:	53 50 20 77 61 73 20 63 6f 6d 70 69 6c 65 64 20     SP was compiled 
     48f:	77 69 74 68 6f 75 74 20 43 52 43 33 32 20 73 75     without CRC32 su
     49f:	70 70 6f 72 74 00                                   pport.

000004a5 <__c.3261>:
     4a5:	5b 25 30 32 75 5d 20 25 73 3a 25 64 20 41 74 74     [%02u] %s:%d Att
     4b5:	65 6d 70 74 20 74 6f 20 63 72 65 61 74 65 20 58     empt to create X
     4c5:	54 45 41 20 65 6e 63 72 79 70 74 65 64 20 63 6f     TEA encrypted co
     4d5:	6e 6e 65 63 74 69 6f 6e 2c 20 62 75 74 20 43 53     nnection, but CS
     4e5:	50 20 77 61 73 20 63 6f 6d 70 69 6c 65 64 20 77     P was compiled w
     4f5:	69 74 68 6f 75 74 20 58 54 45 41 20 73 75 70 70     ithout XTEA supp
     505:	6f 72 74 00                                         ort.

00000509 <__c.3259>:
     509:	5b 25 30 32 75 5d 20 25 73 3a 25 64 20 41 74 74     [%02u] %s:%d Att
     519:	65 6d 70 74 20 74 6f 20 63 72 65 61 74 65 20 48     empt to create H
     529:	4d 41 43 20 61 75 74 68 65 6e 74 69 63 61 74 65     MAC authenticate
     539:	64 20 63 6f 6e 6e 65 63 74 69 6f 6e 2c 20 62 75     d connection, bu
     549:	74 20 43 53 50 20 77 61 73 20 63 6f 6d 70 69 6c     t CSP was compil
     559:	65 64 20 77 69 74 68 6f 75 74 20 48 4d 41 43 20     ed without HMAC 
     569:	73 75 70 70 6f 72 74 00                             support.

00000571 <__c.3257>:
     571:	5b 25 30 32 75 5d 20 25 73 3a 25 64 20 41 74 74     [%02u] %s:%d Att
     581:	65 6d 70 74 20 74 6f 20 63 72 65 61 74 65 20 52     empt to create R
     591:	44 50 20 63 6f 6e 6e 65 63 74 69 6f 6e 2c 20 62     DP connection, b
     5a1:	75 74 20 43 53 50 20 77 61 73 20 63 6f 6d 70 69     ut CSP was compi
     5b1:	6c 65 64 20 77 69 74 68 6f 75 74 20 52 44 50 20     led without RDP 
     5c1:	73 75 70 70 6f 72 74 00                             support.

000005c9 <__c.3246>:
     5c9:	5b 25 30 32 75 5d 20 25 73 3a 25 64 20 46 61 69     [%02u] %s:%d Fai
     5d9:	6c 65 64 20 74 6f 20 6c 6f 63 6b 20 63 6f 6e 6e     led to lock conn
     5e9:	20 61 72 72 61 79 00                                 array.

000005f0 <__c.3244>:
     5f0:	5b 25 30 32 75 5d 20 25 73 3a 25 64 20 43 6f 6e     [%02u] %s:%d Con
     600:	6e 20 61 6c 72 65 61 64 79 20 63 6c 6f 73 65 64     n already closed
	...

00000611 <__c.3242>:
     611:	5b 25 30 32 75 5d 20 25 73 3a 25 64 20 4e 55 4c     [%02u] %s:%d NUL
     621:	4c 20 50 6f 69 6e 74 65 72 20 67 69 76 65 6e 20     L Pointer given 
     631:	74 6f 20 63 73 70 5f 63 6c 6f 73 65 00              to csp_close.

0000063e <__c.3232>:
     63e:	5b 25 30 32 75 5d 20 25 73 3a 25 64 20 4e 6f 20     [%02u] %s:%d No 
     64e:	6d 6f 72 65 20 66 72 65 65 20 63 6f 6e 6e 65 63     more free connec
     65e:	74 69 6f 6e 73 00                                   tions.

00000664 <__c.3227>:
     664:	5b 25 30 32 75 5d 20 25 73 3a 25 64 20 46 61 69     [%02u] %s:%d Fai
     674:	6c 65 64 20 74 6f 20 6c 6f 63 6b 20 63 6f 6e 6e     led to lock conn
     684:	20 61 72 72 61 79 00                                 array.

0000068b <__c.3198>:
     68b:	5b 25 30 32 75 5d 20 25 73 3a 25 64 20 4e 6f 20     [%02u] %s:%d No 
     69b:	6d 6f 72 65 20 6d 65 6d 6f 72 79 20 66 6f 72 20     more memory for 
     6ab:	63 6f 6e 6e 20 73 65 6d 61 70 68 6f 72 65 00        conn semaphore.

000006ba <__c.3193>:
     6ba:	5b 25 30 32 75 5d 20 25 73 3a 25 64 20 46 61 69     [%02u] %s:%d Fai
     6ca:	6c 65 64 20 74 6f 20 63 72 65 61 74 65 20 63 6f     led to create co
     6da:	6e 6e 65 63 74 69 6f 6e 20 6c 6f 63 6b 00           nnection lock.

000006e8 <__c.3186>:
     6e8:	5b 25 30 32 75 5d 20 25 73 3a 25 64 20 4e 6f 20     [%02u] %s:%d No 
     6f8:	6d 6f 72 65 20 6d 65 6d 6f 72 79 20 66 6f 72 20     more memory for 
     708:	73 70 6f 72 74 20 73 65 6d 61 70 68 6f 72 65 00     sport semaphore.

00000718 <__c.3181>:
     718:	5b 25 30 32 75 5d 20 25 73 3a 25 64 20 52 58 20     [%02u] %s:%d RX 
     728:	71 75 65 75 65 20 25 70 20 66 75 6c 6c 20 77 69     queue %p full wi
     738:	74 68 20 25 75 20 69 74 65 6d 73 00                 th %u items.

00000744 <__c.2557>:
     744:	0d 0a 00                                            ...

00000747 <__c.3371>:
     747:	5b 25 30 32 75 5d 20 25 73 3a 25 64 20 52 65 70     [%02u] %s:%d Rep
     757:	6c 79 20 6c 65 6e 67 74 68 20 25 75 20 65 78 70     ly length %u exp
     767:	65 63 74 65 64 20 25 75 00                          ected %u.

00000770 <__c.3352>:
     770:	5b 25 30 32 75 5d 20 25 73 3a 25 64 20 49 6e 76     [%02u] %s:%d Inv
     780:	61 6c 69 64 20 63 61 6c 6c 20 74 6f 20 63 73 70     alid call to csp
     790:	5f 73 65 6e 64 00                                   _send.

00000796 <__c.3342>:
     796:	5b 25 30 32 75 5d 20 25 73 3a 25 64 20 41 74 74     [%02u] %s:%d Att
     7a6:	65 6d 70 74 20 74 6f 20 73 65 6e 64 20 58 54 45     empt to send XTE
     7b6:	41 20 65 6e 63 72 79 70 74 65 64 20 70 61 63 6b     A encrypted pack
     7c6:	65 74 2c 20 62 75 74 20 43 53 50 20 77 61 73 20     et, but CSP was 
     7d6:	63 6f 6d 70 69 6c 65 64 20 77 69 74 68 6f 75 74     compiled without
     7e6:	20 58 54 45 41 20 73 75 70 70 6f 72 74 2e 20 44      XTEA support. D
     7f6:	69 73 63 61 72 64 69 6e 67 20 70 61 63 6b 65 74     iscarding packet
	...

00000807 <__c.3340>:
     807:	5b 25 30 32 75 5d 20 25 73 3a 25 64 20 41 74 74     [%02u] %s:%d Att
     817:	65 6d 70 74 20 74 6f 20 73 65 6e 64 20 70 61 63     empt to send pac
     827:	6b 65 74 20 77 69 74 68 20 43 52 43 33 32 2c 20     ket with CRC32, 
     837:	62 75 74 20 43 53 50 20 77 61 73 20 63 6f 6d 70     but CSP was comp
     847:	69 6c 65 64 20 77 69 74 68 6f 75 74 20 43 52 43     iled without CRC
     857:	33 32 20 73 75 70 70 6f 72 74 2e 20 53 65 6e 64     32 support. Send
     867:	69 6e 67 20 77 69 74 68 6f 75 74 20 43 52 43 33     ing without CRC3
     877:	32 72 00                                            2r.

0000087a <__c.3337>:
     87a:	5b 25 30 32 75 5d 20 25 73 3a 25 64 20 41 74 74     [%02u] %s:%d Att
     88a:	65 6d 70 74 20 74 6f 20 73 65 6e 64 20 70 61 63     empt to send pac
     89a:	6b 65 74 20 77 69 74 68 20 48 4d 41 43 2c 20 62     ket with HMAC, b
     8aa:	75 74 20 43 53 50 20 77 61 73 20 63 6f 6d 70 69     ut CSP was compi
     8ba:	6c 65 64 20 77 69 74 68 6f 75 74 20 48 4d 41 43     led without HMAC
     8ca:	20 73 75 70 70 6f 72 74 2e 20 44 69 73 63 61 72      support. Discar
     8da:	64 69 6e 67 20 70 61 63 6b 65 74 00                 ding packet.

000008e6 <__c.3335>:
     8e6:	5b 25 30 32 75 5d 20 25 73 3a 25 64 20 4f 55 54     [%02u] %s:%d OUT
     8f6:	3a 20 53 20 25 75 2c 20 44 20 25 75 2c 20 44 70     : S %u, D %u, Dp
     906:	20 25 75 2c 20 53 70 20 25 75 2c 20 50 72 20 25      %u, Sp %u, Pr %
     916:	75 2c 20 46 6c 20 30 78 25 30 32 58 2c 20 53 7a     u, Fl 0x%02X, Sz
     926:	20 25 75 20 56 49 41 3a 20 25 73 00                  %u VIA: %s.

00000932 <__c.3333>:
     932:	5b 25 30 32 75 5d 20 25 73 3a 25 64 20 4e 6f 20     [%02u] %s:%d No 
     942:	72 6f 75 74 65 20 74 6f 20 68 6f 73 74 3a 20 25     route to host: %
     952:	23 30 38 78 00                                      #08x.

00000957 <__c.3330>:
     957:	5b 25 30 32 75 5d 20 25 73 3a 25 64 20 63 73 70     [%02u] %s:%d csp
     967:	5f 73 65 6e 64 5f 64 69 72 65 63 74 20 63 61 6c     _send_direct cal
     977:	6c 65 64 20 77 69 74 68 20 4e 55 4c 4c 20 70 61     led with NULL pa
     987:	63 6b 65 74 00                                      cket.

0000098c <__c.2723>:
     98c:	5b 25 30 32 75 5d 20 25 73 3a 25 64 20 45 52 52     [%02u] %s:%d ERR
     99c:	4f 52 3a 20 52 6f 75 74 69 6e 67 20 69 6e 70 75     OR: Routing inpu
     9ac:	74 20 46 49 46 4f 20 69 73 20 46 55 4c 4c 2e 20     t FIFO is FULL. 
     9bc:	44 72 6f 70 70 69 6e 67 20 70 61 63 6b 65 74 2e     Dropping packet.
	...

000009cd <__c.2719>:
     9cd:	5b 25 30 32 75 5d 20 25 73 3a 25 64 20 63 73 70     [%02u] %s:%d csp
     9dd:	5f 6e 65 77 20 70 61 63 6b 65 74 20 63 61 6c 6c     _new packet call
     9ed:	65 64 20 77 69 74 68 20 4e 55 4c 4c 20 69 6e 74     ed with NULL int
     9fd:	65 72 66 61 63 65 00                                erface.

00000a04 <__c.2717>:
     a04:	5b 25 30 32 75 5d 20 25 73 3a 25 64 20 63 73 70     [%02u] %s:%d csp
     a14:	5f 6e 65 77 20 70 61 63 6b 65 74 20 63 61 6c 6c     _new packet call
     a24:	65 64 20 77 69 74 68 20 4e 55 4c 4c 20 70 61 63     ed with NULL pac
     a34:	6b 65 74 00                                         ket.

00000a38 <__c.3089>:
     a38:	5b 25 30 32 75 5d 20 25 73 3a 25 64 20 46 61 69     [%02u] %s:%d Fai
     a48:	6c 65 64 20 74 6f 20 73 74 61 72 74 20 72 6f 75     led to start rou
     a58:	74 65 72 20 74 61 73 6b 00                          ter task.

00000a61 <__c.3060>:
     a61:	5b 25 30 32 75 5d 20 25 73 3a 25 64 20 52 65 63     [%02u] %s:%d Rec
     a71:	65 69 76 65 64 20 70 61 63 6b 65 74 20 77 69 74     eived packet wit
     a81:	68 20 43 52 43 33 32 2c 20 62 75 74 20 43 53 50     h CRC32, but CSP
     a91:	20 77 61 73 20 63 6f 6d 70 69 6c 65 64 20 77 69      was compiled wi
     aa1:	74 68 6f 75 74 20 43 52 43 33 32 20 73 75 70 70     thout CRC32 supp
     ab1:	6f 72 74 2e 20 41 63 63 65 70 74 69 6e 67 20 70     ort. Accepting p
     ac1:	61 63 6b 65 74 00                                   acket.

00000ac7 <__c.3053>:
     ac7:	5b 25 30 32 75 5d 20 25 73 3a 25 64 20 52 65 63     [%02u] %s:%d Rec
     ad7:	65 69 76 65 64 20 52 44 50 20 70 61 63 6b 65 74     eived RDP packet
     ae7:	2c 20 62 75 74 20 43 53 50 20 77 61 73 20 63 6f     , but CSP was co
     af7:	6d 70 69 6c 65 64 20 77 69 74 68 6f 75 74 20 52     mpiled without R
     b07:	44 50 20 73 75 70 70 6f 72 74 2e 20 44 69 73 63     DP support. Disc
     b17:	61 72 64 69 6e 67 20 70 61 63 6b 65 74 00           arding packet.

00000b25 <__c.3051>:
     b25:	5b 25 30 32 75 5d 20 25 73 3a 25 64 20 52 65 63     [%02u] %s:%d Rec
     b35:	65 69 76 65 64 20 70 61 63 6b 65 74 20 77 69 74     eived packet wit
     b45:	68 20 48 4d 41 43 2c 20 62 75 74 20 43 53 50 20     h HMAC, but CSP 
     b55:	77 61 73 20 63 6f 6d 70 69 6c 65 64 20 77 69 74     was compiled wit
     b65:	68 6f 75 74 20 48 4d 41 43 20 73 75 70 70 6f 72     hout HMAC suppor
     b75:	74 2e 20 44 69 73 63 61 72 64 69 6e 67 20 70 61     t. Discarding pa
     b85:	63 6b 65 74 00                                      cket.

00000b8a <__c.3049>:
     b8a:	5b 25 30 32 75 5d 20 25 73 3a 25 64 20 52 65 63     [%02u] %s:%d Rec
     b9a:	65 69 76 65 64 20 58 54 45 41 20 65 6e 63 72 79     eived XTEA encry
     baa:	70 74 65 64 20 70 61 63 6b 65 74 2c 20 62 75 74     pted packet, but
     bba:	20 43 53 50 20 77 61 73 20 63 6f 6d 70 69 6c 65      CSP was compile
     bca:	64 20 77 69 74 68 6f 75 74 20 58 54 45 41 20 73     d without XTEA s
     bda:	75 70 70 6f 72 74 2e 20 44 69 73 63 61 72 64 69     upport. Discardi
     bea:	6e 67 20 70 61 63 6b 65 74 00                       ng packet.

00000bf4 <__c.3077>:
     bf4:	5b 25 30 32 75 5d 20 25 73 3a 25 64 20 4e 6f 20     [%02u] %s:%d No 
     c04:	6d 6f 72 65 20 63 6f 6e 6e 65 63 74 69 6f 6e 73     more connections
     c14:	20 61 76 61 69 6c 61 62 6c 65 00                     available.

00000c1f <__c.3074>:
     c1f:	5b 25 30 32 75 5d 20 25 73 3a 25 64 20 43 6f 6e     [%02u] %s:%d Con
     c2f:	6e 2d 6c 65 73 73 20 73 6f 63 6b 65 74 20 71 75     n-less socket qu
     c3f:	65 75 65 20 66 75 6c 6c 00                          eue full.

00000c48 <__c.3072>:
     c48:	5b 25 30 32 75 5d 20 25 73 3a 25 64 20 52 6f 75     [%02u] %s:%d Rou
     c58:	74 65 72 20 66 61 69 6c 65 64 20 74 6f 20 73 65     ter failed to se
     c68:	6e 64 00                                            nd.

00000c6b <__c.3069>:
     c6b:	5b 25 30 32 75 5d 20 25 73 3a 25 64 20 49 4e 50     [%02u] %s:%d INP
     c7b:	3a 20 53 20 25 75 2c 20 44 20 25 75 2c 20 44 70     : S %u, D %u, Dp
     c8b:	20 25 75 2c 20 53 70 20 25 75 2c 20 50 72 20 25      %u, Sp %u, Pr %
     c9b:	75 2c 20 46 6c 20 30 78 25 30 32 58 2c 20 53 7a     u, Fl 0x%02X, Sz
     cab:	20 25 75 20 56 49 41 3a 20 25 73 00                  %u VIA: %s.

00000cb7 <__c.2553>:
     cb7:	20 20 20 2a 20 20 25 2d 39 73 20 20 25 75 0d 0a        *  %-9s  %u..
	...

00000cc8 <__c.2548>:
     cc8:	25 34 75 20 20 25 2d 39 73 20 20 25 75 0d 0a 00     %4u  %-9s  %u...

00000cd8 <__c.2546>:
     cd8:	4e 6f 64 65 20 20 49 6e 74 65 72 66 61 63 65 20     Node  Interface 
     ce8:	20 41 64 64 72 65 73 73 0d 0a 00                     Address...

00000cf3 <__c.2540>:
     cf3:	5b 25 30 32 75 5d 20 25 73 3a 25 64 20 46 61 69     [%02u] %s:%d Fai
     d03:	6c 65 64 20 74 6f 20 73 65 74 20 72 6f 75 74 65     led to set route
     d13:	3a 20 69 6e 76 61 6c 69 64 20 6e 6f 64 65 20 69     : invalid node i
     d23:	64 20 25 75 00                                      d %u.

00000d28 <__c.2548>:
     d28:	5b 25 30 32 75 5d 20 25 73 3a 25 64 20 57 61 72     [%02u] %s:%d War
     d38:	6e 69 6e 67 20 73 6f 63 6b 65 74 20 63 6f 6e 6e     ning socket conn
     d48:	65 63 74 69 6f 6e 20 71 75 65 75 65 20 66 75 6c     ection queue ful
     d58:	6c 00                                               l.

00000d5a <__c.2546>:
     d5a:	5b 25 30 32 75 5d 20 25 73 3a 25 64 20 43 6f 6e     [%02u] %s:%d Con
     d6a:	6e 65 63 74 69 6f 6e 20 62 75 66 66 65 72 20 71     nection buffer q
     d7a:	75 65 75 65 20 66 75 6c 6c 21 00                    ueue full!.

00000d85 <__c.3453>:
     d85:	50 69 6e 67 20 2d 2d 20 46 61 69 6c 65 64 0d 0a     Ping -- Failed..
	...

00000d96 <__c.3451>:
     d96:	50 69 6e 67 20 2d 2d 20 54 69 6d 65 6f 75 74 0d     Ping -- Timeout.
     da6:	0a 00                                               ..

00000da8 <__c.3449>:
     da8:	52 65 70 6c 79 3a 20 25 73 2c 20 4c 65 6e 67 74     Reply: %s, Lengt
     db8:	68 3a 20 25 64 0d 0a 0d 0a 00                       h: %d.....

00000dc2 <__c.3447>:
     dc2:	50 69 6e 67 20 2d 2d 20 53 75 63 63 65 73 73 0d     Ping -- Success.
     dd2:	0a 00                                               ..

00000dd4 <__c.3144>:
     dd4:	0a 68 00                                            .h.

00000dd7 <__c.3122>:
     dd7:	45 72 72 6f 72 3a 20 69 32 63 20 74 6f 6f 20 6c     Error: i2c too l
     de7:	6f 6e 67 20 0d 0a 00                                ong ...

00000dee <__c.3082>:
     dee:	51 55 45 55 45 20 73 65 6e 64 20 66 61 69 6c 0d     QUEUE send fail.
     dfe:	0a 00                                               ..

00000e00 <__c.3080>:
     e00:	44 65 76 69 63 65 20 69 73 20 49 32 43 20 73 6c     Device is I2C sl
     e10:	61 76 65 2c 20 73 6f 20 69 74 20 63 61 6e 6e 6f     ave, so it canno
     e20:	74 20 69 6e 69 74 69 61 74 65 20 61 20 49 32 43     t initiate a I2C
     e30:	20 66 72 61 6d 65 0d 0a 00                           frame...

00000e39 <__c.3436>:
     e39:	2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 20 45 50 53 3a     ----------- EPS:
     e49:	20 41 75 74 6f 6e 6f 6d 6f 75 73 20 4d 6f 64 65      Autonomous Mode
     e59:	20 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 00               -----------.

00000e66 <__c.3430>:
     e66:	0d 0a 00                                            ...

00000e69 <__c.3428>:
     e69:	2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 20 45 50 53 3a     ----------- EPS:
     e79:	20 49 6e 69 74 69 61 6c 69 7a 61 74 69 6f 6e 20      Initialization 
     e89:	4d 6f 64 65 20 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d     Mode -----------
     e99:	0d 0a 00                                            ...

00000e9c <__ctors_end>:
     e9c:	11 24       	eor	r1, r1
     e9e:	1f be       	out	0x3f, r1	; 63
     ea0:	cf ef       	ldi	r28, 0xFF	; 255
     ea2:	d1 e2       	ldi	r29, 0x21	; 33
     ea4:	de bf       	out	0x3e, r29	; 62
     ea6:	cd bf       	out	0x3d, r28	; 61
     ea8:	00 e0       	ldi	r16, 0x00	; 0
     eaa:	0c bf       	out	0x3c, r16	; 60

00000eac <__do_copy_data>:
     eac:	13 e0       	ldi	r17, 0x03	; 3
     eae:	a0 e0       	ldi	r26, 0x00	; 0
     eb0:	b2 e0       	ldi	r27, 0x02	; 2
     eb2:	e4 e2       	ldi	r30, 0x24	; 36
     eb4:	ff e5       	ldi	r31, 0x5F	; 95
     eb6:	00 e0       	ldi	r16, 0x00	; 0
     eb8:	0b bf       	out	0x3b, r16	; 59
     eba:	02 c0       	rjmp	.+4      	; 0xec0 <__do_copy_data+0x14>
     ebc:	07 90       	elpm	r0, Z+
     ebe:	0d 92       	st	X+, r0
     ec0:	a2 3f       	cpi	r26, 0xF2	; 242
     ec2:	b1 07       	cpc	r27, r17
     ec4:	d9 f7       	brne	.-10     	; 0xebc <__do_copy_data+0x10>

00000ec6 <__do_clear_bss>:
     ec6:	20 e2       	ldi	r18, 0x20	; 32
     ec8:	a2 ef       	ldi	r26, 0xF2	; 242
     eca:	b3 e0       	ldi	r27, 0x03	; 3
     ecc:	01 c0       	rjmp	.+2      	; 0xed0 <.do_clear_bss_start>

00000ece <.do_clear_bss_loop>:
     ece:	1d 92       	st	X+, r1

00000ed0 <.do_clear_bss_start>:
     ed0:	ae 32       	cpi	r26, 0x2E	; 46
     ed2:	b2 07       	cpc	r27, r18
     ed4:	e1 f7       	brne	.-8      	; 0xece <.do_clear_bss_loop>
     ed6:	0e 94 27 2b 	call	0x564e	; 0x564e <main>
     eda:	0c 94 90 2f 	jmp	0x5f20	; 0x5f20 <_exit>

00000ede <__bad_interrupt>:
     ede:	90 c8       	rjmp	.-3808   	; 0x0 <__vectors>

00000ee0 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     ee0:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     ee2:	03 96       	adiw	r24, 0x03	; 3
     ee4:	92 83       	std	Z+2, r25	; 0x02
     ee6:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     ee8:	4f ef       	ldi	r20, 0xFF	; 255
     eea:	5f ef       	ldi	r21, 0xFF	; 255
     eec:	ba 01       	movw	r22, r20
     eee:	43 83       	std	Z+3, r20	; 0x03
     ef0:	54 83       	std	Z+4, r21	; 0x04
     ef2:	65 83       	std	Z+5, r22	; 0x05
     ef4:	76 83       	std	Z+6, r23	; 0x06

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     ef6:	90 87       	std	Z+8, r25	; 0x08
     ef8:	87 83       	std	Z+7, r24	; 0x07
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     efa:	92 87       	std	Z+10, r25	; 0x0a
     efc:	81 87       	std	Z+9, r24	; 0x09

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     efe:	10 82       	st	Z, r1
     f00:	08 95       	ret

00000f02 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     f02:	fc 01       	movw	r30, r24
     f04:	13 86       	std	Z+11, r1	; 0x0b
     f06:	12 86       	std	Z+10, r1	; 0x0a
     f08:	08 95       	ret

00000f0a <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     f0a:	cf 93       	push	r28
     f0c:	df 93       	push	r29
     f0e:	9c 01       	movw	r18, r24
     f10:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
     f12:	dc 01       	movw	r26, r24
     f14:	11 96       	adiw	r26, 0x01	; 1
     f16:	cd 91       	ld	r28, X+
     f18:	dc 91       	ld	r29, X
     f1a:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     f1c:	d5 83       	std	Z+5, r29	; 0x05
     f1e:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     f20:	8e 81       	ldd	r24, Y+6	; 0x06
     f22:	9f 81       	ldd	r25, Y+7	; 0x07
     f24:	97 83       	std	Z+7, r25	; 0x07
     f26:	86 83       	std	Z+6, r24	; 0x06

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
     f28:	8e 81       	ldd	r24, Y+6	; 0x06
     f2a:	9f 81       	ldd	r25, Y+7	; 0x07
     f2c:	dc 01       	movw	r26, r24
     f2e:	15 96       	adiw	r26, 0x05	; 5
     f30:	7c 93       	st	X, r23
     f32:	6e 93       	st	-X, r22
     f34:	14 97       	sbiw	r26, 0x04	; 4
	pxIndex->pxPrevious = pxNewListItem;
     f36:	7f 83       	std	Y+7, r23	; 0x07
     f38:	6e 83       	std	Y+6, r22	; 0x06

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     f3a:	33 87       	std	Z+11, r19	; 0x0b
     f3c:	22 87       	std	Z+10, r18	; 0x0a

	( pxList->uxNumberOfItems )++;
     f3e:	f9 01       	movw	r30, r18
     f40:	80 81       	ld	r24, Z
     f42:	8f 5f       	subi	r24, 0xFF	; 255
     f44:	80 83       	st	Z, r24
}
     f46:	df 91       	pop	r29
     f48:	cf 91       	pop	r28
     f4a:	08 95       	ret

00000f4c <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     f4c:	0f 93       	push	r16
     f4e:	1f 93       	push	r17
     f50:	cf 93       	push	r28
     f52:	df 93       	push	r29
     f54:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     f56:	08 81       	ld	r16, Y
     f58:	19 81       	ldd	r17, Y+1	; 0x01
     f5a:	2a 81       	ldd	r18, Y+2	; 0x02
     f5c:	3b 81       	ldd	r19, Y+3	; 0x03
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     f5e:	0f 3f       	cpi	r16, 0xFF	; 255
     f60:	4f ef       	ldi	r20, 0xFF	; 255
     f62:	14 07       	cpc	r17, r20
     f64:	24 07       	cpc	r18, r20
     f66:	34 07       	cpc	r19, r20
     f68:	21 f4       	brne	.+8      	; 0xf72 <vListInsert+0x26>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     f6a:	fc 01       	movw	r30, r24
     f6c:	a1 85       	ldd	r26, Z+9	; 0x09
     f6e:	b2 85       	ldd	r27, Z+10	; 0x0a
     f70:	11 c0       	rjmp	.+34     	; 0xf94 <vListInsert+0x48>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     f72:	dc 01       	movw	r26, r24
     f74:	13 96       	adiw	r26, 0x03	; 3
     f76:	01 c0       	rjmp	.+2      	; 0xf7a <vListInsert+0x2e>
     f78:	df 01       	movw	r26, r30
     f7a:	14 96       	adiw	r26, 0x04	; 4
     f7c:	ed 91       	ld	r30, X+
     f7e:	fc 91       	ld	r31, X
     f80:	15 97       	sbiw	r26, 0x05	; 5
     f82:	40 81       	ld	r20, Z
     f84:	51 81       	ldd	r21, Z+1	; 0x01
     f86:	62 81       	ldd	r22, Z+2	; 0x02
     f88:	73 81       	ldd	r23, Z+3	; 0x03
     f8a:	04 17       	cp	r16, r20
     f8c:	15 07       	cpc	r17, r21
     f8e:	26 07       	cpc	r18, r22
     f90:	37 07       	cpc	r19, r23
     f92:	90 f7       	brcc	.-28     	; 0xf78 <vListInsert+0x2c>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     f94:	14 96       	adiw	r26, 0x04	; 4
     f96:	ed 91       	ld	r30, X+
     f98:	fc 91       	ld	r31, X
     f9a:	15 97       	sbiw	r26, 0x05	; 5
     f9c:	fd 83       	std	Y+5, r31	; 0x05
     f9e:	ec 83       	std	Y+4, r30	; 0x04
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     fa0:	d7 83       	std	Z+7, r29	; 0x07
     fa2:	c6 83       	std	Z+6, r28	; 0x06
	pxNewListItem->pxPrevious = pxIterator;
     fa4:	bf 83       	std	Y+7, r27	; 0x07
     fa6:	ae 83       	std	Y+6, r26	; 0x06
	pxIterator->pxNext = pxNewListItem;
     fa8:	15 96       	adiw	r26, 0x05	; 5
     faa:	dc 93       	st	X, r29
     fac:	ce 93       	st	-X, r28
     fae:	14 97       	sbiw	r26, 0x04	; 4

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     fb0:	9b 87       	std	Y+11, r25	; 0x0b
     fb2:	8a 87       	std	Y+10, r24	; 0x0a

	( pxList->uxNumberOfItems )++;
     fb4:	fc 01       	movw	r30, r24
     fb6:	20 81       	ld	r18, Z
     fb8:	2f 5f       	subi	r18, 0xFF	; 255
     fba:	20 83       	st	Z, r18
}
     fbc:	df 91       	pop	r29
     fbe:	cf 91       	pop	r28
     fc0:	1f 91       	pop	r17
     fc2:	0f 91       	pop	r16
     fc4:	08 95       	ret

00000fc6 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     fc6:	cf 93       	push	r28
     fc8:	df 93       	push	r29
     fca:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     fcc:	a2 85       	ldd	r26, Z+10	; 0x0a
     fce:	b3 85       	ldd	r27, Z+11	; 0x0b

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     fd0:	c4 81       	ldd	r28, Z+4	; 0x04
     fd2:	d5 81       	ldd	r29, Z+5	; 0x05
     fd4:	86 81       	ldd	r24, Z+6	; 0x06
     fd6:	97 81       	ldd	r25, Z+7	; 0x07
     fd8:	9f 83       	std	Y+7, r25	; 0x07
     fda:	8e 83       	std	Y+6, r24	; 0x06
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     fdc:	c6 81       	ldd	r28, Z+6	; 0x06
     fde:	d7 81       	ldd	r29, Z+7	; 0x07
     fe0:	84 81       	ldd	r24, Z+4	; 0x04
     fe2:	95 81       	ldd	r25, Z+5	; 0x05
     fe4:	9d 83       	std	Y+5, r25	; 0x05
     fe6:	8c 83       	std	Y+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     fe8:	11 96       	adiw	r26, 0x01	; 1
     fea:	8d 91       	ld	r24, X+
     fec:	9c 91       	ld	r25, X
     fee:	12 97       	sbiw	r26, 0x02	; 2
     ff0:	e8 17       	cp	r30, r24
     ff2:	f9 07       	cpc	r31, r25
     ff4:	31 f4       	brne	.+12     	; 0x1002 <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     ff6:	86 81       	ldd	r24, Z+6	; 0x06
     ff8:	97 81       	ldd	r25, Z+7	; 0x07
     ffa:	12 96       	adiw	r26, 0x02	; 2
     ffc:	9c 93       	st	X, r25
     ffe:	8e 93       	st	-X, r24
    1000:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
    1002:	13 86       	std	Z+11, r1	; 0x0b
    1004:	12 86       	std	Z+10, r1	; 0x0a
	( pxList->uxNumberOfItems )--;
    1006:	8c 91       	ld	r24, X
    1008:	81 50       	subi	r24, 0x01	; 1
    100a:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
    100c:	df 91       	pop	r29
    100e:	cf 91       	pop	r28
    1010:	08 95       	ret

00001012 <prvInsertBlockIntoFreeList>:
	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
}
/*-----------------------------------------------------------*/

static void prvInsertBlockIntoFreeList( BlockLink_t *pxBlockToInsert )
{
    1012:	cf 93       	push	r28
    1014:	df 93       	push	r29
    1016:	dc 01       	movw	r26, r24
BlockLink_t *pxIterator;
uint8_t *puc;

	/* Iterate through the list until a block is found that has a higher address
	than the block being inserted. */
	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
    1018:	ea ef       	ldi	r30, 0xFA	; 250
    101a:	f3 e0       	ldi	r31, 0x03	; 3
    101c:	01 c0       	rjmp	.+2      	; 0x1020 <prvInsertBlockIntoFreeList+0xe>
    101e:	f9 01       	movw	r30, r18
    1020:	20 81       	ld	r18, Z
    1022:	31 81       	ldd	r19, Z+1	; 0x01
    1024:	2a 17       	cp	r18, r26
    1026:	3b 07       	cpc	r19, r27
    1028:	d0 f3       	brcs	.-12     	; 0x101e <prvInsertBlockIntoFreeList+0xc>
	}

	/* Do the block being inserted, and the block it is being inserted after
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxIterator;
	if( ( puc + pxIterator->xBlockSize ) == ( uint8_t * ) pxBlockToInsert )
    102a:	82 81       	ldd	r24, Z+2	; 0x02
    102c:	93 81       	ldd	r25, Z+3	; 0x03
    102e:	af 01       	movw	r20, r30
    1030:	48 0f       	add	r20, r24
    1032:	59 1f       	adc	r21, r25
    1034:	a4 17       	cp	r26, r20
    1036:	b5 07       	cpc	r27, r21
    1038:	49 f4       	brne	.+18     	; 0x104c <prvInsertBlockIntoFreeList+0x3a>
	{
		pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
    103a:	12 96       	adiw	r26, 0x02	; 2
    103c:	4d 91       	ld	r20, X+
    103e:	5c 91       	ld	r21, X
    1040:	13 97       	sbiw	r26, 0x03	; 3
    1042:	84 0f       	add	r24, r20
    1044:	95 1f       	adc	r25, r21
    1046:	93 83       	std	Z+3, r25	; 0x03
    1048:	82 83       	std	Z+2, r24	; 0x02
    104a:	df 01       	movw	r26, r30
	}

	/* Do the block being inserted, and the block it is being inserted before
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxBlockToInsert;
	if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) pxIterator->pxNextFreeBlock )
    104c:	12 96       	adiw	r26, 0x02	; 2
    104e:	8d 91       	ld	r24, X+
    1050:	9c 91       	ld	r25, X
    1052:	13 97       	sbiw	r26, 0x03	; 3
    1054:	ed 01       	movw	r28, r26
    1056:	c8 0f       	add	r28, r24
    1058:	d9 1f       	adc	r29, r25
    105a:	2c 17       	cp	r18, r28
    105c:	3d 07       	cpc	r19, r29
    105e:	d9 f4       	brne	.+54     	; 0x1096 <prvInsertBlockIntoFreeList+0x84>
	{
		if( pxIterator->pxNextFreeBlock != pxEnd )
    1060:	20 91 f8 03 	lds	r18, 0x03F8	; 0x8003f8 <pxEnd>
    1064:	30 91 f9 03 	lds	r19, 0x03F9	; 0x8003f9 <pxEnd+0x1>
    1068:	c2 17       	cp	r28, r18
    106a:	d3 07       	cpc	r29, r19
    106c:	81 f0       	breq	.+32     	; 0x108e <prvInsertBlockIntoFreeList+0x7c>
		{
			/* Form one big block from the two blocks. */
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
    106e:	2a 81       	ldd	r18, Y+2	; 0x02
    1070:	3b 81       	ldd	r19, Y+3	; 0x03
    1072:	82 0f       	add	r24, r18
    1074:	93 1f       	adc	r25, r19
    1076:	13 96       	adiw	r26, 0x03	; 3
    1078:	9c 93       	st	X, r25
    107a:	8e 93       	st	-X, r24
    107c:	12 97       	sbiw	r26, 0x02	; 2
			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
    107e:	c0 81       	ld	r28, Z
    1080:	d1 81       	ldd	r29, Z+1	; 0x01
    1082:	88 81       	ld	r24, Y
    1084:	99 81       	ldd	r25, Y+1	; 0x01
    1086:	11 96       	adiw	r26, 0x01	; 1
    1088:	9c 93       	st	X, r25
    108a:	8e 93       	st	-X, r24
    108c:	07 c0       	rjmp	.+14     	; 0x109c <prvInsertBlockIntoFreeList+0x8a>
		}
		else
		{
			pxBlockToInsert->pxNextFreeBlock = pxEnd;
    108e:	11 96       	adiw	r26, 0x01	; 1
    1090:	dc 93       	st	X, r29
    1092:	ce 93       	st	-X, r28
    1094:	03 c0       	rjmp	.+6      	; 0x109c <prvInsertBlockIntoFreeList+0x8a>
		}
	}
	else
	{
		pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;
    1096:	11 96       	adiw	r26, 0x01	; 1
    1098:	3c 93       	st	X, r19
    109a:	2e 93       	st	-X, r18

	/* If the block being inserted plugged a gab, so was merged with the block
	before and the block after, then it's pxNextFreeBlock pointer will have
	already been set, and should not be set here as that would make it point
	to itself. */
	if( pxIterator != pxBlockToInsert )
    109c:	ae 17       	cp	r26, r30
    109e:	bf 07       	cpc	r27, r31
    10a0:	11 f0       	breq	.+4      	; 0x10a6 <prvInsertBlockIntoFreeList+0x94>
	{
		pxIterator->pxNextFreeBlock = pxBlockToInsert;
    10a2:	b1 83       	std	Z+1, r27	; 0x01
    10a4:	a0 83       	st	Z, r26
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
    10a6:	df 91       	pop	r29
    10a8:	cf 91       	pop	r28
    10aa:	08 95       	ret

000010ac <pvPortMalloc>:
static size_t xBlockAllocatedBit = 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    10ac:	cf 92       	push	r12
    10ae:	df 92       	push	r13
    10b0:	ef 92       	push	r14
    10b2:	ff 92       	push	r15
    10b4:	0f 93       	push	r16
    10b6:	1f 93       	push	r17
    10b8:	cf 93       	push	r28
    10ba:	df 93       	push	r29
    10bc:	ec 01       	movw	r28, r24
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
void *pvReturn = NULL;

	vTaskSuspendAll();
    10be:	a6 d7       	rcall	.+3916   	; 0x200c <vTaskSuspendAll>
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( pxEnd == NULL )
    10c0:	80 91 f8 03 	lds	r24, 0x03F8	; 0x8003f8 <pxEnd>
    10c4:	90 91 f9 03 	lds	r25, 0x03F9	; 0x8003f9 <pxEnd+0x1>
    10c8:	89 2b       	or	r24, r25
    10ca:	99 f5       	brne	.+102    	; 0x1132 <pvPortMalloc+0x86>

	pucAlignedHeap = ( uint8_t * ) ulAddress;

	/* xStart is used to hold a pointer to the first item in the list of free
	blocks.  The void cast is used to prevent compiler warnings. */
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
    10cc:	aa ef       	ldi	r26, 0xFA	; 250
    10ce:	b3 e0       	ldi	r27, 0x03	; 3
    10d0:	4e ef       	ldi	r20, 0xFE	; 254
    10d2:	53 e0       	ldi	r21, 0x03	; 3
    10d4:	11 96       	adiw	r26, 0x01	; 1
    10d6:	5c 93       	st	X, r21
    10d8:	4e 93       	st	-X, r20
	xStart.xBlockSize = ( size_t ) 0;
    10da:	13 96       	adiw	r26, 0x03	; 3
    10dc:	1c 92       	st	X, r1
    10de:	1e 92       	st	-X, r1
    10e0:	12 97       	sbiw	r26, 0x02	; 2

	/* pxEnd is used to mark the end of the list of free blocks and is inserted
	at the end of the heap space. */
	ulAddress = ( ( uint32_t ) pucAlignedHeap ) + xTotalHeapSize;
	ulAddress -= xHeapStructSize;
    10e2:	ca 01       	movw	r24, r20
    10e4:	05 2e       	mov	r0, r21
    10e6:	00 0c       	add	r0, r0
    10e8:	aa 0b       	sbc	r26, r26
    10ea:	bb 0b       	sbc	r27, r27
    10ec:	80 5a       	subi	r24, 0xA0	; 160
    10ee:	96 4e       	sbci	r25, 0xE6	; 230
    10f0:	af 4f       	sbci	r26, 0xFF	; 255
    10f2:	bf 4f       	sbci	r27, 0xFF	; 255
	ulAddress &= ~portBYTE_ALIGNMENT_MASK;
	pxEnd = ( void * ) ulAddress;
    10f4:	9c 01       	movw	r18, r24
    10f6:	90 93 f9 03 	sts	0x03F9, r25	; 0x8003f9 <pxEnd+0x1>
    10fa:	80 93 f8 03 	sts	0x03F8, r24	; 0x8003f8 <pxEnd>
	pxEnd->xBlockSize = 0;
    10fe:	fc 01       	movw	r30, r24
    1100:	13 82       	std	Z+3, r1	; 0x03
    1102:	12 82       	std	Z+2, r1	; 0x02
	pxEnd->pxNextFreeBlock = NULL;
    1104:	11 82       	std	Z+1, r1	; 0x01
    1106:	10 82       	st	Z, r1

	/* To start with there is a single free block that is sized to take up the
	entire heap space, minus the space taken by pxEnd. */
	pxFirstFreeBlock = ( void * ) pucAlignedHeap;
	pxFirstFreeBlock->xBlockSize = ulAddress - ( uint32_t ) pxFirstFreeBlock;
    1108:	2e 5f       	subi	r18, 0xFE	; 254
    110a:	33 40       	sbci	r19, 0x03	; 3
    110c:	fa 01       	movw	r30, r20
    110e:	33 83       	std	Z+3, r19	; 0x03
    1110:	22 83       	std	Z+2, r18	; 0x02
	pxFirstFreeBlock->pxNextFreeBlock = pxEnd;
    1112:	91 83       	std	Z+1, r25	; 0x01
    1114:	80 83       	st	Z, r24

	/* Only one block exists - and it covers the entire usable heap space. */
	xMinimumEverFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
    1116:	30 93 f5 03 	sts	0x03F5, r19	; 0x8003f5 <xMinimumEverFreeBytesRemaining+0x1>
    111a:	20 93 f4 03 	sts	0x03F4, r18	; 0x8003f4 <xMinimumEverFreeBytesRemaining>
	xFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
    111e:	30 93 f7 03 	sts	0x03F7, r19	; 0x8003f7 <xFreeBytesRemaining+0x1>
    1122:	20 93 f6 03 	sts	0x03F6, r18	; 0x8003f6 <xFreeBytesRemaining>

	/* Work out the position of the top bit in a size_t variable. */
	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
    1126:	80 e0       	ldi	r24, 0x00	; 0
    1128:	90 e8       	ldi	r25, 0x80	; 128
    112a:	90 93 f3 03 	sts	0x03F3, r25	; 0x8003f3 <__data_end+0x1>
    112e:	80 93 f2 03 	sts	0x03F2, r24	; 0x8003f2 <__data_end>

		/* Check the requested block size is not so large that the top bit is
		set.  The top bit of the block size member of the BlockLink_t structure
		is used to determine who owns the block - the application or the
		kernel, so it must be free. */
		if( ( xWantedSize & xBlockAllocatedBit ) == 0 )
    1132:	e0 90 f2 03 	lds	r14, 0x03F2	; 0x8003f2 <__data_end>
    1136:	f0 90 f3 03 	lds	r15, 0x03F3	; 0x8003f3 <__data_end+0x1>
    113a:	c7 01       	movw	r24, r14
    113c:	8c 23       	and	r24, r28
    113e:	9d 23       	and	r25, r29
    1140:	89 2b       	or	r24, r25
    1142:	09 f0       	breq	.+2      	; 0x1146 <pvPortMalloc+0x9a>
    1144:	5e c0       	rjmp	.+188    	; 0x1202 <pvPortMalloc+0x156>
		{
			/* The wanted size is increased so it can contain a BlockLink_t
			structure in addition to the requested amount of bytes. */
			if( xWantedSize > 0 )
    1146:	20 97       	sbiw	r28, 0x00	; 0
    1148:	09 f4       	brne	.+2      	; 0x114c <pvPortMalloc+0xa0>
    114a:	5e c0       	rjmp	.+188    	; 0x1208 <pvPortMalloc+0x15c>
			{
				xWantedSize += xHeapStructSize;
    114c:	ae 01       	movw	r20, r28
    114e:	4c 5f       	subi	r20, 0xFC	; 252
    1150:	5f 4f       	sbci	r21, 0xFF	; 255
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
    1152:	09 f4       	brne	.+2      	; 0x1156 <pvPortMalloc+0xaa>
    1154:	5c c0       	rjmp	.+184    	; 0x120e <pvPortMalloc+0x162>
    1156:	00 91 f6 03 	lds	r16, 0x03F6	; 0x8003f6 <xFreeBytesRemaining>
    115a:	10 91 f7 03 	lds	r17, 0x03F7	; 0x8003f7 <xFreeBytesRemaining+0x1>
    115e:	04 17       	cp	r16, r20
    1160:	15 07       	cpc	r17, r21
    1162:	08 f4       	brcc	.+2      	; 0x1166 <pvPortMalloc+0xba>
    1164:	57 c0       	rjmp	.+174    	; 0x1214 <pvPortMalloc+0x168>
			{
				/* Traverse the list from the start	(lowest address) block until
				one	of adequate size is found. */
				pxPreviousBlock = &xStart;
				pxBlock = xStart.pxNextFreeBlock;
    1166:	c0 91 fa 03 	lds	r28, 0x03FA	; 0x8003fa <xStart>
    116a:	d0 91 fb 03 	lds	r29, 0x03FB	; 0x8003fb <xStart+0x1>

			if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
			{
				/* Traverse the list from the start	(lowest address) block until
				one	of adequate size is found. */
				pxPreviousBlock = &xStart;
    116e:	ea ef       	ldi	r30, 0xFA	; 250
    1170:	f3 e0       	ldi	r31, 0x03	; 3
				pxBlock = xStart.pxNextFreeBlock;
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
    1172:	02 c0       	rjmp	.+4      	; 0x1178 <pvPortMalloc+0xcc>
    1174:	fe 01       	movw	r30, r28
				{
					pxPreviousBlock = pxBlock;
					pxBlock = pxBlock->pxNextFreeBlock;
    1176:	e9 01       	movw	r28, r18
			{
				/* Traverse the list from the start	(lowest address) block until
				one	of adequate size is found. */
				pxPreviousBlock = &xStart;
				pxBlock = xStart.pxNextFreeBlock;
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
    1178:	2a 81       	ldd	r18, Y+2	; 0x02
    117a:	3b 81       	ldd	r19, Y+3	; 0x03
    117c:	24 17       	cp	r18, r20
    117e:	35 07       	cpc	r19, r21
    1180:	28 f4       	brcc	.+10     	; 0x118c <pvPortMalloc+0xe0>
    1182:	28 81       	ld	r18, Y
    1184:	39 81       	ldd	r19, Y+1	; 0x01
    1186:	21 15       	cp	r18, r1
    1188:	31 05       	cpc	r19, r1
    118a:	a1 f7       	brne	.-24     	; 0x1174 <pvPortMalloc+0xc8>
					pxBlock = pxBlock->pxNextFreeBlock;
				}

				/* If the end marker was reached then a block of adequate size
				was	not found. */
				if( pxBlock != pxEnd )
    118c:	80 91 f8 03 	lds	r24, 0x03F8	; 0x8003f8 <pxEnd>
    1190:	90 91 f9 03 	lds	r25, 0x03F9	; 0x8003f9 <pxEnd+0x1>
    1194:	c8 17       	cp	r28, r24
    1196:	d9 07       	cpc	r29, r25
    1198:	09 f4       	brne	.+2      	; 0x119c <pvPortMalloc+0xf0>
    119a:	3f c0       	rjmp	.+126    	; 0x121a <pvPortMalloc+0x16e>
				{
					/* Return the memory space pointed to - jumping over the
					BlockLink_t structure at its start. */
					pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );
    119c:	c0 80       	ld	r12, Z
    119e:	d1 80       	ldd	r13, Z+1	; 0x01
    11a0:	84 e0       	ldi	r24, 0x04	; 4
    11a2:	c8 0e       	add	r12, r24
    11a4:	d1 1c       	adc	r13, r1

					/* This block is being returned for use so must be taken out
					of the list of free blocks. */
					pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
    11a6:	88 81       	ld	r24, Y
    11a8:	99 81       	ldd	r25, Y+1	; 0x01
    11aa:	91 83       	std	Z+1, r25	; 0x01
    11ac:	80 83       	st	Z, r24

					/* If the block is larger than required it can be split into
					two. */
					if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
    11ae:	2a 81       	ldd	r18, Y+2	; 0x02
    11b0:	3b 81       	ldd	r19, Y+3	; 0x03
    11b2:	24 1b       	sub	r18, r20
    11b4:	35 0b       	sbc	r19, r21
    11b6:	29 30       	cpi	r18, 0x09	; 9
    11b8:	31 05       	cpc	r19, r1
    11ba:	48 f0       	brcs	.+18     	; 0x11ce <pvPortMalloc+0x122>
					{
						/* This block is to be split into two.  Create a new
						block following the number of bytes requested. The void
						cast is used to prevent byte alignment warnings from the
						compiler. */
						pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
    11bc:	ce 01       	movw	r24, r28
    11be:	84 0f       	add	r24, r20
    11c0:	95 1f       	adc	r25, r21
						configASSERT( ( ( ( uint32_t ) pxNewBlockLink ) & portBYTE_ALIGNMENT_MASK ) == 0 );

						/* Calculate the sizes of two blocks split from the
						single block. */
						pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
    11c2:	fc 01       	movw	r30, r24
    11c4:	33 83       	std	Z+3, r19	; 0x03
    11c6:	22 83       	std	Z+2, r18	; 0x02
						pxBlock->xBlockSize = xWantedSize;
    11c8:	5b 83       	std	Y+3, r21	; 0x03

						/* Insert the new block into the list of free blocks. */
						prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
    11ca:	4a 83       	std	Y+2, r20	; 0x02
    11cc:	22 df       	rcall	.-444    	; 0x1012 <prvInsertBlockIntoFreeList>
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}

					xFreeBytesRemaining -= pxBlock->xBlockSize;
    11ce:	8a 81       	ldd	r24, Y+2	; 0x02
    11d0:	9b 81       	ldd	r25, Y+3	; 0x03
    11d2:	08 1b       	sub	r16, r24
    11d4:	19 0b       	sbc	r17, r25
    11d6:	10 93 f7 03 	sts	0x03F7, r17	; 0x8003f7 <xFreeBytesRemaining+0x1>
    11da:	00 93 f6 03 	sts	0x03F6, r16	; 0x8003f6 <xFreeBytesRemaining>

					if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
    11de:	20 91 f4 03 	lds	r18, 0x03F4	; 0x8003f4 <xMinimumEverFreeBytesRemaining>
    11e2:	30 91 f5 03 	lds	r19, 0x03F5	; 0x8003f5 <xMinimumEverFreeBytesRemaining+0x1>
    11e6:	02 17       	cp	r16, r18
    11e8:	13 07       	cpc	r17, r19
    11ea:	20 f4       	brcc	.+8      	; 0x11f4 <pvPortMalloc+0x148>
					{
						xMinimumEverFreeBytesRemaining = xFreeBytesRemaining;
    11ec:	10 93 f5 03 	sts	0x03F5, r17	; 0x8003f5 <xMinimumEverFreeBytesRemaining+0x1>
    11f0:	00 93 f4 03 	sts	0x03F4, r16	; 0x8003f4 <xMinimumEverFreeBytesRemaining>
						mtCOVERAGE_TEST_MARKER();
					}

					/* The block is being returned - it is allocated and owned
					by the application and has no "next" block. */
					pxBlock->xBlockSize |= xBlockAllocatedBit;
    11f4:	e8 2a       	or	r14, r24
    11f6:	f9 2a       	or	r15, r25
    11f8:	fb 82       	std	Y+3, r15	; 0x03
    11fa:	ea 82       	std	Y+2, r14	; 0x02
					pxBlock->pxNextFreeBlock = NULL;
    11fc:	19 82       	std	Y+1, r1	; 0x01
    11fe:	18 82       	st	Y, r1
    1200:	0e c0       	rjmp	.+28     	; 0x121e <pvPortMalloc+0x172>
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
void *pvReturn = NULL;
    1202:	c1 2c       	mov	r12, r1
    1204:	d1 2c       	mov	r13, r1
    1206:	0b c0       	rjmp	.+22     	; 0x121e <pvPortMalloc+0x172>
    1208:	c1 2c       	mov	r12, r1
    120a:	d1 2c       	mov	r13, r1
    120c:	08 c0       	rjmp	.+16     	; 0x121e <pvPortMalloc+0x172>
    120e:	c1 2c       	mov	r12, r1
    1210:	d1 2c       	mov	r13, r1
    1212:	05 c0       	rjmp	.+10     	; 0x121e <pvPortMalloc+0x172>
    1214:	c1 2c       	mov	r12, r1
    1216:	d1 2c       	mov	r13, r1
    1218:	02 c0       	rjmp	.+4      	; 0x121e <pvPortMalloc+0x172>
    121a:	c1 2c       	mov	r12, r1
			mtCOVERAGE_TEST_MARKER();
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
    121c:	d1 2c       	mov	r13, r1
    121e:	df d7       	rcall	.+4030   	; 0x21de <xTaskResumeAll>
	}
	#endif

	configASSERT( ( ( ( uint32_t ) pvReturn ) & portBYTE_ALIGNMENT_MASK ) == 0 );
	return pvReturn;
}
    1220:	c6 01       	movw	r24, r12
    1222:	df 91       	pop	r29
    1224:	cf 91       	pop	r28
    1226:	1f 91       	pop	r17
    1228:	0f 91       	pop	r16
    122a:	ff 90       	pop	r15
    122c:	ef 90       	pop	r14
    122e:	df 90       	pop	r13
    1230:	cf 90       	pop	r12
    1232:	08 95       	ret

00001234 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    1234:	cf 93       	push	r28
    1236:	df 93       	push	r29
uint8_t *puc = ( uint8_t * ) pv;
BlockLink_t *pxLink;

	if( pv != NULL )
    1238:	00 97       	sbiw	r24, 0x00	; 0
    123a:	41 f1       	breq	.+80     	; 0x128c <vPortFree+0x58>

		/* Check the block is actually allocated. */
		configASSERT( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 );
		configASSERT( pxLink->pxNextFreeBlock == NULL );

		if( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 )
    123c:	fc 01       	movw	r30, r24
    123e:	34 97       	sbiw	r30, 0x04	; 4
    1240:	22 81       	ldd	r18, Z+2	; 0x02
    1242:	33 81       	ldd	r19, Z+3	; 0x03
    1244:	40 91 f2 03 	lds	r20, 0x03F2	; 0x8003f2 <__data_end>
    1248:	50 91 f3 03 	lds	r21, 0x03F3	; 0x8003f3 <__data_end+0x1>
    124c:	b9 01       	movw	r22, r18
    124e:	64 23       	and	r22, r20
    1250:	75 23       	and	r23, r21
    1252:	67 2b       	or	r22, r23
    1254:	d9 f0       	breq	.+54     	; 0x128c <vPortFree+0x58>
		{
			if( pxLink->pxNextFreeBlock == NULL )
    1256:	60 81       	ld	r22, Z
    1258:	71 81       	ldd	r23, Z+1	; 0x01
    125a:	67 2b       	or	r22, r23
    125c:	b9 f4       	brne	.+46     	; 0x128c <vPortFree+0x58>
			{
				/* The block is being returned to the heap - it is no longer
				allocated. */
				pxLink->xBlockSize &= ~xBlockAllocatedBit;
    125e:	ef 01       	movw	r28, r30
    1260:	40 95       	com	r20
    1262:	50 95       	com	r21
    1264:	24 23       	and	r18, r20
    1266:	35 23       	and	r19, r21
    1268:	33 83       	std	Z+3, r19	; 0x03
    126a:	22 83       	std	Z+2, r18	; 0x02

				vTaskSuspendAll();
    126c:	cf d6       	rcall	.+3486   	; 0x200c <vTaskSuspendAll>
				{
					/* Add this block to the list of free blocks. */
					xFreeBytesRemaining += pxLink->xBlockSize;
    126e:	20 91 f6 03 	lds	r18, 0x03F6	; 0x8003f6 <xFreeBytesRemaining>
    1272:	30 91 f7 03 	lds	r19, 0x03F7	; 0x8003f7 <xFreeBytesRemaining+0x1>
    1276:	8a 81       	ldd	r24, Y+2	; 0x02
    1278:	9b 81       	ldd	r25, Y+3	; 0x03
    127a:	82 0f       	add	r24, r18
    127c:	93 1f       	adc	r25, r19
    127e:	90 93 f7 03 	sts	0x03F7, r25	; 0x8003f7 <xFreeBytesRemaining+0x1>
    1282:	80 93 f6 03 	sts	0x03F6, r24	; 0x8003f6 <xFreeBytesRemaining>
					traceFREE( pv, pxLink->xBlockSize );
					prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
    1286:	ce 01       	movw	r24, r28
				}
				( void ) xTaskResumeAll();
    1288:	c4 de       	rcall	.-632    	; 0x1012 <prvInsertBlockIntoFreeList>
    128a:	a9 d7       	rcall	.+3922   	; 0x21de <xTaskResumeAll>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
}
    128c:	df 91       	pop	r29
    128e:	cf 91       	pop	r28
    1290:	08 95       	ret

00001292 <pxPortInitialiseStack>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    1292:	31 e1       	ldi	r19, 0x11	; 17
    1294:	fc 01       	movw	r30, r24
    1296:	30 83       	st	Z, r19
    1298:	31 97       	sbiw	r30, 0x01	; 1
    129a:	22 e2       	ldi	r18, 0x22	; 34
    129c:	20 83       	st	Z, r18
    129e:	31 97       	sbiw	r30, 0x01	; 1
    12a0:	a3 e3       	ldi	r26, 0x33	; 51
    12a2:	a0 83       	st	Z, r26
    12a4:	31 97       	sbiw	r30, 0x01	; 1
    12a6:	60 83       	st	Z, r22
    12a8:	31 97       	sbiw	r30, 0x01	; 1
    12aa:	70 83       	st	Z, r23
    12ac:	31 97       	sbiw	r30, 0x01	; 1
    12ae:	10 82       	st	Z, r1
    12b0:	31 97       	sbiw	r30, 0x01	; 1
    12b2:	10 82       	st	Z, r1
    12b4:	31 97       	sbiw	r30, 0x01	; 1
    12b6:	60 e8       	ldi	r22, 0x80	; 128
    12b8:	60 83       	st	Z, r22
    12ba:	31 97       	sbiw	r30, 0x01	; 1
    12bc:	10 82       	st	Z, r1
    12be:	31 97       	sbiw	r30, 0x01	; 1
    12c0:	10 82       	st	Z, r1
    12c2:	31 97       	sbiw	r30, 0x01	; 1
    12c4:	10 82       	st	Z, r1
    12c6:	31 97       	sbiw	r30, 0x01	; 1
    12c8:	62 e0       	ldi	r22, 0x02	; 2
    12ca:	60 83       	st	Z, r22
    12cc:	31 97       	sbiw	r30, 0x01	; 1
    12ce:	63 e0       	ldi	r22, 0x03	; 3
    12d0:	60 83       	st	Z, r22
    12d2:	31 97       	sbiw	r30, 0x01	; 1
    12d4:	64 e0       	ldi	r22, 0x04	; 4
    12d6:	60 83       	st	Z, r22
    12d8:	31 97       	sbiw	r30, 0x01	; 1
    12da:	65 e0       	ldi	r22, 0x05	; 5
    12dc:	60 83       	st	Z, r22
    12de:	31 97       	sbiw	r30, 0x01	; 1
    12e0:	66 e0       	ldi	r22, 0x06	; 6
    12e2:	60 83       	st	Z, r22
    12e4:	31 97       	sbiw	r30, 0x01	; 1
    12e6:	67 e0       	ldi	r22, 0x07	; 7
    12e8:	60 83       	st	Z, r22
    12ea:	31 97       	sbiw	r30, 0x01	; 1
    12ec:	68 e0       	ldi	r22, 0x08	; 8
    12ee:	60 83       	st	Z, r22
    12f0:	31 97       	sbiw	r30, 0x01	; 1
    12f2:	69 e0       	ldi	r22, 0x09	; 9
    12f4:	60 83       	st	Z, r22
    12f6:	31 97       	sbiw	r30, 0x01	; 1
    12f8:	60 e1       	ldi	r22, 0x10	; 16
    12fa:	60 83       	st	Z, r22
    12fc:	31 97       	sbiw	r30, 0x01	; 1
    12fe:	30 83       	st	Z, r19
    1300:	31 97       	sbiw	r30, 0x01	; 1
    1302:	32 e1       	ldi	r19, 0x12	; 18
    1304:	30 83       	st	Z, r19
    1306:	31 97       	sbiw	r30, 0x01	; 1
    1308:	33 e1       	ldi	r19, 0x13	; 19
    130a:	30 83       	st	Z, r19
    130c:	31 97       	sbiw	r30, 0x01	; 1
    130e:	34 e1       	ldi	r19, 0x14	; 20
    1310:	30 83       	st	Z, r19
    1312:	31 97       	sbiw	r30, 0x01	; 1
    1314:	35 e1       	ldi	r19, 0x15	; 21
    1316:	30 83       	st	Z, r19
    1318:	31 97       	sbiw	r30, 0x01	; 1
    131a:	36 e1       	ldi	r19, 0x16	; 22
    131c:	30 83       	st	Z, r19
    131e:	31 97       	sbiw	r30, 0x01	; 1
    1320:	37 e1       	ldi	r19, 0x17	; 23
    1322:	30 83       	st	Z, r19
    1324:	31 97       	sbiw	r30, 0x01	; 1
    1326:	38 e1       	ldi	r19, 0x18	; 24
    1328:	30 83       	st	Z, r19
    132a:	31 97       	sbiw	r30, 0x01	; 1
    132c:	39 e1       	ldi	r19, 0x19	; 25
    132e:	30 83       	st	Z, r19
    1330:	31 97       	sbiw	r30, 0x01	; 1
    1332:	30 e2       	ldi	r19, 0x20	; 32
    1334:	30 83       	st	Z, r19
    1336:	31 97       	sbiw	r30, 0x01	; 1
    1338:	31 e2       	ldi	r19, 0x21	; 33
    133a:	30 83       	st	Z, r19
    133c:	31 97       	sbiw	r30, 0x01	; 1
    133e:	20 83       	st	Z, r18
    1340:	31 97       	sbiw	r30, 0x01	; 1
    1342:	23 e2       	ldi	r18, 0x23	; 35
    1344:	20 83       	st	Z, r18
    1346:	31 97       	sbiw	r30, 0x01	; 1
    1348:	40 83       	st	Z, r20
    134a:	31 97       	sbiw	r30, 0x01	; 1
    134c:	50 83       	st	Z, r21
    134e:	31 97       	sbiw	r30, 0x01	; 1
    1350:	26 e2       	ldi	r18, 0x26	; 38
    1352:	20 83       	st	Z, r18
    1354:	31 97       	sbiw	r30, 0x01	; 1
    1356:	27 e2       	ldi	r18, 0x27	; 39
    1358:	20 83       	st	Z, r18
    135a:	31 97       	sbiw	r30, 0x01	; 1
    135c:	28 e2       	ldi	r18, 0x28	; 40
    135e:	20 83       	st	Z, r18
    1360:	31 97       	sbiw	r30, 0x01	; 1
    1362:	29 e2       	ldi	r18, 0x29	; 41
    1364:	20 83       	st	Z, r18
    1366:	31 97       	sbiw	r30, 0x01	; 1
    1368:	20 e3       	ldi	r18, 0x30	; 48
    136a:	20 83       	st	Z, r18
    136c:	31 97       	sbiw	r30, 0x01	; 1
    136e:	21 e3       	ldi	r18, 0x31	; 49
    1370:	20 83       	st	Z, r18
    1372:	89 97       	sbiw	r24, 0x29	; 41
    1374:	08 95       	ret

00001376 <xPortStartScheduler>:
    1376:	10 92 89 00 	sts	0x0089, r1	; 0x800089 <__TEXT_REGION_LENGTH__+0x700089>
    137a:	89 ef       	ldi	r24, 0xF9	; 249
    137c:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__TEXT_REGION_LENGTH__+0x700088>
    1380:	10 92 80 00 	sts	0x0080, r1	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
    1384:	8b e0       	ldi	r24, 0x0B	; 11
    1386:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__TEXT_REGION_LENGTH__+0x700081>
    138a:	ef e6       	ldi	r30, 0x6F	; 111
    138c:	f0 e0       	ldi	r31, 0x00	; 0
    138e:	80 81       	ld	r24, Z
    1390:	82 60       	ori	r24, 0x02	; 2
    1392:	80 83       	st	Z, r24
    1394:	a0 91 e7 1d 	lds	r26, 0x1DE7	; 0x801de7 <pxCurrentTCB>
    1398:	b0 91 e8 1d 	lds	r27, 0x1DE8	; 0x801de8 <pxCurrentTCB+0x1>
    139c:	cd 91       	ld	r28, X+
    139e:	cd bf       	out	0x3d, r28	; 61
    13a0:	dd 91       	ld	r29, X+
    13a2:	de bf       	out	0x3e, r29	; 62
    13a4:	ff 91       	pop	r31
    13a6:	ef 91       	pop	r30
    13a8:	df 91       	pop	r29
    13aa:	cf 91       	pop	r28
    13ac:	bf 91       	pop	r27
    13ae:	af 91       	pop	r26
    13b0:	9f 91       	pop	r25
    13b2:	8f 91       	pop	r24
    13b4:	7f 91       	pop	r23
    13b6:	6f 91       	pop	r22
    13b8:	5f 91       	pop	r21
    13ba:	4f 91       	pop	r20
    13bc:	3f 91       	pop	r19
    13be:	2f 91       	pop	r18
    13c0:	1f 91       	pop	r17
    13c2:	0f 91       	pop	r16
    13c4:	ff 90       	pop	r15
    13c6:	ef 90       	pop	r14
    13c8:	df 90       	pop	r13
    13ca:	cf 90       	pop	r12
    13cc:	bf 90       	pop	r11
    13ce:	af 90       	pop	r10
    13d0:	9f 90       	pop	r9
    13d2:	8f 90       	pop	r8
    13d4:	7f 90       	pop	r7
    13d6:	6f 90       	pop	r6
    13d8:	5f 90       	pop	r5
    13da:	4f 90       	pop	r4
    13dc:	3f 90       	pop	r3
    13de:	2f 90       	pop	r2
    13e0:	1f 90       	pop	r1
    13e2:	0f 90       	pop	r0
    13e4:	0c be       	out	0x3c, r0	; 60
    13e6:	0f 90       	pop	r0
    13e8:	0b be       	out	0x3b, r0	; 59
    13ea:	0f 90       	pop	r0
    13ec:	0f be       	out	0x3f, r0	; 63
    13ee:	0f 90       	pop	r0
    13f0:	08 95       	ret
    13f2:	81 e0       	ldi	r24, 0x01	; 1
    13f4:	08 95       	ret

000013f6 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    13f6:	0f 92       	push	r0
    13f8:	0f b6       	in	r0, 0x3f	; 63
    13fa:	f8 94       	cli
    13fc:	0f 92       	push	r0
    13fe:	0b b6       	in	r0, 0x3b	; 59
    1400:	0f 92       	push	r0
    1402:	0c b6       	in	r0, 0x3c	; 60
    1404:	0f 92       	push	r0
    1406:	1f 92       	push	r1
    1408:	11 24       	eor	r1, r1
    140a:	2f 92       	push	r2
    140c:	3f 92       	push	r3
    140e:	4f 92       	push	r4
    1410:	5f 92       	push	r5
    1412:	6f 92       	push	r6
    1414:	7f 92       	push	r7
    1416:	8f 92       	push	r8
    1418:	9f 92       	push	r9
    141a:	af 92       	push	r10
    141c:	bf 92       	push	r11
    141e:	cf 92       	push	r12
    1420:	df 92       	push	r13
    1422:	ef 92       	push	r14
    1424:	ff 92       	push	r15
    1426:	0f 93       	push	r16
    1428:	1f 93       	push	r17
    142a:	2f 93       	push	r18
    142c:	3f 93       	push	r19
    142e:	4f 93       	push	r20
    1430:	5f 93       	push	r21
    1432:	6f 93       	push	r22
    1434:	7f 93       	push	r23
    1436:	8f 93       	push	r24
    1438:	9f 93       	push	r25
    143a:	af 93       	push	r26
    143c:	bf 93       	push	r27
    143e:	cf 93       	push	r28
    1440:	df 93       	push	r29
    1442:	ef 93       	push	r30
    1444:	ff 93       	push	r31
    1446:	a0 91 e7 1d 	lds	r26, 0x1DE7	; 0x801de7 <pxCurrentTCB>
    144a:	b0 91 e8 1d 	lds	r27, 0x1DE8	; 0x801de8 <pxCurrentTCB+0x1>
    144e:	0d b6       	in	r0, 0x3d	; 61
    1450:	0d 92       	st	X+, r0
    1452:	0e b6       	in	r0, 0x3e	; 62
    1454:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    1456:	90 d7       	rcall	.+3872   	; 0x2378 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    1458:	a0 91 e7 1d 	lds	r26, 0x1DE7	; 0x801de7 <pxCurrentTCB>
    145c:	b0 91 e8 1d 	lds	r27, 0x1DE8	; 0x801de8 <pxCurrentTCB+0x1>
    1460:	cd 91       	ld	r28, X+
    1462:	cd bf       	out	0x3d, r28	; 61
    1464:	dd 91       	ld	r29, X+
    1466:	de bf       	out	0x3e, r29	; 62
    1468:	ff 91       	pop	r31
    146a:	ef 91       	pop	r30
    146c:	df 91       	pop	r29
    146e:	cf 91       	pop	r28
    1470:	bf 91       	pop	r27
    1472:	af 91       	pop	r26
    1474:	9f 91       	pop	r25
    1476:	8f 91       	pop	r24
    1478:	7f 91       	pop	r23
    147a:	6f 91       	pop	r22
    147c:	5f 91       	pop	r21
    147e:	4f 91       	pop	r20
    1480:	3f 91       	pop	r19
    1482:	2f 91       	pop	r18
    1484:	1f 91       	pop	r17
    1486:	0f 91       	pop	r16
    1488:	ff 90       	pop	r15
    148a:	ef 90       	pop	r14
    148c:	df 90       	pop	r13
    148e:	cf 90       	pop	r12
    1490:	bf 90       	pop	r11
    1492:	af 90       	pop	r10
    1494:	9f 90       	pop	r9
    1496:	8f 90       	pop	r8
    1498:	7f 90       	pop	r7
    149a:	6f 90       	pop	r6
    149c:	5f 90       	pop	r5
    149e:	4f 90       	pop	r4
    14a0:	3f 90       	pop	r3
    14a2:	2f 90       	pop	r2
    14a4:	1f 90       	pop	r1
    14a6:	0f 90       	pop	r0
    14a8:	0c be       	out	0x3c, r0	; 60
    14aa:	0f 90       	pop	r0
    14ac:	0b be       	out	0x3b, r0	; 59
    14ae:	0f 90       	pop	r0
    14b0:	0f be       	out	0x3f, r0	; 63
    14b2:	0f 90       	pop	r0

	asm volatile ( "ret" );
    14b4:	08 95       	ret

000014b6 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    14b6:	0f 92       	push	r0
    14b8:	0f b6       	in	r0, 0x3f	; 63
    14ba:	f8 94       	cli
    14bc:	0f 92       	push	r0
    14be:	0b b6       	in	r0, 0x3b	; 59
    14c0:	0f 92       	push	r0
    14c2:	0c b6       	in	r0, 0x3c	; 60
    14c4:	0f 92       	push	r0
    14c6:	1f 92       	push	r1
    14c8:	11 24       	eor	r1, r1
    14ca:	2f 92       	push	r2
    14cc:	3f 92       	push	r3
    14ce:	4f 92       	push	r4
    14d0:	5f 92       	push	r5
    14d2:	6f 92       	push	r6
    14d4:	7f 92       	push	r7
    14d6:	8f 92       	push	r8
    14d8:	9f 92       	push	r9
    14da:	af 92       	push	r10
    14dc:	bf 92       	push	r11
    14de:	cf 92       	push	r12
    14e0:	df 92       	push	r13
    14e2:	ef 92       	push	r14
    14e4:	ff 92       	push	r15
    14e6:	0f 93       	push	r16
    14e8:	1f 93       	push	r17
    14ea:	2f 93       	push	r18
    14ec:	3f 93       	push	r19
    14ee:	4f 93       	push	r20
    14f0:	5f 93       	push	r21
    14f2:	6f 93       	push	r22
    14f4:	7f 93       	push	r23
    14f6:	8f 93       	push	r24
    14f8:	9f 93       	push	r25
    14fa:	af 93       	push	r26
    14fc:	bf 93       	push	r27
    14fe:	cf 93       	push	r28
    1500:	df 93       	push	r29
    1502:	ef 93       	push	r30
    1504:	ff 93       	push	r31
    1506:	a0 91 e7 1d 	lds	r26, 0x1DE7	; 0x801de7 <pxCurrentTCB>
    150a:	b0 91 e8 1d 	lds	r27, 0x1DE8	; 0x801de8 <pxCurrentTCB+0x1>
    150e:	0d b6       	in	r0, 0x3d	; 61
    1510:	0d 92       	st	X+, r0
    1512:	0e b6       	in	r0, 0x3e	; 62
    1514:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
    1516:	8e d5       	rcall	.+2844   	; 0x2034 <xTaskIncrementTick>
    1518:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
    151a:	2e d7       	rcall	.+3676   	; 0x2378 <vTaskSwitchContext>
    151c:	a0 91 e7 1d 	lds	r26, 0x1DE7	; 0x801de7 <pxCurrentTCB>
	}
	portRESTORE_CONTEXT();
    1520:	b0 91 e8 1d 	lds	r27, 0x1DE8	; 0x801de8 <pxCurrentTCB+0x1>
    1524:	cd 91       	ld	r28, X+
    1526:	cd bf       	out	0x3d, r28	; 61
    1528:	dd 91       	ld	r29, X+
    152a:	de bf       	out	0x3e, r29	; 62
    152c:	ff 91       	pop	r31
    152e:	ef 91       	pop	r30
    1530:	df 91       	pop	r29
    1532:	cf 91       	pop	r28
    1534:	bf 91       	pop	r27
    1536:	af 91       	pop	r26
    1538:	9f 91       	pop	r25
    153a:	8f 91       	pop	r24
    153c:	7f 91       	pop	r23
    153e:	6f 91       	pop	r22
    1540:	5f 91       	pop	r21
    1542:	4f 91       	pop	r20
    1544:	3f 91       	pop	r19
    1546:	2f 91       	pop	r18
    1548:	1f 91       	pop	r17
    154a:	0f 91       	pop	r16
    154c:	ff 90       	pop	r15
    154e:	ef 90       	pop	r14
    1550:	df 90       	pop	r13
    1552:	cf 90       	pop	r12
    1554:	bf 90       	pop	r11
    1556:	af 90       	pop	r10
    1558:	9f 90       	pop	r9
    155a:	8f 90       	pop	r8
    155c:	7f 90       	pop	r7
    155e:	6f 90       	pop	r6
    1560:	5f 90       	pop	r5
    1562:	4f 90       	pop	r4
    1564:	3f 90       	pop	r3
    1566:	2f 90       	pop	r2
    1568:	1f 90       	pop	r1
    156a:	0f 90       	pop	r0
    156c:	0c be       	out	0x3c, r0	; 60
    156e:	0f 90       	pop	r0
    1570:	0b be       	out	0x3b, r0	; 59
    1572:	0f 90       	pop	r0
    1574:	0f be       	out	0x3f, r0	; 63
    1576:	0f 90       	pop	r0
    1578:	08 95       	ret

0000157a <__vector_17>:

	asm volatile ( "ret" );
    157a:	9d df       	rcall	.-198    	; 0x14b6 <vPortYieldFromTick>
	 */
	ISR(TIMER1_COMPA_vect) __attribute__ ( ( signal, naked ) );
	ISR(TIMER1_COMPA_vect)
	{
		vPortYieldFromTick();
		asm volatile ( "reti" );
    157c:	18 95       	reti

0000157e <prvCopyDataToQueue>:
		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
	}
	taskEXIT_CRITICAL();

	return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    157e:	0f 93       	push	r16
    1580:	1f 93       	push	r17
    1582:	cf 93       	push	r28
    1584:	df 93       	push	r29
    1586:	ec 01       	movw	r28, r24
    1588:	04 2f       	mov	r16, r20
    158a:	1e 8d       	ldd	r17, Y+30	; 0x1e
    158c:	48 a1       	ldd	r20, Y+32	; 0x20
    158e:	41 11       	cpse	r20, r1
    1590:	0c c0       	rjmp	.+24     	; 0x15aa <prvCopyDataToQueue+0x2c>
    1592:	88 81       	ld	r24, Y
    1594:	99 81       	ldd	r25, Y+1	; 0x01
    1596:	89 2b       	or	r24, r25
    1598:	09 f0       	breq	.+2      	; 0x159c <prvCopyDataToQueue+0x1e>
    159a:	42 c0       	rjmp	.+132    	; 0x1620 <prvCopyDataToQueue+0xa2>
    159c:	8a 81       	ldd	r24, Y+2	; 0x02
    159e:	9b 81       	ldd	r25, Y+3	; 0x03
    15a0:	0e 94 45 13 	call	0x268a	; 0x268a <xTaskPriorityDisinherit>
    15a4:	1b 82       	std	Y+3, r1	; 0x03
    15a6:	1a 82       	std	Y+2, r1	; 0x02
    15a8:	42 c0       	rjmp	.+132    	; 0x162e <prvCopyDataToQueue+0xb0>
    15aa:	01 11       	cpse	r16, r1
    15ac:	17 c0       	rjmp	.+46     	; 0x15dc <prvCopyDataToQueue+0x5e>
    15ae:	50 e0       	ldi	r21, 0x00	; 0
    15b0:	8c 81       	ldd	r24, Y+4	; 0x04
    15b2:	9d 81       	ldd	r25, Y+5	; 0x05
    15b4:	0e 94 30 2c 	call	0x5860	; 0x5860 <memcpy>
    15b8:	28 a1       	ldd	r18, Y+32	; 0x20
    15ba:	8c 81       	ldd	r24, Y+4	; 0x04
    15bc:	9d 81       	ldd	r25, Y+5	; 0x05
    15be:	82 0f       	add	r24, r18
    15c0:	91 1d       	adc	r25, r1
    15c2:	9d 83       	std	Y+5, r25	; 0x05
    15c4:	8c 83       	std	Y+4, r24	; 0x04
    15c6:	2a 81       	ldd	r18, Y+2	; 0x02
    15c8:	3b 81       	ldd	r19, Y+3	; 0x03
    15ca:	82 17       	cp	r24, r18
    15cc:	93 07       	cpc	r25, r19
    15ce:	50 f1       	brcs	.+84     	; 0x1624 <prvCopyDataToQueue+0xa6>
    15d0:	88 81       	ld	r24, Y
    15d2:	99 81       	ldd	r25, Y+1	; 0x01
    15d4:	9d 83       	std	Y+5, r25	; 0x05
    15d6:	8c 83       	std	Y+4, r24	; 0x04
    15d8:	80 e0       	ldi	r24, 0x00	; 0
    15da:	29 c0       	rjmp	.+82     	; 0x162e <prvCopyDataToQueue+0xb0>
    15dc:	50 e0       	ldi	r21, 0x00	; 0
    15de:	8e 81       	ldd	r24, Y+6	; 0x06
    15e0:	9f 81       	ldd	r25, Y+7	; 0x07
    15e2:	0e 94 30 2c 	call	0x5860	; 0x5860 <memcpy>
    15e6:	88 a1       	ldd	r24, Y+32	; 0x20
    15e8:	90 e0       	ldi	r25, 0x00	; 0
    15ea:	91 95       	neg	r25
    15ec:	81 95       	neg	r24
    15ee:	91 09       	sbc	r25, r1
    15f0:	2e 81       	ldd	r18, Y+6	; 0x06
    15f2:	3f 81       	ldd	r19, Y+7	; 0x07
    15f4:	28 0f       	add	r18, r24
    15f6:	39 1f       	adc	r19, r25
    15f8:	3f 83       	std	Y+7, r19	; 0x07
    15fa:	2e 83       	std	Y+6, r18	; 0x06
    15fc:	48 81       	ld	r20, Y
    15fe:	59 81       	ldd	r21, Y+1	; 0x01
    1600:	24 17       	cp	r18, r20
    1602:	35 07       	cpc	r19, r21
    1604:	30 f4       	brcc	.+12     	; 0x1612 <prvCopyDataToQueue+0x94>
    1606:	2a 81       	ldd	r18, Y+2	; 0x02
    1608:	3b 81       	ldd	r19, Y+3	; 0x03
    160a:	82 0f       	add	r24, r18
    160c:	93 1f       	adc	r25, r19
    160e:	9f 83       	std	Y+7, r25	; 0x07
    1610:	8e 83       	std	Y+6, r24	; 0x06
    1612:	02 30       	cpi	r16, 0x02	; 2
    1614:	49 f4       	brne	.+18     	; 0x1628 <prvCopyDataToQueue+0xaa>
    1616:	11 23       	and	r17, r17
    1618:	49 f0       	breq	.+18     	; 0x162c <prvCopyDataToQueue+0xae>
    161a:	11 50       	subi	r17, 0x01	; 1
    161c:	80 e0       	ldi	r24, 0x00	; 0
    161e:	07 c0       	rjmp	.+14     	; 0x162e <prvCopyDataToQueue+0xb0>
    1620:	80 e0       	ldi	r24, 0x00	; 0
    1622:	05 c0       	rjmp	.+10     	; 0x162e <prvCopyDataToQueue+0xb0>
    1624:	80 e0       	ldi	r24, 0x00	; 0
    1626:	03 c0       	rjmp	.+6      	; 0x162e <prvCopyDataToQueue+0xb0>
    1628:	80 e0       	ldi	r24, 0x00	; 0
    162a:	01 c0       	rjmp	.+2      	; 0x162e <prvCopyDataToQueue+0xb0>
    162c:	80 e0       	ldi	r24, 0x00	; 0
    162e:	1f 5f       	subi	r17, 0xFF	; 255
    1630:	1e 8f       	std	Y+30, r17	; 0x1e
    1632:	df 91       	pop	r29
    1634:	cf 91       	pop	r28
    1636:	1f 91       	pop	r17
    1638:	0f 91       	pop	r16
    163a:	08 95       	ret

0000163c <prvCopyDataFromQueue>:
    163c:	fc 01       	movw	r30, r24
    163e:	40 a1       	ldd	r20, Z+32	; 0x20
    1640:	44 23       	and	r20, r20
    1642:	a9 f0       	breq	.+42     	; 0x166e <prvCopyDataFromQueue+0x32>
    1644:	50 e0       	ldi	r21, 0x00	; 0
    1646:	26 81       	ldd	r18, Z+6	; 0x06
    1648:	37 81       	ldd	r19, Z+7	; 0x07
    164a:	24 0f       	add	r18, r20
    164c:	35 1f       	adc	r19, r21
    164e:	37 83       	std	Z+7, r19	; 0x07
    1650:	26 83       	std	Z+6, r18	; 0x06
    1652:	82 81       	ldd	r24, Z+2	; 0x02
    1654:	93 81       	ldd	r25, Z+3	; 0x03
    1656:	28 17       	cp	r18, r24
    1658:	39 07       	cpc	r19, r25
    165a:	20 f0       	brcs	.+8      	; 0x1664 <prvCopyDataFromQueue+0x28>
    165c:	80 81       	ld	r24, Z
    165e:	91 81       	ldd	r25, Z+1	; 0x01
    1660:	97 83       	std	Z+7, r25	; 0x07
    1662:	86 83       	std	Z+6, r24	; 0x06
    1664:	cb 01       	movw	r24, r22
    1666:	66 81       	ldd	r22, Z+6	; 0x06
    1668:	77 81       	ldd	r23, Z+7	; 0x07
    166a:	0c 94 30 2c 	jmp	0x5860	; 0x5860 <memcpy>
    166e:	08 95       	ret

00001670 <prvUnlockQueue>:
    1670:	ef 92       	push	r14
    1672:	ff 92       	push	r15
    1674:	0f 93       	push	r16
    1676:	1f 93       	push	r17
    1678:	cf 93       	push	r28
    167a:	8c 01       	movw	r16, r24
    167c:	0f b6       	in	r0, 0x3f	; 63
    167e:	f8 94       	cli
    1680:	0f 92       	push	r0
    1682:	fc 01       	movw	r30, r24
    1684:	c2 a1       	ldd	r28, Z+34	; 0x22
    1686:	1c 16       	cp	r1, r28
    1688:	9c f4       	brge	.+38     	; 0x16b0 <prvUnlockQueue+0x40>
    168a:	83 89       	ldd	r24, Z+19	; 0x13
    168c:	81 11       	cpse	r24, r1
    168e:	06 c0       	rjmp	.+12     	; 0x169c <prvUnlockQueue+0x2c>
    1690:	0f c0       	rjmp	.+30     	; 0x16b0 <prvUnlockQueue+0x40>
    1692:	f8 01       	movw	r30, r16
    1694:	83 89       	ldd	r24, Z+19	; 0x13
    1696:	81 11       	cpse	r24, r1
    1698:	05 c0       	rjmp	.+10     	; 0x16a4 <prvUnlockQueue+0x34>
    169a:	0a c0       	rjmp	.+20     	; 0x16b0 <prvUnlockQueue+0x40>
    169c:	78 01       	movw	r14, r16
    169e:	f3 e1       	ldi	r31, 0x13	; 19
    16a0:	ef 0e       	add	r14, r31
    16a2:	f1 1c       	adc	r15, r1
    16a4:	c7 01       	movw	r24, r14
    16a6:	d6 d6       	rcall	.+3500   	; 0x2454 <xTaskRemoveFromEventList>
    16a8:	81 11       	cpse	r24, r1
    16aa:	8d d7       	rcall	.+3866   	; 0x25c6 <vTaskMissedYield>
    16ac:	c1 50       	subi	r28, 0x01	; 1
    16ae:	89 f7       	brne	.-30     	; 0x1692 <prvUnlockQueue+0x22>
    16b0:	8f ef       	ldi	r24, 0xFF	; 255
    16b2:	f8 01       	movw	r30, r16
    16b4:	82 a3       	std	Z+34, r24	; 0x22
    16b6:	0f 90       	pop	r0
    16b8:	0f be       	out	0x3f, r0	; 63
    16ba:	0f b6       	in	r0, 0x3f	; 63
    16bc:	f8 94       	cli
    16be:	0f 92       	push	r0
    16c0:	c1 a1       	ldd	r28, Z+33	; 0x21
    16c2:	1c 16       	cp	r1, r28
    16c4:	9c f4       	brge	.+38     	; 0x16ec <prvUnlockQueue+0x7c>
    16c6:	80 85       	ldd	r24, Z+8	; 0x08
    16c8:	81 11       	cpse	r24, r1
    16ca:	06 c0       	rjmp	.+12     	; 0x16d8 <prvUnlockQueue+0x68>
    16cc:	0f c0       	rjmp	.+30     	; 0x16ec <prvUnlockQueue+0x7c>
    16ce:	f8 01       	movw	r30, r16
    16d0:	80 85       	ldd	r24, Z+8	; 0x08
    16d2:	81 11       	cpse	r24, r1
    16d4:	05 c0       	rjmp	.+10     	; 0x16e0 <prvUnlockQueue+0x70>
    16d6:	0a c0       	rjmp	.+20     	; 0x16ec <prvUnlockQueue+0x7c>
    16d8:	78 01       	movw	r14, r16
    16da:	f8 e0       	ldi	r31, 0x08	; 8
    16dc:	ef 0e       	add	r14, r31
    16de:	f1 1c       	adc	r15, r1
    16e0:	c7 01       	movw	r24, r14
    16e2:	b8 d6       	rcall	.+3440   	; 0x2454 <xTaskRemoveFromEventList>
    16e4:	81 11       	cpse	r24, r1
    16e6:	6f d7       	rcall	.+3806   	; 0x25c6 <vTaskMissedYield>
    16e8:	c1 50       	subi	r28, 0x01	; 1
    16ea:	89 f7       	brne	.-30     	; 0x16ce <prvUnlockQueue+0x5e>
    16ec:	8f ef       	ldi	r24, 0xFF	; 255
    16ee:	f8 01       	movw	r30, r16
    16f0:	81 a3       	std	Z+33, r24	; 0x21
    16f2:	0f 90       	pop	r0
    16f4:	0f be       	out	0x3f, r0	; 63
    16f6:	cf 91       	pop	r28
    16f8:	1f 91       	pop	r17
    16fa:	0f 91       	pop	r16
    16fc:	ff 90       	pop	r15
    16fe:	ef 90       	pop	r14
    1700:	08 95       	ret

00001702 <xQueueGenericReset>:
    1702:	cf 93       	push	r28
    1704:	df 93       	push	r29
    1706:	ec 01       	movw	r28, r24
    1708:	0f b6       	in	r0, 0x3f	; 63
    170a:	f8 94       	cli
    170c:	0f 92       	push	r0
    170e:	48 81       	ld	r20, Y
    1710:	59 81       	ldd	r21, Y+1	; 0x01
    1712:	28 a1       	ldd	r18, Y+32	; 0x20
    1714:	30 e0       	ldi	r19, 0x00	; 0
    1716:	7f 8d       	ldd	r23, Y+31	; 0x1f
    1718:	72 9f       	mul	r23, r18
    171a:	c0 01       	movw	r24, r0
    171c:	73 9f       	mul	r23, r19
    171e:	90 0d       	add	r25, r0
    1720:	11 24       	eor	r1, r1
    1722:	fa 01       	movw	r30, r20
    1724:	e8 0f       	add	r30, r24
    1726:	f9 1f       	adc	r31, r25
    1728:	fb 83       	std	Y+3, r31	; 0x03
    172a:	ea 83       	std	Y+2, r30	; 0x02
    172c:	1e 8e       	std	Y+30, r1	; 0x1e
    172e:	5d 83       	std	Y+5, r21	; 0x05
    1730:	4c 83       	std	Y+4, r20	; 0x04
    1732:	82 1b       	sub	r24, r18
    1734:	93 0b       	sbc	r25, r19
    1736:	84 0f       	add	r24, r20
    1738:	95 1f       	adc	r25, r21
    173a:	9f 83       	std	Y+7, r25	; 0x07
    173c:	8e 83       	std	Y+6, r24	; 0x06
    173e:	8f ef       	ldi	r24, 0xFF	; 255
    1740:	89 a3       	std	Y+33, r24	; 0x21
    1742:	8a a3       	std	Y+34, r24	; 0x22
    1744:	61 11       	cpse	r22, r1
    1746:	0a c0       	rjmp	.+20     	; 0x175c <xQueueGenericReset+0x5a>
    1748:	88 85       	ldd	r24, Y+8	; 0x08
    174a:	88 23       	and	r24, r24
    174c:	69 f0       	breq	.+26     	; 0x1768 <xQueueGenericReset+0x66>
    174e:	ce 01       	movw	r24, r28
    1750:	08 96       	adiw	r24, 0x08	; 8
    1752:	80 d6       	rcall	.+3328   	; 0x2454 <xTaskRemoveFromEventList>
    1754:	88 23       	and	r24, r24
    1756:	41 f0       	breq	.+16     	; 0x1768 <xQueueGenericReset+0x66>
    1758:	4e de       	rcall	.-868    	; 0x13f6 <vPortYield>
    175a:	06 c0       	rjmp	.+12     	; 0x1768 <xQueueGenericReset+0x66>
    175c:	ce 01       	movw	r24, r28
    175e:	08 96       	adiw	r24, 0x08	; 8
    1760:	bf db       	rcall	.-2178   	; 0xee0 <vListInitialise>
    1762:	ce 01       	movw	r24, r28
    1764:	43 96       	adiw	r24, 0x13	; 19
    1766:	bc db       	rcall	.-2184   	; 0xee0 <vListInitialise>
    1768:	0f 90       	pop	r0
    176a:	0f be       	out	0x3f, r0	; 63
    176c:	81 e0       	ldi	r24, 0x01	; 1
    176e:	df 91       	pop	r29
    1770:	cf 91       	pop	r28
    1772:	08 95       	ret

00001774 <xQueueGenericCreate>:
    1774:	ff 92       	push	r15
    1776:	0f 93       	push	r16
    1778:	1f 93       	push	r17
    177a:	cf 93       	push	r28
    177c:	df 93       	push	r29
    177e:	08 2f       	mov	r16, r24
    1780:	16 2f       	mov	r17, r22
    1782:	f4 2e       	mov	r15, r20
    1784:	66 23       	and	r22, r22
    1786:	b9 f0       	breq	.+46     	; 0x17b6 <xQueueGenericCreate+0x42>
    1788:	86 9f       	mul	r24, r22
    178a:	c0 01       	movw	r24, r0
    178c:	11 24       	eor	r1, r1
    178e:	85 96       	adiw	r24, 0x25	; 37
    1790:	8d dc       	rcall	.-1766   	; 0x10ac <pvPortMalloc>
    1792:	ec 01       	movw	r28, r24
    1794:	00 97       	sbiw	r24, 0x00	; 0
    1796:	41 f4       	brne	.+16     	; 0x17a8 <xQueueGenericCreate+0x34>
    1798:	14 c0       	rjmp	.+40     	; 0x17c2 <xQueueGenericCreate+0x4e>
    179a:	0f 8f       	std	Y+31, r16	; 0x1f
    179c:	18 a3       	std	Y+32, r17	; 0x20
    179e:	61 e0       	ldi	r22, 0x01	; 1
    17a0:	ce 01       	movw	r24, r28
    17a2:	af df       	rcall	.-162    	; 0x1702 <xQueueGenericReset>
    17a4:	fc a2       	std	Y+36, r15	; 0x24
    17a6:	0d c0       	rjmp	.+26     	; 0x17c2 <xQueueGenericCreate+0x4e>
    17a8:	85 96       	adiw	r24, 0x25	; 37
    17aa:	99 83       	std	Y+1, r25	; 0x01
    17ac:	88 83       	st	Y, r24
    17ae:	f5 cf       	rjmp	.-22     	; 0x179a <xQueueGenericCreate+0x26>
    17b0:	d9 83       	std	Y+1, r29	; 0x01
    17b2:	c8 83       	st	Y, r28
    17b4:	f2 cf       	rjmp	.-28     	; 0x179a <xQueueGenericCreate+0x26>
    17b6:	85 e2       	ldi	r24, 0x25	; 37
    17b8:	90 e0       	ldi	r25, 0x00	; 0
    17ba:	78 dc       	rcall	.-1808   	; 0x10ac <pvPortMalloc>
    17bc:	ec 01       	movw	r28, r24
    17be:	89 2b       	or	r24, r25
    17c0:	b9 f7       	brne	.-18     	; 0x17b0 <xQueueGenericCreate+0x3c>
    17c2:	ce 01       	movw	r24, r28
    17c4:	df 91       	pop	r29
    17c6:	cf 91       	pop	r28
    17c8:	1f 91       	pop	r17
    17ca:	0f 91       	pop	r16
    17cc:	ff 90       	pop	r15
    17ce:	08 95       	ret

000017d0 <xQueueGenericSend>:
    17d0:	9f 92       	push	r9
    17d2:	af 92       	push	r10
    17d4:	bf 92       	push	r11
    17d6:	cf 92       	push	r12
    17d8:	df 92       	push	r13
    17da:	ef 92       	push	r14
    17dc:	ff 92       	push	r15
    17de:	0f 93       	push	r16
    17e0:	1f 93       	push	r17
    17e2:	cf 93       	push	r28
    17e4:	df 93       	push	r29
    17e6:	cd b7       	in	r28, 0x3d	; 61
    17e8:	de b7       	in	r29, 0x3e	; 62
    17ea:	29 97       	sbiw	r28, 0x09	; 9
    17ec:	0f b6       	in	r0, 0x3f	; 63
    17ee:	f8 94       	cli
    17f0:	de bf       	out	0x3e, r29	; 62
    17f2:	0f be       	out	0x3f, r0	; 63
    17f4:	cd bf       	out	0x3d, r28	; 61
    17f6:	7c 01       	movw	r14, r24
    17f8:	5b 01       	movw	r10, r22
    17fa:	2e 83       	std	Y+6, r18	; 0x06
    17fc:	3f 83       	std	Y+7, r19	; 0x07
    17fe:	48 87       	std	Y+8, r20	; 0x08
    1800:	59 87       	std	Y+9, r21	; 0x09
    1802:	10 e0       	ldi	r17, 0x00	; 0
    1804:	99 24       	eor	r9, r9
    1806:	93 94       	inc	r9
    1808:	6c 01       	movw	r12, r24
    180a:	88 e0       	ldi	r24, 0x08	; 8
    180c:	c8 0e       	add	r12, r24
    180e:	d1 1c       	adc	r13, r1
    1810:	0f b6       	in	r0, 0x3f	; 63
    1812:	f8 94       	cli
    1814:	0f 92       	push	r0
    1816:	f7 01       	movw	r30, r14
    1818:	96 8d       	ldd	r25, Z+30	; 0x1e
    181a:	87 8d       	ldd	r24, Z+31	; 0x1f
    181c:	98 17       	cp	r25, r24
    181e:	10 f0       	brcs	.+4      	; 0x1824 <xQueueGenericSend+0x54>
    1820:	02 30       	cpi	r16, 0x02	; 2
    1822:	a9 f4       	brne	.+42     	; 0x184e <xQueueGenericSend+0x7e>
    1824:	40 2f       	mov	r20, r16
    1826:	b5 01       	movw	r22, r10
    1828:	c7 01       	movw	r24, r14
    182a:	a9 de       	rcall	.-686    	; 0x157e <prvCopyDataToQueue>
    182c:	f7 01       	movw	r30, r14
    182e:	93 89       	ldd	r25, Z+19	; 0x13
    1830:	99 23       	and	r25, r25
    1832:	39 f0       	breq	.+14     	; 0x1842 <xQueueGenericSend+0x72>
    1834:	c7 01       	movw	r24, r14
    1836:	43 96       	adiw	r24, 0x13	; 19
    1838:	0d d6       	rcall	.+3098   	; 0x2454 <xTaskRemoveFromEventList>
    183a:	88 23       	and	r24, r24
    183c:	21 f0       	breq	.+8      	; 0x1846 <xQueueGenericSend+0x76>
    183e:	db dd       	rcall	.-1098   	; 0x13f6 <vPortYield>
    1840:	02 c0       	rjmp	.+4      	; 0x1846 <xQueueGenericSend+0x76>
    1842:	81 11       	cpse	r24, r1
    1844:	d8 dd       	rcall	.-1104   	; 0x13f6 <vPortYield>
    1846:	0f 90       	pop	r0
    1848:	0f be       	out	0x3f, r0	; 63
    184a:	81 e0       	ldi	r24, 0x01	; 1
    184c:	4b c0       	rjmp	.+150    	; 0x18e4 <xQueueGenericSend+0x114>
    184e:	8e 81       	ldd	r24, Y+6	; 0x06
    1850:	9f 81       	ldd	r25, Y+7	; 0x07
    1852:	a8 85       	ldd	r26, Y+8	; 0x08
    1854:	b9 85       	ldd	r27, Y+9	; 0x09
    1856:	89 2b       	or	r24, r25
    1858:	8a 2b       	or	r24, r26
    185a:	8b 2b       	or	r24, r27
    185c:	21 f4       	brne	.+8      	; 0x1866 <xQueueGenericSend+0x96>
    185e:	0f 90       	pop	r0
    1860:	0f be       	out	0x3f, r0	; 63
    1862:	80 e0       	ldi	r24, 0x00	; 0
    1864:	3f c0       	rjmp	.+126    	; 0x18e4 <xQueueGenericSend+0x114>
    1866:	11 11       	cpse	r17, r1
    1868:	04 c0       	rjmp	.+8      	; 0x1872 <xQueueGenericSend+0xa2>
    186a:	ce 01       	movw	r24, r28
    186c:	01 96       	adiw	r24, 0x01	; 1
    186e:	34 d6       	rcall	.+3176   	; 0x24d8 <vTaskSetTimeOutState>
    1870:	19 2d       	mov	r17, r9
    1872:	0f 90       	pop	r0
    1874:	0f be       	out	0x3f, r0	; 63
    1876:	ca d3       	rcall	.+1940   	; 0x200c <vTaskSuspendAll>
    1878:	0f b6       	in	r0, 0x3f	; 63
    187a:	f8 94       	cli
    187c:	0f 92       	push	r0
    187e:	f7 01       	movw	r30, r14
    1880:	81 a1       	ldd	r24, Z+33	; 0x21
    1882:	8f 3f       	cpi	r24, 0xFF	; 255
    1884:	09 f4       	brne	.+2      	; 0x1888 <xQueueGenericSend+0xb8>
    1886:	11 a2       	std	Z+33, r1	; 0x21
    1888:	f7 01       	movw	r30, r14
    188a:	82 a1       	ldd	r24, Z+34	; 0x22
    188c:	8f 3f       	cpi	r24, 0xFF	; 255
    188e:	09 f4       	brne	.+2      	; 0x1892 <xQueueGenericSend+0xc2>
    1890:	12 a2       	std	Z+34, r1	; 0x22
    1892:	0f 90       	pop	r0
    1894:	0f be       	out	0x3f, r0	; 63
    1896:	be 01       	movw	r22, r28
    1898:	6a 5f       	subi	r22, 0xFA	; 250
    189a:	7f 4f       	sbci	r23, 0xFF	; 255
    189c:	ce 01       	movw	r24, r28
    189e:	01 96       	adiw	r24, 0x01	; 1
    18a0:	2c d6       	rcall	.+3160   	; 0x24fa <xTaskCheckForTimeOut>
    18a2:	81 11       	cpse	r24, r1
    18a4:	1b c0       	rjmp	.+54     	; 0x18dc <xQueueGenericSend+0x10c>
    18a6:	0f b6       	in	r0, 0x3f	; 63
    18a8:	f8 94       	cli
    18aa:	0f 92       	push	r0
    18ac:	f7 01       	movw	r30, r14
    18ae:	96 8d       	ldd	r25, Z+30	; 0x1e
    18b0:	0f 90       	pop	r0
    18b2:	0f be       	out	0x3f, r0	; 63
    18b4:	87 8d       	ldd	r24, Z+31	; 0x1f
    18b6:	98 13       	cpse	r25, r24
    18b8:	0d c0       	rjmp	.+26     	; 0x18d4 <xQueueGenericSend+0x104>
    18ba:	4e 81       	ldd	r20, Y+6	; 0x06
    18bc:	5f 81       	ldd	r21, Y+7	; 0x07
    18be:	68 85       	ldd	r22, Y+8	; 0x08
    18c0:	79 85       	ldd	r23, Y+9	; 0x09
    18c2:	c6 01       	movw	r24, r12
    18c4:	b0 d5       	rcall	.+2912   	; 0x2426 <vTaskPlaceOnEventList>
    18c6:	c7 01       	movw	r24, r14
    18c8:	d3 de       	rcall	.-602    	; 0x1670 <prvUnlockQueue>
    18ca:	89 d4       	rcall	.+2322   	; 0x21de <xTaskResumeAll>
    18cc:	81 11       	cpse	r24, r1
    18ce:	a0 cf       	rjmp	.-192    	; 0x1810 <xQueueGenericSend+0x40>
    18d0:	92 dd       	rcall	.-1244   	; 0x13f6 <vPortYield>
    18d2:	9e cf       	rjmp	.-196    	; 0x1810 <xQueueGenericSend+0x40>
    18d4:	c7 01       	movw	r24, r14
    18d6:	cc de       	rcall	.-616    	; 0x1670 <prvUnlockQueue>
    18d8:	82 d4       	rcall	.+2308   	; 0x21de <xTaskResumeAll>
    18da:	9a cf       	rjmp	.-204    	; 0x1810 <xQueueGenericSend+0x40>
    18dc:	c7 01       	movw	r24, r14
    18de:	c8 de       	rcall	.-624    	; 0x1670 <prvUnlockQueue>
    18e0:	7e d4       	rcall	.+2300   	; 0x21de <xTaskResumeAll>
    18e2:	80 e0       	ldi	r24, 0x00	; 0
    18e4:	29 96       	adiw	r28, 0x09	; 9
    18e6:	0f b6       	in	r0, 0x3f	; 63
    18e8:	f8 94       	cli
    18ea:	de bf       	out	0x3e, r29	; 62
    18ec:	0f be       	out	0x3f, r0	; 63
    18ee:	cd bf       	out	0x3d, r28	; 61
    18f0:	df 91       	pop	r29
    18f2:	cf 91       	pop	r28
    18f4:	1f 91       	pop	r17
    18f6:	0f 91       	pop	r16
    18f8:	ff 90       	pop	r15
    18fa:	ef 90       	pop	r14
    18fc:	df 90       	pop	r13
    18fe:	cf 90       	pop	r12
    1900:	bf 90       	pop	r11
    1902:	af 90       	pop	r10
    1904:	9f 90       	pop	r9
    1906:	08 95       	ret

00001908 <xQueueCreateMutex>:
    1908:	0f 93       	push	r16
    190a:	cf 93       	push	r28
    190c:	df 93       	push	r29
    190e:	48 2f       	mov	r20, r24
    1910:	60 e0       	ldi	r22, 0x00	; 0
    1912:	81 e0       	ldi	r24, 0x01	; 1
    1914:	2f df       	rcall	.-418    	; 0x1774 <xQueueGenericCreate>
    1916:	ec 01       	movw	r28, r24
    1918:	00 97       	sbiw	r24, 0x00	; 0
    191a:	61 f0       	breq	.+24     	; 0x1934 <xQueueCreateMutex+0x2c>
    191c:	1b 82       	std	Y+3, r1	; 0x03
    191e:	1a 82       	std	Y+2, r1	; 0x02
    1920:	19 82       	std	Y+1, r1	; 0x01
    1922:	18 82       	st	Y, r1
    1924:	1e 82       	std	Y+6, r1	; 0x06
    1926:	00 e0       	ldi	r16, 0x00	; 0
    1928:	20 e0       	ldi	r18, 0x00	; 0
    192a:	30 e0       	ldi	r19, 0x00	; 0
    192c:	a9 01       	movw	r20, r18
    192e:	60 e0       	ldi	r22, 0x00	; 0
    1930:	70 e0       	ldi	r23, 0x00	; 0
    1932:	4e df       	rcall	.-356    	; 0x17d0 <xQueueGenericSend>
    1934:	ce 01       	movw	r24, r28
    1936:	df 91       	pop	r29
    1938:	cf 91       	pop	r28
    193a:	0f 91       	pop	r16
    193c:	08 95       	ret

0000193e <xQueueGenericSendFromISR>:
    193e:	ef 92       	push	r14
    1940:	ff 92       	push	r15
    1942:	0f 93       	push	r16
    1944:	1f 93       	push	r17
    1946:	cf 93       	push	r28
    1948:	df 93       	push	r29
    194a:	8a 01       	movw	r16, r20
    194c:	fc 01       	movw	r30, r24
    194e:	56 8d       	ldd	r21, Z+30	; 0x1e
    1950:	37 8d       	ldd	r19, Z+31	; 0x1f
    1952:	53 17       	cp	r21, r19
    1954:	10 f0       	brcs	.+4      	; 0x195a <xQueueGenericSendFromISR+0x1c>
    1956:	22 30       	cpi	r18, 0x02	; 2
    1958:	e1 f4       	brne	.+56     	; 0x1992 <xQueueGenericSendFromISR+0x54>
    195a:	42 2f       	mov	r20, r18
    195c:	78 01       	movw	r14, r16
    195e:	ec 01       	movw	r28, r24
    1960:	1a a1       	ldd	r17, Y+34	; 0x22
    1962:	0d de       	rcall	.-998    	; 0x157e <prvCopyDataToQueue>
    1964:	1f 3f       	cpi	r17, 0xFF	; 255
    1966:	79 f4       	brne	.+30     	; 0x1986 <xQueueGenericSendFromISR+0x48>
    1968:	8b 89       	ldd	r24, Y+19	; 0x13
    196a:	88 23       	and	r24, r24
    196c:	a1 f0       	breq	.+40     	; 0x1996 <xQueueGenericSendFromISR+0x58>
    196e:	ce 01       	movw	r24, r28
    1970:	43 96       	adiw	r24, 0x13	; 19
    1972:	70 d5       	rcall	.+2784   	; 0x2454 <xTaskRemoveFromEventList>
    1974:	88 23       	and	r24, r24
    1976:	89 f0       	breq	.+34     	; 0x199a <xQueueGenericSendFromISR+0x5c>
    1978:	e1 14       	cp	r14, r1
    197a:	f1 04       	cpc	r15, r1
    197c:	81 f0       	breq	.+32     	; 0x199e <xQueueGenericSendFromISR+0x60>
    197e:	81 e0       	ldi	r24, 0x01	; 1
    1980:	f7 01       	movw	r30, r14
    1982:	80 83       	st	Z, r24
    1984:	0d c0       	rjmp	.+26     	; 0x19a0 <xQueueGenericSendFromISR+0x62>
    1986:	ff 24       	eor	r15, r15
    1988:	f3 94       	inc	r15
    198a:	f1 0e       	add	r15, r17
    198c:	fa a2       	std	Y+34, r15	; 0x22
    198e:	81 e0       	ldi	r24, 0x01	; 1
    1990:	07 c0       	rjmp	.+14     	; 0x19a0 <xQueueGenericSendFromISR+0x62>
    1992:	80 e0       	ldi	r24, 0x00	; 0
    1994:	05 c0       	rjmp	.+10     	; 0x19a0 <xQueueGenericSendFromISR+0x62>
    1996:	81 e0       	ldi	r24, 0x01	; 1
    1998:	03 c0       	rjmp	.+6      	; 0x19a0 <xQueueGenericSendFromISR+0x62>
    199a:	81 e0       	ldi	r24, 0x01	; 1
    199c:	01 c0       	rjmp	.+2      	; 0x19a0 <xQueueGenericSendFromISR+0x62>
    199e:	81 e0       	ldi	r24, 0x01	; 1
    19a0:	df 91       	pop	r29
    19a2:	cf 91       	pop	r28
    19a4:	1f 91       	pop	r17
    19a6:	0f 91       	pop	r16
    19a8:	ff 90       	pop	r15
    19aa:	ef 90       	pop	r14
    19ac:	08 95       	ret

000019ae <xQueueGenericReceive>:
    19ae:	8f 92       	push	r8
    19b0:	9f 92       	push	r9
    19b2:	af 92       	push	r10
    19b4:	bf 92       	push	r11
    19b6:	cf 92       	push	r12
    19b8:	df 92       	push	r13
    19ba:	ef 92       	push	r14
    19bc:	ff 92       	push	r15
    19be:	0f 93       	push	r16
    19c0:	1f 93       	push	r17
    19c2:	cf 93       	push	r28
    19c4:	df 93       	push	r29
    19c6:	cd b7       	in	r28, 0x3d	; 61
    19c8:	de b7       	in	r29, 0x3e	; 62
    19ca:	29 97       	sbiw	r28, 0x09	; 9
    19cc:	0f b6       	in	r0, 0x3f	; 63
    19ce:	f8 94       	cli
    19d0:	de bf       	out	0x3e, r29	; 62
    19d2:	0f be       	out	0x3f, r0	; 63
    19d4:	cd bf       	out	0x3d, r28	; 61
    19d6:	7c 01       	movw	r14, r24
    19d8:	5b 01       	movw	r10, r22
    19da:	2e 83       	std	Y+6, r18	; 0x06
    19dc:	3f 83       	std	Y+7, r19	; 0x07
    19de:	48 87       	std	Y+8, r20	; 0x08
    19e0:	59 87       	std	Y+9, r21	; 0x09
    19e2:	91 2c       	mov	r9, r1
    19e4:	88 24       	eor	r8, r8
    19e6:	83 94       	inc	r8
    19e8:	6c 01       	movw	r12, r24
    19ea:	83 e1       	ldi	r24, 0x13	; 19
    19ec:	c8 0e       	add	r12, r24
    19ee:	d1 1c       	adc	r13, r1
    19f0:	0f b6       	in	r0, 0x3f	; 63
    19f2:	f8 94       	cli
    19f4:	0f 92       	push	r0
    19f6:	f7 01       	movw	r30, r14
    19f8:	16 8d       	ldd	r17, Z+30	; 0x1e
    19fa:	11 23       	and	r17, r17
    19fc:	61 f1       	breq	.+88     	; 0x1a56 <xQueueGenericReceive+0xa8>
    19fe:	c6 80       	ldd	r12, Z+6	; 0x06
    1a00:	d7 80       	ldd	r13, Z+7	; 0x07
    1a02:	b5 01       	movw	r22, r10
    1a04:	c7 01       	movw	r24, r14
    1a06:	1a de       	rcall	.-972    	; 0x163c <prvCopyDataFromQueue>
    1a08:	01 11       	cpse	r16, r1
    1a0a:	16 c0       	rjmp	.+44     	; 0x1a38 <xQueueGenericReceive+0x8a>
    1a0c:	11 50       	subi	r17, 0x01	; 1
    1a0e:	f7 01       	movw	r30, r14
    1a10:	16 8f       	std	Z+30, r17	; 0x1e
    1a12:	80 81       	ld	r24, Z
    1a14:	91 81       	ldd	r25, Z+1	; 0x01
    1a16:	89 2b       	or	r24, r25
    1a18:	21 f4       	brne	.+8      	; 0x1a22 <xQueueGenericReceive+0x74>
    1a1a:	77 d6       	rcall	.+3310   	; 0x270a <pvTaskIncrementMutexHeldCount>
    1a1c:	f7 01       	movw	r30, r14
    1a1e:	93 83       	std	Z+3, r25	; 0x03
    1a20:	82 83       	std	Z+2, r24	; 0x02
    1a22:	f7 01       	movw	r30, r14
    1a24:	80 85       	ldd	r24, Z+8	; 0x08
    1a26:	88 23       	and	r24, r24
    1a28:	91 f0       	breq	.+36     	; 0x1a4e <xQueueGenericReceive+0xa0>
    1a2a:	c7 01       	movw	r24, r14
    1a2c:	08 96       	adiw	r24, 0x08	; 8
    1a2e:	12 d5       	rcall	.+2596   	; 0x2454 <xTaskRemoveFromEventList>
    1a30:	88 23       	and	r24, r24
    1a32:	69 f0       	breq	.+26     	; 0x1a4e <xQueueGenericReceive+0xa0>
    1a34:	e0 dc       	rcall	.-1600   	; 0x13f6 <vPortYield>
    1a36:	0b c0       	rjmp	.+22     	; 0x1a4e <xQueueGenericReceive+0xa0>
    1a38:	f7 01       	movw	r30, r14
    1a3a:	d7 82       	std	Z+7, r13	; 0x07
    1a3c:	c6 82       	std	Z+6, r12	; 0x06
    1a3e:	83 89       	ldd	r24, Z+19	; 0x13
    1a40:	88 23       	and	r24, r24
    1a42:	29 f0       	breq	.+10     	; 0x1a4e <xQueueGenericReceive+0xa0>
    1a44:	c7 01       	movw	r24, r14
    1a46:	43 96       	adiw	r24, 0x13	; 19
    1a48:	05 d5       	rcall	.+2570   	; 0x2454 <xTaskRemoveFromEventList>
    1a4a:	81 11       	cpse	r24, r1
    1a4c:	d4 dc       	rcall	.-1624   	; 0x13f6 <vPortYield>
    1a4e:	0f 90       	pop	r0
    1a50:	0f be       	out	0x3f, r0	; 63
    1a52:	81 e0       	ldi	r24, 0x01	; 1
    1a54:	5e c0       	rjmp	.+188    	; 0x1b12 <xQueueGenericReceive+0x164>
    1a56:	8e 81       	ldd	r24, Y+6	; 0x06
    1a58:	9f 81       	ldd	r25, Y+7	; 0x07
    1a5a:	a8 85       	ldd	r26, Y+8	; 0x08
    1a5c:	b9 85       	ldd	r27, Y+9	; 0x09
    1a5e:	89 2b       	or	r24, r25
    1a60:	8a 2b       	or	r24, r26
    1a62:	8b 2b       	or	r24, r27
    1a64:	21 f4       	brne	.+8      	; 0x1a6e <xQueueGenericReceive+0xc0>
    1a66:	0f 90       	pop	r0
    1a68:	0f be       	out	0x3f, r0	; 63
    1a6a:	80 e0       	ldi	r24, 0x00	; 0
    1a6c:	52 c0       	rjmp	.+164    	; 0x1b12 <xQueueGenericReceive+0x164>
    1a6e:	91 10       	cpse	r9, r1
    1a70:	04 c0       	rjmp	.+8      	; 0x1a7a <xQueueGenericReceive+0xcc>
    1a72:	ce 01       	movw	r24, r28
    1a74:	01 96       	adiw	r24, 0x01	; 1
    1a76:	30 d5       	rcall	.+2656   	; 0x24d8 <vTaskSetTimeOutState>
    1a78:	98 2c       	mov	r9, r8
    1a7a:	0f 90       	pop	r0
    1a7c:	0f be       	out	0x3f, r0	; 63
    1a7e:	c6 d2       	rcall	.+1420   	; 0x200c <vTaskSuspendAll>
    1a80:	0f b6       	in	r0, 0x3f	; 63
    1a82:	f8 94       	cli
    1a84:	0f 92       	push	r0
    1a86:	f7 01       	movw	r30, r14
    1a88:	81 a1       	ldd	r24, Z+33	; 0x21
    1a8a:	8f 3f       	cpi	r24, 0xFF	; 255
    1a8c:	09 f4       	brne	.+2      	; 0x1a90 <xQueueGenericReceive+0xe2>
    1a8e:	11 a2       	std	Z+33, r1	; 0x21
    1a90:	f7 01       	movw	r30, r14
    1a92:	82 a1       	ldd	r24, Z+34	; 0x22
    1a94:	8f 3f       	cpi	r24, 0xFF	; 255
    1a96:	09 f4       	brne	.+2      	; 0x1a9a <xQueueGenericReceive+0xec>
    1a98:	12 a2       	std	Z+34, r1	; 0x22
    1a9a:	0f 90       	pop	r0
    1a9c:	0f be       	out	0x3f, r0	; 63
    1a9e:	be 01       	movw	r22, r28
    1aa0:	6a 5f       	subi	r22, 0xFA	; 250
    1aa2:	7f 4f       	sbci	r23, 0xFF	; 255
    1aa4:	ce 01       	movw	r24, r28
    1aa6:	01 96       	adiw	r24, 0x01	; 1
    1aa8:	28 d5       	rcall	.+2640   	; 0x24fa <xTaskCheckForTimeOut>
    1aaa:	81 11       	cpse	r24, r1
    1aac:	26 c0       	rjmp	.+76     	; 0x1afa <xQueueGenericReceive+0x14c>
    1aae:	0f b6       	in	r0, 0x3f	; 63
    1ab0:	f8 94       	cli
    1ab2:	0f 92       	push	r0
    1ab4:	f7 01       	movw	r30, r14
    1ab6:	86 8d       	ldd	r24, Z+30	; 0x1e
    1ab8:	0f 90       	pop	r0
    1aba:	0f be       	out	0x3f, r0	; 63
    1abc:	81 11       	cpse	r24, r1
    1abe:	19 c0       	rjmp	.+50     	; 0x1af2 <xQueueGenericReceive+0x144>
    1ac0:	80 81       	ld	r24, Z
    1ac2:	91 81       	ldd	r25, Z+1	; 0x01
    1ac4:	89 2b       	or	r24, r25
    1ac6:	41 f4       	brne	.+16     	; 0x1ad8 <xQueueGenericReceive+0x12a>
    1ac8:	0f b6       	in	r0, 0x3f	; 63
    1aca:	f8 94       	cli
    1acc:	0f 92       	push	r0
    1ace:	82 81       	ldd	r24, Z+2	; 0x02
    1ad0:	93 81       	ldd	r25, Z+3	; 0x03
    1ad2:	7d d5       	rcall	.+2810   	; 0x25ce <vTaskPriorityInherit>
    1ad4:	0f 90       	pop	r0
    1ad6:	0f be       	out	0x3f, r0	; 63
    1ad8:	4e 81       	ldd	r20, Y+6	; 0x06
    1ada:	5f 81       	ldd	r21, Y+7	; 0x07
    1adc:	68 85       	ldd	r22, Y+8	; 0x08
    1ade:	79 85       	ldd	r23, Y+9	; 0x09
    1ae0:	c6 01       	movw	r24, r12
    1ae2:	a1 d4       	rcall	.+2370   	; 0x2426 <vTaskPlaceOnEventList>
    1ae4:	c7 01       	movw	r24, r14
    1ae6:	c4 dd       	rcall	.-1144   	; 0x1670 <prvUnlockQueue>
    1ae8:	7a d3       	rcall	.+1780   	; 0x21de <xTaskResumeAll>
    1aea:	81 11       	cpse	r24, r1
    1aec:	81 cf       	rjmp	.-254    	; 0x19f0 <xQueueGenericReceive+0x42>
    1aee:	83 dc       	rcall	.-1786   	; 0x13f6 <vPortYield>
    1af0:	7f cf       	rjmp	.-258    	; 0x19f0 <xQueueGenericReceive+0x42>
    1af2:	c7 01       	movw	r24, r14
    1af4:	bd dd       	rcall	.-1158   	; 0x1670 <prvUnlockQueue>
    1af6:	73 d3       	rcall	.+1766   	; 0x21de <xTaskResumeAll>
    1af8:	7b cf       	rjmp	.-266    	; 0x19f0 <xQueueGenericReceive+0x42>
    1afa:	c7 01       	movw	r24, r14
    1afc:	b9 dd       	rcall	.-1166   	; 0x1670 <prvUnlockQueue>
    1afe:	6f d3       	rcall	.+1758   	; 0x21de <xTaskResumeAll>
    1b00:	0f b6       	in	r0, 0x3f	; 63
    1b02:	f8 94       	cli
    1b04:	0f 92       	push	r0
    1b06:	f7 01       	movw	r30, r14
    1b08:	86 8d       	ldd	r24, Z+30	; 0x1e
    1b0a:	0f 90       	pop	r0
    1b0c:	0f be       	out	0x3f, r0	; 63
    1b0e:	81 11       	cpse	r24, r1
    1b10:	6f cf       	rjmp	.-290    	; 0x19f0 <xQueueGenericReceive+0x42>
    1b12:	29 96       	adiw	r28, 0x09	; 9
    1b14:	0f b6       	in	r0, 0x3f	; 63
    1b16:	f8 94       	cli
    1b18:	de bf       	out	0x3e, r29	; 62
    1b1a:	0f be       	out	0x3f, r0	; 63
    1b1c:	cd bf       	out	0x3d, r28	; 61
    1b1e:	df 91       	pop	r29
    1b20:	cf 91       	pop	r28
    1b22:	1f 91       	pop	r17
    1b24:	0f 91       	pop	r16
    1b26:	ff 90       	pop	r15
    1b28:	ef 90       	pop	r14
    1b2a:	df 90       	pop	r13
    1b2c:	cf 90       	pop	r12
    1b2e:	bf 90       	pop	r11
    1b30:	af 90       	pop	r10
    1b32:	9f 90       	pop	r9
    1b34:	8f 90       	pop	r8
    1b36:	08 95       	ret

00001b38 <xQueueReceiveFromISR>:
    1b38:	ef 92       	push	r14
    1b3a:	ff 92       	push	r15
    1b3c:	0f 93       	push	r16
    1b3e:	1f 93       	push	r17
    1b40:	cf 93       	push	r28
    1b42:	df 93       	push	r29
    1b44:	fc 01       	movw	r30, r24
    1b46:	c6 8d       	ldd	r28, Z+30	; 0x1e
    1b48:	cc 23       	and	r28, r28
    1b4a:	e9 f0       	breq	.+58     	; 0x1b86 <xQueueReceiveFromISR+0x4e>
    1b4c:	7a 01       	movw	r14, r20
    1b4e:	8c 01       	movw	r16, r24
    1b50:	d1 a1       	ldd	r29, Z+33	; 0x21
    1b52:	74 dd       	rcall	.-1304   	; 0x163c <prvCopyDataFromQueue>
    1b54:	c1 50       	subi	r28, 0x01	; 1
    1b56:	f8 01       	movw	r30, r16
    1b58:	c6 8f       	std	Z+30, r28	; 0x1e
    1b5a:	df 3f       	cpi	r29, 0xFF	; 255
    1b5c:	79 f4       	brne	.+30     	; 0x1b7c <xQueueReceiveFromISR+0x44>
    1b5e:	80 85       	ldd	r24, Z+8	; 0x08
    1b60:	88 23       	and	r24, r24
    1b62:	99 f0       	breq	.+38     	; 0x1b8a <xQueueReceiveFromISR+0x52>
    1b64:	c8 01       	movw	r24, r16
    1b66:	08 96       	adiw	r24, 0x08	; 8
    1b68:	75 d4       	rcall	.+2282   	; 0x2454 <xTaskRemoveFromEventList>
    1b6a:	88 23       	and	r24, r24
    1b6c:	81 f0       	breq	.+32     	; 0x1b8e <xQueueReceiveFromISR+0x56>
    1b6e:	e1 14       	cp	r14, r1
    1b70:	f1 04       	cpc	r15, r1
    1b72:	79 f0       	breq	.+30     	; 0x1b92 <xQueueReceiveFromISR+0x5a>
    1b74:	81 e0       	ldi	r24, 0x01	; 1
    1b76:	f7 01       	movw	r30, r14
    1b78:	80 83       	st	Z, r24
    1b7a:	0c c0       	rjmp	.+24     	; 0x1b94 <xQueueReceiveFromISR+0x5c>
    1b7c:	df 5f       	subi	r29, 0xFF	; 255
    1b7e:	f8 01       	movw	r30, r16
    1b80:	d1 a3       	std	Z+33, r29	; 0x21
    1b82:	81 e0       	ldi	r24, 0x01	; 1
    1b84:	07 c0       	rjmp	.+14     	; 0x1b94 <xQueueReceiveFromISR+0x5c>
    1b86:	80 e0       	ldi	r24, 0x00	; 0
    1b88:	05 c0       	rjmp	.+10     	; 0x1b94 <xQueueReceiveFromISR+0x5c>
    1b8a:	81 e0       	ldi	r24, 0x01	; 1
    1b8c:	03 c0       	rjmp	.+6      	; 0x1b94 <xQueueReceiveFromISR+0x5c>
    1b8e:	81 e0       	ldi	r24, 0x01	; 1
    1b90:	01 c0       	rjmp	.+2      	; 0x1b94 <xQueueReceiveFromISR+0x5c>
    1b92:	81 e0       	ldi	r24, 0x01	; 1
    1b94:	df 91       	pop	r29
    1b96:	cf 91       	pop	r28
    1b98:	1f 91       	pop	r17
    1b9a:	0f 91       	pop	r16
    1b9c:	ff 90       	pop	r15
    1b9e:	ef 90       	pop	r14
    1ba0:	08 95       	ret

00001ba2 <uxQueueMessagesWaiting>:
    1ba2:	0f b6       	in	r0, 0x3f	; 63
    1ba4:	f8 94       	cli
    1ba6:	0f 92       	push	r0
    1ba8:	fc 01       	movw	r30, r24
    1baa:	86 8d       	ldd	r24, Z+30	; 0x1e
    1bac:	0f 90       	pop	r0
    1bae:	0f be       	out	0x3f, r0	; 63
    1bb0:	08 95       	ret

00001bb2 <uxQueueMessagesWaitingFromISR>:
{
UBaseType_t uxReturn;

	configASSERT( xQueue );

	uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    1bb2:	fc 01       	movw	r30, r24
    1bb4:	86 8d       	ldd	r24, Z+30	; 0x1e

	return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    1bb6:	08 95       	ret

00001bb8 <prvResetNextTaskUnblockTime>:
	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */

	return uxReturn;
}
    1bb8:	e0 91 98 1d 	lds	r30, 0x1D98	; 0x801d98 <pxDelayedTaskList>
    1bbc:	f0 91 99 1d 	lds	r31, 0x1D99	; 0x801d99 <pxDelayedTaskList+0x1>
    1bc0:	80 81       	ld	r24, Z
    1bc2:	81 11       	cpse	r24, r1
    1bc4:	0c c0       	rjmp	.+24     	; 0x1bde <prvResetNextTaskUnblockTime+0x26>
    1bc6:	8f ef       	ldi	r24, 0xFF	; 255
    1bc8:	9f ef       	ldi	r25, 0xFF	; 255
    1bca:	dc 01       	movw	r26, r24
    1bcc:	80 93 65 1d 	sts	0x1D65, r24	; 0x801d65 <xNextTaskUnblockTime>
    1bd0:	90 93 66 1d 	sts	0x1D66, r25	; 0x801d66 <xNextTaskUnblockTime+0x1>
    1bd4:	a0 93 67 1d 	sts	0x1D67, r26	; 0x801d67 <xNextTaskUnblockTime+0x2>
    1bd8:	b0 93 68 1d 	sts	0x1D68, r27	; 0x801d68 <xNextTaskUnblockTime+0x3>
    1bdc:	08 95       	ret
    1bde:	e0 91 98 1d 	lds	r30, 0x1D98	; 0x801d98 <pxDelayedTaskList>
    1be2:	f0 91 99 1d 	lds	r31, 0x1D99	; 0x801d99 <pxDelayedTaskList+0x1>
    1be6:	07 80       	ldd	r0, Z+7	; 0x07
    1be8:	f0 85       	ldd	r31, Z+8	; 0x08
    1bea:	e0 2d       	mov	r30, r0
    1bec:	00 84       	ldd	r0, Z+8	; 0x08
    1bee:	f1 85       	ldd	r31, Z+9	; 0x09
    1bf0:	e0 2d       	mov	r30, r0
    1bf2:	82 81       	ldd	r24, Z+2	; 0x02
    1bf4:	93 81       	ldd	r25, Z+3	; 0x03
    1bf6:	a4 81       	ldd	r26, Z+4	; 0x04
    1bf8:	b5 81       	ldd	r27, Z+5	; 0x05
    1bfa:	80 93 65 1d 	sts	0x1D65, r24	; 0x801d65 <xNextTaskUnblockTime>
    1bfe:	90 93 66 1d 	sts	0x1D66, r25	; 0x801d66 <xNextTaskUnblockTime+0x1>
    1c02:	a0 93 67 1d 	sts	0x1D67, r26	; 0x801d67 <xNextTaskUnblockTime+0x2>
    1c06:	b0 93 68 1d 	sts	0x1D68, r27	; 0x801d68 <xNextTaskUnblockTime+0x3>
    1c0a:	08 95       	ret

00001c0c <prvAddCurrentTaskToDelayedList>:
    1c0c:	8f 92       	push	r8
    1c0e:	9f 92       	push	r9
    1c10:	af 92       	push	r10
    1c12:	bf 92       	push	r11
    1c14:	cf 92       	push	r12
    1c16:	df 92       	push	r13
    1c18:	ef 92       	push	r14
    1c1a:	ff 92       	push	r15
    1c1c:	cf 93       	push	r28
    1c1e:	6b 01       	movw	r12, r22
    1c20:	7c 01       	movw	r14, r24
    1c22:	c4 2f       	mov	r28, r20
    1c24:	80 90 6f 1d 	lds	r8, 0x1D6F	; 0x801d6f <xTickCount>
    1c28:	90 90 70 1d 	lds	r9, 0x1D70	; 0x801d70 <xTickCount+0x1>
    1c2c:	a0 90 71 1d 	lds	r10, 0x1D71	; 0x801d71 <xTickCount+0x2>
    1c30:	b0 90 72 1d 	lds	r11, 0x1D72	; 0x801d72 <xTickCount+0x3>
    1c34:	80 91 e7 1d 	lds	r24, 0x1DE7	; 0x801de7 <pxCurrentTCB>
    1c38:	90 91 e8 1d 	lds	r25, 0x1DE8	; 0x801de8 <pxCurrentTCB+0x1>
    1c3c:	02 96       	adiw	r24, 0x02	; 2
    1c3e:	c3 d9       	rcall	.-3194   	; 0xfc6 <uxListRemove>
    1c40:	8f ef       	ldi	r24, 0xFF	; 255
    1c42:	c8 16       	cp	r12, r24
    1c44:	d8 06       	cpc	r13, r24
    1c46:	e8 06       	cpc	r14, r24
    1c48:	f8 06       	cpc	r15, r24
    1c4a:	61 f4       	brne	.+24     	; 0x1c64 <prvAddCurrentTaskToDelayedList+0x58>
    1c4c:	cc 23       	and	r28, r28
    1c4e:	51 f0       	breq	.+20     	; 0x1c64 <prvAddCurrentTaskToDelayedList+0x58>
    1c50:	60 91 e7 1d 	lds	r22, 0x1DE7	; 0x801de7 <pxCurrentTCB>
    1c54:	70 91 e8 1d 	lds	r23, 0x1DE8	; 0x801de8 <pxCurrentTCB+0x1>
    1c58:	6e 5f       	subi	r22, 0xFE	; 254
    1c5a:	7f 4f       	sbci	r23, 0xFF	; 255
    1c5c:	84 e7       	ldi	r24, 0x74	; 116
    1c5e:	9d e1       	ldi	r25, 0x1D	; 29
    1c60:	54 d9       	rcall	.-3416   	; 0xf0a <vListInsertEnd>
    1c62:	3d c0       	rjmp	.+122    	; 0x1cde <prvAddCurrentTaskToDelayedList+0xd2>
    1c64:	c8 0c       	add	r12, r8
    1c66:	d9 1c       	adc	r13, r9
    1c68:	ea 1c       	adc	r14, r10
    1c6a:	fb 1c       	adc	r15, r11
    1c6c:	e0 91 e7 1d 	lds	r30, 0x1DE7	; 0x801de7 <pxCurrentTCB>
    1c70:	f0 91 e8 1d 	lds	r31, 0x1DE8	; 0x801de8 <pxCurrentTCB+0x1>
    1c74:	c2 82       	std	Z+2, r12	; 0x02
    1c76:	d3 82       	std	Z+3, r13	; 0x03
    1c78:	e4 82       	std	Z+4, r14	; 0x04
    1c7a:	f5 82       	std	Z+5, r15	; 0x05
    1c7c:	c8 14       	cp	r12, r8
    1c7e:	d9 04       	cpc	r13, r9
    1c80:	ea 04       	cpc	r14, r10
    1c82:	fb 04       	cpc	r15, r11
    1c84:	60 f4       	brcc	.+24     	; 0x1c9e <prvAddCurrentTaskToDelayedList+0x92>
    1c86:	60 91 e7 1d 	lds	r22, 0x1DE7	; 0x801de7 <pxCurrentTCB>
    1c8a:	70 91 e8 1d 	lds	r23, 0x1DE8	; 0x801de8 <pxCurrentTCB+0x1>
    1c8e:	80 91 96 1d 	lds	r24, 0x1D96	; 0x801d96 <pxOverflowDelayedTaskList>
    1c92:	90 91 97 1d 	lds	r25, 0x1D97	; 0x801d97 <pxOverflowDelayedTaskList+0x1>
    1c96:	6e 5f       	subi	r22, 0xFE	; 254
    1c98:	7f 4f       	sbci	r23, 0xFF	; 255
    1c9a:	58 d9       	rcall	.-3408   	; 0xf4c <vListInsert>
    1c9c:	20 c0       	rjmp	.+64     	; 0x1cde <prvAddCurrentTaskToDelayedList+0xd2>
    1c9e:	60 91 e7 1d 	lds	r22, 0x1DE7	; 0x801de7 <pxCurrentTCB>
    1ca2:	70 91 e8 1d 	lds	r23, 0x1DE8	; 0x801de8 <pxCurrentTCB+0x1>
    1ca6:	80 91 98 1d 	lds	r24, 0x1D98	; 0x801d98 <pxDelayedTaskList>
    1caa:	90 91 99 1d 	lds	r25, 0x1D99	; 0x801d99 <pxDelayedTaskList+0x1>
    1cae:	6e 5f       	subi	r22, 0xFE	; 254
    1cb0:	7f 4f       	sbci	r23, 0xFF	; 255
    1cb2:	4c d9       	rcall	.-3432   	; 0xf4c <vListInsert>
    1cb4:	80 91 65 1d 	lds	r24, 0x1D65	; 0x801d65 <xNextTaskUnblockTime>
    1cb8:	90 91 66 1d 	lds	r25, 0x1D66	; 0x801d66 <xNextTaskUnblockTime+0x1>
    1cbc:	a0 91 67 1d 	lds	r26, 0x1D67	; 0x801d67 <xNextTaskUnblockTime+0x2>
    1cc0:	b0 91 68 1d 	lds	r27, 0x1D68	; 0x801d68 <xNextTaskUnblockTime+0x3>
    1cc4:	c8 16       	cp	r12, r24
    1cc6:	d9 06       	cpc	r13, r25
    1cc8:	ea 06       	cpc	r14, r26
    1cca:	fb 06       	cpc	r15, r27
    1ccc:	40 f4       	brcc	.+16     	; 0x1cde <prvAddCurrentTaskToDelayedList+0xd2>
    1cce:	c0 92 65 1d 	sts	0x1D65, r12	; 0x801d65 <xNextTaskUnblockTime>
    1cd2:	d0 92 66 1d 	sts	0x1D66, r13	; 0x801d66 <xNextTaskUnblockTime+0x1>
    1cd6:	e0 92 67 1d 	sts	0x1D67, r14	; 0x801d67 <xNextTaskUnblockTime+0x2>
    1cda:	f0 92 68 1d 	sts	0x1D68, r15	; 0x801d68 <xNextTaskUnblockTime+0x3>
    1cde:	cf 91       	pop	r28
    1ce0:	ff 90       	pop	r15
    1ce2:	ef 90       	pop	r14
    1ce4:	df 90       	pop	r13
    1ce6:	cf 90       	pop	r12
    1ce8:	bf 90       	pop	r11
    1cea:	af 90       	pop	r10
    1cec:	9f 90       	pop	r9
    1cee:	8f 90       	pop	r8
    1cf0:	08 95       	ret

00001cf2 <xTaskCreate>:
    1cf2:	4f 92       	push	r4
    1cf4:	5f 92       	push	r5
    1cf6:	6f 92       	push	r6
    1cf8:	7f 92       	push	r7
    1cfa:	8f 92       	push	r8
    1cfc:	9f 92       	push	r9
    1cfe:	af 92       	push	r10
    1d00:	bf 92       	push	r11
    1d02:	cf 92       	push	r12
    1d04:	df 92       	push	r13
    1d06:	ef 92       	push	r14
    1d08:	ff 92       	push	r15
    1d0a:	0f 93       	push	r16
    1d0c:	1f 93       	push	r17
    1d0e:	cf 93       	push	r28
    1d10:	df 93       	push	r29
    1d12:	4c 01       	movw	r8, r24
    1d14:	6b 01       	movw	r12, r22
    1d16:	5a 01       	movw	r10, r20
    1d18:	29 01       	movw	r4, r18
    1d1a:	ca 01       	movw	r24, r20
    1d1c:	c7 d9       	rcall	.-3186   	; 0x10ac <pvPortMalloc>
    1d1e:	3c 01       	movw	r6, r24
    1d20:	89 2b       	or	r24, r25
    1d22:	09 f4       	brne	.+2      	; 0x1d26 <xTaskCreate+0x34>
    1d24:	e1 c0       	rjmp	.+450    	; 0x1ee8 <xTaskCreate+0x1f6>
    1d26:	8a e3       	ldi	r24, 0x3A	; 58
    1d28:	90 e0       	ldi	r25, 0x00	; 0
    1d2a:	c0 d9       	rcall	.-3200   	; 0x10ac <pvPortMalloc>
    1d2c:	ec 01       	movw	r28, r24
    1d2e:	89 2b       	or	r24, r25
    1d30:	b1 f0       	breq	.+44     	; 0x1d5e <xTaskCreate+0x6c>
    1d32:	7c 8e       	std	Y+28, r7	; 0x1c
    1d34:	6b 8e       	std	Y+27, r6	; 0x1b
    1d36:	a5 01       	movw	r20, r10
    1d38:	65 ea       	ldi	r22, 0xA5	; 165
    1d3a:	70 e0       	ldi	r23, 0x00	; 0
    1d3c:	c3 01       	movw	r24, r6
    1d3e:	0e 94 39 2c 	call	0x5872	; 0x5872 <memset>
    1d42:	21 e0       	ldi	r18, 0x01	; 1
    1d44:	a2 1a       	sub	r10, r18
    1d46:	b1 08       	sbc	r11, r1
    1d48:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1d4a:	9c 8d       	ldd	r25, Y+28	; 0x1c
    1d4c:	a8 0e       	add	r10, r24
    1d4e:	b9 1e       	adc	r11, r25
    1d50:	d6 01       	movw	r26, r12
    1d52:	8c 91       	ld	r24, X
    1d54:	8d 8f       	std	Y+29, r24	; 0x1d
    1d56:	8c 91       	ld	r24, X
    1d58:	81 11       	cpse	r24, r1
    1d5a:	04 c0       	rjmp	.+8      	; 0x1d64 <xTaskCreate+0x72>
    1d5c:	17 c0       	rjmp	.+46     	; 0x1d8c <xTaskCreate+0x9a>
    1d5e:	c3 01       	movw	r24, r6
    1d60:	69 da       	rcall	.-2862   	; 0x1234 <vPortFree>
    1d62:	c2 c0       	rjmp	.+388    	; 0x1ee8 <xTaskCreate+0x1f6>
    1d64:	ae 01       	movw	r20, r28
    1d66:	42 5e       	subi	r20, 0xE2	; 226
    1d68:	5f 4f       	sbci	r21, 0xFF	; 255
    1d6a:	f6 01       	movw	r30, r12
    1d6c:	31 96       	adiw	r30, 0x01	; 1
    1d6e:	b4 e1       	ldi	r27, 0x14	; 20
    1d70:	cb 0e       	add	r12, r27
    1d72:	d1 1c       	adc	r13, r1
    1d74:	cf 01       	movw	r24, r30
    1d76:	21 91       	ld	r18, Z+
    1d78:	da 01       	movw	r26, r20
    1d7a:	2d 93       	st	X+, r18
    1d7c:	ad 01       	movw	r20, r26
    1d7e:	dc 01       	movw	r26, r24
    1d80:	8c 91       	ld	r24, X
    1d82:	88 23       	and	r24, r24
    1d84:	19 f0       	breq	.+6      	; 0x1d8c <xTaskCreate+0x9a>
    1d86:	ce 16       	cp	r12, r30
    1d88:	df 06       	cpc	r13, r31
    1d8a:	a1 f7       	brne	.-24     	; 0x1d74 <xTaskCreate+0x82>
    1d8c:	18 aa       	std	Y+48, r1	; 0x30
    1d8e:	05 30       	cpi	r16, 0x05	; 5
    1d90:	08 f0       	brcs	.+2      	; 0x1d94 <xTaskCreate+0xa2>
    1d92:	04 e0       	ldi	r16, 0x04	; 4
    1d94:	0a 8f       	std	Y+26, r16	; 0x1a
    1d96:	0b ab       	std	Y+51, r16	; 0x33
    1d98:	1c aa       	std	Y+52, r1	; 0x34
    1d9a:	6e 01       	movw	r12, r28
    1d9c:	b2 e0       	ldi	r27, 0x02	; 2
    1d9e:	cb 0e       	add	r12, r27
    1da0:	d1 1c       	adc	r13, r1
    1da2:	c6 01       	movw	r24, r12
    1da4:	ae d8       	rcall	.-3748   	; 0xf02 <vListInitialiseItem>
    1da6:	ce 01       	movw	r24, r28
    1da8:	0e 96       	adiw	r24, 0x0e	; 14
    1daa:	ab d8       	rcall	.-3754   	; 0xf02 <vListInitialiseItem>
    1dac:	db 87       	std	Y+11, r29	; 0x0b
    1dae:	ca 87       	std	Y+10, r28	; 0x0a
    1db0:	85 e0       	ldi	r24, 0x05	; 5
    1db2:	90 e0       	ldi	r25, 0x00	; 0
    1db4:	a0 e0       	ldi	r26, 0x00	; 0
    1db6:	b0 e0       	ldi	r27, 0x00	; 0
    1db8:	80 1b       	sub	r24, r16
    1dba:	91 09       	sbc	r25, r1
    1dbc:	a1 09       	sbc	r26, r1
    1dbe:	b1 09       	sbc	r27, r1
    1dc0:	8e 87       	std	Y+14, r24	; 0x0e
    1dc2:	9f 87       	std	Y+15, r25	; 0x0f
    1dc4:	a8 8b       	std	Y+16, r26	; 0x10
    1dc6:	b9 8b       	std	Y+17, r27	; 0x11
    1dc8:	df 8b       	std	Y+23, r29	; 0x17
    1dca:	ce 8b       	std	Y+22, r28	; 0x16
    1dcc:	1d aa       	std	Y+53, r1	; 0x35
    1dce:	1e aa       	std	Y+54, r1	; 0x36
    1dd0:	1f aa       	std	Y+55, r1	; 0x37
    1dd2:	18 ae       	std	Y+56, r1	; 0x38
    1dd4:	19 ae       	std	Y+57, r1	; 0x39
    1dd6:	a2 01       	movw	r20, r4
    1dd8:	b4 01       	movw	r22, r8
    1dda:	c5 01       	movw	r24, r10
    1ddc:	5a da       	rcall	.-2892   	; 0x1292 <pxPortInitialiseStack>
    1dde:	99 83       	std	Y+1, r25	; 0x01
    1de0:	88 83       	st	Y, r24
    1de2:	e1 14       	cp	r14, r1
    1de4:	f1 04       	cpc	r15, r1
    1de6:	19 f0       	breq	.+6      	; 0x1dee <xTaskCreate+0xfc>
    1de8:	f7 01       	movw	r30, r14
    1dea:	d1 83       	std	Z+1, r29	; 0x01
    1dec:	c0 83       	st	Z, r28
    1dee:	0f b6       	in	r0, 0x3f	; 63
    1df0:	f8 94       	cli
    1df2:	0f 92       	push	r0
    1df4:	80 91 73 1d 	lds	r24, 0x1D73	; 0x801d73 <uxCurrentNumberOfTasks>
    1df8:	8f 5f       	subi	r24, 0xFF	; 255
    1dfa:	80 93 73 1d 	sts	0x1D73, r24	; 0x801d73 <uxCurrentNumberOfTasks>
    1dfe:	80 91 e7 1d 	lds	r24, 0x1DE7	; 0x801de7 <pxCurrentTCB>
    1e02:	90 91 e8 1d 	lds	r25, 0x1DE8	; 0x801de8 <pxCurrentTCB+0x1>
    1e06:	89 2b       	or	r24, r25
    1e08:	a9 f5       	brne	.+106    	; 0x1e74 <xTaskCreate+0x182>
    1e0a:	d0 93 e8 1d 	sts	0x1DE8, r29	; 0x801de8 <pxCurrentTCB+0x1>
    1e0e:	c0 93 e7 1d 	sts	0x1DE7, r28	; 0x801de7 <pxCurrentTCB>
    1e12:	80 91 73 1d 	lds	r24, 0x1D73	; 0x801d73 <uxCurrentNumberOfTasks>
    1e16:	81 30       	cpi	r24, 0x01	; 1
    1e18:	09 f0       	breq	.+2      	; 0x1e1c <xTaskCreate+0x12a>
    1e1a:	3c c0       	rjmp	.+120    	; 0x1e94 <xTaskCreate+0x1a2>
    1e1c:	0f 2e       	mov	r0, r31
    1e1e:	f0 eb       	ldi	r31, 0xB0	; 176
    1e20:	ef 2e       	mov	r14, r31
    1e22:	fd e1       	ldi	r31, 0x1D	; 29
    1e24:	ff 2e       	mov	r15, r31
    1e26:	f0 2d       	mov	r31, r0
    1e28:	07 ee       	ldi	r16, 0xE7	; 231
    1e2a:	1d e1       	ldi	r17, 0x1D	; 29
    1e2c:	c7 01       	movw	r24, r14
    1e2e:	58 d8       	rcall	.-3920   	; 0xee0 <vListInitialise>
    1e30:	fb e0       	ldi	r31, 0x0B	; 11
    1e32:	ef 0e       	add	r14, r31
    1e34:	f1 1c       	adc	r15, r1
    1e36:	e0 16       	cp	r14, r16
    1e38:	f1 06       	cpc	r15, r17
    1e3a:	c1 f7       	brne	.-16     	; 0x1e2c <xTaskCreate+0x13a>
    1e3c:	85 ea       	ldi	r24, 0xA5	; 165
    1e3e:	9d e1       	ldi	r25, 0x1D	; 29
    1e40:	4f d8       	rcall	.-3938   	; 0xee0 <vListInitialise>
    1e42:	8a e9       	ldi	r24, 0x9A	; 154
    1e44:	9d e1       	ldi	r25, 0x1D	; 29
    1e46:	4c d8       	rcall	.-3944   	; 0xee0 <vListInitialise>
    1e48:	8b e8       	ldi	r24, 0x8B	; 139
    1e4a:	9d e1       	ldi	r25, 0x1D	; 29
    1e4c:	49 d8       	rcall	.-3950   	; 0xee0 <vListInitialise>
    1e4e:	80 e8       	ldi	r24, 0x80	; 128
    1e50:	9d e1       	ldi	r25, 0x1D	; 29
    1e52:	46 d8       	rcall	.-3956   	; 0xee0 <vListInitialise>
    1e54:	84 e7       	ldi	r24, 0x74	; 116
    1e56:	9d e1       	ldi	r25, 0x1D	; 29
    1e58:	43 d8       	rcall	.-3962   	; 0xee0 <vListInitialise>
    1e5a:	85 ea       	ldi	r24, 0xA5	; 165
    1e5c:	9d e1       	ldi	r25, 0x1D	; 29
    1e5e:	90 93 99 1d 	sts	0x1D99, r25	; 0x801d99 <pxDelayedTaskList+0x1>
    1e62:	80 93 98 1d 	sts	0x1D98, r24	; 0x801d98 <pxDelayedTaskList>
    1e66:	8a e9       	ldi	r24, 0x9A	; 154
    1e68:	9d e1       	ldi	r25, 0x1D	; 29
    1e6a:	90 93 97 1d 	sts	0x1D97, r25	; 0x801d97 <pxOverflowDelayedTaskList+0x1>
    1e6e:	80 93 96 1d 	sts	0x1D96, r24	; 0x801d96 <pxOverflowDelayedTaskList>
    1e72:	10 c0       	rjmp	.+32     	; 0x1e94 <xTaskCreate+0x1a2>
    1e74:	80 91 6d 1d 	lds	r24, 0x1D6D	; 0x801d6d <xSchedulerRunning>
    1e78:	81 11       	cpse	r24, r1
    1e7a:	0c c0       	rjmp	.+24     	; 0x1e94 <xTaskCreate+0x1a2>
    1e7c:	e0 91 e7 1d 	lds	r30, 0x1DE7	; 0x801de7 <pxCurrentTCB>
    1e80:	f0 91 e8 1d 	lds	r31, 0x1DE8	; 0x801de8 <pxCurrentTCB+0x1>
    1e84:	92 8d       	ldd	r25, Z+26	; 0x1a
    1e86:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1e88:	89 17       	cp	r24, r25
    1e8a:	20 f0       	brcs	.+8      	; 0x1e94 <xTaskCreate+0x1a2>
    1e8c:	d0 93 e8 1d 	sts	0x1DE8, r29	; 0x801de8 <pxCurrentTCB+0x1>
    1e90:	c0 93 e7 1d 	sts	0x1DE7, r28	; 0x801de7 <pxCurrentTCB>
    1e94:	80 91 69 1d 	lds	r24, 0x1D69	; 0x801d69 <uxTaskNumber>
    1e98:	8f 5f       	subi	r24, 0xFF	; 255
    1e9a:	80 93 69 1d 	sts	0x1D69, r24	; 0x801d69 <uxTaskNumber>
    1e9e:	89 ab       	std	Y+49, r24	; 0x31
    1ea0:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1ea2:	90 91 6e 1d 	lds	r25, 0x1D6E	; 0x801d6e <uxTopReadyPriority>
    1ea6:	98 17       	cp	r25, r24
    1ea8:	10 f4       	brcc	.+4      	; 0x1eae <xTaskCreate+0x1bc>
    1eaa:	80 93 6e 1d 	sts	0x1D6E, r24	; 0x801d6e <uxTopReadyPriority>
    1eae:	2b e0       	ldi	r18, 0x0B	; 11
    1eb0:	82 9f       	mul	r24, r18
    1eb2:	c0 01       	movw	r24, r0
    1eb4:	11 24       	eor	r1, r1
    1eb6:	b6 01       	movw	r22, r12
    1eb8:	80 55       	subi	r24, 0x50	; 80
    1eba:	92 4e       	sbci	r25, 0xE2	; 226
    1ebc:	26 d8       	rcall	.-4020   	; 0xf0a <vListInsertEnd>
    1ebe:	0f 90       	pop	r0
    1ec0:	0f be       	out	0x3f, r0	; 63
    1ec2:	80 91 6d 1d 	lds	r24, 0x1D6D	; 0x801d6d <xSchedulerRunning>
    1ec6:	88 23       	and	r24, r24
    1ec8:	59 f0       	breq	.+22     	; 0x1ee0 <xTaskCreate+0x1ee>
    1eca:	e0 91 e7 1d 	lds	r30, 0x1DE7	; 0x801de7 <pxCurrentTCB>
    1ece:	f0 91 e8 1d 	lds	r31, 0x1DE8	; 0x801de8 <pxCurrentTCB+0x1>
    1ed2:	92 8d       	ldd	r25, Z+26	; 0x1a
    1ed4:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1ed6:	98 17       	cp	r25, r24
    1ed8:	28 f4       	brcc	.+10     	; 0x1ee4 <xTaskCreate+0x1f2>
    1eda:	8d da       	rcall	.-2790   	; 0x13f6 <vPortYield>
    1edc:	81 e0       	ldi	r24, 0x01	; 1
    1ede:	05 c0       	rjmp	.+10     	; 0x1eea <xTaskCreate+0x1f8>
    1ee0:	81 e0       	ldi	r24, 0x01	; 1
    1ee2:	03 c0       	rjmp	.+6      	; 0x1eea <xTaskCreate+0x1f8>
    1ee4:	81 e0       	ldi	r24, 0x01	; 1
    1ee6:	01 c0       	rjmp	.+2      	; 0x1eea <xTaskCreate+0x1f8>
    1ee8:	8f ef       	ldi	r24, 0xFF	; 255
    1eea:	df 91       	pop	r29
    1eec:	cf 91       	pop	r28
    1eee:	1f 91       	pop	r17
    1ef0:	0f 91       	pop	r16
    1ef2:	ff 90       	pop	r15
    1ef4:	ef 90       	pop	r14
    1ef6:	df 90       	pop	r13
    1ef8:	cf 90       	pop	r12
    1efa:	bf 90       	pop	r11
    1efc:	af 90       	pop	r10
    1efe:	9f 90       	pop	r9
    1f00:	8f 90       	pop	r8
    1f02:	7f 90       	pop	r7
    1f04:	6f 90       	pop	r6
    1f06:	5f 90       	pop	r5
    1f08:	4f 90       	pop	r4
    1f0a:	08 95       	ret

00001f0c <xTaskResumeFromISR>:
    1f0c:	ef 92       	push	r14
    1f0e:	ff 92       	push	r15
    1f10:	1f 93       	push	r17
    1f12:	cf 93       	push	r28
    1f14:	df 93       	push	r29
    1f16:	fc 01       	movw	r30, r24
    1f18:	24 85       	ldd	r18, Z+12	; 0x0c
    1f1a:	35 85       	ldd	r19, Z+13	; 0x0d
    1f1c:	24 57       	subi	r18, 0x74	; 116
    1f1e:	3d 41       	sbci	r19, 0x1D	; 29
    1f20:	c1 f5       	brne	.+112    	; 0x1f92 <xTaskResumeFromISR+0x86>
    1f22:	fc 01       	movw	r30, r24
    1f24:	20 8d       	ldd	r18, Z+24	; 0x18
    1f26:	31 8d       	ldd	r19, Z+25	; 0x19
    1f28:	fd e1       	ldi	r31, 0x1D	; 29
    1f2a:	2b 38       	cpi	r18, 0x8B	; 139
    1f2c:	3f 07       	cpc	r19, r31
    1f2e:	99 f1       	breq	.+102    	; 0x1f96 <xTaskResumeFromISR+0x8a>
    1f30:	23 2b       	or	r18, r19
    1f32:	99 f5       	brne	.+102    	; 0x1f9a <xTaskResumeFromISR+0x8e>
    1f34:	ec 01       	movw	r28, r24
    1f36:	80 91 62 1d 	lds	r24, 0x1D62	; 0x801d62 <uxSchedulerSuspended>
    1f3a:	81 11       	cpse	r24, r1
    1f3c:	21 c0       	rjmp	.+66     	; 0x1f80 <xTaskResumeFromISR+0x74>
    1f3e:	e0 91 e7 1d 	lds	r30, 0x1DE7	; 0x801de7 <pxCurrentTCB>
    1f42:	f0 91 e8 1d 	lds	r31, 0x1DE8	; 0x801de8 <pxCurrentTCB+0x1>
    1f46:	11 e0       	ldi	r17, 0x01	; 1
    1f48:	9a 8d       	ldd	r25, Y+26	; 0x1a
    1f4a:	82 8d       	ldd	r24, Z+26	; 0x1a
    1f4c:	98 17       	cp	r25, r24
    1f4e:	08 f4       	brcc	.+2      	; 0x1f52 <xTaskResumeFromISR+0x46>
    1f50:	10 e0       	ldi	r17, 0x00	; 0
    1f52:	7e 01       	movw	r14, r28
    1f54:	22 e0       	ldi	r18, 0x02	; 2
    1f56:	e2 0e       	add	r14, r18
    1f58:	f1 1c       	adc	r15, r1
    1f5a:	c7 01       	movw	r24, r14
    1f5c:	34 d8       	rcall	.-3992   	; 0xfc6 <uxListRemove>
    1f5e:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1f60:	90 91 6e 1d 	lds	r25, 0x1D6E	; 0x801d6e <uxTopReadyPriority>
    1f64:	98 17       	cp	r25, r24
    1f66:	10 f4       	brcc	.+4      	; 0x1f6c <xTaskResumeFromISR+0x60>
    1f68:	80 93 6e 1d 	sts	0x1D6E, r24	; 0x801d6e <uxTopReadyPriority>
    1f6c:	4b e0       	ldi	r20, 0x0B	; 11
    1f6e:	84 9f       	mul	r24, r20
    1f70:	c0 01       	movw	r24, r0
    1f72:	11 24       	eor	r1, r1
    1f74:	b7 01       	movw	r22, r14
    1f76:	80 55       	subi	r24, 0x50	; 80
    1f78:	92 4e       	sbci	r25, 0xE2	; 226
    1f7a:	0e 94 85 07 	call	0xf0a	; 0xf0a <vListInsertEnd>
    1f7e:	0e c0       	rjmp	.+28     	; 0x1f9c <xTaskResumeFromISR+0x90>
    1f80:	be 01       	movw	r22, r28
    1f82:	62 5f       	subi	r22, 0xF2	; 242
    1f84:	7f 4f       	sbci	r23, 0xFF	; 255
    1f86:	8b e8       	ldi	r24, 0x8B	; 139
    1f88:	9d e1       	ldi	r25, 0x1D	; 29
    1f8a:	0e 94 85 07 	call	0xf0a	; 0xf0a <vListInsertEnd>
    1f8e:	10 e0       	ldi	r17, 0x00	; 0
    1f90:	05 c0       	rjmp	.+10     	; 0x1f9c <xTaskResumeFromISR+0x90>
    1f92:	10 e0       	ldi	r17, 0x00	; 0
    1f94:	03 c0       	rjmp	.+6      	; 0x1f9c <xTaskResumeFromISR+0x90>
    1f96:	10 e0       	ldi	r17, 0x00	; 0
    1f98:	01 c0       	rjmp	.+2      	; 0x1f9c <xTaskResumeFromISR+0x90>
    1f9a:	10 e0       	ldi	r17, 0x00	; 0
    1f9c:	81 2f       	mov	r24, r17
    1f9e:	df 91       	pop	r29
    1fa0:	cf 91       	pop	r28
    1fa2:	1f 91       	pop	r17
    1fa4:	ff 90       	pop	r15
    1fa6:	ef 90       	pop	r14
    1fa8:	08 95       	ret

00001faa <vTaskStartScheduler>:
    1faa:	ef 92       	push	r14
    1fac:	ff 92       	push	r15
    1fae:	0f 93       	push	r16
    1fb0:	0f 2e       	mov	r0, r31
    1fb2:	f3 e6       	ldi	r31, 0x63	; 99
    1fb4:	ef 2e       	mov	r14, r31
    1fb6:	fd e1       	ldi	r31, 0x1D	; 29
    1fb8:	ff 2e       	mov	r15, r31
    1fba:	f0 2d       	mov	r31, r0
    1fbc:	00 e0       	ldi	r16, 0x00	; 0
    1fbe:	20 e0       	ldi	r18, 0x00	; 0
    1fc0:	30 e0       	ldi	r19, 0x00	; 0
    1fc2:	40 e0       	ldi	r20, 0x00	; 0
    1fc4:	54 e0       	ldi	r21, 0x04	; 4
    1fc6:	6f e7       	ldi	r22, 0x7F	; 127
    1fc8:	72 e0       	ldi	r23, 0x02	; 2
    1fca:	82 e8       	ldi	r24, 0x82	; 130
    1fcc:	91 e1       	ldi	r25, 0x11	; 17
    1fce:	91 de       	rcall	.-734    	; 0x1cf2 <xTaskCreate>
    1fd0:	81 30       	cpi	r24, 0x01	; 1
    1fd2:	c1 f4       	brne	.+48     	; 0x2004 <vTaskStartScheduler+0x5a>
    1fd4:	f8 94       	cli
    1fd6:	8f ef       	ldi	r24, 0xFF	; 255
    1fd8:	9f ef       	ldi	r25, 0xFF	; 255
    1fda:	dc 01       	movw	r26, r24
    1fdc:	80 93 65 1d 	sts	0x1D65, r24	; 0x801d65 <xNextTaskUnblockTime>
    1fe0:	90 93 66 1d 	sts	0x1D66, r25	; 0x801d66 <xNextTaskUnblockTime+0x1>
    1fe4:	a0 93 67 1d 	sts	0x1D67, r26	; 0x801d67 <xNextTaskUnblockTime+0x2>
    1fe8:	b0 93 68 1d 	sts	0x1D68, r27	; 0x801d68 <xNextTaskUnblockTime+0x3>
    1fec:	81 e0       	ldi	r24, 0x01	; 1
    1fee:	80 93 6d 1d 	sts	0x1D6D, r24	; 0x801d6d <xSchedulerRunning>
    1ff2:	10 92 6f 1d 	sts	0x1D6F, r1	; 0x801d6f <xTickCount>
    1ff6:	10 92 70 1d 	sts	0x1D70, r1	; 0x801d70 <xTickCount+0x1>
    1ffa:	10 92 71 1d 	sts	0x1D71, r1	; 0x801d71 <xTickCount+0x2>
    1ffe:	10 92 72 1d 	sts	0x1D72, r1	; 0x801d72 <xTickCount+0x3>
    2002:	b9 d9       	rcall	.-3214   	; 0x1376 <xPortStartScheduler>
    2004:	0f 91       	pop	r16
    2006:	ff 90       	pop	r15
    2008:	ef 90       	pop	r14
    200a:	08 95       	ret

0000200c <vTaskSuspendAll>:
    200c:	80 91 62 1d 	lds	r24, 0x1D62	; 0x801d62 <uxSchedulerSuspended>
    2010:	8f 5f       	subi	r24, 0xFF	; 255
    2012:	80 93 62 1d 	sts	0x1D62, r24	; 0x801d62 <uxSchedulerSuspended>
    2016:	08 95       	ret

00002018 <xTaskGetTickCount>:
    2018:	0f b6       	in	r0, 0x3f	; 63
    201a:	f8 94       	cli
    201c:	0f 92       	push	r0
    201e:	60 91 6f 1d 	lds	r22, 0x1D6F	; 0x801d6f <xTickCount>
    2022:	70 91 70 1d 	lds	r23, 0x1D70	; 0x801d70 <xTickCount+0x1>
    2026:	80 91 71 1d 	lds	r24, 0x1D71	; 0x801d71 <xTickCount+0x2>
    202a:	90 91 72 1d 	lds	r25, 0x1D72	; 0x801d72 <xTickCount+0x3>
    202e:	0f 90       	pop	r0
    2030:	0f be       	out	0x3f, r0	; 63
    2032:	08 95       	ret

00002034 <xTaskIncrementTick>:
    2034:	9f 92       	push	r9
    2036:	af 92       	push	r10
    2038:	bf 92       	push	r11
    203a:	cf 92       	push	r12
    203c:	df 92       	push	r13
    203e:	ef 92       	push	r14
    2040:	ff 92       	push	r15
    2042:	0f 93       	push	r16
    2044:	1f 93       	push	r17
    2046:	cf 93       	push	r28
    2048:	df 93       	push	r29
    204a:	80 91 62 1d 	lds	r24, 0x1D62	; 0x801d62 <uxSchedulerSuspended>
    204e:	81 11       	cpse	r24, r1
    2050:	ad c0       	rjmp	.+346    	; 0x21ac <xTaskIncrementTick+0x178>
    2052:	c0 90 6f 1d 	lds	r12, 0x1D6F	; 0x801d6f <xTickCount>
    2056:	d0 90 70 1d 	lds	r13, 0x1D70	; 0x801d70 <xTickCount+0x1>
    205a:	e0 90 71 1d 	lds	r14, 0x1D71	; 0x801d71 <xTickCount+0x2>
    205e:	f0 90 72 1d 	lds	r15, 0x1D72	; 0x801d72 <xTickCount+0x3>
    2062:	8f ef       	ldi	r24, 0xFF	; 255
    2064:	c8 1a       	sub	r12, r24
    2066:	d8 0a       	sbc	r13, r24
    2068:	e8 0a       	sbc	r14, r24
    206a:	f8 0a       	sbc	r15, r24
    206c:	c0 92 6f 1d 	sts	0x1D6F, r12	; 0x801d6f <xTickCount>
    2070:	d0 92 70 1d 	sts	0x1D70, r13	; 0x801d70 <xTickCount+0x1>
    2074:	e0 92 71 1d 	sts	0x1D71, r14	; 0x801d71 <xTickCount+0x2>
    2078:	f0 92 72 1d 	sts	0x1D72, r15	; 0x801d72 <xTickCount+0x3>
    207c:	c1 14       	cp	r12, r1
    207e:	d1 04       	cpc	r13, r1
    2080:	e1 04       	cpc	r14, r1
    2082:	f1 04       	cpc	r15, r1
    2084:	b1 f4       	brne	.+44     	; 0x20b2 <xTaskIncrementTick+0x7e>
    2086:	80 91 98 1d 	lds	r24, 0x1D98	; 0x801d98 <pxDelayedTaskList>
    208a:	90 91 99 1d 	lds	r25, 0x1D99	; 0x801d99 <pxDelayedTaskList+0x1>
    208e:	20 91 96 1d 	lds	r18, 0x1D96	; 0x801d96 <pxOverflowDelayedTaskList>
    2092:	30 91 97 1d 	lds	r19, 0x1D97	; 0x801d97 <pxOverflowDelayedTaskList+0x1>
    2096:	30 93 99 1d 	sts	0x1D99, r19	; 0x801d99 <pxDelayedTaskList+0x1>
    209a:	20 93 98 1d 	sts	0x1D98, r18	; 0x801d98 <pxDelayedTaskList>
    209e:	90 93 97 1d 	sts	0x1D97, r25	; 0x801d97 <pxOverflowDelayedTaskList+0x1>
    20a2:	80 93 96 1d 	sts	0x1D96, r24	; 0x801d96 <pxOverflowDelayedTaskList>
    20a6:	80 91 6a 1d 	lds	r24, 0x1D6A	; 0x801d6a <xNumOfOverflows>
    20aa:	8f 5f       	subi	r24, 0xFF	; 255
    20ac:	80 93 6a 1d 	sts	0x1D6A, r24	; 0x801d6a <xNumOfOverflows>
    20b0:	83 dd       	rcall	.-1274   	; 0x1bb8 <prvResetNextTaskUnblockTime>
    20b2:	80 91 65 1d 	lds	r24, 0x1D65	; 0x801d65 <xNextTaskUnblockTime>
    20b6:	90 91 66 1d 	lds	r25, 0x1D66	; 0x801d66 <xNextTaskUnblockTime+0x1>
    20ba:	a0 91 67 1d 	lds	r26, 0x1D67	; 0x801d67 <xNextTaskUnblockTime+0x2>
    20be:	b0 91 68 1d 	lds	r27, 0x1D68	; 0x801d68 <xNextTaskUnblockTime+0x3>
    20c2:	c8 16       	cp	r12, r24
    20c4:	d9 06       	cpc	r13, r25
    20c6:	ea 06       	cpc	r14, r26
    20c8:	fb 06       	cpc	r15, r27
    20ca:	10 f4       	brcc	.+4      	; 0x20d0 <xTaskIncrementTick+0x9c>
    20cc:	b1 2c       	mov	r11, r1
    20ce:	5d c0       	rjmp	.+186    	; 0x218a <xTaskIncrementTick+0x156>
    20d0:	b1 2c       	mov	r11, r1
    20d2:	0f 2e       	mov	r0, r31
    20d4:	fb e0       	ldi	r31, 0x0B	; 11
    20d6:	af 2e       	mov	r10, r31
    20d8:	f0 2d       	mov	r31, r0
    20da:	99 24       	eor	r9, r9
    20dc:	93 94       	inc	r9
    20de:	e0 91 98 1d 	lds	r30, 0x1D98	; 0x801d98 <pxDelayedTaskList>
    20e2:	f0 91 99 1d 	lds	r31, 0x1D99	; 0x801d99 <pxDelayedTaskList+0x1>
    20e6:	80 81       	ld	r24, Z
    20e8:	81 11       	cpse	r24, r1
    20ea:	0c c0       	rjmp	.+24     	; 0x2104 <xTaskIncrementTick+0xd0>
    20ec:	8f ef       	ldi	r24, 0xFF	; 255
    20ee:	9f ef       	ldi	r25, 0xFF	; 255
    20f0:	dc 01       	movw	r26, r24
    20f2:	80 93 65 1d 	sts	0x1D65, r24	; 0x801d65 <xNextTaskUnblockTime>
    20f6:	90 93 66 1d 	sts	0x1D66, r25	; 0x801d66 <xNextTaskUnblockTime+0x1>
    20fa:	a0 93 67 1d 	sts	0x1D67, r26	; 0x801d67 <xNextTaskUnblockTime+0x2>
    20fe:	b0 93 68 1d 	sts	0x1D68, r27	; 0x801d68 <xNextTaskUnblockTime+0x3>
    2102:	43 c0       	rjmp	.+134    	; 0x218a <xTaskIncrementTick+0x156>
    2104:	e0 91 98 1d 	lds	r30, 0x1D98	; 0x801d98 <pxDelayedTaskList>
    2108:	f0 91 99 1d 	lds	r31, 0x1D99	; 0x801d99 <pxDelayedTaskList+0x1>
    210c:	07 80       	ldd	r0, Z+7	; 0x07
    210e:	f0 85       	ldd	r31, Z+8	; 0x08
    2110:	e0 2d       	mov	r30, r0
    2112:	c0 85       	ldd	r28, Z+8	; 0x08
    2114:	d1 85       	ldd	r29, Z+9	; 0x09
    2116:	8a 81       	ldd	r24, Y+2	; 0x02
    2118:	9b 81       	ldd	r25, Y+3	; 0x03
    211a:	ac 81       	ldd	r26, Y+4	; 0x04
    211c:	bd 81       	ldd	r27, Y+5	; 0x05
    211e:	c8 16       	cp	r12, r24
    2120:	d9 06       	cpc	r13, r25
    2122:	ea 06       	cpc	r14, r26
    2124:	fb 06       	cpc	r15, r27
    2126:	48 f4       	brcc	.+18     	; 0x213a <xTaskIncrementTick+0x106>
    2128:	80 93 65 1d 	sts	0x1D65, r24	; 0x801d65 <xNextTaskUnblockTime>
    212c:	90 93 66 1d 	sts	0x1D66, r25	; 0x801d66 <xNextTaskUnblockTime+0x1>
    2130:	a0 93 67 1d 	sts	0x1D67, r26	; 0x801d67 <xNextTaskUnblockTime+0x2>
    2134:	b0 93 68 1d 	sts	0x1D68, r27	; 0x801d68 <xNextTaskUnblockTime+0x3>
    2138:	28 c0       	rjmp	.+80     	; 0x218a <xTaskIncrementTick+0x156>
    213a:	8e 01       	movw	r16, r28
    213c:	0e 5f       	subi	r16, 0xFE	; 254
    213e:	1f 4f       	sbci	r17, 0xFF	; 255
    2140:	c8 01       	movw	r24, r16
    2142:	0e 94 e3 07 	call	0xfc6	; 0xfc6 <uxListRemove>
    2146:	88 8d       	ldd	r24, Y+24	; 0x18
    2148:	99 8d       	ldd	r25, Y+25	; 0x19
    214a:	89 2b       	or	r24, r25
    214c:	21 f0       	breq	.+8      	; 0x2156 <xTaskIncrementTick+0x122>
    214e:	ce 01       	movw	r24, r28
    2150:	0e 96       	adiw	r24, 0x0e	; 14
    2152:	0e 94 e3 07 	call	0xfc6	; 0xfc6 <uxListRemove>
    2156:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2158:	90 91 6e 1d 	lds	r25, 0x1D6E	; 0x801d6e <uxTopReadyPriority>
    215c:	98 17       	cp	r25, r24
    215e:	10 f4       	brcc	.+4      	; 0x2164 <xTaskIncrementTick+0x130>
    2160:	80 93 6e 1d 	sts	0x1D6E, r24	; 0x801d6e <uxTopReadyPriority>
    2164:	a8 9e       	mul	r10, r24
    2166:	c0 01       	movw	r24, r0
    2168:	11 24       	eor	r1, r1
    216a:	b8 01       	movw	r22, r16
    216c:	80 55       	subi	r24, 0x50	; 80
    216e:	92 4e       	sbci	r25, 0xE2	; 226
    2170:	0e 94 85 07 	call	0xf0a	; 0xf0a <vListInsertEnd>
    2174:	e0 91 e7 1d 	lds	r30, 0x1DE7	; 0x801de7 <pxCurrentTCB>
    2178:	f0 91 e8 1d 	lds	r31, 0x1DE8	; 0x801de8 <pxCurrentTCB+0x1>
    217c:	9a 8d       	ldd	r25, Y+26	; 0x1a
    217e:	82 8d       	ldd	r24, Z+26	; 0x1a
    2180:	98 17       	cp	r25, r24
    2182:	08 f4       	brcc	.+2      	; 0x2186 <xTaskIncrementTick+0x152>
    2184:	ac cf       	rjmp	.-168    	; 0x20de <xTaskIncrementTick+0xaa>
    2186:	b9 2c       	mov	r11, r9
    2188:	aa cf       	rjmp	.-172    	; 0x20de <xTaskIncrementTick+0xaa>
    218a:	e0 91 e7 1d 	lds	r30, 0x1DE7	; 0x801de7 <pxCurrentTCB>
    218e:	f0 91 e8 1d 	lds	r31, 0x1DE8	; 0x801de8 <pxCurrentTCB+0x1>
    2192:	e2 8d       	ldd	r30, Z+26	; 0x1a
    2194:	8b e0       	ldi	r24, 0x0B	; 11
    2196:	e8 9f       	mul	r30, r24
    2198:	f0 01       	movw	r30, r0
    219a:	11 24       	eor	r1, r1
    219c:	e0 55       	subi	r30, 0x50	; 80
    219e:	f2 4e       	sbci	r31, 0xE2	; 226
    21a0:	80 81       	ld	r24, Z
    21a2:	82 30       	cpi	r24, 0x02	; 2
    21a4:	48 f0       	brcs	.+18     	; 0x21b8 <xTaskIncrementTick+0x184>
    21a6:	bb 24       	eor	r11, r11
    21a8:	b3 94       	inc	r11
    21aa:	06 c0       	rjmp	.+12     	; 0x21b8 <xTaskIncrementTick+0x184>
    21ac:	80 91 6c 1d 	lds	r24, 0x1D6C	; 0x801d6c <uxPendedTicks>
    21b0:	8f 5f       	subi	r24, 0xFF	; 255
    21b2:	80 93 6c 1d 	sts	0x1D6C, r24	; 0x801d6c <uxPendedTicks>
    21b6:	b1 2c       	mov	r11, r1
    21b8:	80 91 6b 1d 	lds	r24, 0x1D6B	; 0x801d6b <xYieldPending>
    21bc:	88 23       	and	r24, r24
    21be:	11 f0       	breq	.+4      	; 0x21c4 <xTaskIncrementTick+0x190>
    21c0:	bb 24       	eor	r11, r11
    21c2:	b3 94       	inc	r11
    21c4:	8b 2d       	mov	r24, r11
    21c6:	df 91       	pop	r29
    21c8:	cf 91       	pop	r28
    21ca:	1f 91       	pop	r17
    21cc:	0f 91       	pop	r16
    21ce:	ff 90       	pop	r15
    21d0:	ef 90       	pop	r14
    21d2:	df 90       	pop	r13
    21d4:	cf 90       	pop	r12
    21d6:	bf 90       	pop	r11
    21d8:	af 90       	pop	r10
    21da:	9f 90       	pop	r9
    21dc:	08 95       	ret

000021de <xTaskResumeAll>:
    21de:	cf 92       	push	r12
    21e0:	df 92       	push	r13
    21e2:	ef 92       	push	r14
    21e4:	ff 92       	push	r15
    21e6:	0f 93       	push	r16
    21e8:	1f 93       	push	r17
    21ea:	cf 93       	push	r28
    21ec:	df 93       	push	r29
    21ee:	0f b6       	in	r0, 0x3f	; 63
    21f0:	f8 94       	cli
    21f2:	0f 92       	push	r0
    21f4:	80 91 62 1d 	lds	r24, 0x1D62	; 0x801d62 <uxSchedulerSuspended>
    21f8:	81 50       	subi	r24, 0x01	; 1
    21fa:	80 93 62 1d 	sts	0x1D62, r24	; 0x801d62 <uxSchedulerSuspended>
    21fe:	80 91 62 1d 	lds	r24, 0x1D62	; 0x801d62 <uxSchedulerSuspended>
    2202:	81 11       	cpse	r24, r1
    2204:	59 c0       	rjmp	.+178    	; 0x22b8 <__stack+0xb9>
    2206:	80 91 73 1d 	lds	r24, 0x1D73	; 0x801d73 <uxCurrentNumberOfTasks>
    220a:	81 11       	cpse	r24, r1
    220c:	2c c0       	rjmp	.+88     	; 0x2266 <__stack+0x67>
    220e:	57 c0       	rjmp	.+174    	; 0x22be <__stack+0xbf>
    2210:	d7 01       	movw	r26, r14
    2212:	17 96       	adiw	r26, 0x07	; 7
    2214:	ed 91       	ld	r30, X+
    2216:	fc 91       	ld	r31, X
    2218:	18 97       	sbiw	r26, 0x08	; 8
    221a:	c0 85       	ldd	r28, Z+8	; 0x08
    221c:	d1 85       	ldd	r29, Z+9	; 0x09
    221e:	ce 01       	movw	r24, r28
    2220:	0e 96       	adiw	r24, 0x0e	; 14
    2222:	0e 94 e3 07 	call	0xfc6	; 0xfc6 <uxListRemove>
    2226:	8e 01       	movw	r16, r28
    2228:	0e 5f       	subi	r16, 0xFE	; 254
    222a:	1f 4f       	sbci	r17, 0xFF	; 255
    222c:	c8 01       	movw	r24, r16
    222e:	0e 94 e3 07 	call	0xfc6	; 0xfc6 <uxListRemove>
    2232:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2234:	90 91 6e 1d 	lds	r25, 0x1D6E	; 0x801d6e <uxTopReadyPriority>
    2238:	98 17       	cp	r25, r24
    223a:	10 f4       	brcc	.+4      	; 0x2240 <__stack+0x41>
    223c:	80 93 6e 1d 	sts	0x1D6E, r24	; 0x801d6e <uxTopReadyPriority>
    2240:	d8 9e       	mul	r13, r24
    2242:	c0 01       	movw	r24, r0
    2244:	11 24       	eor	r1, r1
    2246:	b8 01       	movw	r22, r16
    2248:	80 55       	subi	r24, 0x50	; 80
    224a:	92 4e       	sbci	r25, 0xE2	; 226
    224c:	0e 94 85 07 	call	0xf0a	; 0xf0a <vListInsertEnd>
    2250:	e0 91 e7 1d 	lds	r30, 0x1DE7	; 0x801de7 <pxCurrentTCB>
    2254:	f0 91 e8 1d 	lds	r31, 0x1DE8	; 0x801de8 <pxCurrentTCB+0x1>
    2258:	9a 8d       	ldd	r25, Y+26	; 0x1a
    225a:	82 8d       	ldd	r24, Z+26	; 0x1a
    225c:	98 17       	cp	r25, r24
    225e:	88 f0       	brcs	.+34     	; 0x2282 <__stack+0x83>
    2260:	c0 92 6b 1d 	sts	0x1D6B, r12	; 0x801d6b <xYieldPending>
    2264:	0e c0       	rjmp	.+28     	; 0x2282 <__stack+0x83>
    2266:	c0 e0       	ldi	r28, 0x00	; 0
    2268:	d0 e0       	ldi	r29, 0x00	; 0
    226a:	0f 2e       	mov	r0, r31
    226c:	fb e8       	ldi	r31, 0x8B	; 139
    226e:	ef 2e       	mov	r14, r31
    2270:	fd e1       	ldi	r31, 0x1D	; 29
    2272:	ff 2e       	mov	r15, r31
    2274:	f0 2d       	mov	r31, r0
    2276:	0f 2e       	mov	r0, r31
    2278:	fb e0       	ldi	r31, 0x0B	; 11
    227a:	df 2e       	mov	r13, r31
    227c:	f0 2d       	mov	r31, r0
    227e:	cc 24       	eor	r12, r12
    2280:	c3 94       	inc	r12
    2282:	f7 01       	movw	r30, r14
    2284:	80 81       	ld	r24, Z
    2286:	81 11       	cpse	r24, r1
    2288:	c3 cf       	rjmp	.-122    	; 0x2210 <__stack+0x11>
    228a:	cd 2b       	or	r28, r29
    228c:	09 f0       	breq	.+2      	; 0x2290 <__stack+0x91>
    228e:	94 dc       	rcall	.-1752   	; 0x1bb8 <prvResetNextTaskUnblockTime>
    2290:	c0 91 6c 1d 	lds	r28, 0x1D6C	; 0x801d6c <uxPendedTicks>
    2294:	cc 23       	and	r28, r28
    2296:	49 f0       	breq	.+18     	; 0x22aa <__stack+0xab>
    2298:	d1 e0       	ldi	r29, 0x01	; 1
    229a:	cc de       	rcall	.-616    	; 0x2034 <xTaskIncrementTick>
    229c:	81 11       	cpse	r24, r1
    229e:	d0 93 6b 1d 	sts	0x1D6B, r29	; 0x801d6b <xYieldPending>
    22a2:	c1 50       	subi	r28, 0x01	; 1
    22a4:	d1 f7       	brne	.-12     	; 0x229a <__stack+0x9b>
    22a6:	10 92 6c 1d 	sts	0x1D6C, r1	; 0x801d6c <uxPendedTicks>
    22aa:	80 91 6b 1d 	lds	r24, 0x1D6B	; 0x801d6b <xYieldPending>
    22ae:	88 23       	and	r24, r24
    22b0:	29 f0       	breq	.+10     	; 0x22bc <__stack+0xbd>
    22b2:	a1 d8       	rcall	.-3774   	; 0x13f6 <vPortYield>
    22b4:	81 e0       	ldi	r24, 0x01	; 1
    22b6:	03 c0       	rjmp	.+6      	; 0x22be <__stack+0xbf>
    22b8:	80 e0       	ldi	r24, 0x00	; 0
    22ba:	01 c0       	rjmp	.+2      	; 0x22be <__stack+0xbf>
    22bc:	80 e0       	ldi	r24, 0x00	; 0
    22be:	0f 90       	pop	r0
    22c0:	0f be       	out	0x3f, r0	; 63
    22c2:	df 91       	pop	r29
    22c4:	cf 91       	pop	r28
    22c6:	1f 91       	pop	r17
    22c8:	0f 91       	pop	r16
    22ca:	ff 90       	pop	r15
    22cc:	ef 90       	pop	r14
    22ce:	df 90       	pop	r13
    22d0:	cf 90       	pop	r12
    22d2:	08 95       	ret

000022d4 <vTaskDelay>:
    22d4:	cf 92       	push	r12
    22d6:	df 92       	push	r13
    22d8:	ef 92       	push	r14
    22da:	ff 92       	push	r15
    22dc:	6b 01       	movw	r12, r22
    22de:	7c 01       	movw	r14, r24
    22e0:	67 2b       	or	r22, r23
    22e2:	68 2b       	or	r22, r24
    22e4:	69 2b       	or	r22, r25
    22e6:	41 f0       	breq	.+16     	; 0x22f8 <vTaskDelay+0x24>
    22e8:	91 de       	rcall	.-734    	; 0x200c <vTaskSuspendAll>
    22ea:	40 e0       	ldi	r20, 0x00	; 0
    22ec:	c7 01       	movw	r24, r14
    22ee:	b6 01       	movw	r22, r12
    22f0:	8d dc       	rcall	.-1766   	; 0x1c0c <prvAddCurrentTaskToDelayedList>
    22f2:	75 df       	rcall	.-278    	; 0x21de <xTaskResumeAll>
    22f4:	81 11       	cpse	r24, r1
    22f6:	01 c0       	rjmp	.+2      	; 0x22fa <vTaskDelay+0x26>
    22f8:	7e d8       	rcall	.-3844   	; 0x13f6 <vPortYield>
    22fa:	ff 90       	pop	r15
    22fc:	ef 90       	pop	r14
    22fe:	df 90       	pop	r13
    2300:	cf 90       	pop	r12
    2302:	08 95       	ret

00002304 <prvIdleTask>:
    2304:	00 e8       	ldi	r16, 0x80	; 128
    2306:	1d e1       	ldi	r17, 0x1D	; 29
    2308:	0f 2e       	mov	r0, r31
    230a:	f0 eb       	ldi	r31, 0xB0	; 176
    230c:	ef 2e       	mov	r14, r31
    230e:	fd e1       	ldi	r31, 0x1D	; 29
    2310:	ff 2e       	mov	r15, r31
    2312:	f0 2d       	mov	r31, r0
    2314:	27 c0       	rjmp	.+78     	; 0x2364 <prvIdleTask+0x60>
    2316:	7a de       	rcall	.-780    	; 0x200c <vTaskSuspendAll>
    2318:	d8 01       	movw	r26, r16
    231a:	cc 91       	ld	r28, X
    231c:	60 df       	rcall	.-320    	; 0x21de <xTaskResumeAll>
    231e:	cc 23       	and	r28, r28
    2320:	09 f1       	breq	.+66     	; 0x2364 <prvIdleTask+0x60>
    2322:	0f b6       	in	r0, 0x3f	; 63
    2324:	f8 94       	cli
    2326:	0f 92       	push	r0
    2328:	d8 01       	movw	r26, r16
    232a:	17 96       	adiw	r26, 0x07	; 7
    232c:	ed 91       	ld	r30, X+
    232e:	fc 91       	ld	r31, X
    2330:	18 97       	sbiw	r26, 0x08	; 8
    2332:	c0 85       	ldd	r28, Z+8	; 0x08
    2334:	d1 85       	ldd	r29, Z+9	; 0x09
    2336:	ce 01       	movw	r24, r28
    2338:	02 96       	adiw	r24, 0x02	; 2
    233a:	0e 94 e3 07 	call	0xfc6	; 0xfc6 <uxListRemove>
    233e:	80 91 73 1d 	lds	r24, 0x1D73	; 0x801d73 <uxCurrentNumberOfTasks>
    2342:	81 50       	subi	r24, 0x01	; 1
    2344:	80 93 73 1d 	sts	0x1D73, r24	; 0x801d73 <uxCurrentNumberOfTasks>
    2348:	80 91 7f 1d 	lds	r24, 0x1D7F	; 0x801d7f <uxDeletedTasksWaitingCleanUp>
    234c:	81 50       	subi	r24, 0x01	; 1
    234e:	80 93 7f 1d 	sts	0x1D7F, r24	; 0x801d7f <uxDeletedTasksWaitingCleanUp>
    2352:	0f 90       	pop	r0
    2354:	0f be       	out	0x3f, r0	; 63
    2356:	8b 8d       	ldd	r24, Y+27	; 0x1b
    2358:	9c 8d       	ldd	r25, Y+28	; 0x1c
    235a:	0e 94 1a 09 	call	0x1234	; 0x1234 <vPortFree>
    235e:	ce 01       	movw	r24, r28
    2360:	0e 94 1a 09 	call	0x1234	; 0x1234 <vPortFree>
    2364:	80 91 7f 1d 	lds	r24, 0x1D7F	; 0x801d7f <uxDeletedTasksWaitingCleanUp>
    2368:	81 11       	cpse	r24, r1
    236a:	d5 cf       	rjmp	.-86     	; 0x2316 <prvIdleTask+0x12>
    236c:	f7 01       	movw	r30, r14
    236e:	80 81       	ld	r24, Z
    2370:	82 30       	cpi	r24, 0x02	; 2
    2372:	c0 f3       	brcs	.-16     	; 0x2364 <prvIdleTask+0x60>
    2374:	40 d8       	rcall	.-3968   	; 0x13f6 <vPortYield>
    2376:	f6 cf       	rjmp	.-20     	; 0x2364 <prvIdleTask+0x60>

00002378 <vTaskSwitchContext>:
    2378:	80 91 62 1d 	lds	r24, 0x1D62	; 0x801d62 <uxSchedulerSuspended>
    237c:	88 23       	and	r24, r24
    237e:	21 f0       	breq	.+8      	; 0x2388 <vTaskSwitchContext+0x10>
    2380:	81 e0       	ldi	r24, 0x01	; 1
    2382:	80 93 6b 1d 	sts	0x1D6B, r24	; 0x801d6b <xYieldPending>
    2386:	08 95       	ret
    2388:	10 92 6b 1d 	sts	0x1D6B, r1	; 0x801d6b <xYieldPending>
    238c:	80 91 6e 1d 	lds	r24, 0x1D6E	; 0x801d6e <uxTopReadyPriority>
    2390:	28 2f       	mov	r18, r24
    2392:	30 e0       	ldi	r19, 0x00	; 0
    2394:	9b e0       	ldi	r25, 0x0B	; 11
    2396:	89 9f       	mul	r24, r25
    2398:	f0 01       	movw	r30, r0
    239a:	11 24       	eor	r1, r1
    239c:	e0 55       	subi	r30, 0x50	; 80
    239e:	f2 4e       	sbci	r31, 0xE2	; 226
    23a0:	90 81       	ld	r25, Z
    23a2:	91 11       	cpse	r25, r1
    23a4:	0e c0       	rjmp	.+28     	; 0x23c2 <vTaskSwitchContext+0x4a>
    23a6:	4b e0       	ldi	r20, 0x0B	; 11
    23a8:	81 50       	subi	r24, 0x01	; 1
    23aa:	28 2f       	mov	r18, r24
    23ac:	30 e0       	ldi	r19, 0x00	; 0
    23ae:	42 9f       	mul	r20, r18
    23b0:	f0 01       	movw	r30, r0
    23b2:	43 9f       	mul	r20, r19
    23b4:	f0 0d       	add	r31, r0
    23b6:	11 24       	eor	r1, r1
    23b8:	e0 55       	subi	r30, 0x50	; 80
    23ba:	f2 4e       	sbci	r31, 0xE2	; 226
    23bc:	90 81       	ld	r25, Z
    23be:	99 23       	and	r25, r25
    23c0:	99 f3       	breq	.-26     	; 0x23a8 <vTaskSwitchContext+0x30>
    23c2:	9b e0       	ldi	r25, 0x0B	; 11
    23c4:	92 9f       	mul	r25, r18
    23c6:	a0 01       	movw	r20, r0
    23c8:	93 9f       	mul	r25, r19
    23ca:	50 0d       	add	r21, r0
    23cc:	11 24       	eor	r1, r1
    23ce:	da 01       	movw	r26, r20
    23d0:	a0 55       	subi	r26, 0x50	; 80
    23d2:	b2 4e       	sbci	r27, 0xE2	; 226
    23d4:	11 96       	adiw	r26, 0x01	; 1
    23d6:	ed 91       	ld	r30, X+
    23d8:	fc 91       	ld	r31, X
    23da:	12 97       	sbiw	r26, 0x02	; 2
    23dc:	04 80       	ldd	r0, Z+4	; 0x04
    23de:	f5 81       	ldd	r31, Z+5	; 0x05
    23e0:	e0 2d       	mov	r30, r0
    23e2:	12 96       	adiw	r26, 0x02	; 2
    23e4:	fc 93       	st	X, r31
    23e6:	ee 93       	st	-X, r30
    23e8:	11 97       	sbiw	r26, 0x01	; 1
    23ea:	4d 54       	subi	r20, 0x4D	; 77
    23ec:	52 4e       	sbci	r21, 0xE2	; 226
    23ee:	e4 17       	cp	r30, r20
    23f0:	f5 07       	cpc	r31, r21
    23f2:	29 f4       	brne	.+10     	; 0x23fe <vTaskSwitchContext+0x86>
    23f4:	44 81       	ldd	r20, Z+4	; 0x04
    23f6:	55 81       	ldd	r21, Z+5	; 0x05
    23f8:	fd 01       	movw	r30, r26
    23fa:	52 83       	std	Z+2, r21	; 0x02
    23fc:	41 83       	std	Z+1, r20	; 0x01
    23fe:	9b e0       	ldi	r25, 0x0B	; 11
    2400:	92 9f       	mul	r25, r18
    2402:	f0 01       	movw	r30, r0
    2404:	93 9f       	mul	r25, r19
    2406:	f0 0d       	add	r31, r0
    2408:	11 24       	eor	r1, r1
    240a:	e0 55       	subi	r30, 0x50	; 80
    240c:	f2 4e       	sbci	r31, 0xE2	; 226
    240e:	01 80       	ldd	r0, Z+1	; 0x01
    2410:	f2 81       	ldd	r31, Z+2	; 0x02
    2412:	e0 2d       	mov	r30, r0
    2414:	20 85       	ldd	r18, Z+8	; 0x08
    2416:	31 85       	ldd	r19, Z+9	; 0x09
    2418:	30 93 e8 1d 	sts	0x1DE8, r19	; 0x801de8 <pxCurrentTCB+0x1>
    241c:	20 93 e7 1d 	sts	0x1DE7, r18	; 0x801de7 <pxCurrentTCB>
    2420:	80 93 6e 1d 	sts	0x1D6E, r24	; 0x801d6e <uxTopReadyPriority>
    2424:	08 95       	ret

00002426 <vTaskPlaceOnEventList>:
    2426:	cf 92       	push	r12
    2428:	df 92       	push	r13
    242a:	ef 92       	push	r14
    242c:	ff 92       	push	r15
    242e:	6a 01       	movw	r12, r20
    2430:	7b 01       	movw	r14, r22
    2432:	60 91 e7 1d 	lds	r22, 0x1DE7	; 0x801de7 <pxCurrentTCB>
    2436:	70 91 e8 1d 	lds	r23, 0x1DE8	; 0x801de8 <pxCurrentTCB+0x1>
    243a:	62 5f       	subi	r22, 0xF2	; 242
    243c:	7f 4f       	sbci	r23, 0xFF	; 255
    243e:	0e 94 a6 07 	call	0xf4c	; 0xf4c <vListInsert>
    2442:	41 e0       	ldi	r20, 0x01	; 1
    2444:	c7 01       	movw	r24, r14
    2446:	b6 01       	movw	r22, r12
    2448:	e1 db       	rcall	.-2110   	; 0x1c0c <prvAddCurrentTaskToDelayedList>
    244a:	ff 90       	pop	r15
    244c:	ef 90       	pop	r14
    244e:	df 90       	pop	r13
    2450:	cf 90       	pop	r12
    2452:	08 95       	ret

00002454 <xTaskRemoveFromEventList>:
    2454:	0f 93       	push	r16
    2456:	1f 93       	push	r17
    2458:	cf 93       	push	r28
    245a:	df 93       	push	r29
    245c:	dc 01       	movw	r26, r24
    245e:	17 96       	adiw	r26, 0x07	; 7
    2460:	ed 91       	ld	r30, X+
    2462:	fc 91       	ld	r31, X
    2464:	18 97       	sbiw	r26, 0x08	; 8
    2466:	c0 85       	ldd	r28, Z+8	; 0x08
    2468:	d1 85       	ldd	r29, Z+9	; 0x09
    246a:	8e 01       	movw	r16, r28
    246c:	02 5f       	subi	r16, 0xF2	; 242
    246e:	1f 4f       	sbci	r17, 0xFF	; 255
    2470:	c8 01       	movw	r24, r16
    2472:	0e 94 e3 07 	call	0xfc6	; 0xfc6 <uxListRemove>
    2476:	80 91 62 1d 	lds	r24, 0x1D62	; 0x801d62 <uxSchedulerSuspended>
    247a:	81 11       	cpse	r24, r1
    247c:	16 c0       	rjmp	.+44     	; 0x24aa <xTaskRemoveFromEventList+0x56>
    247e:	0c 50       	subi	r16, 0x0C	; 12
    2480:	11 09       	sbc	r17, r1
    2482:	c8 01       	movw	r24, r16
    2484:	0e 94 e3 07 	call	0xfc6	; 0xfc6 <uxListRemove>
    2488:	8a 8d       	ldd	r24, Y+26	; 0x1a
    248a:	90 91 6e 1d 	lds	r25, 0x1D6E	; 0x801d6e <uxTopReadyPriority>
    248e:	98 17       	cp	r25, r24
    2490:	10 f4       	brcc	.+4      	; 0x2496 <xTaskRemoveFromEventList+0x42>
    2492:	80 93 6e 1d 	sts	0x1D6E, r24	; 0x801d6e <uxTopReadyPriority>
    2496:	bb e0       	ldi	r27, 0x0B	; 11
    2498:	8b 9f       	mul	r24, r27
    249a:	c0 01       	movw	r24, r0
    249c:	11 24       	eor	r1, r1
    249e:	b8 01       	movw	r22, r16
    24a0:	80 55       	subi	r24, 0x50	; 80
    24a2:	92 4e       	sbci	r25, 0xE2	; 226
    24a4:	0e 94 85 07 	call	0xf0a	; 0xf0a <vListInsertEnd>
    24a8:	05 c0       	rjmp	.+10     	; 0x24b4 <xTaskRemoveFromEventList+0x60>
    24aa:	b8 01       	movw	r22, r16
    24ac:	8b e8       	ldi	r24, 0x8B	; 139
    24ae:	9d e1       	ldi	r25, 0x1D	; 29
    24b0:	0e 94 85 07 	call	0xf0a	; 0xf0a <vListInsertEnd>
    24b4:	e0 91 e7 1d 	lds	r30, 0x1DE7	; 0x801de7 <pxCurrentTCB>
    24b8:	f0 91 e8 1d 	lds	r31, 0x1DE8	; 0x801de8 <pxCurrentTCB+0x1>
    24bc:	9a 8d       	ldd	r25, Y+26	; 0x1a
    24be:	82 8d       	ldd	r24, Z+26	; 0x1a
    24c0:	89 17       	cp	r24, r25
    24c2:	20 f4       	brcc	.+8      	; 0x24cc <xTaskRemoveFromEventList+0x78>
    24c4:	81 e0       	ldi	r24, 0x01	; 1
    24c6:	80 93 6b 1d 	sts	0x1D6B, r24	; 0x801d6b <xYieldPending>
    24ca:	01 c0       	rjmp	.+2      	; 0x24ce <xTaskRemoveFromEventList+0x7a>
    24cc:	80 e0       	ldi	r24, 0x00	; 0
    24ce:	df 91       	pop	r29
    24d0:	cf 91       	pop	r28
    24d2:	1f 91       	pop	r17
    24d4:	0f 91       	pop	r16
    24d6:	08 95       	ret

000024d8 <vTaskSetTimeOutState>:
    24d8:	20 91 6a 1d 	lds	r18, 0x1D6A	; 0x801d6a <xNumOfOverflows>
    24dc:	fc 01       	movw	r30, r24
    24de:	20 83       	st	Z, r18
    24e0:	40 91 6f 1d 	lds	r20, 0x1D6F	; 0x801d6f <xTickCount>
    24e4:	50 91 70 1d 	lds	r21, 0x1D70	; 0x801d70 <xTickCount+0x1>
    24e8:	60 91 71 1d 	lds	r22, 0x1D71	; 0x801d71 <xTickCount+0x2>
    24ec:	70 91 72 1d 	lds	r23, 0x1D72	; 0x801d72 <xTickCount+0x3>
    24f0:	41 83       	std	Z+1, r20	; 0x01
    24f2:	52 83       	std	Z+2, r21	; 0x02
    24f4:	63 83       	std	Z+3, r22	; 0x03
    24f6:	74 83       	std	Z+4, r23	; 0x04
    24f8:	08 95       	ret

000024fa <xTaskCheckForTimeOut>:
    24fa:	8f 92       	push	r8
    24fc:	9f 92       	push	r9
    24fe:	af 92       	push	r10
    2500:	bf 92       	push	r11
    2502:	cf 92       	push	r12
    2504:	df 92       	push	r13
    2506:	ef 92       	push	r14
    2508:	ff 92       	push	r15
    250a:	0f 93       	push	r16
    250c:	1f 93       	push	r17
    250e:	cf 93       	push	r28
    2510:	df 93       	push	r29
    2512:	fb 01       	movw	r30, r22
    2514:	0f b6       	in	r0, 0x3f	; 63
    2516:	f8 94       	cli
    2518:	0f 92       	push	r0
    251a:	00 91 6f 1d 	lds	r16, 0x1D6F	; 0x801d6f <xTickCount>
    251e:	10 91 70 1d 	lds	r17, 0x1D70	; 0x801d70 <xTickCount+0x1>
    2522:	20 91 71 1d 	lds	r18, 0x1D71	; 0x801d71 <xTickCount+0x2>
    2526:	30 91 72 1d 	lds	r19, 0x1D72	; 0x801d72 <xTickCount+0x3>
    252a:	40 81       	ld	r20, Z
    252c:	51 81       	ldd	r21, Z+1	; 0x01
    252e:	62 81       	ldd	r22, Z+2	; 0x02
    2530:	73 81       	ldd	r23, Z+3	; 0x03
    2532:	4f 3f       	cpi	r20, 0xFF	; 255
    2534:	af ef       	ldi	r26, 0xFF	; 255
    2536:	5a 07       	cpc	r21, r26
    2538:	6a 07       	cpc	r22, r26
    253a:	7a 07       	cpc	r23, r26
    253c:	81 f1       	breq	.+96     	; 0x259e <xTaskCheckForTimeOut+0xa4>
    253e:	a0 91 6a 1d 	lds	r26, 0x1D6A	; 0x801d6a <xNumOfOverflows>
    2542:	ec 01       	movw	r28, r24
    2544:	b8 81       	ld	r27, Y
    2546:	ba 17       	cp	r27, r26
    2548:	49 f0       	breq	.+18     	; 0x255c <xTaskCheckForTimeOut+0x62>
    254a:	c9 80       	ldd	r12, Y+1	; 0x01
    254c:	da 80       	ldd	r13, Y+2	; 0x02
    254e:	eb 80       	ldd	r14, Y+3	; 0x03
    2550:	fc 80       	ldd	r15, Y+4	; 0x04
    2552:	0c 15       	cp	r16, r12
    2554:	1d 05       	cpc	r17, r13
    2556:	2e 05       	cpc	r18, r14
    2558:	3f 05       	cpc	r19, r15
    255a:	18 f5       	brcc	.+70     	; 0x25a2 <xTaskCheckForTimeOut+0xa8>
    255c:	dc 01       	movw	r26, r24
    255e:	11 96       	adiw	r26, 0x01	; 1
    2560:	cd 90       	ld	r12, X+
    2562:	dd 90       	ld	r13, X+
    2564:	ed 90       	ld	r14, X+
    2566:	fc 90       	ld	r15, X
    2568:	14 97       	sbiw	r26, 0x04	; 4
    256a:	48 01       	movw	r8, r16
    256c:	59 01       	movw	r10, r18
    256e:	8c 18       	sub	r8, r12
    2570:	9d 08       	sbc	r9, r13
    2572:	ae 08       	sbc	r10, r14
    2574:	bf 08       	sbc	r11, r15
    2576:	84 16       	cp	r8, r20
    2578:	95 06       	cpc	r9, r21
    257a:	a6 06       	cpc	r10, r22
    257c:	b7 06       	cpc	r11, r23
    257e:	98 f4       	brcc	.+38     	; 0x25a6 <xTaskCheckForTimeOut+0xac>
    2580:	c0 1a       	sub	r12, r16
    2582:	d1 0a       	sbc	r13, r17
    2584:	e2 0a       	sbc	r14, r18
    2586:	f3 0a       	sbc	r15, r19
    2588:	4c 0d       	add	r20, r12
    258a:	5d 1d       	adc	r21, r13
    258c:	6e 1d       	adc	r22, r14
    258e:	7f 1d       	adc	r23, r15
    2590:	40 83       	st	Z, r20
    2592:	51 83       	std	Z+1, r21	; 0x01
    2594:	62 83       	std	Z+2, r22	; 0x02
    2596:	73 83       	std	Z+3, r23	; 0x03
    2598:	9f df       	rcall	.-194    	; 0x24d8 <vTaskSetTimeOutState>
    259a:	80 e0       	ldi	r24, 0x00	; 0
    259c:	05 c0       	rjmp	.+10     	; 0x25a8 <xTaskCheckForTimeOut+0xae>
    259e:	80 e0       	ldi	r24, 0x00	; 0
    25a0:	03 c0       	rjmp	.+6      	; 0x25a8 <xTaskCheckForTimeOut+0xae>
    25a2:	81 e0       	ldi	r24, 0x01	; 1
    25a4:	01 c0       	rjmp	.+2      	; 0x25a8 <xTaskCheckForTimeOut+0xae>
    25a6:	81 e0       	ldi	r24, 0x01	; 1
    25a8:	0f 90       	pop	r0
    25aa:	0f be       	out	0x3f, r0	; 63
    25ac:	df 91       	pop	r29
    25ae:	cf 91       	pop	r28
    25b0:	1f 91       	pop	r17
    25b2:	0f 91       	pop	r16
    25b4:	ff 90       	pop	r15
    25b6:	ef 90       	pop	r14
    25b8:	df 90       	pop	r13
    25ba:	cf 90       	pop	r12
    25bc:	bf 90       	pop	r11
    25be:	af 90       	pop	r10
    25c0:	9f 90       	pop	r9
    25c2:	8f 90       	pop	r8
    25c4:	08 95       	ret

000025c6 <vTaskMissedYield>:
    25c6:	81 e0       	ldi	r24, 0x01	; 1
    25c8:	80 93 6b 1d 	sts	0x1D6B, r24	; 0x801d6b <xYieldPending>
    25cc:	08 95       	ret

000025ce <vTaskPriorityInherit>:
    25ce:	0f 93       	push	r16
    25d0:	1f 93       	push	r17
    25d2:	cf 93       	push	r28
    25d4:	df 93       	push	r29
    25d6:	fc 01       	movw	r30, r24
    25d8:	89 2b       	or	r24, r25
    25da:	09 f4       	brne	.+2      	; 0x25de <vTaskPriorityInherit+0x10>
    25dc:	51 c0       	rjmp	.+162    	; 0x2680 <vTaskPriorityInherit+0xb2>
    25de:	82 8d       	ldd	r24, Z+26	; 0x1a
    25e0:	a0 91 e7 1d 	lds	r26, 0x1DE7	; 0x801de7 <pxCurrentTCB>
    25e4:	b0 91 e8 1d 	lds	r27, 0x1DE8	; 0x801de8 <pxCurrentTCB+0x1>
    25e8:	5a 96       	adiw	r26, 0x1a	; 26
    25ea:	9c 91       	ld	r25, X
    25ec:	89 17       	cp	r24, r25
    25ee:	08 f0       	brcs	.+2      	; 0x25f2 <vTaskPriorityInherit+0x24>
    25f0:	47 c0       	rjmp	.+142    	; 0x2680 <vTaskPriorityInherit+0xb2>
    25f2:	46 85       	ldd	r20, Z+14	; 0x0e
    25f4:	57 85       	ldd	r21, Z+15	; 0x0f
    25f6:	60 89       	ldd	r22, Z+16	; 0x10
    25f8:	71 89       	ldd	r23, Z+17	; 0x11
    25fa:	77 23       	and	r23, r23
    25fc:	94 f0       	brlt	.+36     	; 0x2622 <vTaskPriorityInherit+0x54>
    25fe:	a0 91 e7 1d 	lds	r26, 0x1DE7	; 0x801de7 <pxCurrentTCB>
    2602:	b0 91 e8 1d 	lds	r27, 0x1DE8	; 0x801de8 <pxCurrentTCB+0x1>
    2606:	5a 96       	adiw	r26, 0x1a	; 26
    2608:	9c 91       	ld	r25, X
    260a:	45 e0       	ldi	r20, 0x05	; 5
    260c:	50 e0       	ldi	r21, 0x00	; 0
    260e:	60 e0       	ldi	r22, 0x00	; 0
    2610:	70 e0       	ldi	r23, 0x00	; 0
    2612:	49 1b       	sub	r20, r25
    2614:	51 09       	sbc	r21, r1
    2616:	61 09       	sbc	r22, r1
    2618:	71 09       	sbc	r23, r1
    261a:	46 87       	std	Z+14, r20	; 0x0e
    261c:	57 87       	std	Z+15, r21	; 0x0f
    261e:	60 8b       	std	Z+16, r22	; 0x10
    2620:	71 8b       	std	Z+17, r23	; 0x11
    2622:	2b e0       	ldi	r18, 0x0B	; 11
    2624:	82 9f       	mul	r24, r18
    2626:	c0 01       	movw	r24, r0
    2628:	11 24       	eor	r1, r1
    262a:	80 55       	subi	r24, 0x50	; 80
    262c:	92 4e       	sbci	r25, 0xE2	; 226
    262e:	24 85       	ldd	r18, Z+12	; 0x0c
    2630:	35 85       	ldd	r19, Z+13	; 0x0d
    2632:	28 17       	cp	r18, r24
    2634:	39 07       	cpc	r19, r25
    2636:	e9 f4       	brne	.+58     	; 0x2672 <vTaskPriorityInherit+0xa4>
    2638:	8f 01       	movw	r16, r30
    263a:	ef 01       	movw	r28, r30
    263c:	22 96       	adiw	r28, 0x02	; 2
    263e:	ce 01       	movw	r24, r28
    2640:	0e 94 e3 07 	call	0xfc6	; 0xfc6 <uxListRemove>
    2644:	e0 91 e7 1d 	lds	r30, 0x1DE7	; 0x801de7 <pxCurrentTCB>
    2648:	f0 91 e8 1d 	lds	r31, 0x1DE8	; 0x801de8 <pxCurrentTCB+0x1>
    264c:	82 8d       	ldd	r24, Z+26	; 0x1a
    264e:	f8 01       	movw	r30, r16
    2650:	82 8f       	std	Z+26, r24	; 0x1a
    2652:	90 91 6e 1d 	lds	r25, 0x1D6E	; 0x801d6e <uxTopReadyPriority>
    2656:	98 17       	cp	r25, r24
    2658:	10 f4       	brcc	.+4      	; 0x265e <vTaskPriorityInherit+0x90>
    265a:	80 93 6e 1d 	sts	0x1D6E, r24	; 0x801d6e <uxTopReadyPriority>
    265e:	fb e0       	ldi	r31, 0x0B	; 11
    2660:	8f 9f       	mul	r24, r31
    2662:	c0 01       	movw	r24, r0
    2664:	11 24       	eor	r1, r1
    2666:	be 01       	movw	r22, r28
    2668:	80 55       	subi	r24, 0x50	; 80
    266a:	92 4e       	sbci	r25, 0xE2	; 226
    266c:	0e 94 85 07 	call	0xf0a	; 0xf0a <vListInsertEnd>
    2670:	07 c0       	rjmp	.+14     	; 0x2680 <vTaskPriorityInherit+0xb2>
    2672:	a0 91 e7 1d 	lds	r26, 0x1DE7	; 0x801de7 <pxCurrentTCB>
    2676:	b0 91 e8 1d 	lds	r27, 0x1DE8	; 0x801de8 <pxCurrentTCB+0x1>
    267a:	5a 96       	adiw	r26, 0x1a	; 26
    267c:	8c 91       	ld	r24, X
    267e:	82 8f       	std	Z+26, r24	; 0x1a
    2680:	df 91       	pop	r29
    2682:	cf 91       	pop	r28
    2684:	1f 91       	pop	r17
    2686:	0f 91       	pop	r16
    2688:	08 95       	ret

0000268a <xTaskPriorityDisinherit>:
    268a:	0f 93       	push	r16
    268c:	1f 93       	push	r17
    268e:	cf 93       	push	r28
    2690:	df 93       	push	r29
    2692:	fc 01       	movw	r30, r24
    2694:	89 2b       	or	r24, r25
    2696:	79 f1       	breq	.+94     	; 0x26f6 <xTaskPriorityDisinherit+0x6c>
    2698:	84 a9       	ldd	r24, Z+52	; 0x34
    269a:	81 50       	subi	r24, 0x01	; 1
    269c:	84 ab       	std	Z+52, r24	; 0x34
    269e:	22 8d       	ldd	r18, Z+26	; 0x1a
    26a0:	93 a9       	ldd	r25, Z+51	; 0x33
    26a2:	29 17       	cp	r18, r25
    26a4:	51 f1       	breq	.+84     	; 0x26fa <xTaskPriorityDisinherit+0x70>
    26a6:	81 11       	cpse	r24, r1
    26a8:	2a c0       	rjmp	.+84     	; 0x26fe <xTaskPriorityDisinherit+0x74>
    26aa:	ef 01       	movw	r28, r30
    26ac:	8f 01       	movw	r16, r30
    26ae:	0e 5f       	subi	r16, 0xFE	; 254
    26b0:	1f 4f       	sbci	r17, 0xFF	; 255
    26b2:	c8 01       	movw	r24, r16
    26b4:	0e 94 e3 07 	call	0xfc6	; 0xfc6 <uxListRemove>
    26b8:	8b a9       	ldd	r24, Y+51	; 0x33
    26ba:	8a 8f       	std	Y+26, r24	; 0x1a
    26bc:	45 e0       	ldi	r20, 0x05	; 5
    26be:	50 e0       	ldi	r21, 0x00	; 0
    26c0:	60 e0       	ldi	r22, 0x00	; 0
    26c2:	70 e0       	ldi	r23, 0x00	; 0
    26c4:	48 1b       	sub	r20, r24
    26c6:	51 09       	sbc	r21, r1
    26c8:	61 09       	sbc	r22, r1
    26ca:	71 09       	sbc	r23, r1
    26cc:	4e 87       	std	Y+14, r20	; 0x0e
    26ce:	5f 87       	std	Y+15, r21	; 0x0f
    26d0:	68 8b       	std	Y+16, r22	; 0x10
    26d2:	79 8b       	std	Y+17, r23	; 0x11
    26d4:	90 91 6e 1d 	lds	r25, 0x1D6E	; 0x801d6e <uxTopReadyPriority>
    26d8:	98 17       	cp	r25, r24
    26da:	10 f4       	brcc	.+4      	; 0x26e0 <xTaskPriorityDisinherit+0x56>
    26dc:	80 93 6e 1d 	sts	0x1D6E, r24	; 0x801d6e <uxTopReadyPriority>
    26e0:	2b e0       	ldi	r18, 0x0B	; 11
    26e2:	82 9f       	mul	r24, r18
    26e4:	c0 01       	movw	r24, r0
    26e6:	11 24       	eor	r1, r1
    26e8:	b8 01       	movw	r22, r16
    26ea:	80 55       	subi	r24, 0x50	; 80
    26ec:	92 4e       	sbci	r25, 0xE2	; 226
    26ee:	0e 94 85 07 	call	0xf0a	; 0xf0a <vListInsertEnd>
    26f2:	81 e0       	ldi	r24, 0x01	; 1
    26f4:	05 c0       	rjmp	.+10     	; 0x2700 <xTaskPriorityDisinherit+0x76>
    26f6:	80 e0       	ldi	r24, 0x00	; 0
    26f8:	03 c0       	rjmp	.+6      	; 0x2700 <xTaskPriorityDisinherit+0x76>
    26fa:	80 e0       	ldi	r24, 0x00	; 0
    26fc:	01 c0       	rjmp	.+2      	; 0x2700 <xTaskPriorityDisinherit+0x76>
    26fe:	80 e0       	ldi	r24, 0x00	; 0
    2700:	df 91       	pop	r29
    2702:	cf 91       	pop	r28
    2704:	1f 91       	pop	r17
    2706:	0f 91       	pop	r16
    2708:	08 95       	ret

0000270a <pvTaskIncrementMutexHeldCount>:

	void *pvTaskIncrementMutexHeldCount( void )
	{
		/* If xSemaphoreCreateMutex() is called before any tasks have been created
		then pxCurrentTCB will be NULL. */
		if( pxCurrentTCB != NULL )
    270a:	80 91 e7 1d 	lds	r24, 0x1DE7	; 0x801de7 <pxCurrentTCB>
    270e:	90 91 e8 1d 	lds	r25, 0x1DE8	; 0x801de8 <pxCurrentTCB+0x1>
    2712:	89 2b       	or	r24, r25
    2714:	39 f0       	breq	.+14     	; 0x2724 <pvTaskIncrementMutexHeldCount+0x1a>
		{
			( pxCurrentTCB->uxMutexesHeld )++;
    2716:	e0 91 e7 1d 	lds	r30, 0x1DE7	; 0x801de7 <pxCurrentTCB>
    271a:	f0 91 e8 1d 	lds	r31, 0x1DE8	; 0x801de8 <pxCurrentTCB+0x1>
    271e:	84 a9       	ldd	r24, Z+52	; 0x34
    2720:	8f 5f       	subi	r24, 0xFF	; 255
    2722:	84 ab       	std	Z+52, r24	; 0x34
		}

		return pxCurrentTCB;
    2724:	80 91 e7 1d 	lds	r24, 0x1DE7	; 0x801de7 <pxCurrentTCB>
    2728:	90 91 e8 1d 	lds	r25, 0x1DE8	; 0x801de8 <pxCurrentTCB+0x1>
	}
    272c:	08 95       	ret

0000272e <csp_malloc>:

/* FreeRTOS includes */
#include <FreeRTOS.h>

void * csp_malloc(size_t size) {
	return pvPortMalloc(size);
    272e:	0c 94 56 08 	jmp	0x10ac	; 0x10ac <pvPortMalloc>
}
    2732:	08 95       	ret

00002734 <csp_free>:

void csp_free(void *ptr) {
	vPortFree(ptr);
    2734:	0c 94 1a 09 	jmp	0x1234	; 0x1234 <vPortFree>
    2738:	08 95       	ret

0000273a <csp_queue_create>:
csp_queue_handle_t csp_queue_create(int length, size_t item_size) {
	return xQueueCreate(length, item_size);
}

void csp_queue_remove(csp_queue_handle_t queue) {
	vQueueDelete(queue);
    273a:	40 e0       	ldi	r20, 0x00	; 0
    273c:	1b c8       	rjmp	.-4042   	; 0x1774 <xQueueGenericCreate>
    273e:	08 95       	ret

00002740 <csp_queue_enqueue>:
}

int csp_queue_enqueue(csp_queue_handle_t handle, void * value, uint32_t timeout) {
    2740:	0f 93       	push	r16
	if (timeout != CSP_MAX_DELAY)
		timeout = timeout / portTICK_RATE_MS;
	return xQueueSendToBack(handle, value, timeout);
    2742:	00 e0       	ldi	r16, 0x00	; 0
    2744:	45 d8       	rcall	.-3958   	; 0x17d0 <xQueueGenericSend>
}
    2746:	08 2e       	mov	r0, r24
    2748:	00 0c       	add	r0, r0
    274a:	99 0b       	sbc	r25, r25
    274c:	0f 91       	pop	r16
    274e:	08 95       	ret

00002750 <csp_queue_enqueue_isr>:

int csp_queue_enqueue_isr(csp_queue_handle_t handle, void * value, CSP_BASE_TYPE * task_woken) {
	return xQueueSendToBackFromISR(handle, value, (signed CSP_BASE_TYPE *)task_woken);
    2750:	20 e0       	ldi	r18, 0x00	; 0
    2752:	f5 d8       	rcall	.-3606   	; 0x193e <xQueueGenericSendFromISR>
}
    2754:	08 2e       	mov	r0, r24
    2756:	00 0c       	add	r0, r0
    2758:	99 0b       	sbc	r25, r25
    275a:	08 95       	ret

0000275c <csp_queue_dequeue>:

int csp_queue_dequeue(csp_queue_handle_t handle, void * buf, uint32_t timeout) {
    275c:	0f 93       	push	r16
	if (timeout != CSP_MAX_DELAY)
		timeout = timeout / portTICK_RATE_MS;
	return xQueueReceive(handle, buf, timeout);
    275e:	00 e0       	ldi	r16, 0x00	; 0
    2760:	26 d9       	rcall	.-3508   	; 0x19ae <xQueueGenericReceive>
}
    2762:	08 2e       	mov	r0, r24
    2764:	00 0c       	add	r0, r0
    2766:	99 0b       	sbc	r25, r25
    2768:	0f 91       	pop	r16
    276a:	08 95       	ret

0000276c <csp_queue_dequeue_isr>:

int csp_queue_dequeue_isr(csp_queue_handle_t handle, void * buf, CSP_BASE_TYPE * task_woken) {
	return xQueueReceiveFromISR(handle, buf, (signed CSP_BASE_TYPE *)task_woken);
    276c:	e5 d9       	rcall	.-3126   	; 0x1b38 <xQueueReceiveFromISR>
}
    276e:	08 2e       	mov	r0, r24
    2770:	00 0c       	add	r0, r0
    2772:	99 0b       	sbc	r25, r25
    2774:	08 95       	ret

00002776 <csp_queue_size>:

int csp_queue_size(csp_queue_handle_t handle) {
	return uxQueueMessagesWaiting(handle);
    2776:	15 da       	rcall	.-3030   	; 0x1ba2 <uxQueueMessagesWaiting>
}
    2778:	90 e0       	ldi	r25, 0x00	; 0
    277a:	08 95       	ret

0000277c <csp_mutex_create>:
	return csp_bin_sem_remove(mutex);
}

int csp_mutex_lock(csp_mutex_t * mutex, uint32_t timeout) {
	return csp_bin_sem_wait(mutex, timeout);
}
    277c:	cf 93       	push	r28
    277e:	df 93       	push	r29
    2780:	ec 01       	movw	r28, r24
    2782:	81 e0       	ldi	r24, 0x01	; 1
    2784:	c1 d8       	rcall	.-3710   	; 0x1908 <xQueueCreateMutex>
    2786:	99 83       	std	Y+1, r25	; 0x01
    2788:	88 83       	st	Y, r24
    278a:	21 e0       	ldi	r18, 0x01	; 1
    278c:	30 e0       	ldi	r19, 0x00	; 0
    278e:	89 2b       	or	r24, r25
    2790:	11 f4       	brne	.+4      	; 0x2796 <csp_mutex_create+0x1a>
    2792:	20 e0       	ldi	r18, 0x00	; 0
    2794:	30 e0       	ldi	r19, 0x00	; 0
    2796:	c9 01       	movw	r24, r18
    2798:	df 91       	pop	r29
    279a:	cf 91       	pop	r28
    279c:	08 95       	ret

0000279e <csp_bin_sem_create>:
    279e:	0f 93       	push	r16
    27a0:	cf 93       	push	r28
    27a2:	df 93       	push	r29
    27a4:	ec 01       	movw	r28, r24
    27a6:	43 e0       	ldi	r20, 0x03	; 3
    27a8:	60 e0       	ldi	r22, 0x00	; 0
    27aa:	81 e0       	ldi	r24, 0x01	; 1
    27ac:	0e 94 ba 0b 	call	0x1774	; 0x1774 <xQueueGenericCreate>
    27b0:	99 83       	std	Y+1, r25	; 0x01
    27b2:	88 83       	st	Y, r24
    27b4:	00 97       	sbiw	r24, 0x00	; 0
    27b6:	39 f0       	breq	.+14     	; 0x27c6 <csp_bin_sem_create+0x28>
    27b8:	00 e0       	ldi	r16, 0x00	; 0
    27ba:	20 e0       	ldi	r18, 0x00	; 0
    27bc:	30 e0       	ldi	r19, 0x00	; 0
    27be:	a9 01       	movw	r20, r18
    27c0:	60 e0       	ldi	r22, 0x00	; 0
    27c2:	70 e0       	ldi	r23, 0x00	; 0
    27c4:	05 d8       	rcall	.-4086   	; 0x17d0 <xQueueGenericSend>
    27c6:	81 e0       	ldi	r24, 0x01	; 1
    27c8:	90 e0       	ldi	r25, 0x00	; 0
    27ca:	df 91       	pop	r29
    27cc:	cf 91       	pop	r28
    27ce:	0f 91       	pop	r16
    27d0:	08 95       	ret

000027d2 <csp_bin_sem_wait>:
    27d2:	cf 92       	push	r12
    27d4:	df 92       	push	r13
    27d6:	ef 92       	push	r14
    27d8:	ff 92       	push	r15
    27da:	0f 93       	push	r16
    27dc:	cf 93       	push	r28
    27de:	df 93       	push	r29
    27e0:	ec 01       	movw	r28, r24
    27e2:	6a 01       	movw	r12, r20
    27e4:	7b 01       	movw	r14, r22
    27e6:	80 91 0a 02 	lds	r24, 0x020A	; 0x80020a <csp_debug_level_enabled+0x6>
    27ea:	88 23       	and	r24, r24
    27ec:	e1 f0       	breq	.+56     	; 0x2826 <csp_bin_sem_wait+0x54>
    27ee:	0e 94 62 1c 	call	0x38c4	; 0x38c4 <csp_get_address>
    27f2:	df 93       	push	r29
    27f4:	cf 93       	push	r28
    27f6:	1f 92       	push	r1
    27f8:	95 e4       	ldi	r25, 0x45	; 69
    27fa:	9f 93       	push	r25
    27fc:	24 ea       	ldi	r18, 0xA4	; 164
    27fe:	32 e0       	ldi	r19, 0x02	; 2
    2800:	3f 93       	push	r19
    2802:	2f 93       	push	r18
    2804:	1f 92       	push	r1
    2806:	8f 93       	push	r24
    2808:	8a e9       	ldi	r24, 0x9A	; 154
    280a:	92 e0       	ldi	r25, 0x02	; 2
    280c:	9f 93       	push	r25
    280e:	8f 93       	push	r24
    2810:	86 e0       	ldi	r24, 0x06	; 6
    2812:	8f 93       	push	r24
    2814:	6f d7       	rcall	.+3806   	; 0x36f4 <do_csp_debug>
    2816:	8d b7       	in	r24, 0x3d	; 61
    2818:	9e b7       	in	r25, 0x3e	; 62
    281a:	0b 96       	adiw	r24, 0x0b	; 11
    281c:	0f b6       	in	r0, 0x3f	; 63
    281e:	f8 94       	cli
    2820:	9e bf       	out	0x3e, r25	; 62
    2822:	0f be       	out	0x3f, r0	; 63
    2824:	8d bf       	out	0x3d, r24	; 61
    2826:	00 e0       	ldi	r16, 0x00	; 0
    2828:	a7 01       	movw	r20, r14
    282a:	96 01       	movw	r18, r12
    282c:	60 e0       	ldi	r22, 0x00	; 0
    282e:	70 e0       	ldi	r23, 0x00	; 0
    2830:	88 81       	ld	r24, Y
    2832:	99 81       	ldd	r25, Y+1	; 0x01
    2834:	bc d8       	rcall	.-3720   	; 0x19ae <xQueueGenericReceive>
    2836:	21 e0       	ldi	r18, 0x01	; 1
    2838:	30 e0       	ldi	r19, 0x00	; 0
    283a:	81 30       	cpi	r24, 0x01	; 1
    283c:	11 f0       	breq	.+4      	; 0x2842 <csp_bin_sem_wait+0x70>
    283e:	20 e0       	ldi	r18, 0x00	; 0
    2840:	30 e0       	ldi	r19, 0x00	; 0
    2842:	c9 01       	movw	r24, r18
    2844:	df 91       	pop	r29
    2846:	cf 91       	pop	r28
    2848:	0f 91       	pop	r16
    284a:	ff 90       	pop	r15
    284c:	ef 90       	pop	r14
    284e:	df 90       	pop	r13
    2850:	cf 90       	pop	r12
    2852:	08 95       	ret

00002854 <csp_bin_sem_post>:
	} else {
		return CSP_SEMAPHORE_ERROR;
	}
}

int csp_bin_sem_post(csp_bin_sem_handle_t * sem) {
    2854:	0f 93       	push	r16
    2856:	cf 93       	push	r28
    2858:	df 93       	push	r29
    285a:	ec 01       	movw	r28, r24
	csp_log_lock("Post: %p", sem);
    285c:	80 91 0a 02 	lds	r24, 0x020A	; 0x80020a <csp_debug_level_enabled+0x6>
    2860:	88 23       	and	r24, r24
    2862:	e1 f0       	breq	.+56     	; 0x289c <csp_bin_sem_post+0x48>
    2864:	0e 94 62 1c 	call	0x38c4	; 0x38c4 <csp_get_address>
    2868:	df 93       	push	r29
    286a:	cf 93       	push	r28
    286c:	1f 92       	push	r1
    286e:	90 e5       	ldi	r25, 0x50	; 80
    2870:	9f 93       	push	r25
    2872:	24 ea       	ldi	r18, 0xA4	; 164
    2874:	32 e0       	ldi	r19, 0x02	; 2
    2876:	3f 93       	push	r19
    2878:	2f 93       	push	r18
    287a:	1f 92       	push	r1
    287c:	8f 93       	push	r24
    287e:	84 e8       	ldi	r24, 0x84	; 132
    2880:	92 e0       	ldi	r25, 0x02	; 2
    2882:	9f 93       	push	r25
    2884:	8f 93       	push	r24
    2886:	86 e0       	ldi	r24, 0x06	; 6
    2888:	8f 93       	push	r24
    288a:	34 d7       	rcall	.+3688   	; 0x36f4 <do_csp_debug>
    288c:	8d b7       	in	r24, 0x3d	; 61
    288e:	9e b7       	in	r25, 0x3e	; 62
    2890:	0b 96       	adiw	r24, 0x0b	; 11
    2892:	0f b6       	in	r0, 0x3f	; 63
    2894:	f8 94       	cli
    2896:	9e bf       	out	0x3e, r25	; 62
    2898:	0f be       	out	0x3f, r0	; 63
    289a:	8d bf       	out	0x3d, r24	; 61
	if (xSemaphoreGive(*sem) == pdPASS) {
    289c:	00 e0       	ldi	r16, 0x00	; 0
    289e:	20 e0       	ldi	r18, 0x00	; 0
    28a0:	30 e0       	ldi	r19, 0x00	; 0
    28a2:	a9 01       	movw	r20, r18
    28a4:	60 e0       	ldi	r22, 0x00	; 0
    28a6:	70 e0       	ldi	r23, 0x00	; 0
    28a8:	88 81       	ld	r24, Y
    28aa:	99 81       	ldd	r25, Y+1	; 0x01
    28ac:	0e 94 e8 0b 	call	0x17d0	; 0x17d0 <xQueueGenericSend>
    28b0:	21 e0       	ldi	r18, 0x01	; 1
    28b2:	30 e0       	ldi	r19, 0x00	; 0
    28b4:	81 30       	cpi	r24, 0x01	; 1
    28b6:	11 f0       	breq	.+4      	; 0x28bc <csp_bin_sem_post+0x68>
    28b8:	20 e0       	ldi	r18, 0x00	; 0
    28ba:	30 e0       	ldi	r19, 0x00	; 0
		return CSP_SEMAPHORE_OK;
	} else {
		return CSP_SEMAPHORE_ERROR;
	}
}
    28bc:	c9 01       	movw	r24, r18
    28be:	df 91       	pop	r29
    28c0:	cf 91       	pop	r28
    28c2:	0f 91       	pop	r16
    28c4:	08 95       	ret

000028c6 <csp_sys_set_color>:
	csp_log_error("Failed to shutdown");

	return CSP_ERR_INVAL;
}

void csp_sys_set_color(csp_color_t color) {
    28c6:	98 2f       	mov	r25, r24

	unsigned int color_code, modifier_code;
	switch (color & COLOR_MASK_COLOR) {
    28c8:	e8 2f       	mov	r30, r24
    28ca:	ef 70       	andi	r30, 0x0F	; 15
    28cc:	4e 2f       	mov	r20, r30
    28ce:	50 e0       	ldi	r21, 0x00	; 0
    28d0:	fa 01       	movw	r30, r20
    28d2:	31 97       	sbiw	r30, 0x01	; 1
    28d4:	e8 30       	cpi	r30, 0x08	; 8
    28d6:	f1 05       	cpc	r31, r1
    28d8:	d8 f4       	brcc	.+54     	; 0x2910 <csp_sys_set_color+0x4a>
    28da:	88 27       	eor	r24, r24
    28dc:	ee 58       	subi	r30, 0x8E	; 142
    28de:	ff 4f       	sbci	r31, 0xFF	; 255
    28e0:	8f 4f       	sbci	r24, 0xFF	; 255
    28e2:	0c 94 b0 2b 	jmp	0x5760	; 0x5760 <__tablejump2__>
		case COLOR_BLACK:
			color_code = 30; break;
		case COLOR_RED:
			color_code = 31; break;
    28e6:	2f e1       	ldi	r18, 0x1F	; 31
    28e8:	30 e0       	ldi	r19, 0x00	; 0
    28ea:	17 c0       	rjmp	.+46     	; 0x291a <csp_sys_set_color+0x54>
		case COLOR_GREEN:
			color_code = 32; break;
    28ec:	20 e2       	ldi	r18, 0x20	; 32
    28ee:	30 e0       	ldi	r19, 0x00	; 0
    28f0:	14 c0       	rjmp	.+40     	; 0x291a <csp_sys_set_color+0x54>
		case COLOR_YELLOW:
			color_code = 33; break;
    28f2:	21 e2       	ldi	r18, 0x21	; 33
    28f4:	30 e0       	ldi	r19, 0x00	; 0
    28f6:	11 c0       	rjmp	.+34     	; 0x291a <csp_sys_set_color+0x54>
		case COLOR_BLUE:
			color_code = 34; break;
    28f8:	22 e2       	ldi	r18, 0x22	; 34
    28fa:	30 e0       	ldi	r19, 0x00	; 0
    28fc:	0e c0       	rjmp	.+28     	; 0x291a <csp_sys_set_color+0x54>
		case COLOR_MAGENTA:
			color_code = 35; break;
    28fe:	23 e2       	ldi	r18, 0x23	; 35
    2900:	30 e0       	ldi	r19, 0x00	; 0
    2902:	0b c0       	rjmp	.+22     	; 0x291a <csp_sys_set_color+0x54>
		case COLOR_CYAN:
			color_code = 36; break;
    2904:	24 e2       	ldi	r18, 0x24	; 36
    2906:	30 e0       	ldi	r19, 0x00	; 0
    2908:	08 c0       	rjmp	.+16     	; 0x291a <csp_sys_set_color+0x54>
		case COLOR_WHITE:
			color_code = 37; break;
    290a:	25 e2       	ldi	r18, 0x25	; 37
    290c:	30 e0       	ldi	r19, 0x00	; 0
    290e:	05 c0       	rjmp	.+10     	; 0x291a <csp_sys_set_color+0x54>
		case COLOR_RESET:
		default:
			color_code = 0; break;
    2910:	20 e0       	ldi	r18, 0x00	; 0
    2912:	30 e0       	ldi	r19, 0x00	; 0
    2914:	02 c0       	rjmp	.+4      	; 0x291a <csp_sys_set_color+0x54>
void csp_sys_set_color(csp_color_t color) {

	unsigned int color_code, modifier_code;
	switch (color & COLOR_MASK_COLOR) {
		case COLOR_BLACK:
			color_code = 30; break;
    2916:	2e e1       	ldi	r18, 0x1E	; 30
    2918:	30 e0       	ldi	r19, 0x00	; 0
		case COLOR_RESET:
		default:
			color_code = 0; break;
	}
	
	switch (color & COLOR_MASK_MODIFIER) {
    291a:	89 2f       	mov	r24, r25
    291c:	80 7f       	andi	r24, 0xF0	; 240
    291e:	80 32       	cpi	r24, 0x20	; 32
    2920:	49 f0       	breq	.+18     	; 0x2934 <csp_sys_set_color+0x6e>
    2922:	18 f4       	brcc	.+6      	; 0x292a <csp_sys_set_color+0x64>
    2924:	80 31       	cpi	r24, 0x10	; 16
    2926:	91 f0       	breq	.+36     	; 0x294c <csp_sys_set_color+0x86>
    2928:	0e c0       	rjmp	.+28     	; 0x2946 <csp_sys_set_color+0x80>
    292a:	80 33       	cpi	r24, 0x30	; 48
    292c:	31 f0       	breq	.+12     	; 0x293a <csp_sys_set_color+0x74>
    292e:	80 34       	cpi	r24, 0x40	; 64
    2930:	39 f0       	breq	.+14     	; 0x2940 <csp_sys_set_color+0x7a>
    2932:	09 c0       	rjmp	.+18     	; 0x2946 <csp_sys_set_color+0x80>
		case COLOR_BOLD:
			modifier_code = 1; break;
		case COLOR_UNDERLINE:
			modifier_code = 2; break;
    2934:	82 e0       	ldi	r24, 0x02	; 2
    2936:	90 e0       	ldi	r25, 0x00	; 0
    2938:	0b c0       	rjmp	.+22     	; 0x2950 <csp_sys_set_color+0x8a>
		case COLOR_BLINK:
			modifier_code = 3; break;
    293a:	83 e0       	ldi	r24, 0x03	; 3
    293c:	90 e0       	ldi	r25, 0x00	; 0
    293e:	08 c0       	rjmp	.+16     	; 0x2950 <csp_sys_set_color+0x8a>
		case COLOR_HIDE:
			modifier_code = 4; break;
    2940:	84 e0       	ldi	r24, 0x04	; 4
    2942:	90 e0       	ldi	r25, 0x00	; 0
    2944:	05 c0       	rjmp	.+10     	; 0x2950 <csp_sys_set_color+0x8a>
		case COLOR_NORMAL:
		default:
			modifier_code = 0; break;
    2946:	80 e0       	ldi	r24, 0x00	; 0
    2948:	90 e0       	ldi	r25, 0x00	; 0
    294a:	02 c0       	rjmp	.+4      	; 0x2950 <csp_sys_set_color+0x8a>
			color_code = 0; break;
	}
	
	switch (color & COLOR_MASK_MODIFIER) {
		case COLOR_BOLD:
			modifier_code = 1; break;
    294c:	81 e0       	ldi	r24, 0x01	; 1
    294e:	90 e0       	ldi	r25, 0x00	; 0
		case COLOR_NORMAL:
		default:
			modifier_code = 0; break;
	}

	printf("\033[%u;%um", modifier_code, color_code);
    2950:	3f 93       	push	r19
    2952:	2f 93       	push	r18
    2954:	9f 93       	push	r25
    2956:	8f 93       	push	r24
    2958:	80 eb       	ldi	r24, 0xB0	; 176
    295a:	92 e0       	ldi	r25, 0x02	; 2
    295c:	9f 93       	push	r25
    295e:	8f 93       	push	r24
    2960:	0e 94 8d 2c 	call	0x591a	; 0x591a <printf_P>
}
    2964:	0f 90       	pop	r0
    2966:	0f 90       	pop	r0
    2968:	0f 90       	pop	r0
    296a:	0f 90       	pop	r0
    296c:	0f 90       	pop	r0
    296e:	0f 90       	pop	r0
    2970:	08 95       	ret

00002972 <csp_thread_create>:
/* CSP includes */
#include <csp/csp.h>

#include <csp/arch/csp_thread.h>

int csp_thread_create(csp_thread_return_t (* routine)(void *), const char * const thread_name, unsigned short stack_depth, void * parameters, unsigned int priority, csp_thread_handle_t * handle) {
    2972:	ef 92       	push	r14
    2974:	ff 92       	push	r15
    2976:	0f 93       	push	r16
#if (FREERTOS_VERSION >= 8)
	portBASE_TYPE ret = xTaskCreate(routine, thread_name, stack_depth, parameters, priority, handle);
#else
	portBASE_TYPE ret = xTaskCreate(routine, (signed char *) thread_name, stack_depth, parameters, priority, handle);
    2978:	bc d9       	rcall	.-3208   	; 0x1cf2 <xTaskCreate>
    297a:	21 e0       	ldi	r18, 0x01	; 1
    297c:	30 e0       	ldi	r19, 0x00	; 0
    297e:	81 30       	cpi	r24, 0x01	; 1
    2980:	11 f4       	brne	.+4      	; 0x2986 <csp_thread_create+0x14>
    2982:	20 e0       	ldi	r18, 0x00	; 0
    2984:	30 e0       	ldi	r19, 0x00	; 0
#endif
	if (ret != pdTRUE)
		return CSP_ERR_NOMEM;
	return CSP_ERR_NONE;
}
    2986:	88 27       	eor	r24, r24
    2988:	99 27       	eor	r25, r25
    298a:	82 1b       	sub	r24, r18
    298c:	93 0b       	sbc	r25, r19
    298e:	0f 91       	pop	r16
    2990:	ff 90       	pop	r15
    2992:	ef 90       	pop	r14
    2994:	08 95       	ret

00002996 <csp_get_ms>:
#include <csp/csp.h>

#include <csp/arch/csp_time.h>

uint32_t csp_get_ms(void) {
	return (uint32_t)(xTaskGetTickCount() * (1000/configTICK_RATE_HZ));
    2996:	40 cb       	rjmp	.-2432   	; 0x2018 <xTaskGetTickCount>
}
    2998:	08 95       	ret

0000299a <csp_buffer_init>:
static char * csp_buffer_pool;
static unsigned int count, size;

CSP_DEFINE_CRITICAL(csp_critical_lock);

int csp_buffer_init(int buf_count, int buf_size) {
    299a:	cf 92       	push	r12
    299c:	df 92       	push	r13
    299e:	ef 92       	push	r14
    29a0:	ff 92       	push	r15
    29a2:	0f 93       	push	r16
    29a4:	1f 93       	push	r17
    29a6:	cf 93       	push	r28
    29a8:	df 93       	push	r29
    29aa:	1f 92       	push	r1
    29ac:	1f 92       	push	r1
    29ae:	cd b7       	in	r28, 0x3d	; 61
    29b0:	de b7       	in	r29, 0x3e	; 62

	unsigned int i;
	csp_skbf_t * buf;

	count = buf_count;
    29b2:	90 93 ec 1d 	sts	0x1DEC, r25	; 0x801dec <count+0x1>
    29b6:	80 93 eb 1d 	sts	0x1DEB, r24	; 0x801deb <count>
	size = buf_size + CSP_BUFFER_PACKET_OVERHEAD;
    29ba:	9b 01       	movw	r18, r22
    29bc:	22 5f       	subi	r18, 0xF2	; 242
    29be:	3f 4f       	sbci	r19, 0xFF	; 255
    29c0:	30 93 ea 1d 	sts	0x1DEA, r19	; 0x801dea <size+0x1>
    29c4:	20 93 e9 1d 	sts	0x1DE9, r18	; 0x801de9 <size>
	unsigned int skbfsize = (sizeof(csp_skbf_t) + size);
	skbfsize = CSP_BUFFER_ALIGN * ((skbfsize + CSP_BUFFER_ALIGN - 1) / CSP_BUFFER_ALIGN);
    29c8:	6d 5e       	subi	r22, 0xED	; 237
    29ca:	7f 4f       	sbci	r23, 0xFF	; 255
    29cc:	6b 01       	movw	r12, r22
    29ce:	e8 94       	clt
    29d0:	c0 f8       	bld	r12, 0
	unsigned int poolsize = count * skbfsize;
    29d2:	8c 9d       	mul	r24, r12
    29d4:	80 01       	movw	r16, r0
    29d6:	8d 9d       	mul	r24, r13
    29d8:	10 0d       	add	r17, r0
    29da:	9c 9d       	mul	r25, r12
    29dc:	10 0d       	add	r17, r0
    29de:	11 24       	eor	r1, r1

	csp_buffer_pool = csp_malloc(poolsize);
    29e0:	c8 01       	movw	r24, r16
    29e2:	a5 de       	rcall	.-694    	; 0x272e <csp_malloc>
    29e4:	90 93 ee 1d 	sts	0x1DEE, r25	; 0x801dee <csp_buffer_pool+0x1>
    29e8:	80 93 ed 1d 	sts	0x1DED, r24	; 0x801ded <csp_buffer_pool>
	if (csp_buffer_pool == NULL)
    29ec:	89 2b       	or	r24, r25
    29ee:	09 f4       	brne	.+2      	; 0x29f2 <csp_buffer_init+0x58>
    29f0:	4f c0       	rjmp	.+158    	; 0x2a90 <csp_buffer_init+0xf6>
		goto fail_malloc;

	csp_buffers = csp_queue_create(count, sizeof(void *));
    29f2:	62 e0       	ldi	r22, 0x02	; 2
    29f4:	70 e0       	ldi	r23, 0x00	; 0
    29f6:	80 91 eb 1d 	lds	r24, 0x1DEB	; 0x801deb <count>
    29fa:	90 91 ec 1d 	lds	r25, 0x1DEC	; 0x801dec <count+0x1>
    29fe:	9d de       	rcall	.-710    	; 0x273a <csp_queue_create>
    2a00:	90 93 f0 1d 	sts	0x1DF0, r25	; 0x801df0 <csp_buffers+0x1>
    2a04:	80 93 ef 1d 	sts	0x1DEF, r24	; 0x801def <csp_buffers>
	
	if (!csp_buffers)
    2a08:	89 2b       	or	r24, r25
    2a0a:	d1 f1       	breq	.+116    	; 0x2a80 <csp_buffer_init+0xe6>
		goto fail_queue;

	if (CSP_INIT_CRITICAL(csp_critical_lock) != CSP_ERR_NONE)
		goto fail_critical;

	memset(csp_buffer_pool, 0, poolsize);
    2a0c:	a8 01       	movw	r20, r16
    2a0e:	60 e0       	ldi	r22, 0x00	; 0
    2a10:	70 e0       	ldi	r23, 0x00	; 0
    2a12:	80 91 ed 1d 	lds	r24, 0x1DED	; 0x801ded <csp_buffer_pool>
    2a16:	90 91 ee 1d 	lds	r25, 0x1DEE	; 0x801dee <csp_buffer_pool+0x1>
    2a1a:	0e 94 39 2c 	call	0x5872	; 0x5872 <memset>

	for (i = 0; i < count; i++) {
    2a1e:	80 91 eb 1d 	lds	r24, 0x1DEB	; 0x801deb <count>
    2a22:	90 91 ec 1d 	lds	r25, 0x1DEC	; 0x801dec <count+0x1>
    2a26:	89 2b       	or	r24, r25
    2a28:	b1 f1       	breq	.+108    	; 0x2a96 <csp_buffer_init+0xfc>
    2a2a:	e1 2c       	mov	r14, r1
    2a2c:	f1 2c       	mov	r15, r1
    2a2e:	00 e0       	ldi	r16, 0x00	; 0
    2a30:	10 e0       	ldi	r17, 0x00	; 0
		/* We have already taken care of pointer alignment since
		 * skbfsize is an integer multiple of sizeof(int *)
		 * but the explicit cast to a void * is still necessary
		 * to tell the compiler so.
		 */
		buf = (void *) &csp_buffer_pool[i * skbfsize];
    2a32:	e0 91 ed 1d 	lds	r30, 0x1DED	; 0x801ded <csp_buffer_pool>
    2a36:	f0 91 ee 1d 	lds	r31, 0x1DEE	; 0x801dee <csp_buffer_pool+0x1>
    2a3a:	ee 0d       	add	r30, r14
    2a3c:	ff 1d       	adc	r31, r15
    2a3e:	fa 83       	std	Y+2, r31	; 0x02
    2a40:	e9 83       	std	Y+1, r30	; 0x01
		buf->refcount = 0;
    2a42:	11 82       	std	Z+1, r1	; 0x01
    2a44:	10 82       	st	Z, r1
		buf->skbf_addr = buf;
    2a46:	e9 81       	ldd	r30, Y+1	; 0x01
    2a48:	fa 81       	ldd	r31, Y+2	; 0x02
    2a4a:	f3 83       	std	Z+3, r31	; 0x03
    2a4c:	e2 83       	std	Z+2, r30	; 0x02

		csp_queue_enqueue(csp_buffers, &buf, 0);
    2a4e:	20 e0       	ldi	r18, 0x00	; 0
    2a50:	30 e0       	ldi	r19, 0x00	; 0
    2a52:	a9 01       	movw	r20, r18
    2a54:	be 01       	movw	r22, r28
    2a56:	6f 5f       	subi	r22, 0xFF	; 255
    2a58:	7f 4f       	sbci	r23, 0xFF	; 255
    2a5a:	80 91 ef 1d 	lds	r24, 0x1DEF	; 0x801def <csp_buffers>
    2a5e:	90 91 f0 1d 	lds	r25, 0x1DF0	; 0x801df0 <csp_buffers+0x1>
    2a62:	6e de       	rcall	.-804    	; 0x2740 <csp_queue_enqueue>
	if (CSP_INIT_CRITICAL(csp_critical_lock) != CSP_ERR_NONE)
		goto fail_critical;

	memset(csp_buffer_pool, 0, poolsize);

	for (i = 0; i < count; i++) {
    2a64:	0f 5f       	subi	r16, 0xFF	; 255
    2a66:	1f 4f       	sbci	r17, 0xFF	; 255
    2a68:	ec 0c       	add	r14, r12
    2a6a:	fd 1c       	adc	r15, r13
    2a6c:	80 91 eb 1d 	lds	r24, 0x1DEB	; 0x801deb <count>
    2a70:	90 91 ec 1d 	lds	r25, 0x1DEC	; 0x801dec <count+0x1>
    2a74:	08 17       	cp	r16, r24
    2a76:	19 07       	cpc	r17, r25
    2a78:	e0 f2       	brcs	.-72     	; 0x2a32 <csp_buffer_init+0x98>

		csp_queue_enqueue(csp_buffers, &buf, 0);

	}

	return CSP_ERR_NONE;
    2a7a:	80 e0       	ldi	r24, 0x00	; 0
    2a7c:	90 e0       	ldi	r25, 0x00	; 0
    2a7e:	0d c0       	rjmp	.+26     	; 0x2a9a <csp_buffer_init+0x100>

fail_critical:
	csp_queue_remove(csp_buffers);
fail_queue:
	csp_free(csp_buffer_pool);
    2a80:	80 91 ed 1d 	lds	r24, 0x1DED	; 0x801ded <csp_buffer_pool>
    2a84:	90 91 ee 1d 	lds	r25, 0x1DEE	; 0x801dee <csp_buffer_pool+0x1>
    2a88:	55 de       	rcall	.-854    	; 0x2734 <csp_free>
fail_malloc:
	return CSP_ERR_NOMEM;
    2a8a:	8f ef       	ldi	r24, 0xFF	; 255
    2a8c:	9f ef       	ldi	r25, 0xFF	; 255
    2a8e:	05 c0       	rjmp	.+10     	; 0x2a9a <csp_buffer_init+0x100>
    2a90:	8f ef       	ldi	r24, 0xFF	; 255
    2a92:	9f ef       	ldi	r25, 0xFF	; 255
    2a94:	02 c0       	rjmp	.+4      	; 0x2a9a <csp_buffer_init+0x100>

		csp_queue_enqueue(csp_buffers, &buf, 0);

	}

	return CSP_ERR_NONE;
    2a96:	80 e0       	ldi	r24, 0x00	; 0
    2a98:	90 e0       	ldi	r25, 0x00	; 0
fail_queue:
	csp_free(csp_buffer_pool);
fail_malloc:
	return CSP_ERR_NOMEM;

}
    2a9a:	0f 90       	pop	r0
    2a9c:	0f 90       	pop	r0
    2a9e:	df 91       	pop	r29
    2aa0:	cf 91       	pop	r28
    2aa2:	1f 91       	pop	r17
    2aa4:	0f 91       	pop	r16
    2aa6:	ff 90       	pop	r15
    2aa8:	ef 90       	pop	r14
    2aaa:	df 90       	pop	r13
    2aac:	cf 90       	pop	r12
    2aae:	08 95       	ret

00002ab0 <csp_buffer_get_isr>:

void *csp_buffer_get_isr(size_t buf_size) {
    2ab0:	cf 93       	push	r28
    2ab2:	df 93       	push	r29
    2ab4:	00 d0       	rcall	.+0      	; 0x2ab6 <csp_buffer_get_isr+0x6>
    2ab6:	cd b7       	in	r28, 0x3d	; 61
    2ab8:	de b7       	in	r29, 0x3e	; 62

	csp_skbf_t * buffer = NULL;
    2aba:	1a 82       	std	Y+2, r1	; 0x02
    2abc:	19 82       	std	Y+1, r1	; 0x01
	CSP_BASE_TYPE task_woken = 0;
    2abe:	1b 82       	std	Y+3, r1	; 0x03

	if (buf_size + CSP_BUFFER_PACKET_OVERHEAD > size)
    2ac0:	0e 96       	adiw	r24, 0x0e	; 14
    2ac2:	20 91 e9 1d 	lds	r18, 0x1DE9	; 0x801de9 <size>
    2ac6:	30 91 ea 1d 	lds	r19, 0x1DEA	; 0x801dea <size+0x1>
    2aca:	28 17       	cp	r18, r24
    2acc:	39 07       	cpc	r19, r25
    2ace:	e8 f0       	brcs	.+58     	; 0x2b0a <csp_buffer_get_isr+0x5a>
		return NULL;

	csp_queue_dequeue_isr(csp_buffers, &buffer, &task_woken);
    2ad0:	ae 01       	movw	r20, r28
    2ad2:	4d 5f       	subi	r20, 0xFD	; 253
    2ad4:	5f 4f       	sbci	r21, 0xFF	; 255
    2ad6:	be 01       	movw	r22, r28
    2ad8:	6f 5f       	subi	r22, 0xFF	; 255
    2ada:	7f 4f       	sbci	r23, 0xFF	; 255
    2adc:	80 91 ef 1d 	lds	r24, 0x1DEF	; 0x801def <csp_buffers>
    2ae0:	90 91 f0 1d 	lds	r25, 0x1DF0	; 0x801df0 <csp_buffers+0x1>
    2ae4:	43 de       	rcall	.-890    	; 0x276c <csp_queue_dequeue_isr>
	if (buffer == NULL)
    2ae6:	e9 81       	ldd	r30, Y+1	; 0x01
    2ae8:	fa 81       	ldd	r31, Y+2	; 0x02
    2aea:	30 97       	sbiw	r30, 0x00	; 0
    2aec:	89 f0       	breq	.+34     	; 0x2b10 <csp_buffer_get_isr+0x60>
		return NULL;

	if (buffer != buffer->skbf_addr)
    2aee:	82 81       	ldd	r24, Z+2	; 0x02
    2af0:	93 81       	ldd	r25, Z+3	; 0x03
    2af2:	e8 17       	cp	r30, r24
    2af4:	f9 07       	cpc	r31, r25
    2af6:	79 f4       	brne	.+30     	; 0x2b16 <csp_buffer_get_isr+0x66>
		return NULL;

	buffer->refcount++;
    2af8:	80 81       	ld	r24, Z
    2afa:	91 81       	ldd	r25, Z+1	; 0x01
    2afc:	01 96       	adiw	r24, 0x01	; 1
    2afe:	91 83       	std	Z+1, r25	; 0x01
    2b00:	80 83       	st	Z, r24
	return buffer->skbf_data;
    2b02:	89 81       	ldd	r24, Y+1	; 0x01
    2b04:	9a 81       	ldd	r25, Y+2	; 0x02
    2b06:	04 96       	adiw	r24, 0x04	; 4
    2b08:	08 c0       	rjmp	.+16     	; 0x2b1a <csp_buffer_get_isr+0x6a>

	csp_skbf_t * buffer = NULL;
	CSP_BASE_TYPE task_woken = 0;

	if (buf_size + CSP_BUFFER_PACKET_OVERHEAD > size)
		return NULL;
    2b0a:	80 e0       	ldi	r24, 0x00	; 0
    2b0c:	90 e0       	ldi	r25, 0x00	; 0
    2b0e:	05 c0       	rjmp	.+10     	; 0x2b1a <csp_buffer_get_isr+0x6a>

	csp_queue_dequeue_isr(csp_buffers, &buffer, &task_woken);
	if (buffer == NULL)
		return NULL;
    2b10:	80 e0       	ldi	r24, 0x00	; 0
    2b12:	90 e0       	ldi	r25, 0x00	; 0
    2b14:	02 c0       	rjmp	.+4      	; 0x2b1a <csp_buffer_get_isr+0x6a>

	if (buffer != buffer->skbf_addr)
		return NULL;
    2b16:	80 e0       	ldi	r24, 0x00	; 0
    2b18:	90 e0       	ldi	r25, 0x00	; 0

	buffer->refcount++;
	return buffer->skbf_data;

}
    2b1a:	0f 90       	pop	r0
    2b1c:	0f 90       	pop	r0
    2b1e:	0f 90       	pop	r0
    2b20:	df 91       	pop	r29
    2b22:	cf 91       	pop	r28
    2b24:	08 95       	ret

00002b26 <csp_buffer_get>:

void *csp_buffer_get(size_t buf_size) {
    2b26:	ef 92       	push	r14
    2b28:	ff 92       	push	r15
    2b2a:	0f 93       	push	r16
    2b2c:	1f 93       	push	r17
    2b2e:	cf 93       	push	r28
    2b30:	df 93       	push	r29
    2b32:	1f 92       	push	r1
    2b34:	1f 92       	push	r1
    2b36:	cd b7       	in	r28, 0x3d	; 61
    2b38:	de b7       	in	r29, 0x3e	; 62
    2b3a:	8c 01       	movw	r16, r24

	csp_skbf_t * buffer = NULL;
    2b3c:	1a 82       	std	Y+2, r1	; 0x02
    2b3e:	19 82       	std	Y+1, r1	; 0x01

	if (buf_size + CSP_BUFFER_PACKET_OVERHEAD > size) {
    2b40:	9c 01       	movw	r18, r24
    2b42:	22 5f       	subi	r18, 0xF2	; 242
    2b44:	3f 4f       	sbci	r19, 0xFF	; 255
    2b46:	80 91 e9 1d 	lds	r24, 0x1DE9	; 0x801de9 <size>
    2b4a:	90 91 ea 1d 	lds	r25, 0x1DEA	; 0x801dea <size+0x1>
    2b4e:	82 17       	cp	r24, r18
    2b50:	93 07       	cpc	r25, r19
    2b52:	f8 f4       	brcc	.+62     	; 0x2b92 <csp_buffer_get+0x6c>
		csp_log_error("Attempt to allocate too large block %u", buf_size);
    2b54:	80 91 04 02 	lds	r24, 0x0204	; 0x800204 <csp_debug_level_enabled>
    2b58:	88 23       	and	r24, r24
    2b5a:	09 f4       	brne	.+2      	; 0x2b5e <csp_buffer_get+0x38>
    2b5c:	94 c0       	rjmp	.+296    	; 0x2c86 <csp_buffer_get+0x160>
    2b5e:	b2 d6       	rcall	.+3428   	; 0x38c4 <csp_get_address>
    2b60:	1f 93       	push	r17
    2b62:	0f 93       	push	r16
    2b64:	1f 92       	push	r1
    2b66:	9c e7       	ldi	r25, 0x7C	; 124
    2b68:	9f 93       	push	r25
    2b6a:	26 ec       	ldi	r18, 0xC6	; 198
    2b6c:	32 e0       	ldi	r19, 0x02	; 2
    2b6e:	3f 93       	push	r19
    2b70:	2f 93       	push	r18
    2b72:	1f 92       	push	r1
    2b74:	8f 93       	push	r24
    2b76:	8b e0       	ldi	r24, 0x0B	; 11
    2b78:	94 e0       	ldi	r25, 0x04	; 4
    2b7a:	9f 93       	push	r25
    2b7c:	8f 93       	push	r24
    2b7e:	1f 92       	push	r1
    2b80:	b9 d5       	rcall	.+2930   	; 0x36f4 <do_csp_debug>
    2b82:	0f b6       	in	r0, 0x3f	; 63
    2b84:	f8 94       	cli
    2b86:	de bf       	out	0x3e, r29	; 62
    2b88:	0f be       	out	0x3f, r0	; 63
    2b8a:	cd bf       	out	0x3d, r28	; 61
		return NULL;
    2b8c:	80 e0       	ldi	r24, 0x00	; 0
    2b8e:	90 e0       	ldi	r25, 0x00	; 0
    2b90:	82 c0       	rjmp	.+260    	; 0x2c96 <csp_buffer_get+0x170>
	}

	csp_queue_dequeue(csp_buffers, &buffer, 0);
    2b92:	20 e0       	ldi	r18, 0x00	; 0
    2b94:	30 e0       	ldi	r19, 0x00	; 0
    2b96:	a9 01       	movw	r20, r18
    2b98:	be 01       	movw	r22, r28
    2b9a:	6f 5f       	subi	r22, 0xFF	; 255
    2b9c:	7f 4f       	sbci	r23, 0xFF	; 255
    2b9e:	80 91 ef 1d 	lds	r24, 0x1DEF	; 0x801def <csp_buffers>
    2ba2:	90 91 f0 1d 	lds	r25, 0x1DF0	; 0x801df0 <csp_buffers+0x1>
    2ba6:	da dd       	rcall	.-1100   	; 0x275c <csp_queue_dequeue>
	if (buffer == NULL) {
    2ba8:	09 81       	ldd	r16, Y+1	; 0x01
    2baa:	1a 81       	ldd	r17, Y+2	; 0x02
    2bac:	01 15       	cp	r16, r1
    2bae:	11 05       	cpc	r17, r1
    2bb0:	e9 f4       	brne	.+58     	; 0x2bec <csp_buffer_get+0xc6>
		csp_log_error("Out of buffers");
    2bb2:	80 91 04 02 	lds	r24, 0x0204	; 0x800204 <csp_debug_level_enabled>
    2bb6:	88 23       	and	r24, r24
    2bb8:	09 f4       	brne	.+2      	; 0x2bbc <csp_buffer_get+0x96>
    2bba:	68 c0       	rjmp	.+208    	; 0x2c8c <csp_buffer_get+0x166>
    2bbc:	83 d6       	rcall	.+3334   	; 0x38c4 <csp_get_address>
    2bbe:	1f 92       	push	r1
    2bc0:	92 e8       	ldi	r25, 0x82	; 130
    2bc2:	9f 93       	push	r25
    2bc4:	26 ec       	ldi	r18, 0xC6	; 198
    2bc6:	32 e0       	ldi	r19, 0x02	; 2
    2bc8:	3f 93       	push	r19
    2bca:	2f 93       	push	r18
    2bcc:	1f 92       	push	r1
    2bce:	8f 93       	push	r24
    2bd0:	8f ee       	ldi	r24, 0xEF	; 239
    2bd2:	93 e0       	ldi	r25, 0x03	; 3
    2bd4:	9f 93       	push	r25
    2bd6:	8f 93       	push	r24
    2bd8:	1f 92       	push	r1
    2bda:	8c d5       	rcall	.+2840   	; 0x36f4 <do_csp_debug>
    2bdc:	0f b6       	in	r0, 0x3f	; 63
    2bde:	f8 94       	cli
    2be0:	de bf       	out	0x3e, r29	; 62
    2be2:	0f be       	out	0x3f, r0	; 63
    2be4:	cd bf       	out	0x3d, r28	; 61
		return NULL;
    2be6:	80 e0       	ldi	r24, 0x00	; 0
    2be8:	90 e0       	ldi	r25, 0x00	; 0
    2bea:	55 c0       	rjmp	.+170    	; 0x2c96 <csp_buffer_get+0x170>
	}

	csp_log_buffer("GET: %p %p", buffer, buffer->skbf_addr);
    2bec:	80 91 07 02 	lds	r24, 0x0207	; 0x800207 <csp_debug_level_enabled+0x3>
    2bf0:	88 23       	and	r24, r24
    2bf2:	e9 f0       	breq	.+58     	; 0x2c2e <csp_buffer_get+0x108>
    2bf4:	f8 01       	movw	r30, r16
    2bf6:	f2 80       	ldd	r15, Z+2	; 0x02
    2bf8:	e3 80       	ldd	r14, Z+3	; 0x03
    2bfa:	64 d6       	rcall	.+3272   	; 0x38c4 <csp_get_address>
    2bfc:	ef 92       	push	r14
    2bfe:	ff 92       	push	r15
    2c00:	1f 93       	push	r17
    2c02:	0f 93       	push	r16
    2c04:	1f 92       	push	r1
    2c06:	96 e8       	ldi	r25, 0x86	; 134
    2c08:	9f 93       	push	r25
    2c0a:	26 ec       	ldi	r18, 0xC6	; 198
    2c0c:	32 e0       	ldi	r19, 0x02	; 2
    2c0e:	3f 93       	push	r19
    2c10:	2f 93       	push	r18
    2c12:	1f 92       	push	r1
    2c14:	8f 93       	push	r24
    2c16:	87 ed       	ldi	r24, 0xD7	; 215
    2c18:	93 e0       	ldi	r25, 0x03	; 3
    2c1a:	9f 93       	push	r25
    2c1c:	8f 93       	push	r24
    2c1e:	83 e0       	ldi	r24, 0x03	; 3
    2c20:	8f 93       	push	r24
    2c22:	68 d5       	rcall	.+2768   	; 0x36f4 <do_csp_debug>
    2c24:	0f b6       	in	r0, 0x3f	; 63
    2c26:	f8 94       	cli
    2c28:	de bf       	out	0x3e, r29	; 62
    2c2a:	0f be       	out	0x3f, r0	; 63
    2c2c:	cd bf       	out	0x3d, r28	; 61

	if (buffer != buffer->skbf_addr) {
    2c2e:	e9 81       	ldd	r30, Y+1	; 0x01
    2c30:	fa 81       	ldd	r31, Y+2	; 0x02
    2c32:	82 81       	ldd	r24, Z+2	; 0x02
    2c34:	93 81       	ldd	r25, Z+3	; 0x03
    2c36:	e8 17       	cp	r30, r24
    2c38:	f9 07       	cpc	r31, r25
		csp_log_error("Corrupt CSP buffer");
    2c3a:	e1 f0       	breq	.+56     	; 0x2c74 <csp_buffer_get+0x14e>
    2c3c:	80 91 04 02 	lds	r24, 0x0204	; 0x800204 <csp_debug_level_enabled>
    2c40:	88 23       	and	r24, r24
    2c42:	39 f1       	breq	.+78     	; 0x2c92 <csp_buffer_get+0x16c>
    2c44:	3f d6       	rcall	.+3198   	; 0x38c4 <csp_get_address>
    2c46:	1f 92       	push	r1
    2c48:	99 e8       	ldi	r25, 0x89	; 137
    2c4a:	9f 93       	push	r25
    2c4c:	26 ec       	ldi	r18, 0xC6	; 198
    2c4e:	32 e0       	ldi	r19, 0x02	; 2
    2c50:	3f 93       	push	r19
    2c52:	2f 93       	push	r18
    2c54:	1f 92       	push	r1
    2c56:	8f 93       	push	r24
    2c58:	87 eb       	ldi	r24, 0xB7	; 183
    2c5a:	93 e0       	ldi	r25, 0x03	; 3
    2c5c:	9f 93       	push	r25
    2c5e:	8f 93       	push	r24
    2c60:	1f 92       	push	r1
    2c62:	48 d5       	rcall	.+2704   	; 0x36f4 <do_csp_debug>
    2c64:	0f b6       	in	r0, 0x3f	; 63
    2c66:	f8 94       	cli
    2c68:	de bf       	out	0x3e, r29	; 62
    2c6a:	0f be       	out	0x3f, r0	; 63
    2c6c:	cd bf       	out	0x3d, r28	; 61
		return NULL;
    2c6e:	80 e0       	ldi	r24, 0x00	; 0
    2c70:	90 e0       	ldi	r25, 0x00	; 0
    2c72:	11 c0       	rjmp	.+34     	; 0x2c96 <csp_buffer_get+0x170>
	}

	buffer->refcount++;
    2c74:	80 81       	ld	r24, Z
    2c76:	91 81       	ldd	r25, Z+1	; 0x01
    2c78:	01 96       	adiw	r24, 0x01	; 1
    2c7a:	91 83       	std	Z+1, r25	; 0x01
    2c7c:	80 83       	st	Z, r24
	return buffer->skbf_data;
    2c7e:	89 81       	ldd	r24, Y+1	; 0x01
    2c80:	9a 81       	ldd	r25, Y+2	; 0x02
    2c82:	04 96       	adiw	r24, 0x04	; 4
    2c84:	08 c0       	rjmp	.+16     	; 0x2c96 <csp_buffer_get+0x170>

	csp_skbf_t * buffer = NULL;

	if (buf_size + CSP_BUFFER_PACKET_OVERHEAD > size) {
		csp_log_error("Attempt to allocate too large block %u", buf_size);
		return NULL;
    2c86:	80 e0       	ldi	r24, 0x00	; 0
    2c88:	90 e0       	ldi	r25, 0x00	; 0
    2c8a:	05 c0       	rjmp	.+10     	; 0x2c96 <csp_buffer_get+0x170>
	}

	csp_queue_dequeue(csp_buffers, &buffer, 0);
	if (buffer == NULL) {
		csp_log_error("Out of buffers");
		return NULL;
    2c8c:	80 e0       	ldi	r24, 0x00	; 0
    2c8e:	90 e0       	ldi	r25, 0x00	; 0
    2c90:	02 c0       	rjmp	.+4      	; 0x2c96 <csp_buffer_get+0x170>

	csp_log_buffer("GET: %p %p", buffer, buffer->skbf_addr);

	if (buffer != buffer->skbf_addr) {
		csp_log_error("Corrupt CSP buffer");
		return NULL;
    2c92:	80 e0       	ldi	r24, 0x00	; 0
    2c94:	90 e0       	ldi	r25, 0x00	; 0
	}

	buffer->refcount++;
	return buffer->skbf_data;
}
    2c96:	0f 90       	pop	r0
    2c98:	0f 90       	pop	r0
    2c9a:	df 91       	pop	r29
    2c9c:	cf 91       	pop	r28
    2c9e:	1f 91       	pop	r17
    2ca0:	0f 91       	pop	r16
    2ca2:	ff 90       	pop	r15
    2ca4:	ef 90       	pop	r14
    2ca6:	08 95       	ret

00002ca8 <csp_buffer_free_isr>:

void csp_buffer_free_isr(void *packet) {
    2ca8:	cf 93       	push	r28
    2caa:	df 93       	push	r29
    2cac:	00 d0       	rcall	.+0      	; 0x2cae <csp_buffer_free_isr+0x6>
    2cae:	cd b7       	in	r28, 0x3d	; 61
    2cb0:	de b7       	in	r29, 0x3e	; 62
	CSP_BASE_TYPE task_woken = 0;
    2cb2:	19 82       	std	Y+1, r1	; 0x01
	if (!packet)
    2cb4:	00 97       	sbiw	r24, 0x00	; 0
    2cb6:	51 f1       	breq	.+84     	; 0x2d0c <csp_buffer_free_isr+0x64>
		return;

	csp_skbf_t * buf = packet - sizeof(csp_skbf_t);
    2cb8:	9c 01       	movw	r18, r24
    2cba:	24 50       	subi	r18, 0x04	; 4
    2cbc:	31 09       	sbc	r19, r1
    2cbe:	3b 83       	std	Y+3, r19	; 0x03
    2cc0:	2a 83       	std	Y+2, r18	; 0x02

	if (((uintptr_t) buf % CSP_BUFFER_ALIGN) > 0)
    2cc2:	20 fd       	sbrc	r18, 0
    2cc4:	23 c0       	rjmp	.+70     	; 0x2d0c <csp_buffer_free_isr+0x64>
		return;

	if (buf->skbf_addr != buf)
    2cc6:	f9 01       	movw	r30, r18
    2cc8:	42 81       	ldd	r20, Z+2	; 0x02
    2cca:	53 81       	ldd	r21, Z+3	; 0x03
    2ccc:	24 17       	cp	r18, r20
    2cce:	35 07       	cpc	r19, r21
    2cd0:	e9 f4       	brne	.+58     	; 0x2d0c <csp_buffer_free_isr+0x64>
		return;

	if (buf->refcount == 0) {
    2cd2:	f9 01       	movw	r30, r18
    2cd4:	20 81       	ld	r18, Z
    2cd6:	31 81       	ldd	r19, Z+1	; 0x01
    2cd8:	21 15       	cp	r18, r1
    2cda:	31 05       	cpc	r19, r1
    2cdc:	b9 f0       	breq	.+46     	; 0x2d0c <csp_buffer_free_isr+0x64>
		return;
	} else if (buf->refcount > 1) {
    2cde:	22 30       	cpi	r18, 0x02	; 2
    2ce0:	31 05       	cpc	r19, r1
    2ce2:	28 f0       	brcs	.+10     	; 0x2cee <csp_buffer_free_isr+0x46>
		buf->refcount--;
    2ce4:	21 50       	subi	r18, 0x01	; 1
    2ce6:	31 09       	sbc	r19, r1
    2ce8:	31 83       	std	Z+1, r19	; 0x01
    2cea:	20 83       	st	Z, r18
		return;
    2cec:	0f c0       	rjmp	.+30     	; 0x2d0c <csp_buffer_free_isr+0x64>
	} else {
		buf->refcount = 0;
    2cee:	fc 01       	movw	r30, r24
    2cf0:	34 97       	sbiw	r30, 0x04	; 4
    2cf2:	11 82       	std	Z+1, r1	; 0x01
    2cf4:	10 82       	st	Z, r1
		csp_queue_enqueue_isr(csp_buffers, &buf, &task_woken);
    2cf6:	ae 01       	movw	r20, r28
    2cf8:	4f 5f       	subi	r20, 0xFF	; 255
    2cfa:	5f 4f       	sbci	r21, 0xFF	; 255
    2cfc:	be 01       	movw	r22, r28
    2cfe:	6e 5f       	subi	r22, 0xFE	; 254
    2d00:	7f 4f       	sbci	r23, 0xFF	; 255
    2d02:	80 91 ef 1d 	lds	r24, 0x1DEF	; 0x801def <csp_buffers>
    2d06:	90 91 f0 1d 	lds	r25, 0x1DF0	; 0x801df0 <csp_buffers+0x1>
    2d0a:	22 dd       	rcall	.-1468   	; 0x2750 <csp_queue_enqueue_isr>
	}

}
    2d0c:	0f 90       	pop	r0
    2d0e:	0f 90       	pop	r0
    2d10:	0f 90       	pop	r0
    2d12:	df 91       	pop	r29
    2d14:	cf 91       	pop	r28
    2d16:	08 95       	ret

00002d18 <csp_buffer_free>:

void csp_buffer_free(void *packet) {
    2d18:	cf 92       	push	r12
    2d1a:	df 92       	push	r13
    2d1c:	ef 92       	push	r14
    2d1e:	ff 92       	push	r15
    2d20:	0f 93       	push	r16
    2d22:	1f 93       	push	r17
    2d24:	cf 93       	push	r28
    2d26:	df 93       	push	r29
    2d28:	1f 92       	push	r1
    2d2a:	1f 92       	push	r1
    2d2c:	cd b7       	in	r28, 0x3d	; 61
    2d2e:	de b7       	in	r29, 0x3e	; 62
    2d30:	8c 01       	movw	r16, r24
	if (!packet) {
    2d32:	00 97       	sbiw	r24, 0x00	; 0
    2d34:	d9 f4       	brne	.+54     	; 0x2d6c <csp_buffer_free+0x54>
		csp_log_error("Attempt to free null pointer");
    2d36:	80 91 04 02 	lds	r24, 0x0204	; 0x800204 <csp_debug_level_enabled>
    2d3a:	88 23       	and	r24, r24
    2d3c:	09 f4       	brne	.+2      	; 0x2d40 <csp_buffer_free+0x28>
    2d3e:	d7 c0       	rjmp	.+430    	; 0x2eee <csp_buffer_free+0x1d6>
    2d40:	c1 d5       	rcall	.+2946   	; 0x38c4 <csp_get_address>
    2d42:	1f 92       	push	r1
    2d44:	9c ea       	ldi	r25, 0xAC	; 172
    2d46:	9f 93       	push	r25
    2d48:	26 ec       	ldi	r18, 0xC6	; 198
    2d4a:	32 e0       	ldi	r19, 0x02	; 2
    2d4c:	3f 93       	push	r19
    2d4e:	2f 93       	push	r18
    2d50:	1f 92       	push	r1
    2d52:	8f 93       	push	r24
    2d54:	8d e8       	ldi	r24, 0x8D	; 141
    2d56:	93 e0       	ldi	r25, 0x03	; 3
    2d58:	9f 93       	push	r25
    2d5a:	8f 93       	push	r24
    2d5c:	1f 92       	push	r1
    2d5e:	ca d4       	rcall	.+2452   	; 0x36f4 <do_csp_debug>
    2d60:	0f b6       	in	r0, 0x3f	; 63
    2d62:	f8 94       	cli
    2d64:	de bf       	out	0x3e, r29	; 62
    2d66:	0f be       	out	0x3f, r0	; 63
    2d68:	cd bf       	out	0x3d, r28	; 61
    2d6a:	c1 c0       	rjmp	.+386    	; 0x2eee <csp_buffer_free+0x1d6>
		return;
	}

	csp_skbf_t * buf = packet - sizeof(csp_skbf_t);
    2d6c:	7c 01       	movw	r14, r24
    2d6e:	94 e0       	ldi	r25, 0x04	; 4
    2d70:	e9 1a       	sub	r14, r25
    2d72:	f1 08       	sbc	r15, r1
    2d74:	fa 82       	std	Y+2, r15	; 0x02
    2d76:	e9 82       	std	Y+1, r14	; 0x01

	if (((uintptr_t) buf % CSP_BUFFER_ALIGN) > 0) {
    2d78:	e0 fe       	sbrs	r14, 0
    2d7a:	1d c0       	rjmp	.+58     	; 0x2db6 <csp_buffer_free+0x9e>
		csp_log_error("FREE: Unaligned CSP buffer pointer %p", packet);
    2d7c:	80 91 04 02 	lds	r24, 0x0204	; 0x800204 <csp_debug_level_enabled>
    2d80:	88 23       	and	r24, r24
    2d82:	09 f4       	brne	.+2      	; 0x2d86 <csp_buffer_free+0x6e>
    2d84:	b4 c0       	rjmp	.+360    	; 0x2eee <csp_buffer_free+0x1d6>
    2d86:	9e d5       	rcall	.+2876   	; 0x38c4 <csp_get_address>
    2d88:	1f 93       	push	r17
    2d8a:	0f 93       	push	r16
    2d8c:	1f 92       	push	r1
    2d8e:	93 eb       	ldi	r25, 0xB3	; 179
    2d90:	9f 93       	push	r25
    2d92:	26 ec       	ldi	r18, 0xC6	; 198
    2d94:	32 e0       	ldi	r19, 0x02	; 2
    2d96:	3f 93       	push	r19
    2d98:	2f 93       	push	r18
    2d9a:	1f 92       	push	r1
    2d9c:	8f 93       	push	r24
    2d9e:	8a e5       	ldi	r24, 0x5A	; 90
    2da0:	93 e0       	ldi	r25, 0x03	; 3
    2da2:	9f 93       	push	r25
    2da4:	8f 93       	push	r24
    2da6:	1f 92       	push	r1
    2da8:	a5 d4       	rcall	.+2378   	; 0x36f4 <do_csp_debug>
    2daa:	0f b6       	in	r0, 0x3f	; 63
    2dac:	f8 94       	cli
    2dae:	de bf       	out	0x3e, r29	; 62
    2db0:	0f be       	out	0x3f, r0	; 63
    2db2:	cd bf       	out	0x3d, r28	; 61
    2db4:	9c c0       	rjmp	.+312    	; 0x2eee <csp_buffer_free+0x1d6>
		return;
	}

	if (buf->skbf_addr != buf) {
    2db6:	f8 01       	movw	r30, r16
    2db8:	34 97       	sbiw	r30, 0x04	; 4
    2dba:	82 81       	ldd	r24, Z+2	; 0x02
    2dbc:	93 81       	ldd	r25, Z+3	; 0x03
    2dbe:	e8 16       	cp	r14, r24
    2dc0:	f9 06       	cpc	r15, r25
    2dc2:	e9 f0       	breq	.+58     	; 0x2dfe <csp_buffer_free+0xe6>
		csp_log_error("FREE: Invalid CSP buffer pointer %p", packet);
    2dc4:	80 91 04 02 	lds	r24, 0x0204	; 0x800204 <csp_debug_level_enabled>
    2dc8:	88 23       	and	r24, r24
    2dca:	09 f4       	brne	.+2      	; 0x2dce <csp_buffer_free+0xb6>
    2dcc:	90 c0       	rjmp	.+288    	; 0x2eee <csp_buffer_free+0x1d6>
    2dce:	7a d5       	rcall	.+2804   	; 0x38c4 <csp_get_address>
    2dd0:	1f 93       	push	r17
    2dd2:	0f 93       	push	r16
    2dd4:	1f 92       	push	r1
    2dd6:	98 eb       	ldi	r25, 0xB8	; 184
    2dd8:	9f 93       	push	r25
    2dda:	26 ec       	ldi	r18, 0xC6	; 198
    2ddc:	32 e0       	ldi	r19, 0x02	; 2
    2dde:	3f 93       	push	r19
    2de0:	2f 93       	push	r18
    2de2:	1f 92       	push	r1
    2de4:	8f 93       	push	r24
    2de6:	89 e2       	ldi	r24, 0x29	; 41
    2de8:	93 e0       	ldi	r25, 0x03	; 3
    2dea:	9f 93       	push	r25
    2dec:	8f 93       	push	r24
    2dee:	1f 92       	push	r1
    2df0:	81 d4       	rcall	.+2306   	; 0x36f4 <do_csp_debug>
    2df2:	0f b6       	in	r0, 0x3f	; 63
    2df4:	f8 94       	cli
    2df6:	de bf       	out	0x3e, r29	; 62
    2df8:	0f be       	out	0x3f, r0	; 63
    2dfa:	cd bf       	out	0x3d, r28	; 61
    2dfc:	78 c0       	rjmp	.+240    	; 0x2eee <csp_buffer_free+0x1d6>
		return;
	}

	if (buf->refcount == 0) {
    2dfe:	f8 01       	movw	r30, r16
    2e00:	34 97       	sbiw	r30, 0x04	; 4
    2e02:	80 81       	ld	r24, Z
    2e04:	91 81       	ldd	r25, Z+1	; 0x01
    2e06:	00 97       	sbiw	r24, 0x00	; 0
		csp_log_error("FREE: Buffer already free %p", buf);
    2e08:	e9 f4       	brne	.+58     	; 0x2e44 <csp_buffer_free+0x12c>
    2e0a:	80 91 04 02 	lds	r24, 0x0204	; 0x800204 <csp_debug_level_enabled>
    2e0e:	88 23       	and	r24, r24
    2e10:	09 f4       	brne	.+2      	; 0x2e14 <csp_buffer_free+0xfc>
    2e12:	6d c0       	rjmp	.+218    	; 0x2eee <csp_buffer_free+0x1d6>
    2e14:	57 d5       	rcall	.+2734   	; 0x38c4 <csp_get_address>
    2e16:	ff 92       	push	r15
    2e18:	ef 92       	push	r14
    2e1a:	1f 92       	push	r1
    2e1c:	9d eb       	ldi	r25, 0xBD	; 189
    2e1e:	9f 93       	push	r25
    2e20:	26 ec       	ldi	r18, 0xC6	; 198
    2e22:	32 e0       	ldi	r19, 0x02	; 2
    2e24:	3f 93       	push	r19
    2e26:	2f 93       	push	r18
    2e28:	1f 92       	push	r1
    2e2a:	8f 93       	push	r24
    2e2c:	8f ef       	ldi	r24, 0xFF	; 255
    2e2e:	92 e0       	ldi	r25, 0x02	; 2
    2e30:	9f 93       	push	r25
    2e32:	8f 93       	push	r24
    2e34:	1f 92       	push	r1
    2e36:	5e d4       	rcall	.+2236   	; 0x36f4 <do_csp_debug>
    2e38:	0f b6       	in	r0, 0x3f	; 63
    2e3a:	f8 94       	cli
    2e3c:	de bf       	out	0x3e, r29	; 62
    2e3e:	0f be       	out	0x3f, r0	; 63
    2e40:	cd bf       	out	0x3d, r28	; 61
    2e42:	55 c0       	rjmp	.+170    	; 0x2eee <csp_buffer_free+0x1d6>
		return;
	} else if (buf->refcount > 1) {
    2e44:	82 30       	cpi	r24, 0x02	; 2
    2e46:	91 05       	cpc	r25, r1
    2e48:	38 f1       	brcs	.+78     	; 0x2e98 <csp_buffer_free+0x180>
		buf->refcount--;
    2e4a:	6c 01       	movw	r12, r24
    2e4c:	21 e0       	ldi	r18, 0x01	; 1
    2e4e:	c2 1a       	sub	r12, r18
    2e50:	d1 08       	sbc	r13, r1
    2e52:	f8 01       	movw	r30, r16
    2e54:	34 97       	sbiw	r30, 0x04	; 4
    2e56:	d1 82       	std	Z+1, r13	; 0x01
		csp_log_error("FREE: Buffer %p in use by %u users", buf, buf->refcount);
    2e58:	c0 82       	st	Z, r12
    2e5a:	80 91 04 02 	lds	r24, 0x0204	; 0x800204 <csp_debug_level_enabled>
    2e5e:	88 23       	and	r24, r24
    2e60:	09 f4       	brne	.+2      	; 0x2e64 <csp_buffer_free+0x14c>
    2e62:	45 c0       	rjmp	.+138    	; 0x2eee <csp_buffer_free+0x1d6>
    2e64:	2f d5       	rcall	.+2654   	; 0x38c4 <csp_get_address>
    2e66:	df 92       	push	r13
    2e68:	cf 92       	push	r12
    2e6a:	ff 92       	push	r15
    2e6c:	ef 92       	push	r14
    2e6e:	1f 92       	push	r1
    2e70:	91 ec       	ldi	r25, 0xC1	; 193
    2e72:	9f 93       	push	r25
    2e74:	26 ec       	ldi	r18, 0xC6	; 198
    2e76:	32 e0       	ldi	r19, 0x02	; 2
    2e78:	3f 93       	push	r19
    2e7a:	2f 93       	push	r18
    2e7c:	1f 92       	push	r1
    2e7e:	8f 93       	push	r24
    2e80:	8f ec       	ldi	r24, 0xCF	; 207
    2e82:	92 e0       	ldi	r25, 0x02	; 2
    2e84:	9f 93       	push	r25
    2e86:	8f 93       	push	r24
    2e88:	1f 92       	push	r1
    2e8a:	34 d4       	rcall	.+2152   	; 0x36f4 <do_csp_debug>
    2e8c:	0f b6       	in	r0, 0x3f	; 63
    2e8e:	f8 94       	cli
    2e90:	de bf       	out	0x3e, r29	; 62
    2e92:	0f be       	out	0x3f, r0	; 63
    2e94:	cd bf       	out	0x3d, r28	; 61
		return;
	} else {
		buf->refcount = 0;
    2e96:	2b c0       	rjmp	.+86     	; 0x2eee <csp_buffer_free+0x1d6>
    2e98:	f8 01       	movw	r30, r16
    2e9a:	34 97       	sbiw	r30, 0x04	; 4
    2e9c:	11 82       	std	Z+1, r1	; 0x01
		csp_log_buffer("FREE: %p", buf);
    2e9e:	10 82       	st	Z, r1
    2ea0:	80 91 07 02 	lds	r24, 0x0207	; 0x800207 <csp_debug_level_enabled+0x3>
    2ea4:	88 23       	and	r24, r24
    2ea6:	c1 f0       	breq	.+48     	; 0x2ed8 <csp_buffer_free+0x1c0>
    2ea8:	0d d5       	rcall	.+2586   	; 0x38c4 <csp_get_address>
    2eaa:	ff 92       	push	r15
    2eac:	ef 92       	push	r14
    2eae:	1f 92       	push	r1
    2eb0:	95 ec       	ldi	r25, 0xC5	; 197
    2eb2:	9f 93       	push	r25
    2eb4:	26 ec       	ldi	r18, 0xC6	; 198
    2eb6:	32 e0       	ldi	r19, 0x02	; 2
    2eb8:	3f 93       	push	r19
    2eba:	2f 93       	push	r18
    2ebc:	1f 92       	push	r1
    2ebe:	8f 93       	push	r24
    2ec0:	89 eb       	ldi	r24, 0xB9	; 185
    2ec2:	92 e0       	ldi	r25, 0x02	; 2
    2ec4:	9f 93       	push	r25
    2ec6:	8f 93       	push	r24
    2ec8:	83 e0       	ldi	r24, 0x03	; 3
    2eca:	8f 93       	push	r24
    2ecc:	13 d4       	rcall	.+2086   	; 0x36f4 <do_csp_debug>
    2ece:	0f b6       	in	r0, 0x3f	; 63
    2ed0:	f8 94       	cli
    2ed2:	de bf       	out	0x3e, r29	; 62
    2ed4:	0f be       	out	0x3f, r0	; 63
		csp_queue_enqueue(csp_buffers, &buf, 0);
    2ed6:	cd bf       	out	0x3d, r28	; 61
    2ed8:	20 e0       	ldi	r18, 0x00	; 0
    2eda:	30 e0       	ldi	r19, 0x00	; 0
    2edc:	a9 01       	movw	r20, r18
    2ede:	be 01       	movw	r22, r28
    2ee0:	6f 5f       	subi	r22, 0xFF	; 255
    2ee2:	7f 4f       	sbci	r23, 0xFF	; 255
    2ee4:	80 91 ef 1d 	lds	r24, 0x1DEF	; 0x801def <csp_buffers>
    2ee8:	90 91 f0 1d 	lds	r25, 0x1DF0	; 0x801df0 <csp_buffers+0x1>
    2eec:	29 dc       	rcall	.-1966   	; 0x2740 <csp_queue_enqueue>
	}

}
    2eee:	0f 90       	pop	r0
    2ef0:	0f 90       	pop	r0
    2ef2:	df 91       	pop	r29
    2ef4:	cf 91       	pop	r28
    2ef6:	1f 91       	pop	r17
    2ef8:	0f 91       	pop	r16
    2efa:	ff 90       	pop	r15
    2efc:	ef 90       	pop	r14
    2efe:	df 90       	pop	r13
    2f00:	cf 90       	pop	r12
    2f02:	08 95       	ret

00002f04 <csp_conn_enqueue_packet>:

	return CSP_ERR_NONE;

}

int csp_conn_enqueue_packet(csp_conn_t * conn, csp_packet_t * packet) {
    2f04:	df 92       	push	r13
    2f06:	ef 92       	push	r14
    2f08:	ff 92       	push	r15
    2f0a:	0f 93       	push	r16
    2f0c:	1f 93       	push	r17
    2f0e:	cf 93       	push	r28
    2f10:	df 93       	push	r29
    2f12:	1f 92       	push	r1
    2f14:	1f 92       	push	r1
    2f16:	cd b7       	in	r28, 0x3d	; 61
    2f18:	de b7       	in	r29, 0x3e	; 62
    2f1a:	7a 83       	std	Y+2, r23	; 0x02
    2f1c:	69 83       	std	Y+1, r22	; 0x01

	if (!conn)
    2f1e:	00 97       	sbiw	r24, 0x00	; 0
    2f20:	b1 f1       	breq	.+108    	; 0x2f8e <csp_conn_enqueue_packet+0x8a>
    2f22:	8c 01       	movw	r16, r24
		rxq = csp_conn_get_rxq(packet->id.pri);
	} else {
		rxq = CSP_RX_QUEUES - 1;
	}

	if (csp_queue_enqueue(conn->rx_queue[rxq], &packet, 0) != CSP_QUEUE_OK) {
    2f24:	20 e0       	ldi	r18, 0x00	; 0
    2f26:	30 e0       	ldi	r19, 0x00	; 0
    2f28:	a9 01       	movw	r20, r18
    2f2a:	be 01       	movw	r22, r28
    2f2c:	6f 5f       	subi	r22, 0xFF	; 255
    2f2e:	7f 4f       	sbci	r23, 0xFF	; 255
    2f30:	fc 01       	movw	r30, r24
    2f32:	84 85       	ldd	r24, Z+12	; 0x0c
    2f34:	95 85       	ldd	r25, Z+13	; 0x0d
    2f36:	04 dc       	rcall	.-2040   	; 0x2740 <csp_queue_enqueue>
    2f38:	01 97       	sbiw	r24, 0x01	; 1
    2f3a:	61 f1       	breq	.+88     	; 0x2f94 <csp_conn_enqueue_packet+0x90>
		csp_log_error("RX queue %p full with %u items", conn->rx_queue[rxq], csp_queue_size(conn->rx_queue[rxq]));
    2f3c:	80 91 04 02 	lds	r24, 0x0204	; 0x800204 <csp_debug_level_enabled>
    2f40:	88 23       	and	r24, r24
    2f42:	59 f1       	breq	.+86     	; 0x2f9a <csp_conn_enqueue_packet+0x96>
    2f44:	f8 01       	movw	r30, r16
    2f46:	84 85       	ldd	r24, Z+12	; 0x0c
    2f48:	95 85       	ldd	r25, Z+13	; 0x0d
    2f4a:	15 dc       	rcall	.-2006   	; 0x2776 <csp_queue_size>
    2f4c:	e8 2e       	mov	r14, r24
    2f4e:	d9 2e       	mov	r13, r25
    2f50:	f8 01       	movw	r30, r16
    2f52:	f4 84       	ldd	r15, Z+12	; 0x0c
    2f54:	15 85       	ldd	r17, Z+13	; 0x0d
    2f56:	b6 d4       	rcall	.+2412   	; 0x38c4 <csp_get_address>
    2f58:	df 92       	push	r13
    2f5a:	ef 92       	push	r14
    2f5c:	1f 93       	push	r17
    2f5e:	ff 92       	push	r15
    2f60:	1f 92       	push	r1
    2f62:	95 e6       	ldi	r25, 0x65	; 101
    2f64:	9f 93       	push	r25
    2f66:	25 ee       	ldi	r18, 0xE5	; 229
    2f68:	32 e0       	ldi	r19, 0x02	; 2
    2f6a:	3f 93       	push	r19
    2f6c:	2f 93       	push	r18
    2f6e:	1f 92       	push	r1
    2f70:	8f 93       	push	r24
    2f72:	88 e1       	ldi	r24, 0x18	; 24
    2f74:	97 e0       	ldi	r25, 0x07	; 7
    2f76:	9f 93       	push	r25
    2f78:	8f 93       	push	r24
    2f7a:	1f 92       	push	r1
    2f7c:	bb d3       	rcall	.+1910   	; 0x36f4 <do_csp_debug>
    2f7e:	0f b6       	in	r0, 0x3f	; 63
    2f80:	f8 94       	cli
    2f82:	de bf       	out	0x3e, r29	; 62
    2f84:	0f be       	out	0x3f, r0	; 63
    2f86:	cd bf       	out	0x3d, r28	; 61
		return CSP_ERR_NOMEM;
    2f88:	8f ef       	ldi	r24, 0xFF	; 255
    2f8a:	9f ef       	ldi	r25, 0xFF	; 255
    2f8c:	08 c0       	rjmp	.+16     	; 0x2f9e <csp_conn_enqueue_packet+0x9a>
}

int csp_conn_enqueue_packet(csp_conn_t * conn, csp_packet_t * packet) {

	if (!conn)
		return CSP_ERR_INVAL;
    2f8e:	8e ef       	ldi	r24, 0xFE	; 254
    2f90:	9f ef       	ldi	r25, 0xFF	; 255
    2f92:	05 c0       	rjmp	.+10     	; 0x2f9e <csp_conn_enqueue_packet+0x9a>
		csp_log_error("QOS event queue full");
		return CSP_ERR_NOMEM;
	}
#endif

	return CSP_ERR_NONE;
    2f94:	80 e0       	ldi	r24, 0x00	; 0
    2f96:	90 e0       	ldi	r25, 0x00	; 0
    2f98:	02 c0       	rjmp	.+4      	; 0x2f9e <csp_conn_enqueue_packet+0x9a>
		rxq = CSP_RX_QUEUES - 1;
	}

	if (csp_queue_enqueue(conn->rx_queue[rxq], &packet, 0) != CSP_QUEUE_OK) {
		csp_log_error("RX queue %p full with %u items", conn->rx_queue[rxq], csp_queue_size(conn->rx_queue[rxq]));
		return CSP_ERR_NOMEM;
    2f9a:	8f ef       	ldi	r24, 0xFF	; 255
    2f9c:	9f ef       	ldi	r25, 0xFF	; 255
		return CSP_ERR_NOMEM;
	}
#endif

	return CSP_ERR_NONE;
}
    2f9e:	0f 90       	pop	r0
    2fa0:	0f 90       	pop	r0
    2fa2:	df 91       	pop	r29
    2fa4:	cf 91       	pop	r28
    2fa6:	1f 91       	pop	r17
    2fa8:	0f 91       	pop	r16
    2faa:	ff 90       	pop	r15
    2fac:	ef 90       	pop	r14
    2fae:	df 90       	pop	r13
    2fb0:	08 95       	ret

00002fb2 <csp_conn_init>:

int csp_conn_init(void) {
    2fb2:	0f 93       	push	r16
    2fb4:	1f 93       	push	r17
    2fb6:	cf 93       	push	r28
    2fb8:	df 93       	push	r29

	/* Initialize source port */
	srand(csp_get_ms());
    2fba:	ed dc       	rcall	.-1574   	; 0x2996 <csp_get_ms>
    2fbc:	cb 01       	movw	r24, r22
    2fbe:	0e 94 25 2c 	call	0x584a	; 0x584a <srand>
	sport = (rand() % (CSP_ID_PORT_MAX - CSP_MAX_BIND_PORT)) + (CSP_MAX_BIND_PORT + 1);
    2fc2:	0e 94 22 2c 	call	0x5844	; 0x5844 <rand>
    2fc6:	8f 71       	andi	r24, 0x1F	; 31
    2fc8:	90 78       	andi	r25, 0x80	; 128
    2fca:	99 23       	and	r25, r25
    2fcc:	24 f4       	brge	.+8      	; 0x2fd6 <csp_conn_init+0x24>
    2fce:	01 97       	sbiw	r24, 0x01	; 1
    2fd0:	80 6e       	ori	r24, 0xE0	; 224
    2fd2:	9f 6f       	ori	r25, 0xFF	; 255
    2fd4:	01 96       	adiw	r24, 0x01	; 1
    2fd6:	80 5e       	subi	r24, 0xE0	; 224
    2fd8:	80 93 f4 1d 	sts	0x1DF4, r24	; 0x801df4 <sport>

	if (csp_bin_sem_create(&sport_lock) != CSP_SEMAPHORE_OK) {
    2fdc:	82 ef       	ldi	r24, 0xF2	; 242
    2fde:	9d e1       	ldi	r25, 0x1D	; 29
    2fe0:	de db       	rcall	.-2116   	; 0x279e <csp_bin_sem_create>
    2fe2:	01 97       	sbiw	r24, 0x01	; 1
    2fe4:	29 f4       	brne	.+10     	; 0x2ff0 <csp_conn_init+0x3e>
    2fe6:	c9 ef       	ldi	r28, 0xF9	; 249
    2fe8:	dd e1       	ldi	r29, 0x1D	; 29
    2fea:	09 ee       	ldi	r16, 0xE9	; 233
    2fec:	1e e1       	ldi	r17, 0x1E	; 30
    2fee:	44 c0       	rjmp	.+136    	; 0x3078 <csp_conn_init+0xc6>
		csp_log_error("No more memory for sport semaphore");
    2ff0:	80 91 04 02 	lds	r24, 0x0204	; 0x800204 <csp_debug_level_enabled>
    2ff4:	88 23       	and	r24, r24
    2ff6:	09 f4       	brne	.+2      	; 0x2ffa <csp_conn_init+0x48>
    2ff8:	72 c0       	rjmp	.+228    	; 0x30de <csp_conn_init+0x12c>
    2ffa:	64 d4       	rcall	.+2248   	; 0x38c4 <csp_get_address>
    2ffc:	1f 92       	push	r1
    2ffe:	9b e7       	ldi	r25, 0x7B	; 123
    3000:	9f 93       	push	r25
    3002:	25 ee       	ldi	r18, 0xE5	; 229
    3004:	32 e0       	ldi	r19, 0x02	; 2
    3006:	3f 93       	push	r19
    3008:	2f 93       	push	r18
    300a:	1f 92       	push	r1
    300c:	8f 93       	push	r24
    300e:	88 ee       	ldi	r24, 0xE8	; 232
    3010:	96 e0       	ldi	r25, 0x06	; 6
    3012:	9f 93       	push	r25
    3014:	8f 93       	push	r24
    3016:	1f 92       	push	r1
    3018:	6d d3       	rcall	.+1754   	; 0x36f4 <do_csp_debug>
    301a:	8d b7       	in	r24, 0x3d	; 61
    301c:	9e b7       	in	r25, 0x3e	; 62
    301e:	09 96       	adiw	r24, 0x09	; 9
    3020:	0f b6       	in	r0, 0x3f	; 63
    3022:	f8 94       	cli
    3024:	9e bf       	out	0x3e, r25	; 62
    3026:	0f be       	out	0x3f, r0	; 63
    3028:	8d bf       	out	0x3d, r24	; 61
		return CSP_ERR_NOMEM;
    302a:	8f ef       	ldi	r24, 0xFF	; 255
    302c:	9f ef       	ldi	r25, 0xFF	; 255
    302e:	62 c0       	rjmp	.+196    	; 0x30f4 <csp_conn_init+0x142>
		arr_conn[i].rx_event = csp_queue_create(CSP_CONN_QUEUE_LENGTH, sizeof(int));
#endif
		arr_conn[i].state = CONN_CLOSED;

		if (csp_mutex_create(&arr_conn[i].lock) != CSP_MUTEX_OK) {
			csp_log_error("Failed to create connection lock");
    3030:	80 91 04 02 	lds	r24, 0x0204	; 0x800204 <csp_debug_level_enabled>
    3034:	88 23       	and	r24, r24
    3036:	09 f4       	brne	.+2      	; 0x303a <csp_conn_init+0x88>
    3038:	55 c0       	rjmp	.+170    	; 0x30e4 <csp_conn_init+0x132>
    303a:	44 d4       	rcall	.+2184   	; 0x38c4 <csp_get_address>
    303c:	1f 92       	push	r1
    303e:	9a e8       	ldi	r25, 0x8A	; 138
    3040:	9f 93       	push	r25
    3042:	25 ee       	ldi	r18, 0xE5	; 229
    3044:	32 e0       	ldi	r19, 0x02	; 2
    3046:	3f 93       	push	r19
    3048:	2f 93       	push	r18
    304a:	1f 92       	push	r1
    304c:	8f 93       	push	r24
    304e:	8a eb       	ldi	r24, 0xBA	; 186
    3050:	96 e0       	ldi	r25, 0x06	; 6
    3052:	9f 93       	push	r25
    3054:	8f 93       	push	r24
    3056:	1f 92       	push	r1
    3058:	4d d3       	rcall	.+1690   	; 0x36f4 <do_csp_debug>
    305a:	8d b7       	in	r24, 0x3d	; 61
    305c:	9e b7       	in	r25, 0x3e	; 62
    305e:	09 96       	adiw	r24, 0x09	; 9
    3060:	0f b6       	in	r0, 0x3f	; 63
    3062:	f8 94       	cli
    3064:	9e bf       	out	0x3e, r25	; 62
    3066:	0f be       	out	0x3f, r0	; 63
    3068:	8d bf       	out	0x3d, r24	; 61
			return CSP_ERR_NOMEM;
    306a:	8f ef       	ldi	r24, 0xFF	; 255
    306c:	9f ef       	ldi	r25, 0xFF	; 255
    306e:	42 c0       	rjmp	.+132    	; 0x30f4 <csp_conn_init+0x142>
    3070:	68 96       	adiw	r28, 0x18	; 24
		csp_log_error("No more memory for sport semaphore");
		return CSP_ERR_NOMEM;
	}

	int i, prio;
	for (i = 0; i < CSP_CONN_MAX; i++) {
    3072:	0c 17       	cp	r16, r28
    3074:	1d 07       	cpc	r17, r29
		for (prio = 0; prio < CSP_RX_QUEUES; prio++)
			arr_conn[i].rx_queue[prio] = csp_queue_create(CSP_RX_QUEUE_LENGTH, sizeof(csp_packet_t *));
    3076:	79 f0       	breq	.+30     	; 0x3096 <csp_conn_init+0xe4>
    3078:	62 e0       	ldi	r22, 0x02	; 2
    307a:	70 e0       	ldi	r23, 0x00	; 0
    307c:	84 e6       	ldi	r24, 0x64	; 100
    307e:	90 e0       	ldi	r25, 0x00	; 0
    3080:	5c db       	rcall	.-2376   	; 0x273a <csp_queue_create>
    3082:	9b 87       	std	Y+11, r25	; 0x0b

#ifdef CSP_USE_QOS
		arr_conn[i].rx_event = csp_queue_create(CSP_CONN_QUEUE_LENGTH, sizeof(int));
#endif
		arr_conn[i].state = CONN_CLOSED;
    3084:	8a 87       	std	Y+10, r24	; 0x0a
    3086:	fe 01       	movw	r30, r28
    3088:	31 97       	sbiw	r30, 0x01	; 1

		if (csp_mutex_create(&arr_conn[i].lock) != CSP_MUTEX_OK) {
    308a:	10 82       	st	Z, r1
    308c:	ce 01       	movw	r24, r28
    308e:	76 db       	rcall	.-2324   	; 0x277c <csp_mutex_create>
    3090:	01 97       	sbiw	r24, 0x01	; 1
    3092:	71 f3       	breq	.-36     	; 0x3070 <csp_conn_init+0xbe>
			return CSP_ERR_NOMEM;
		}
#endif
	}

	if (csp_bin_sem_create(&conn_lock) != CSP_SEMAPHORE_OK) {
    3094:	cd cf       	rjmp	.-102    	; 0x3030 <csp_conn_init+0x7e>
    3096:	85 ef       	ldi	r24, 0xF5	; 245
    3098:	9d e1       	ldi	r25, 0x1D	; 29
    309a:	81 db       	rcall	.-2302   	; 0x279e <csp_bin_sem_create>
    309c:	01 97       	sbiw	r24, 0x01	; 1
		csp_log_error("No more memory for conn semaphore");
    309e:	29 f1       	breq	.+74     	; 0x30ea <csp_conn_init+0x138>
    30a0:	80 91 04 02 	lds	r24, 0x0204	; 0x800204 <csp_debug_level_enabled>
    30a4:	88 23       	and	r24, r24
    30a6:	21 f1       	breq	.+72     	; 0x30f0 <csp_conn_init+0x13e>
    30a8:	0d d4       	rcall	.+2074   	; 0x38c4 <csp_get_address>
    30aa:	1f 92       	push	r1
    30ac:	97 e9       	ldi	r25, 0x97	; 151
    30ae:	9f 93       	push	r25
    30b0:	25 ee       	ldi	r18, 0xE5	; 229
    30b2:	32 e0       	ldi	r19, 0x02	; 2
    30b4:	3f 93       	push	r19
    30b6:	2f 93       	push	r18
    30b8:	1f 92       	push	r1
    30ba:	8f 93       	push	r24
    30bc:	8b e8       	ldi	r24, 0x8B	; 139
    30be:	96 e0       	ldi	r25, 0x06	; 6
    30c0:	9f 93       	push	r25
    30c2:	8f 93       	push	r24
    30c4:	1f 92       	push	r1
    30c6:	16 d3       	rcall	.+1580   	; 0x36f4 <do_csp_debug>
    30c8:	8d b7       	in	r24, 0x3d	; 61
    30ca:	9e b7       	in	r25, 0x3e	; 62
    30cc:	09 96       	adiw	r24, 0x09	; 9
    30ce:	0f b6       	in	r0, 0x3f	; 63
    30d0:	f8 94       	cli
    30d2:	9e bf       	out	0x3e, r25	; 62
    30d4:	0f be       	out	0x3f, r0	; 63
    30d6:	8d bf       	out	0x3d, r24	; 61
		return CSP_ERR_NOMEM;
    30d8:	8f ef       	ldi	r24, 0xFF	; 255
    30da:	9f ef       	ldi	r25, 0xFF	; 255
    30dc:	0b c0       	rjmp	.+22     	; 0x30f4 <csp_conn_init+0x142>
	srand(csp_get_ms());
	sport = (rand() % (CSP_ID_PORT_MAX - CSP_MAX_BIND_PORT)) + (CSP_MAX_BIND_PORT + 1);

	if (csp_bin_sem_create(&sport_lock) != CSP_SEMAPHORE_OK) {
		csp_log_error("No more memory for sport semaphore");
		return CSP_ERR_NOMEM;
    30de:	8f ef       	ldi	r24, 0xFF	; 255
    30e0:	9f ef       	ldi	r25, 0xFF	; 255
    30e2:	08 c0       	rjmp	.+16     	; 0x30f4 <csp_conn_init+0x142>
#endif
		arr_conn[i].state = CONN_CLOSED;

		if (csp_mutex_create(&arr_conn[i].lock) != CSP_MUTEX_OK) {
			csp_log_error("Failed to create connection lock");
			return CSP_ERR_NOMEM;
    30e4:	8f ef       	ldi	r24, 0xFF	; 255
    30e6:	9f ef       	ldi	r25, 0xFF	; 255
    30e8:	05 c0       	rjmp	.+10     	; 0x30f4 <csp_conn_init+0x142>
	if (csp_bin_sem_create(&conn_lock) != CSP_SEMAPHORE_OK) {
		csp_log_error("No more memory for conn semaphore");
		return CSP_ERR_NOMEM;
	}

	return CSP_ERR_NONE;
    30ea:	80 e0       	ldi	r24, 0x00	; 0
    30ec:	90 e0       	ldi	r25, 0x00	; 0
    30ee:	02 c0       	rjmp	.+4      	; 0x30f4 <csp_conn_init+0x142>
#endif
	}

	if (csp_bin_sem_create(&conn_lock) != CSP_SEMAPHORE_OK) {
		csp_log_error("No more memory for conn semaphore");
		return CSP_ERR_NOMEM;
    30f0:	8f ef       	ldi	r24, 0xFF	; 255
    30f2:	9f ef       	ldi	r25, 0xFF	; 255
	}

	return CSP_ERR_NONE;

}
    30f4:	df 91       	pop	r29
    30f6:	cf 91       	pop	r28
    30f8:	1f 91       	pop	r17
    30fa:	0f 91       	pop	r16
    30fc:	08 95       	ret

000030fe <csp_conn_find>:

csp_conn_t * csp_conn_find(uint32_t id, uint32_t mask) {
    30fe:	8f 92       	push	r8
    3100:	9f 92       	push	r9
    3102:	af 92       	push	r10
    3104:	bf 92       	push	r11
    3106:	cf 92       	push	r12
    3108:	df 92       	push	r13
    310a:	ef 92       	push	r14
    310c:	ff 92       	push	r15
    310e:	6b 01       	movw	r12, r22
    3110:	7c 01       	movw	r14, r24
    3112:	49 01       	movw	r8, r18
    3114:	5a 01       	movw	r10, r20
    3116:	e7 ef       	ldi	r30, 0xF7	; 247
    3118:	fd e1       	ldi	r31, 0x1D	; 29

	/* Search for matching connection */
	int i;
	csp_conn_t * conn;

	for (i = 0; i < CSP_CONN_MAX; i++) {
    311a:	80 e0       	ldi	r24, 0x00	; 0
    311c:	90 e0       	ldi	r25, 0x00	; 0
		conn = &arr_conn[i];
		if ((conn->state != CONN_CLOSED) && (conn->type == CONN_CLIENT) && (conn->idin.ext & mask) == (id & mask))
    311e:	31 81       	ldd	r19, Z+1	; 0x01
    3120:	33 23       	and	r19, r19
    3122:	09 f1       	breq	.+66     	; 0x3166 <csp_conn_find+0x68>
    3124:	20 81       	ld	r18, Z
    3126:	21 11       	cpse	r18, r1
    3128:	1e c0       	rjmp	.+60     	; 0x3166 <csp_conn_find+0x68>
    312a:	44 81       	ldd	r20, Z+4	; 0x04
    312c:	55 81       	ldd	r21, Z+5	; 0x05
    312e:	66 81       	ldd	r22, Z+6	; 0x06
    3130:	77 81       	ldd	r23, Z+7	; 0x07
    3132:	4c 25       	eor	r20, r12
    3134:	5d 25       	eor	r21, r13
    3136:	6e 25       	eor	r22, r14
    3138:	7f 25       	eor	r23, r15
    313a:	48 21       	and	r20, r8
    313c:	59 21       	and	r21, r9
    313e:	6a 21       	and	r22, r10
    3140:	7b 21       	and	r23, r11
    3142:	45 2b       	or	r20, r21
    3144:	46 2b       	or	r20, r22
    3146:	47 2b       	or	r20, r23
    3148:	71 f4       	brne	.+28     	; 0x3166 <csp_conn_find+0x68>
	/* Search for matching connection */
	int i;
	csp_conn_t * conn;

	for (i = 0; i < CSP_CONN_MAX; i++) {
		conn = &arr_conn[i];
    314a:	9c 01       	movw	r18, r24
    314c:	22 0f       	add	r18, r18
    314e:	33 1f       	adc	r19, r19
    3150:	82 0f       	add	r24, r18
    3152:	93 1f       	adc	r25, r19
    3154:	88 0f       	add	r24, r24
    3156:	99 1f       	adc	r25, r25
    3158:	88 0f       	add	r24, r24
    315a:	99 1f       	adc	r25, r25
    315c:	88 0f       	add	r24, r24
    315e:	99 1f       	adc	r25, r25
    3160:	89 50       	subi	r24, 0x09	; 9
    3162:	92 4e       	sbci	r25, 0xE2	; 226
    3164:	07 c0       	rjmp	.+14     	; 0x3174 <csp_conn_find+0x76>

	/* Search for matching connection */
	int i;
	csp_conn_t * conn;

	for (i = 0; i < CSP_CONN_MAX; i++) {
    3166:	01 96       	adiw	r24, 0x01	; 1
    3168:	78 96       	adiw	r30, 0x18	; 24
    316a:	8a 30       	cpi	r24, 0x0A	; 10
    316c:	91 05       	cpc	r25, r1
    316e:	b9 f6       	brne	.-82     	; 0x311e <csp_conn_find+0x20>
		conn = &arr_conn[i];
		if ((conn->state != CONN_CLOSED) && (conn->type == CONN_CLIENT) && (conn->idin.ext & mask) == (id & mask))
			return conn;
	}
	
	return NULL;
    3170:	80 e0       	ldi	r24, 0x00	; 0
    3172:	90 e0       	ldi	r25, 0x00	; 0

}
    3174:	ff 90       	pop	r15
    3176:	ef 90       	pop	r14
    3178:	df 90       	pop	r13
    317a:	cf 90       	pop	r12
    317c:	bf 90       	pop	r11
    317e:	af 90       	pop	r10
    3180:	9f 90       	pop	r9
    3182:	8f 90       	pop	r8
    3184:	08 95       	ret

00003186 <csp_conn_flush_rx_queue>:

int csp_conn_flush_rx_queue(csp_conn_t * conn) {
    3186:	0f 93       	push	r16
    3188:	1f 93       	push	r17
    318a:	cf 93       	push	r28
    318c:	df 93       	push	r29
    318e:	1f 92       	push	r1
    3190:	1f 92       	push	r1
    3192:	cd b7       	in	r28, 0x3d	; 61
    3194:	de b7       	in	r29, 0x3e	; 62
    3196:	8c 01       	movw	r16, r24
    3198:	05 c0       	rjmp	.+10     	; 0x31a4 <csp_conn_flush_rx_queue+0x1e>
	int prio;

	/* Flush packet queues */
	for (prio = 0; prio < CSP_RX_QUEUES; prio++) {
		while (csp_queue_dequeue(conn->rx_queue[prio], &packet, 0) == CSP_QUEUE_OK)
			if (packet != NULL)
    319a:	89 81       	ldd	r24, Y+1	; 0x01
    319c:	9a 81       	ldd	r25, Y+2	; 0x02
    319e:	00 97       	sbiw	r24, 0x00	; 0
    31a0:	09 f0       	breq	.+2      	; 0x31a4 <csp_conn_flush_rx_queue+0x1e>
				csp_buffer_free(packet);
    31a2:	ba dd       	rcall	.-1164   	; 0x2d18 <csp_buffer_free>

	int prio;

	/* Flush packet queues */
	for (prio = 0; prio < CSP_RX_QUEUES; prio++) {
		while (csp_queue_dequeue(conn->rx_queue[prio], &packet, 0) == CSP_QUEUE_OK)
    31a4:	20 e0       	ldi	r18, 0x00	; 0
    31a6:	30 e0       	ldi	r19, 0x00	; 0
    31a8:	a9 01       	movw	r20, r18
    31aa:	be 01       	movw	r22, r28
    31ac:	6f 5f       	subi	r22, 0xFF	; 255
    31ae:	7f 4f       	sbci	r23, 0xFF	; 255
    31b0:	f8 01       	movw	r30, r16
    31b2:	84 85       	ldd	r24, Z+12	; 0x0c
    31b4:	95 85       	ldd	r25, Z+13	; 0x0d
    31b6:	d2 da       	rcall	.-2652   	; 0x275c <csp_queue_dequeue>
    31b8:	01 97       	sbiw	r24, 0x01	; 1
    31ba:	79 f3       	breq	.-34     	; 0x319a <csp_conn_flush_rx_queue+0x14>
	while (csp_queue_dequeue(conn->rx_event, &event, 0) == CSP_QUEUE_OK);
#endif

	return CSP_ERR_NONE;

}
    31bc:	80 e0       	ldi	r24, 0x00	; 0
    31be:	90 e0       	ldi	r25, 0x00	; 0
    31c0:	0f 90       	pop	r0
    31c2:	0f 90       	pop	r0
    31c4:	df 91       	pop	r29
    31c6:	cf 91       	pop	r28
    31c8:	1f 91       	pop	r17
    31ca:	0f 91       	pop	r16
    31cc:	08 95       	ret

000031ce <csp_conn_allocate>:

csp_conn_t * csp_conn_allocate(csp_conn_type_t type) {
    31ce:	1f 93       	push	r17
    31d0:	cf 93       	push	r28
    31d2:	df 93       	push	r29
    31d4:	18 2f       	mov	r17, r24

	int i, j;
	static uint8_t csp_conn_last_given = 0;
	csp_conn_t * conn;

	if (csp_bin_sem_wait(&conn_lock, 100) != CSP_SEMAPHORE_OK) {
    31d6:	44 e6       	ldi	r20, 0x64	; 100
    31d8:	50 e0       	ldi	r21, 0x00	; 0
    31da:	60 e0       	ldi	r22, 0x00	; 0
    31dc:	70 e0       	ldi	r23, 0x00	; 0
    31de:	85 ef       	ldi	r24, 0xF5	; 245
    31e0:	9d e1       	ldi	r25, 0x1D	; 29
    31e2:	f7 da       	rcall	.-2578   	; 0x27d2 <csp_bin_sem_wait>
    31e4:	01 97       	sbiw	r24, 0x01	; 1
    31e6:	01 f1       	breq	.+64     	; 0x3228 <csp_conn_allocate+0x5a>
		csp_log_error("Failed to lock conn array");
    31e8:	80 91 04 02 	lds	r24, 0x0204	; 0x800204 <csp_debug_level_enabled>
    31ec:	88 23       	and	r24, r24
    31ee:	09 f4       	brne	.+2      	; 0x31f2 <csp_conn_allocate+0x24>
    31f0:	7e c0       	rjmp	.+252    	; 0x32ee <csp_conn_allocate+0x120>
    31f2:	68 d3       	rcall	.+1744   	; 0x38c4 <csp_get_address>
    31f4:	1f 92       	push	r1
    31f6:	9d ec       	ldi	r25, 0xCD	; 205
    31f8:	9f 93       	push	r25
    31fa:	25 ee       	ldi	r18, 0xE5	; 229
    31fc:	32 e0       	ldi	r19, 0x02	; 2
    31fe:	3f 93       	push	r19
    3200:	2f 93       	push	r18
    3202:	1f 92       	push	r1
    3204:	8f 93       	push	r24
    3206:	84 e6       	ldi	r24, 0x64	; 100
    3208:	96 e0       	ldi	r25, 0x06	; 6
    320a:	9f 93       	push	r25
    320c:	8f 93       	push	r24
    320e:	1f 92       	push	r1
    3210:	71 d2       	rcall	.+1250   	; 0x36f4 <do_csp_debug>
    3212:	8d b7       	in	r24, 0x3d	; 61
    3214:	9e b7       	in	r25, 0x3e	; 62
    3216:	09 96       	adiw	r24, 0x09	; 9
    3218:	0f b6       	in	r0, 0x3f	; 63
    321a:	f8 94       	cli
    321c:	9e bf       	out	0x3e, r25	; 62
    321e:	0f be       	out	0x3f, r0	; 63
    3220:	8d bf       	out	0x3d, r24	; 61
		return NULL;
    3222:	80 e0       	ldi	r24, 0x00	; 0
    3224:	90 e0       	ldi	r25, 0x00	; 0
    3226:	70 c0       	rjmp	.+224    	; 0x3308 <csp_conn_allocate+0x13a>
	}

	/* Search for free connection */
	i = csp_conn_last_given;
	i = (i + 1) % CSP_CONN_MAX;
    3228:	80 91 f1 1d 	lds	r24, 0x1DF1	; 0x801df1 <csp_conn_last_given.3225>
    322c:	90 e0       	ldi	r25, 0x00	; 0
    322e:	01 96       	adiw	r24, 0x01	; 1
    3230:	6a e0       	ldi	r22, 0x0A	; 10
    3232:	70 e0       	ldi	r23, 0x00	; 0
    3234:	0e 94 7b 2b 	call	0x56f6	; 0x56f6 <__divmodhi4>

	for (j = 0; j < CSP_CONN_MAX; j++) {
		conn = &arr_conn[i];
		if (conn->state == CONN_CLOSED)
    3238:	fc 01       	movw	r30, r24
    323a:	ee 0f       	add	r30, r30
    323c:	ff 1f       	adc	r31, r31
    323e:	e8 0f       	add	r30, r24
    3240:	f9 1f       	adc	r31, r25
    3242:	ee 0f       	add	r30, r30
    3244:	ff 1f       	adc	r31, r31
    3246:	ee 0f       	add	r30, r30
    3248:	ff 1f       	adc	r31, r31
    324a:	ee 0f       	add	r30, r30
    324c:	ff 1f       	adc	r31, r31
    324e:	e9 50       	subi	r30, 0x09	; 9
    3250:	f2 4e       	sbci	r31, 0xE2	; 226
    3252:	41 81       	ldd	r20, Z+1	; 0x01
    3254:	41 11       	cpse	r20, r1
    3256:	4e c0       	rjmp	.+156    	; 0x32f4 <csp_conn_allocate+0x126>
	/* Search for free connection */
	i = csp_conn_last_given;
	i = (i + 1) % CSP_CONN_MAX;

	for (j = 0; j < CSP_CONN_MAX; j++) {
		conn = &arr_conn[i];
    3258:	ef 01       	movw	r28, r30
    325a:	17 c0       	rjmp	.+46     	; 0x328a <csp_conn_allocate+0xbc>
    325c:	ec 01       	movw	r28, r24
    325e:	cc 0f       	add	r28, r28
    3260:	dd 1f       	adc	r29, r29
    3262:	c8 0f       	add	r28, r24
    3264:	d9 1f       	adc	r29, r25
    3266:	cc 0f       	add	r28, r28
    3268:	dd 1f       	adc	r29, r29
    326a:	cc 0f       	add	r28, r28
    326c:	dd 1f       	adc	r29, r29
    326e:	cc 0f       	add	r28, r28
    3270:	dd 1f       	adc	r29, r29
    3272:	c9 50       	subi	r28, 0x09	; 9
    3274:	d2 4e       	sbci	r29, 0xE2	; 226
		if (conn->state == CONN_CLOSED)
    3276:	49 81       	ldd	r20, Y+1	; 0x01
    3278:	44 23       	and	r20, r20
    327a:	39 f0       	breq	.+14     	; 0x328a <csp_conn_allocate+0xbc>
			break;
		i = (i + 1) % CSP_CONN_MAX;
    327c:	01 96       	adiw	r24, 0x01	; 1
    327e:	bf 01       	movw	r22, r30
    3280:	0e 94 7b 2b 	call	0x56f6	; 0x56f6 <__divmodhi4>
    3284:	21 50       	subi	r18, 0x01	; 1
    3286:	31 09       	sbc	r19, r1

	/* Search for free connection */
	i = csp_conn_last_given;
	i = (i + 1) % CSP_CONN_MAX;

	for (j = 0; j < CSP_CONN_MAX; j++) {
    3288:	49 f7       	brne	.-46     	; 0x325c <csp_conn_allocate+0x8e>
		if (conn->state == CONN_CLOSED)
			break;
		i = (i + 1) % CSP_CONN_MAX;
	}

	if (conn->state == CONN_OPEN) {
    328a:	29 81       	ldd	r18, Y+1	; 0x01
    328c:	21 30       	cpi	r18, 0x01	; 1
    328e:	11 f5       	brne	.+68     	; 0x32d4 <csp_conn_allocate+0x106>
		csp_log_error("No more free connections");
    3290:	80 91 04 02 	lds	r24, 0x0204	; 0x800204 <csp_debug_level_enabled>
    3294:	88 23       	and	r24, r24
    3296:	c1 f0       	breq	.+48     	; 0x32c8 <csp_conn_allocate+0xfa>
    3298:	15 d3       	rcall	.+1578   	; 0x38c4 <csp_get_address>
    329a:	1f 92       	push	r1
    329c:	9d ed       	ldi	r25, 0xDD	; 221
    329e:	9f 93       	push	r25
    32a0:	25 ee       	ldi	r18, 0xE5	; 229
    32a2:	32 e0       	ldi	r19, 0x02	; 2
    32a4:	3f 93       	push	r19
    32a6:	2f 93       	push	r18
    32a8:	1f 92       	push	r1
    32aa:	8f 93       	push	r24
    32ac:	8e e3       	ldi	r24, 0x3E	; 62
    32ae:	96 e0       	ldi	r25, 0x06	; 6
    32b0:	9f 93       	push	r25
    32b2:	8f 93       	push	r24
    32b4:	1f 92       	push	r1
    32b6:	1e d2       	rcall	.+1084   	; 0x36f4 <do_csp_debug>
    32b8:	8d b7       	in	r24, 0x3d	; 61
    32ba:	9e b7       	in	r25, 0x3e	; 62
    32bc:	09 96       	adiw	r24, 0x09	; 9
    32be:	0f b6       	in	r0, 0x3f	; 63
    32c0:	f8 94       	cli
    32c2:	9e bf       	out	0x3e, r25	; 62
    32c4:	0f be       	out	0x3f, r0	; 63
		csp_bin_sem_post(&conn_lock);
    32c6:	8d bf       	out	0x3d, r24	; 61
    32c8:	85 ef       	ldi	r24, 0xF5	; 245
    32ca:	9d e1       	ldi	r25, 0x1D	; 29
    32cc:	c3 da       	rcall	.-2682   	; 0x2854 <csp_bin_sem_post>
		return NULL;
    32ce:	80 e0       	ldi	r24, 0x00	; 0
    32d0:	90 e0       	ldi	r25, 0x00	; 0
    32d2:	1a c0       	rjmp	.+52     	; 0x3308 <csp_conn_allocate+0x13a>
	}

	conn->state = CONN_OPEN;
    32d4:	91 e0       	ldi	r25, 0x01	; 1
    32d6:	99 83       	std	Y+1, r25	; 0x01
	conn->socket = NULL;
    32d8:	1f 86       	std	Y+15, r1	; 0x0f
	conn->type = type;
    32da:	1e 86       	std	Y+14, r1	; 0x0e
	csp_conn_last_given = i;
    32dc:	18 83       	st	Y, r17
    32de:	80 93 f1 1d 	sts	0x1DF1, r24	; 0x801df1 <csp_conn_last_given.3225>
	csp_bin_sem_post(&conn_lock);
    32e2:	85 ef       	ldi	r24, 0xF5	; 245
    32e4:	9d e1       	ldi	r25, 0x1D	; 29
    32e6:	b6 da       	rcall	.-2708   	; 0x2854 <csp_bin_sem_post>

	return conn;
    32e8:	8c 2f       	mov	r24, r28
    32ea:	9d 2f       	mov	r25, r29
    32ec:	0d c0       	rjmp	.+26     	; 0x3308 <csp_conn_allocate+0x13a>
	static uint8_t csp_conn_last_given = 0;
	csp_conn_t * conn;

	if (csp_bin_sem_wait(&conn_lock, 100) != CSP_SEMAPHORE_OK) {
		csp_log_error("Failed to lock conn array");
		return NULL;
    32ee:	80 e0       	ldi	r24, 0x00	; 0
    32f0:	90 e0       	ldi	r25, 0x00	; 0
    32f2:	0a c0       	rjmp	.+20     	; 0x3308 <csp_conn_allocate+0x13a>

	for (j = 0; j < CSP_CONN_MAX; j++) {
		conn = &arr_conn[i];
		if (conn->state == CONN_CLOSED)
			break;
		i = (i + 1) % CSP_CONN_MAX;
    32f4:	01 96       	adiw	r24, 0x01	; 1
    32f6:	6a e0       	ldi	r22, 0x0A	; 10
    32f8:	70 e0       	ldi	r23, 0x00	; 0
    32fa:	0e 94 7b 2b 	call	0x56f6	; 0x56f6 <__divmodhi4>
    32fe:	29 e0       	ldi	r18, 0x09	; 9
    3300:	30 e0       	ldi	r19, 0x00	; 0
    3302:	ea e0       	ldi	r30, 0x0A	; 10
    3304:	f0 e0       	ldi	r31, 0x00	; 0
    3306:	aa cf       	rjmp	.-172    	; 0x325c <csp_conn_allocate+0x8e>
	csp_conn_last_given = i;
	csp_bin_sem_post(&conn_lock);

	return conn;

}
    3308:	df 91       	pop	r29
    330a:	cf 91       	pop	r28
    330c:	1f 91       	pop	r17
    330e:	08 95       	ret

00003310 <csp_conn_new>:

csp_conn_t * csp_conn_new(csp_id_t idin, csp_id_t idout) {
    3310:	8f 92       	push	r8
    3312:	9f 92       	push	r9
    3314:	af 92       	push	r10
    3316:	bf 92       	push	r11
    3318:	cf 92       	push	r12
    331a:	df 92       	push	r13
    331c:	ef 92       	push	r14
    331e:	ff 92       	push	r15
    3320:	cf 93       	push	r28
    3322:	df 93       	push	r29
    3324:	4b 01       	movw	r8, r22
    3326:	5c 01       	movw	r10, r24
    3328:	69 01       	movw	r12, r18
    332a:	7a 01       	movw	r14, r20

	/* Allocate connection structure */
	csp_conn_t * conn = csp_conn_allocate(CONN_CLIENT);
    332c:	80 e0       	ldi	r24, 0x00	; 0
    332e:	4f df       	rcall	.-354    	; 0x31ce <csp_conn_allocate>
    3330:	ec 01       	movw	r28, r24

	if (conn) {
    3332:	89 2b       	or	r24, r25
    3334:	79 f0       	breq	.+30     	; 0x3354 <csp_conn_new+0x44>
		/* No lock is needed here, because nobody else *
		 * has a reference to this connection yet.     */
		conn->idin.ext = idin.ext;
    3336:	8c 82       	std	Y+4, r8	; 0x04
    3338:	9d 82       	std	Y+5, r9	; 0x05
    333a:	ae 82       	std	Y+6, r10	; 0x06
    333c:	bf 82       	std	Y+7, r11	; 0x07
		conn->idout.ext = idout.ext;
    333e:	c8 86       	std	Y+8, r12	; 0x08
    3340:	d9 86       	std	Y+9, r13	; 0x09
    3342:	ea 86       	std	Y+10, r14	; 0x0a
		conn->timestamp = csp_get_ms();
    3344:	fb 86       	std	Y+11, r15	; 0x0b
    3346:	27 db       	rcall	.-2482   	; 0x2996 <csp_get_ms>
    3348:	68 8b       	std	Y+16, r22	; 0x10
    334a:	79 8b       	std	Y+17, r23	; 0x11
    334c:	8a 8b       	std	Y+18, r24	; 0x12

		/* Ensure connection queue is empty */
		csp_conn_flush_rx_queue(conn);
    334e:	9b 8b       	std	Y+19, r25	; 0x13
    3350:	ce 01       	movw	r24, r28
    3352:	19 df       	rcall	.-462    	; 0x3186 <csp_conn_flush_rx_queue>
	}

	return conn;

}
    3354:	ce 01       	movw	r24, r28
    3356:	df 91       	pop	r29
    3358:	cf 91       	pop	r28
    335a:	ff 90       	pop	r15
    335c:	ef 90       	pop	r14
    335e:	df 90       	pop	r13
    3360:	cf 90       	pop	r12
    3362:	bf 90       	pop	r11
    3364:	af 90       	pop	r10
    3366:	9f 90       	pop	r9
    3368:	8f 90       	pop	r8
    336a:	08 95       	ret

0000336c <csp_close>:

int csp_close(csp_conn_t * conn) {
    336c:	cf 93       	push	r28
    336e:	df 93       	push	r29
    3370:	ec 01       	movw	r28, r24

	if (conn == NULL) {
    3372:	89 2b       	or	r24, r25
    3374:	09 f5       	brne	.+66     	; 0x33b8 <csp_close+0x4c>
		csp_log_error("NULL Pointer given to csp_close");
    3376:	80 91 04 02 	lds	r24, 0x0204	; 0x800204 <csp_debug_level_enabled>
    337a:	88 23       	and	r24, r24
    337c:	09 f4       	brne	.+2      	; 0x3380 <csp_close+0x14>
    337e:	73 c0       	rjmp	.+230    	; 0x3466 <csp_close+0xfa>
    3380:	a1 d2       	rcall	.+1346   	; 0x38c4 <csp_get_address>
    3382:	91 e0       	ldi	r25, 0x01	; 1
    3384:	9f 93       	push	r25
    3386:	93 e0       	ldi	r25, 0x03	; 3
    3388:	9f 93       	push	r25
    338a:	25 ee       	ldi	r18, 0xE5	; 229
    338c:	32 e0       	ldi	r19, 0x02	; 2
    338e:	3f 93       	push	r19
    3390:	2f 93       	push	r18
    3392:	1f 92       	push	r1
    3394:	8f 93       	push	r24
    3396:	81 e1       	ldi	r24, 0x11	; 17
    3398:	96 e0       	ldi	r25, 0x06	; 6
    339a:	9f 93       	push	r25
    339c:	8f 93       	push	r24
    339e:	1f 92       	push	r1
    33a0:	a9 d1       	rcall	.+850    	; 0x36f4 <do_csp_debug>
    33a2:	8d b7       	in	r24, 0x3d	; 61
    33a4:	9e b7       	in	r25, 0x3e	; 62
    33a6:	09 96       	adiw	r24, 0x09	; 9
    33a8:	0f b6       	in	r0, 0x3f	; 63
    33aa:	f8 94       	cli
    33ac:	9e bf       	out	0x3e, r25	; 62
    33ae:	0f be       	out	0x3f, r0	; 63
    33b0:	8d bf       	out	0x3d, r24	; 61
		return CSP_ERR_INVAL;
    33b2:	8e ef       	ldi	r24, 0xFE	; 254
    33b4:	9f ef       	ldi	r25, 0xFF	; 255
    33b6:	5f c0       	rjmp	.+190    	; 0x3476 <csp_close+0x10a>
	}

	if (conn->state == CONN_CLOSED) {
    33b8:	89 81       	ldd	r24, Y+1	; 0x01
    33ba:	81 11       	cpse	r24, r1
    33bc:	22 c0       	rjmp	.+68     	; 0x3402 <csp_close+0x96>
		csp_log_protocol("Conn already closed");
    33be:	80 91 09 02 	lds	r24, 0x0209	; 0x800209 <csp_debug_level_enabled+0x5>
    33c2:	88 23       	and	r24, r24
    33c4:	09 f4       	brne	.+2      	; 0x33c8 <csp_close+0x5c>
    33c6:	52 c0       	rjmp	.+164    	; 0x346c <csp_close+0x100>
    33c8:	7d d2       	rcall	.+1274   	; 0x38c4 <csp_get_address>
    33ca:	91 e0       	ldi	r25, 0x01	; 1
    33cc:	9f 93       	push	r25
    33ce:	98 e0       	ldi	r25, 0x08	; 8
    33d0:	9f 93       	push	r25
    33d2:	25 ee       	ldi	r18, 0xE5	; 229
    33d4:	32 e0       	ldi	r19, 0x02	; 2
    33d6:	3f 93       	push	r19
    33d8:	2f 93       	push	r18
    33da:	1f 92       	push	r1
    33dc:	8f 93       	push	r24
    33de:	80 ef       	ldi	r24, 0xF0	; 240
    33e0:	95 e0       	ldi	r25, 0x05	; 5
    33e2:	9f 93       	push	r25
    33e4:	8f 93       	push	r24
    33e6:	85 e0       	ldi	r24, 0x05	; 5
    33e8:	8f 93       	push	r24
    33ea:	84 d1       	rcall	.+776    	; 0x36f4 <do_csp_debug>
    33ec:	8d b7       	in	r24, 0x3d	; 61
    33ee:	9e b7       	in	r25, 0x3e	; 62
    33f0:	09 96       	adiw	r24, 0x09	; 9
    33f2:	0f b6       	in	r0, 0x3f	; 63
    33f4:	f8 94       	cli
    33f6:	9e bf       	out	0x3e, r25	; 62
    33f8:	0f be       	out	0x3f, r0	; 63
    33fa:	8d bf       	out	0x3d, r24	; 61
		return CSP_ERR_NONE;
    33fc:	80 e0       	ldi	r24, 0x00	; 0
    33fe:	90 e0       	ldi	r25, 0x00	; 0
    3400:	3a c0       	rjmp	.+116    	; 0x3476 <csp_close+0x10a>
		if (csp_rdp_close(conn) == CSP_ERR_AGAIN)
			return CSP_ERR_NONE;
#endif

	/* Lock connection array while closing connection */
	if (csp_bin_sem_wait(&conn_lock, 100) != CSP_SEMAPHORE_OK) {
    3402:	44 e6       	ldi	r20, 0x64	; 100
    3404:	50 e0       	ldi	r21, 0x00	; 0
    3406:	60 e0       	ldi	r22, 0x00	; 0
    3408:	70 e0       	ldi	r23, 0x00	; 0
    340a:	85 ef       	ldi	r24, 0xF5	; 245
    340c:	9d e1       	ldi	r25, 0x1D	; 29
    340e:	e1 d9       	rcall	.-3134   	; 0x27d2 <csp_bin_sem_wait>
    3410:	01 97       	sbiw	r24, 0x01	; 1
    3412:	01 f1       	breq	.+64     	; 0x3454 <csp_close+0xe8>
		csp_log_error("Failed to lock conn array");
    3414:	80 91 04 02 	lds	r24, 0x0204	; 0x800204 <csp_debug_level_enabled>
    3418:	88 23       	and	r24, r24
    341a:	59 f1       	breq	.+86     	; 0x3472 <csp_close+0x106>
    341c:	53 d2       	rcall	.+1190   	; 0x38c4 <csp_get_address>
    341e:	91 e0       	ldi	r25, 0x01	; 1
    3420:	9f 93       	push	r25
    3422:	95 e1       	ldi	r25, 0x15	; 21
    3424:	9f 93       	push	r25
    3426:	25 ee       	ldi	r18, 0xE5	; 229
    3428:	32 e0       	ldi	r19, 0x02	; 2
    342a:	3f 93       	push	r19
    342c:	2f 93       	push	r18
    342e:	1f 92       	push	r1
    3430:	8f 93       	push	r24
    3432:	89 ec       	ldi	r24, 0xC9	; 201
    3434:	95 e0       	ldi	r25, 0x05	; 5
    3436:	9f 93       	push	r25
    3438:	8f 93       	push	r24
    343a:	1f 92       	push	r1
    343c:	5b d1       	rcall	.+694    	; 0x36f4 <do_csp_debug>
    343e:	8d b7       	in	r24, 0x3d	; 61
    3440:	9e b7       	in	r25, 0x3e	; 62
    3442:	09 96       	adiw	r24, 0x09	; 9
    3444:	0f b6       	in	r0, 0x3f	; 63
    3446:	f8 94       	cli
    3448:	9e bf       	out	0x3e, r25	; 62
    344a:	0f be       	out	0x3f, r0	; 63
    344c:	8d bf       	out	0x3d, r24	; 61
		return CSP_ERR_TIMEDOUT;
    344e:	8d ef       	ldi	r24, 0xFD	; 253
    3450:	9f ef       	ldi	r25, 0xFF	; 255
	}

	/* Set to closed */
	conn->state = CONN_CLOSED;
    3452:	11 c0       	rjmp	.+34     	; 0x3476 <csp_close+0x10a>

	/* Ensure connection queue is empty */
	csp_conn_flush_rx_queue(conn);
    3454:	19 82       	std	Y+1, r1	; 0x01
    3456:	ce 01       	movw	r24, r28
    3458:	96 de       	rcall	.-724    	; 0x3186 <csp_conn_flush_rx_queue>
	if (conn->idin.flags & CSP_FRDP)
		csp_rdp_flush_all(conn);
#endif

	/* Unlock connection array */
	csp_bin_sem_post(&conn_lock);
    345a:	85 ef       	ldi	r24, 0xF5	; 245
    345c:	9d e1       	ldi	r25, 0x1D	; 29
    345e:	fa d9       	rcall	.-3084   	; 0x2854 <csp_bin_sem_post>
    3460:	80 e0       	ldi	r24, 0x00	; 0

	return CSP_ERR_NONE;
    3462:	90 e0       	ldi	r25, 0x00	; 0
    3464:	08 c0       	rjmp	.+16     	; 0x3476 <csp_close+0x10a>
    3466:	8e ef       	ldi	r24, 0xFE	; 254

int csp_close(csp_conn_t * conn) {

	if (conn == NULL) {
		csp_log_error("NULL Pointer given to csp_close");
		return CSP_ERR_INVAL;
    3468:	9f ef       	ldi	r25, 0xFF	; 255
    346a:	05 c0       	rjmp	.+10     	; 0x3476 <csp_close+0x10a>
    346c:	80 e0       	ldi	r24, 0x00	; 0
	}

	if (conn->state == CONN_CLOSED) {
		csp_log_protocol("Conn already closed");
		return CSP_ERR_NONE;
    346e:	90 e0       	ldi	r25, 0x00	; 0
    3470:	02 c0       	rjmp	.+4      	; 0x3476 <csp_close+0x10a>
    3472:	8d ef       	ldi	r24, 0xFD	; 253
#endif

	/* Lock connection array while closing connection */
	if (csp_bin_sem_wait(&conn_lock, 100) != CSP_SEMAPHORE_OK) {
		csp_log_error("Failed to lock conn array");
		return CSP_ERR_TIMEDOUT;
    3474:	9f ef       	ldi	r25, 0xFF	; 255
    3476:	df 91       	pop	r29

	/* Unlock connection array */
	csp_bin_sem_post(&conn_lock);

	return CSP_ERR_NONE;
}
    3478:	cf 91       	pop	r28
    347a:	08 95       	ret

0000347c <csp_connect>:
    347c:	7f 92       	push	r7

csp_conn_t * csp_connect(uint8_t prio, uint8_t dest, uint8_t dport, uint32_t timeout, uint32_t opts) {
    347e:	8f 92       	push	r8
    3480:	9f 92       	push	r9
    3482:	af 92       	push	r10
    3484:	bf 92       	push	r11
    3486:	cf 92       	push	r12
    3488:	df 92       	push	r13
    348a:	ef 92       	push	r14
    348c:	ff 92       	push	r15
    348e:	0f 93       	push	r16
    3490:	1f 93       	push	r17
    3492:	cf 93       	push	r28
    3494:	df 93       	push	r29
    3496:	16 2f       	mov	r17, r22
    3498:	b4 2e       	mov	r11, r20
	/* Force options on all connections */
	opts |= CSP_CONNECTION_SO;

	/* Generate identifier */
	csp_id_t incoming_id, outgoing_id;
	incoming_id.pri = prio;
    349a:	c8 2f       	mov	r28, r24
    349c:	c2 95       	swap	r28
    349e:	cc 0f       	add	r28, r28
    34a0:	cc 0f       	add	r28, r28
    34a2:	c0 7c       	andi	r28, 0xC0	; 192
    34a4:	0c 2f       	mov	r16, r28
	incoming_id.dst = csp_get_address();
    34a6:	0e d2       	rcall	.+1052   	; 0x38c4 <csp_get_address>
    34a8:	a8 2e       	mov	r10, r24
    34aa:	aa 0c       	add	r10, r10
    34ac:	aa 0c       	add	r10, r10
    34ae:	aa 0c       	add	r10, r10
    34b0:	aa 0c       	add	r10, r10
    34b2:	82 95       	swap	r24
    34b4:	81 70       	andi	r24, 0x01	; 1
    34b6:	08 2b       	or	r16, r24
	incoming_id.src = dest;
    34b8:	81 2f       	mov	r24, r17
    34ba:	8f 71       	andi	r24, 0x1F	; 31
    34bc:	98 2f       	mov	r25, r24
    34be:	99 0f       	add	r25, r25
    34c0:	09 2b       	or	r16, r25
	incoming_id.sport = dport;
    34c2:	db 2d       	mov	r29, r11
    34c4:	df 73       	andi	r29, 0x3F	; 63
    34c6:	9d 2e       	mov	r9, r29
	incoming_id.flags = 0;
    34c8:	81 2c       	mov	r8, r1
	outgoing_id.pri = prio;
	outgoing_id.dst = dest;
    34ca:	12 95       	swap	r17
    34cc:	10 7f       	andi	r17, 0xF0	; 240
    34ce:	82 95       	swap	r24
    34d0:	8f 70       	andi	r24, 0x0F	; 15
	outgoing_id.src = csp_get_address();
    34d2:	c8 2b       	or	r28, r24
    34d4:	f7 d1       	rcall	.+1006   	; 0x38c4 <csp_get_address>
    34d6:	8f 71       	andi	r24, 0x1F	; 31
    34d8:	88 0f       	add	r24, r24
    34da:	c8 2b       	or	r28, r24
	outgoing_id.dport = dport;
    34dc:	bb 0c       	add	r11, r11
    34de:	bb 0c       	add	r11, r11
    34e0:	bb 0c       	add	r11, r11
    34e2:	bb 0c       	add	r11, r11
    34e4:	bb 0c       	add	r11, r11
    34e6:	bb 0c       	add	r11, r11
    34e8:	8d 2f       	mov	r24, r29
    34ea:	86 95       	lsr	r24
    34ec:	86 95       	lsr	r24
    34ee:	18 2b       	or	r17, r24
	outgoing_id.flags = 0;

	/* Set connection options */
	if (opts & CSP_O_RDP) {
    34f0:	c0 fe       	sbrs	r12, 0
    34f2:	21 c0       	rjmp	.+66     	; 0x3536 <csp_connect+0xba>
#ifdef CSP_USE_RDP
		incoming_id.flags |= CSP_FRDP;
		outgoing_id.flags |= CSP_FRDP;
#else
		csp_log_error("Attempt to create RDP connection, but CSP was compiled without RDP support");
    34f4:	80 91 04 02 	lds	r24, 0x0204	; 0x800204 <csp_debug_level_enabled>
    34f8:	88 23       	and	r24, r24
    34fa:	09 f4       	brne	.+2      	; 0x34fe <csp_connect+0x82>
    34fc:	da c0       	rjmp	.+436    	; 0x36b2 <csp_connect+0x236>
    34fe:	e2 d1       	rcall	.+964    	; 0x38c4 <csp_get_address>
    3500:	91 e0       	ldi	r25, 0x01	; 1
    3502:	9f 93       	push	r25
    3504:	93 e4       	ldi	r25, 0x43	; 67
    3506:	9f 93       	push	r25
    3508:	25 ee       	ldi	r18, 0xE5	; 229
    350a:	32 e0       	ldi	r19, 0x02	; 2
    350c:	3f 93       	push	r19
    350e:	2f 93       	push	r18
    3510:	1f 92       	push	r1
    3512:	8f 93       	push	r24
    3514:	81 e7       	ldi	r24, 0x71	; 113
    3516:	95 e0       	ldi	r25, 0x05	; 5
    3518:	9f 93       	push	r25
    351a:	8f 93       	push	r24
    351c:	1f 92       	push	r1
    351e:	ea d0       	rcall	.+468    	; 0x36f4 <do_csp_debug>
    3520:	8d b7       	in	r24, 0x3d	; 61
    3522:	9e b7       	in	r25, 0x3e	; 62
    3524:	09 96       	adiw	r24, 0x09	; 9
    3526:	0f b6       	in	r0, 0x3f	; 63
    3528:	f8 94       	cli
    352a:	9e bf       	out	0x3e, r25	; 62
    352c:	0f be       	out	0x3f, r0	; 63
    352e:	8d bf       	out	0x3d, r24	; 61
		return NULL;
    3530:	80 e0       	ldi	r24, 0x00	; 0
    3532:	90 e0       	ldi	r25, 0x00	; 0
    3534:	d1 c0       	rjmp	.+418    	; 0x36d8 <csp_connect+0x25c>
#endif
	}

	if (opts & CSP_O_HMAC) {
    3536:	c2 fe       	sbrs	r12, 2
    3538:	21 c0       	rjmp	.+66     	; 0x357c <csp_connect+0x100>
#ifdef CSP_USE_HMAC
		outgoing_id.flags |= CSP_FHMAC;
		incoming_id.flags |= CSP_FHMAC;
#else
		csp_log_error("Attempt to create HMAC authenticated connection, but CSP was compiled without HMAC support");
    353a:	80 91 04 02 	lds	r24, 0x0204	; 0x800204 <csp_debug_level_enabled>
    353e:	88 23       	and	r24, r24
    3540:	09 f4       	brne	.+2      	; 0x3544 <csp_connect+0xc8>
    3542:	ba c0       	rjmp	.+372    	; 0x36b8 <csp_connect+0x23c>
    3544:	bf d1       	rcall	.+894    	; 0x38c4 <csp_get_address>
    3546:	91 e0       	ldi	r25, 0x01	; 1
    3548:	9f 93       	push	r25
    354a:	9d e4       	ldi	r25, 0x4D	; 77
    354c:	9f 93       	push	r25
    354e:	25 ee       	ldi	r18, 0xE5	; 229
    3550:	32 e0       	ldi	r19, 0x02	; 2
    3552:	3f 93       	push	r19
    3554:	2f 93       	push	r18
    3556:	1f 92       	push	r1
    3558:	8f 93       	push	r24
    355a:	89 e0       	ldi	r24, 0x09	; 9
    355c:	95 e0       	ldi	r25, 0x05	; 5
    355e:	9f 93       	push	r25
    3560:	8f 93       	push	r24
    3562:	1f 92       	push	r1
    3564:	c7 d0       	rcall	.+398    	; 0x36f4 <do_csp_debug>
    3566:	8d b7       	in	r24, 0x3d	; 61
    3568:	9e b7       	in	r25, 0x3e	; 62
    356a:	09 96       	adiw	r24, 0x09	; 9
    356c:	0f b6       	in	r0, 0x3f	; 63
    356e:	f8 94       	cli
    3570:	9e bf       	out	0x3e, r25	; 62
    3572:	0f be       	out	0x3f, r0	; 63
    3574:	8d bf       	out	0x3d, r24	; 61
		return NULL;
    3576:	80 e0       	ldi	r24, 0x00	; 0
    3578:	90 e0       	ldi	r25, 0x00	; 0
    357a:	ae c0       	rjmp	.+348    	; 0x36d8 <csp_connect+0x25c>
#endif
	}

	if (opts & CSP_O_XTEA) {
    357c:	c4 fe       	sbrs	r12, 4
#ifdef CSP_USE_XTEA
		outgoing_id.flags |= CSP_FXTEA;
		incoming_id.flags |= CSP_FXTEA;
#else
		csp_log_error("Attempt to create XTEA encrypted connection, but CSP was compiled without XTEA support");
    357e:	21 c0       	rjmp	.+66     	; 0x35c2 <csp_connect+0x146>
    3580:	80 91 04 02 	lds	r24, 0x0204	; 0x800204 <csp_debug_level_enabled>
    3584:	88 23       	and	r24, r24
    3586:	09 f4       	brne	.+2      	; 0x358a <csp_connect+0x10e>
    3588:	9a c0       	rjmp	.+308    	; 0x36be <csp_connect+0x242>
    358a:	9c d1       	rcall	.+824    	; 0x38c4 <csp_get_address>
    358c:	91 e0       	ldi	r25, 0x01	; 1
    358e:	9f 93       	push	r25
    3590:	97 e5       	ldi	r25, 0x57	; 87
    3592:	9f 93       	push	r25
    3594:	25 ee       	ldi	r18, 0xE5	; 229
    3596:	32 e0       	ldi	r19, 0x02	; 2
    3598:	3f 93       	push	r19
    359a:	2f 93       	push	r18
    359c:	1f 92       	push	r1
    359e:	8f 93       	push	r24
    35a0:	85 ea       	ldi	r24, 0xA5	; 165
    35a2:	94 e0       	ldi	r25, 0x04	; 4
    35a4:	9f 93       	push	r25
    35a6:	8f 93       	push	r24
    35a8:	1f 92       	push	r1
    35aa:	a4 d0       	rcall	.+328    	; 0x36f4 <do_csp_debug>
    35ac:	8d b7       	in	r24, 0x3d	; 61
    35ae:	9e b7       	in	r25, 0x3e	; 62
    35b0:	09 96       	adiw	r24, 0x09	; 9
    35b2:	0f b6       	in	r0, 0x3f	; 63
    35b4:	f8 94       	cli
    35b6:	9e bf       	out	0x3e, r25	; 62
    35b8:	0f be       	out	0x3f, r0	; 63
    35ba:	8d bf       	out	0x3d, r24	; 61
		return NULL;
    35bc:	80 e0       	ldi	r24, 0x00	; 0
    35be:	90 e0       	ldi	r25, 0x00	; 0
#endif
	}

	if (opts & CSP_O_CRC32) {
    35c0:	8b c0       	rjmp	.+278    	; 0x36d8 <csp_connect+0x25c>
    35c2:	c6 fe       	sbrs	r12, 6
#ifdef CSP_USE_CRC32
		outgoing_id.flags |= CSP_FCRC32;
		incoming_id.flags |= CSP_FCRC32;
#else
		csp_log_error("Attempt to create CRC32 validated connection, but CSP was compiled without CRC32 support");
    35c4:	21 c0       	rjmp	.+66     	; 0x3608 <csp_connect+0x18c>
    35c6:	80 91 04 02 	lds	r24, 0x0204	; 0x800204 <csp_debug_level_enabled>
    35ca:	88 23       	and	r24, r24
    35cc:	09 f4       	brne	.+2      	; 0x35d0 <csp_connect+0x154>
    35ce:	7a c0       	rjmp	.+244    	; 0x36c4 <csp_connect+0x248>
    35d0:	79 d1       	rcall	.+754    	; 0x38c4 <csp_get_address>
    35d2:	91 e0       	ldi	r25, 0x01	; 1
    35d4:	9f 93       	push	r25
    35d6:	91 e6       	ldi	r25, 0x61	; 97
    35d8:	9f 93       	push	r25
    35da:	25 ee       	ldi	r18, 0xE5	; 229
    35dc:	32 e0       	ldi	r19, 0x02	; 2
    35de:	3f 93       	push	r19
    35e0:	2f 93       	push	r18
    35e2:	1f 92       	push	r1
    35e4:	8f 93       	push	r24
    35e6:	8f e3       	ldi	r24, 0x3F	; 63
    35e8:	94 e0       	ldi	r25, 0x04	; 4
    35ea:	9f 93       	push	r25
    35ec:	8f 93       	push	r24
    35ee:	1f 92       	push	r1
    35f0:	81 d0       	rcall	.+258    	; 0x36f4 <do_csp_debug>
    35f2:	8d b7       	in	r24, 0x3d	; 61
    35f4:	9e b7       	in	r25, 0x3e	; 62
    35f6:	09 96       	adiw	r24, 0x09	; 9
    35f8:	0f b6       	in	r0, 0x3f	; 63
    35fa:	f8 94       	cli
    35fc:	9e bf       	out	0x3e, r25	; 62
    35fe:	0f be       	out	0x3f, r0	; 63
    3600:	8d bf       	out	0x3d, r24	; 61
		return NULL;
    3602:	80 e0       	ldi	r24, 0x00	; 0
    3604:	90 e0       	ldi	r25, 0x00	; 0
    3606:	68 c0       	rjmp	.+208    	; 0x36d8 <csp_connect+0x25c>
	
	/* Find an unused ephemeral port */
	csp_conn_t * conn;

	/* Wait for sport lock */
	if (csp_bin_sem_wait(&sport_lock, 1000) != CSP_SEMAPHORE_OK)
    3608:	48 ee       	ldi	r20, 0xE8	; 232
    360a:	53 e0       	ldi	r21, 0x03	; 3
    360c:	60 e0       	ldi	r22, 0x00	; 0
    360e:	70 e0       	ldi	r23, 0x00	; 0
    3610:	82 ef       	ldi	r24, 0xF2	; 242
    3612:	9d e1       	ldi	r25, 0x1D	; 29
    3614:	de d8       	rcall	.-3652   	; 0x27d2 <csp_bin_sem_wait>
    3616:	01 97       	sbiw	r24, 0x01	; 1
    3618:	09 f0       	breq	.+2      	; 0x361c <csp_connect+0x1a0>
    361a:	57 c0       	rjmp	.+174    	; 0x36ca <csp_connect+0x24e>
    361c:	d0 91 f4 1d 	lds	r29, 0x1DF4	; 0x801df4 <sport>
		return NULL;

	uint8_t start = sport;
    3620:	68 94       	set
	while (++sport != start) {
		if (sport > CSP_ID_PORT_MAX)
			sport = CSP_MAX_BIND_PORT + 1;
    3622:	77 24       	eor	r7, r7
    3624:	75 f8       	bld	r7, 5
    3626:	25 c0       	rjmp	.+74     	; 0x3672 <csp_connect+0x1f6>
	/* Wait for sport lock */
	if (csp_bin_sem_wait(&sport_lock, 1000) != CSP_SEMAPHORE_OK)
		return NULL;

	uint8_t start = sport;
	while (++sport != start) {
    3628:	80 34       	cpi	r24, 0x40	; 64
		if (sport > CSP_ID_PORT_MAX)
    362a:	10 f0       	brcs	.+4      	; 0x3630 <csp_connect+0x1b4>
    362c:	70 92 f4 1d 	sts	0x1DF4, r7	; 0x801df4 <sport>
			sport = CSP_MAX_BIND_PORT + 1;
    3630:	90 91 f4 1d 	lds	r25, 0x1DF4	; 0x801df4 <sport>

		outgoing_id.sport = sport;
    3634:	89 2f       	mov	r24, r25
    3636:	8f 73       	andi	r24, 0x3F	; 63
    3638:	2b 2d       	mov	r18, r11
    363a:	20 7c       	andi	r18, 0xC0	; 192
    363c:	b2 2e       	mov	r11, r18
    363e:	b8 2a       	or	r11, r24
    3640:	92 95       	swap	r25
		incoming_id.dport = sport;
    3642:	99 0f       	add	r25, r25
    3644:	99 0f       	add	r25, r25
    3646:	90 7c       	andi	r25, 0xC0	; 192
    3648:	29 2d       	mov	r18, r9
    364a:	2f 73       	andi	r18, 0x3F	; 63
    364c:	92 2e       	mov	r9, r18
    364e:	99 2a       	or	r9, r25
    3650:	86 95       	lsr	r24
    3652:	86 95       	lsr	r24
    3654:	9a 2d       	mov	r25, r10
    3656:	90 7f       	andi	r25, 0xF0	; 240
    3658:	a9 2e       	mov	r10, r25
    365a:	a8 2a       	or	r10, r24
		
		/* Match on destination port of _incoming_ identifier */
		conn = csp_conn_find(incoming_id.ext, CSP_ID_DPORT_MASK);
    365c:	20 e0       	ldi	r18, 0x00	; 0
    365e:	30 ec       	ldi	r19, 0xC0	; 192
    3660:	4f e0       	ldi	r20, 0x0F	; 15
    3662:	50 e0       	ldi	r21, 0x00	; 0
    3664:	68 2d       	mov	r22, r8
    3666:	79 2d       	mov	r23, r9
    3668:	8a 2d       	mov	r24, r10
    366a:	90 2f       	mov	r25, r16
    366c:	48 dd       	rcall	.-1392   	; 0x30fe <csp_conn_find>

		/* Break if we found an unused ephemeral port */
		if (conn == NULL)
    366e:	89 2b       	or	r24, r25
    3670:	39 f0       	breq	.+14     	; 0x3680 <csp_connect+0x204>
	/* Wait for sport lock */
	if (csp_bin_sem_wait(&sport_lock, 1000) != CSP_SEMAPHORE_OK)
		return NULL;

	uint8_t start = sport;
	while (++sport != start) {
    3672:	80 91 f4 1d 	lds	r24, 0x1DF4	; 0x801df4 <sport>
    3676:	8f 5f       	subi	r24, 0xFF	; 255
    3678:	80 93 f4 1d 	sts	0x1DF4, r24	; 0x801df4 <sport>
    367c:	d8 13       	cpse	r29, r24
    367e:	d4 cf       	rjmp	.-88     	; 0x3628 <csp_connect+0x1ac>
		if (conn == NULL)
			break;
	}

	/* Post sport lock */
	csp_bin_sem_post(&sport_lock);
    3680:	82 ef       	ldi	r24, 0xF2	; 242
    3682:	9d e1       	ldi	r25, 0x1D	; 29
    3684:	e7 d8       	rcall	.-3634   	; 0x2854 <csp_bin_sem_post>
    3686:	80 91 f4 1d 	lds	r24, 0x1DF4	; 0x801df4 <sport>

	/* If no available ephemeral port was found */
	if (sport == start)
    368a:	d8 17       	cp	r29, r24
    368c:	09 f1       	breq	.+66     	; 0x36d0 <csp_connect+0x254>
		return NULL;

	/* Get storage for new connection */
	conn = csp_conn_new(incoming_id, outgoing_id);
    368e:	20 e0       	ldi	r18, 0x00	; 0
    3690:	3b 2d       	mov	r19, r11
    3692:	41 2f       	mov	r20, r17
    3694:	5c 2f       	mov	r21, r28
    3696:	60 e0       	ldi	r22, 0x00	; 0
    3698:	79 2d       	mov	r23, r9
    369a:	8a 2d       	mov	r24, r10
    369c:	90 2f       	mov	r25, r16
    369e:	38 de       	rcall	.-912    	; 0x3310 <csp_conn_new>
    36a0:	fc 01       	movw	r30, r24
    36a2:	00 97       	sbiw	r24, 0x00	; 0
	if (conn == NULL)
    36a4:	c1 f0       	breq	.+48     	; 0x36d6 <csp_connect+0x25a>
    36a6:	c4 8a       	std	Z+20, r12	; 0x14
		return NULL;

	/* Set connection options */
	conn->opts = opts;
    36a8:	d5 8a       	std	Z+21, r13	; 0x15
    36aa:	e6 8a       	std	Z+22, r14	; 0x16
    36ac:	f7 8a       	std	Z+23, r15	; 0x17
    36ae:	9f 2f       	mov	r25, r31
		}
	}
#endif

	/* We have a successful connection */
	return conn;
    36b0:	13 c0       	rjmp	.+38     	; 0x36d8 <csp_connect+0x25c>
    36b2:	80 e0       	ldi	r24, 0x00	; 0
#ifdef CSP_USE_RDP
		incoming_id.flags |= CSP_FRDP;
		outgoing_id.flags |= CSP_FRDP;
#else
		csp_log_error("Attempt to create RDP connection, but CSP was compiled without RDP support");
		return NULL;
    36b4:	90 e0       	ldi	r25, 0x00	; 0
    36b6:	10 c0       	rjmp	.+32     	; 0x36d8 <csp_connect+0x25c>
    36b8:	80 e0       	ldi	r24, 0x00	; 0
#ifdef CSP_USE_HMAC
		outgoing_id.flags |= CSP_FHMAC;
		incoming_id.flags |= CSP_FHMAC;
#else
		csp_log_error("Attempt to create HMAC authenticated connection, but CSP was compiled without HMAC support");
		return NULL;
    36ba:	90 e0       	ldi	r25, 0x00	; 0
    36bc:	0d c0       	rjmp	.+26     	; 0x36d8 <csp_connect+0x25c>
    36be:	80 e0       	ldi	r24, 0x00	; 0
#ifdef CSP_USE_XTEA
		outgoing_id.flags |= CSP_FXTEA;
		incoming_id.flags |= CSP_FXTEA;
#else
		csp_log_error("Attempt to create XTEA encrypted connection, but CSP was compiled without XTEA support");
		return NULL;
    36c0:	90 e0       	ldi	r25, 0x00	; 0
    36c2:	0a c0       	rjmp	.+20     	; 0x36d8 <csp_connect+0x25c>
    36c4:	80 e0       	ldi	r24, 0x00	; 0
#ifdef CSP_USE_CRC32
		outgoing_id.flags |= CSP_FCRC32;
		incoming_id.flags |= CSP_FCRC32;
#else
		csp_log_error("Attempt to create CRC32 validated connection, but CSP was compiled without CRC32 support");
		return NULL;
    36c6:	90 e0       	ldi	r25, 0x00	; 0
    36c8:	07 c0       	rjmp	.+14     	; 0x36d8 <csp_connect+0x25c>
    36ca:	80 e0       	ldi	r24, 0x00	; 0
	/* Find an unused ephemeral port */
	csp_conn_t * conn;

	/* Wait for sport lock */
	if (csp_bin_sem_wait(&sport_lock, 1000) != CSP_SEMAPHORE_OK)
		return NULL;
    36cc:	90 e0       	ldi	r25, 0x00	; 0
    36ce:	04 c0       	rjmp	.+8      	; 0x36d8 <csp_connect+0x25c>
    36d0:	80 e0       	ldi	r24, 0x00	; 0
	/* Post sport lock */
	csp_bin_sem_post(&sport_lock);

	/* If no available ephemeral port was found */
	if (sport == start)
		return NULL;
    36d2:	90 e0       	ldi	r25, 0x00	; 0
    36d4:	01 c0       	rjmp	.+2      	; 0x36d8 <csp_connect+0x25c>
    36d6:	9f 2f       	mov	r25, r31

	/* Get storage for new connection */
	conn = csp_conn_new(incoming_id, outgoing_id);
	if (conn == NULL)
		return NULL;
    36d8:	df 91       	pop	r29
#endif

	/* We have a successful connection */
	return conn;

}
    36da:	cf 91       	pop	r28
    36dc:	1f 91       	pop	r17
    36de:	0f 91       	pop	r16
    36e0:	ff 90       	pop	r15
    36e2:	ef 90       	pop	r14
    36e4:	df 90       	pop	r13
    36e6:	cf 90       	pop	r12
    36e8:	bf 90       	pop	r11
    36ea:	af 90       	pop	r10
    36ec:	9f 90       	pop	r9
    36ee:	8f 90       	pop	r8
    36f0:	7f 90       	pop	r7
    36f2:	08 95       	ret

000036f4 <do_csp_debug>:
    36f4:	0f 93       	push	r16
 * can be used instead to set a custom debug hook */
void csp_debug_hook_set(csp_debug_hook_func_t f) {
	csp_debug_hook_func = f;
}

void do_csp_debug(csp_debug_level_t level, const char * format, ...) {
    36f6:	1f 93       	push	r17
    36f8:	cf 93       	push	r28
    36fa:	df 93       	push	r29
    36fc:	cd b7       	in	r28, 0x3d	; 61
    36fe:	de b7       	in	r29, 0x3e	; 62
    3700:	98 85       	ldd	r25, Y+8	; 0x08

	int color = COLOR_RESET;
	va_list args;

	/* Don't print anything if log level is disabled */
	if (level > CSP_LOCK || !csp_debug_level_enabled[level])
    3702:	97 30       	cpi	r25, 0x07	; 7
    3704:	08 f0       	brcs	.+2      	; 0x3708 <do_csp_debug+0x14>
    3706:	46 c0       	rjmp	.+140    	; 0x3794 <do_csp_debug+0xa0>
    3708:	e9 2f       	mov	r30, r25
    370a:	f0 e0       	ldi	r31, 0x00	; 0
    370c:	ec 5f       	subi	r30, 0xFC	; 252
    370e:	fd 4f       	sbci	r31, 0xFD	; 253
    3710:	80 81       	ld	r24, Z
    3712:	88 23       	and	r24, r24
    3714:	09 f4       	brne	.+2      	; 0x3718 <do_csp_debug+0x24>
    3716:	3e c0       	rjmp	.+124    	; 0x3794 <do_csp_debug+0xa0>
		return;

	switch(level) {
    3718:	49 2f       	mov	r20, r25
    371a:	50 e0       	ldi	r21, 0x00	; 0
    371c:	47 30       	cpi	r20, 0x07	; 7
    371e:	51 05       	cpc	r21, r1
    3720:	c8 f5       	brcc	.+114    	; 0x3794 <do_csp_debug+0xa0>
    3722:	fa 01       	movw	r30, r20
    3724:	88 27       	eor	r24, r24
    3726:	e6 58       	subi	r30, 0x86	; 134
    3728:	ff 4f       	sbci	r31, 0xFF	; 255
    372a:	8f 4f       	sbci	r24, 0xFF	; 255
    372c:	0c 94 b0 2b 	jmp	0x5760	; 0x5760 <__tablejump2__>
	case CSP_INFO:
		color = COLOR_GREEN | COLOR_BOLD;
		break;
	case CSP_ERROR:
		color = COLOR_RED | COLOR_BOLD;
    3730:	82 e1       	ldi	r24, 0x12	; 18
    3732:	0b c0       	rjmp	.+22     	; 0x374a <do_csp_debug+0x56>
		break;
	case CSP_WARN:
		color = COLOR_YELLOW | COLOR_BOLD;
    3734:	84 e1       	ldi	r24, 0x14	; 20
		break;
    3736:	09 c0       	rjmp	.+18     	; 0x374a <do_csp_debug+0x56>
	case CSP_BUFFER:
		color = COLOR_MAGENTA;
    3738:	86 e0       	ldi	r24, 0x06	; 6
		break;
    373a:	07 c0       	rjmp	.+14     	; 0x374a <do_csp_debug+0x56>
	case CSP_PACKET:
		color = COLOR_GREEN;
    373c:	83 e0       	ldi	r24, 0x03	; 3
		break;
    373e:	05 c0       	rjmp	.+10     	; 0x374a <do_csp_debug+0x56>
	case CSP_PROTOCOL:
		color = COLOR_BLUE;
    3740:	85 e0       	ldi	r24, 0x05	; 5
		break;
    3742:	03 c0       	rjmp	.+6      	; 0x374a <do_csp_debug+0x56>
	case CSP_LOCK:
		color = COLOR_CYAN;
    3744:	87 e0       	ldi	r24, 0x07	; 7
		break;
    3746:	01 c0       	rjmp	.+2      	; 0x374a <do_csp_debug+0x56>
	if (level > CSP_LOCK || !csp_debug_level_enabled[level])
		return;

	switch(level) {
	case CSP_INFO:
		color = COLOR_GREEN | COLOR_BOLD;
    3748:	83 e1       	ldi	r24, 0x13	; 19
		break;
	default:
		return;
	}
	
	va_start(args, format);
    374a:	ae 01       	movw	r20, r28
    374c:	45 5f       	subi	r20, 0xF5	; 245
    374e:	5f 4f       	sbci	r21, 0xFF	; 255
    3750:	04 2f       	mov	r16, r20
    3752:	15 2f       	mov	r17, r21

	/* If csp_debug_hook symbol is defined, pass on the message.
	 * Otherwise, just print with pretty colors ... */
	if (csp_debug_hook_func) {
    3754:	e0 91 e7 1e 	lds	r30, 0x1EE7	; 0x801ee7 <csp_debug_hook_func>
    3758:	f0 91 e8 1e 	lds	r31, 0x1EE8	; 0x801ee8 <csp_debug_hook_func+0x1>
    375c:	30 97       	sbiw	r30, 0x00	; 0
    375e:	29 f0       	breq	.+10     	; 0x376a <do_csp_debug+0x76>
		csp_debug_hook_func(level, format, args);
    3760:	69 85       	ldd	r22, Y+9	; 0x09
    3762:	7a 85       	ldd	r23, Y+10	; 0x0a
    3764:	89 2f       	mov	r24, r25
    3766:	19 95       	eicall
    3768:	15 c0       	rjmp	.+42     	; 0x3794 <do_csp_debug+0xa0>
	} else {
		csp_sys_set_color(color);
    376a:	ad d8       	rcall	.-3750   	; 0x28c6 <csp_sys_set_color>
#ifdef __AVR__
		vfprintf_P(stdout, format, args);
    376c:	40 2f       	mov	r20, r16
    376e:	51 2f       	mov	r21, r17
    3770:	69 85       	ldd	r22, Y+9	; 0x09
    3772:	7a 85       	ldd	r23, Y+10	; 0x0a
    3774:	80 91 2a 20 	lds	r24, 0x202A	; 0x80202a <__iob+0x2>
    3778:	90 91 2b 20 	lds	r25, 0x202B	; 0x80202b <__iob+0x3>
    377c:	0e 94 b4 2c 	call	0x5968	; 0x5968 <vfprintf_P>
#else
		vprintf(format, args);
#endif
		printf("\r\n");
    3780:	84 e4       	ldi	r24, 0x44	; 68
    3782:	97 e0       	ldi	r25, 0x07	; 7
    3784:	9f 93       	push	r25
    3786:	8f 93       	push	r24
    3788:	0e 94 8d 2c 	call	0x591a	; 0x591a <printf_P>
		csp_sys_set_color(COLOR_RESET);
    378c:	80 ef       	ldi	r24, 0xF0	; 240
    378e:	9b d8       	rcall	.-3786   	; 0x28c6 <csp_sys_set_color>
    3790:	0f 90       	pop	r0
    3792:	0f 90       	pop	r0
	}

	va_end(args);

}
    3794:	df 91       	pop	r29
    3796:	cf 91       	pop	r28
    3798:	1f 91       	pop	r17
    379a:	0f 91       	pop	r16
    379c:	08 95       	ret

0000379e <csp_hton32>:
inline uint16_t __attribute__ ((__const__)) csp_ntoh16(uint16_t n16) {
	return csp_hton16(n16);
}

/* Convert 32-bit number from host byte order to network byte order */
inline uint32_t __attribute__ ((__const__)) csp_hton32(uint32_t h32) {
    379e:	cf 92       	push	r12
    37a0:	df 92       	push	r13
    37a2:	ef 92       	push	r14
    37a4:	ff 92       	push	r15
    37a6:	0f 93       	push	r16
    37a8:	1f 93       	push	r17
#ifdef CSP_BIG_ENDIAN
	return h32;
#else
	return (((h32 & 0xff000000) >> 24) |
    37aa:	c9 2e       	mov	r12, r25
    37ac:	dd 24       	eor	r13, r13
    37ae:	ee 24       	eor	r14, r14
    37b0:	ff 24       	eor	r15, r15
    37b2:	36 2f       	mov	r19, r22
    37b4:	22 27       	eor	r18, r18
    37b6:	11 27       	eor	r17, r17
    37b8:	00 27       	eor	r16, r16
    37ba:	0c 29       	or	r16, r12
    37bc:	1d 29       	or	r17, r13
    37be:	2e 29       	or	r18, r14
    37c0:	3f 29       	or	r19, r15
    37c2:	6b 01       	movw	r12, r22
    37c4:	7c 01       	movw	r14, r24
    37c6:	cc 24       	eor	r12, r12
    37c8:	ee 24       	eor	r14, r14
    37ca:	ff 24       	eor	r15, r15
    37cc:	fe 2c       	mov	r15, r14
    37ce:	ed 2c       	mov	r14, r13
    37d0:	dc 2c       	mov	r13, r12
    37d2:	cc 24       	eor	r12, r12
    37d4:	0c 29       	or	r16, r12
    37d6:	1d 29       	or	r17, r13
    37d8:	2e 29       	or	r18, r14
    37da:	3f 29       	or	r19, r15
    37dc:	dc 01       	movw	r26, r24
    37de:	cb 01       	movw	r24, r22
    37e0:	88 27       	eor	r24, r24
    37e2:	99 27       	eor	r25, r25
    37e4:	bb 27       	eor	r27, r27
    37e6:	89 2f       	mov	r24, r25
    37e8:	9a 2f       	mov	r25, r26
    37ea:	ab 2f       	mov	r26, r27
    37ec:	bb 27       	eor	r27, r27
    37ee:	bc 01       	movw	r22, r24
    37f0:	cd 01       	movw	r24, r26
    37f2:	60 2b       	or	r22, r16
    37f4:	71 2b       	or	r23, r17
    37f6:	82 2b       	or	r24, r18
    37f8:	93 2b       	or	r25, r19
			((h32 & 0x000000ff) << 24) |
			((h32 & 0x0000ff00) <<  8) |
			((h32 & 0x00ff0000) >>  8));
#endif
}
    37fa:	1f 91       	pop	r17
    37fc:	0f 91       	pop	r16
    37fe:	ff 90       	pop	r15
    3800:	ef 90       	pop	r14
    3802:	df 90       	pop	r13
    3804:	cf 90       	pop	r12
    3806:	08 95       	ret

00003808 <csp_ntoh32>:

/* Convert 32-bit number from network byte order to host byte order */
inline uint32_t __attribute__ ((__const__)) csp_ntoh32(uint32_t n32) {
    3808:	cf 92       	push	r12
    380a:	df 92       	push	r13
    380c:	ef 92       	push	r14
    380e:	ff 92       	push	r15
    3810:	0f 93       	push	r16
    3812:	1f 93       	push	r17
	return csp_hton32(n32);
    3814:	c9 2e       	mov	r12, r25
    3816:	dd 24       	eor	r13, r13
    3818:	ee 24       	eor	r14, r14
    381a:	ff 24       	eor	r15, r15
    381c:	36 2f       	mov	r19, r22
    381e:	22 27       	eor	r18, r18
    3820:	11 27       	eor	r17, r17
    3822:	00 27       	eor	r16, r16
    3824:	0c 29       	or	r16, r12
    3826:	1d 29       	or	r17, r13
    3828:	2e 29       	or	r18, r14
    382a:	3f 29       	or	r19, r15
    382c:	6b 01       	movw	r12, r22
    382e:	7c 01       	movw	r14, r24
    3830:	cc 24       	eor	r12, r12
    3832:	ee 24       	eor	r14, r14
    3834:	ff 24       	eor	r15, r15
    3836:	fe 2c       	mov	r15, r14
    3838:	ed 2c       	mov	r14, r13
    383a:	dc 2c       	mov	r13, r12
    383c:	cc 24       	eor	r12, r12
    383e:	0c 29       	or	r16, r12
    3840:	1d 29       	or	r17, r13
    3842:	2e 29       	or	r18, r14
    3844:	3f 29       	or	r19, r15
    3846:	dc 01       	movw	r26, r24
    3848:	cb 01       	movw	r24, r22
    384a:	88 27       	eor	r24, r24
    384c:	99 27       	eor	r25, r25
    384e:	bb 27       	eor	r27, r27
    3850:	89 2f       	mov	r24, r25
    3852:	9a 2f       	mov	r25, r26
    3854:	ab 2f       	mov	r26, r27
    3856:	bb 27       	eor	r27, r27
    3858:	bc 01       	movw	r22, r24
    385a:	cd 01       	movw	r24, r26
    385c:	60 2b       	or	r22, r16
    385e:	71 2b       	or	r23, r17
    3860:	82 2b       	or	r24, r18
    3862:	93 2b       	or	r25, r19
}
    3864:	1f 91       	pop	r17
    3866:	0f 91       	pop	r16
    3868:	ff 90       	pop	r15
    386a:	ef 90       	pop	r14
    386c:	df 90       	pop	r13
    386e:	cf 90       	pop	r12
    3870:	08 95       	ret

00003872 <csp_iflist_add>:
}

void csp_iflist_add(csp_iface_t *ifc) {

	/* Add interface to pool */
	if (interfaces == NULL) {
    3872:	a0 91 e9 1e 	lds	r26, 0x1EE9	; 0x801ee9 <interfaces>
    3876:	b0 91 ea 1e 	lds	r27, 0x1EEA	; 0x801eea <interfaces+0x1>
    387a:	10 97       	sbiw	r26, 0x00	; 0
    387c:	41 f4       	brne	.+16     	; 0x388e <csp_iflist_add+0x1c>
		/* This is the first interface to be added */
		interfaces = ifc;
    387e:	90 93 ea 1e 	sts	0x1EEA, r25	; 0x801eea <interfaces+0x1>
    3882:	80 93 e9 1e 	sts	0x1EE9, r24	; 0x801ee9 <interfaces>
		ifc->next = NULL;
    3886:	fc 01       	movw	r30, r24
    3888:	12 aa       	std	Z+50, r1	; 0x32
    388a:	11 aa       	std	Z+49, r1	; 0x31
    388c:	08 95       	ret
	} else {
		/* One or more interfaces were already added */
		csp_iface_t * i = interfaces;
		while (i != ifc && i->next)
    388e:	a8 17       	cp	r26, r24
    3890:	b9 07       	cpc	r27, r25
    3892:	b9 f0       	breq	.+46     	; 0x38c2 <csp_iflist_add+0x50>
    3894:	d1 96       	adiw	r26, 0x31	; 49
    3896:	ed 91       	ld	r30, X+
    3898:	fc 91       	ld	r31, X
    389a:	d2 97       	sbiw	r26, 0x32	; 50
    389c:	30 97       	sbiw	r30, 0x00	; 0
    389e:	41 f4       	brne	.+16     	; 0x38b0 <csp_iflist_add+0x3e>
    38a0:	fd 01       	movw	r30, r26
    38a2:	0a c0       	rjmp	.+20     	; 0x38b8 <csp_iflist_add+0x46>
    38a4:	21 a9       	ldd	r18, Z+49	; 0x31
    38a6:	32 a9       	ldd	r19, Z+50	; 0x32
    38a8:	21 15       	cp	r18, r1
    38aa:	31 05       	cpc	r19, r1
    38ac:	29 f0       	breq	.+10     	; 0x38b8 <csp_iflist_add+0x46>
    38ae:	f9 01       	movw	r30, r18
    38b0:	8e 17       	cp	r24, r30
    38b2:	9f 07       	cpc	r25, r31
    38b4:	b9 f7       	brne	.-18     	; 0x38a4 <csp_iflist_add+0x32>
    38b6:	08 95       	ret
			i = i->next;

		/* Insert interface last if not already in pool */
		if (i != ifc && i->next == NULL) {
			i->next = ifc;
    38b8:	92 ab       	std	Z+50, r25	; 0x32
    38ba:	81 ab       	std	Z+49, r24	; 0x31
			ifc->next = NULL;
    38bc:	fc 01       	movw	r30, r24
    38be:	12 aa       	std	Z+50, r1	; 0x32
    38c0:	11 aa       	std	Z+49, r1	; 0x31
    38c2:	08 95       	ret

000038c4 <csp_get_address>:
}

int csp_send_prio(uint8_t prio, csp_conn_t * conn, csp_packet_t * packet, uint32_t timeout) {
	conn->idout.pri = prio;
	return csp_send(conn, packet, timeout);
}
    38c4:	80 91 eb 1e 	lds	r24, 0x1EEB	; 0x801eeb <csp_my_address>
    38c8:	08 95       	ret

000038ca <csp_init>:
    38ca:	cf 93       	push	r28
    38cc:	df 93       	push	r29
    38ce:	80 93 eb 1e 	sts	0x1EEB, r24	; 0x801eeb <csp_my_address>
    38d2:	6f db       	rcall	.-2338   	; 0x2fb2 <csp_conn_init>
    38d4:	00 97       	sbiw	r24, 0x00	; 0
    38d6:	e9 f4       	brne	.+58     	; 0x3912 <csp_init+0x48>
    38d8:	3c d3       	rcall	.+1656   	; 0x3f52 <csp_port_init>
    38da:	00 97       	sbiw	r24, 0x00	; 0
    38dc:	d1 f4       	brne	.+52     	; 0x3912 <csp_init+0x48>
    38de:	43 d3       	rcall	.+1670   	; 0x3f66 <csp_qfifo_init>
    38e0:	ec 01       	movw	r28, r24
    38e2:	00 97       	sbiw	r24, 0x00	; 0
    38e4:	a9 f4       	brne	.+42     	; 0x3910 <csp_init+0x46>
    38e6:	8e e3       	ldi	r24, 0x3E	; 62
    38e8:	92 e0       	ldi	r25, 0x02	; 2
    38ea:	c3 df       	rcall	.-122    	; 0x3872 <csp_iflist_add>
    38ec:	2f ef       	ldi	r18, 0xFF	; 255
    38ee:	4e e3       	ldi	r20, 0x3E	; 62
    38f0:	52 e0       	ldi	r21, 0x02	; 2
    38f2:	65 e0       	ldi	r22, 0x05	; 5
    38f4:	80 91 eb 1e 	lds	r24, 0x1EEB	; 0x801eeb <csp_my_address>
    38f8:	0e 94 bb 24 	call	0x4976	; 0x4976 <csp_rtable_set>
    38fc:	2f ef       	ldi	r18, 0xFF	; 255
    38fe:	4e e3       	ldi	r20, 0x3E	; 62
    3900:	52 e0       	ldi	r21, 0x02	; 2
    3902:	65 e0       	ldi	r22, 0x05	; 5
    3904:	80 e2       	ldi	r24, 0x20	; 32
    3906:	0e 94 bb 24 	call	0x4976	; 0x4976 <csp_rtable_set>
    390a:	8c 2f       	mov	r24, r28
    390c:	9d 2f       	mov	r25, r29
    390e:	01 c0       	rjmp	.+2      	; 0x3912 <csp_init+0x48>
    3910:	9d 2f       	mov	r25, r29
    3912:	df 91       	pop	r29
    3914:	cf 91       	pop	r28
    3916:	08 95       	ret

00003918 <csp_read>:
    3918:	cf 93       	push	r28
    391a:	df 93       	push	r29
    391c:	1f 92       	push	r1
    391e:	1f 92       	push	r1
    3920:	cd b7       	in	r28, 0x3d	; 61
    3922:	de b7       	in	r29, 0x3e	; 62
    3924:	1a 82       	std	Y+2, r1	; 0x02
    3926:	19 82       	std	Y+1, r1	; 0x01
    3928:	00 97       	sbiw	r24, 0x00	; 0
    392a:	91 f0       	breq	.+36     	; 0x3950 <csp_read+0x38>
    392c:	fc 01       	movw	r30, r24
    392e:	21 81       	ldd	r18, Z+1	; 0x01
    3930:	21 30       	cpi	r18, 0x01	; 1
    3932:	89 f4       	brne	.+34     	; 0x3956 <csp_read+0x3e>
    3934:	9a 01       	movw	r18, r20
    3936:	ab 01       	movw	r20, r22
    3938:	be 01       	movw	r22, r28
    393a:	6f 5f       	subi	r22, 0xFF	; 255
    393c:	7f 4f       	sbci	r23, 0xFF	; 255
    393e:	84 85       	ldd	r24, Z+12	; 0x0c
    3940:	95 85       	ldd	r25, Z+13	; 0x0d
    3942:	0e 94 ae 13 	call	0x275c	; 0x275c <csp_queue_dequeue>
    3946:	01 97       	sbiw	r24, 0x01	; 1
    3948:	49 f4       	brne	.+18     	; 0x395c <csp_read+0x44>
    394a:	89 81       	ldd	r24, Y+1	; 0x01
    394c:	9a 81       	ldd	r25, Y+2	; 0x02
    394e:	08 c0       	rjmp	.+16     	; 0x3960 <csp_read+0x48>
    3950:	80 e0       	ldi	r24, 0x00	; 0
    3952:	90 e0       	ldi	r25, 0x00	; 0
    3954:	05 c0       	rjmp	.+10     	; 0x3960 <csp_read+0x48>
    3956:	80 e0       	ldi	r24, 0x00	; 0
    3958:	90 e0       	ldi	r25, 0x00	; 0
    395a:	02 c0       	rjmp	.+4      	; 0x3960 <csp_read+0x48>
    395c:	80 e0       	ldi	r24, 0x00	; 0
    395e:	90 e0       	ldi	r25, 0x00	; 0
    3960:	0f 90       	pop	r0
    3962:	0f 90       	pop	r0
    3964:	df 91       	pop	r29
    3966:	cf 91       	pop	r28
    3968:	08 95       	ret

0000396a <csp_send_direct>:
    396a:	4f 92       	push	r4
    396c:	5f 92       	push	r5
    396e:	6f 92       	push	r6
    3970:	7f 92       	push	r7
    3972:	8f 92       	push	r8
    3974:	9f 92       	push	r9
    3976:	af 92       	push	r10
    3978:	bf 92       	push	r11
    397a:	cf 92       	push	r12
    397c:	df 92       	push	r13
    397e:	ef 92       	push	r14
    3980:	ff 92       	push	r15
    3982:	0f 93       	push	r16
    3984:	1f 93       	push	r17
    3986:	cf 93       	push	r28
    3988:	df 93       	push	r29
    398a:	a6 2e       	mov	r10, r22
    398c:	87 2e       	mov	r8, r23
    398e:	98 2e       	mov	r9, r24
    3990:	b9 2e       	mov	r11, r25
    3992:	6a 01       	movw	r12, r20
    3994:	e9 01       	movw	r28, r18
    3996:	27 01       	movw	r4, r14
    3998:	38 01       	movw	r6, r16
    399a:	41 15       	cp	r20, r1
    399c:	51 05       	cpc	r21, r1
    399e:	09 f5       	brne	.+66     	; 0x39e2 <csp_send_direct+0x78>
    39a0:	80 91 04 02 	lds	r24, 0x0204	; 0x800204 <csp_debug_level_enabled>
    39a4:	88 23       	and	r24, r24
    39a6:	09 f4       	brne	.+2      	; 0x39aa <csp_send_direct+0x40>
    39a8:	45 c1       	rjmp	.+650    	; 0x3c34 <csp_send_direct+0x2ca>
    39aa:	1f 92       	push	r1
    39ac:	85 ef       	ldi	r24, 0xF5	; 245
    39ae:	8f 93       	push	r24
    39b0:	82 e0       	ldi	r24, 0x02	; 2
    39b2:	93 e0       	ldi	r25, 0x03	; 3
    39b4:	9f 93       	push	r25
    39b6:	8f 93       	push	r24
    39b8:	80 91 eb 1e 	lds	r24, 0x1EEB	; 0x801eeb <csp_my_address>
    39bc:	1f 92       	push	r1
    39be:	8f 93       	push	r24
    39c0:	87 e5       	ldi	r24, 0x57	; 87
    39c2:	99 e0       	ldi	r25, 0x09	; 9
    39c4:	9f 93       	push	r25
    39c6:	8f 93       	push	r24
    39c8:	1f 92       	push	r1
    39ca:	94 de       	rcall	.-728    	; 0x36f4 <do_csp_debug>
    39cc:	8d b7       	in	r24, 0x3d	; 61
    39ce:	9e b7       	in	r25, 0x3e	; 62
    39d0:	09 96       	adiw	r24, 0x09	; 9
    39d2:	0f b6       	in	r0, 0x3f	; 63
    39d4:	f8 94       	cli
    39d6:	9e bf       	out	0x3e, r25	; 62
    39d8:	0f be       	out	0x3f, r0	; 63
    39da:	8d bf       	out	0x3d, r24	; 61
    39dc:	86 ef       	ldi	r24, 0xF6	; 246
    39de:	9f ef       	ldi	r25, 0xFF	; 255
    39e0:	2e c1       	rjmp	.+604    	; 0x3c3e <csp_send_direct+0x2d4>
    39e2:	20 97       	sbiw	r28, 0x00	; 0
    39e4:	21 f0       	breq	.+8      	; 0x39ee <csp_send_direct+0x84>
    39e6:	8c 81       	ldd	r24, Y+4	; 0x04
    39e8:	9d 81       	ldd	r25, Y+5	; 0x05
    39ea:	89 2b       	or	r24, r25
    39ec:	29 f5       	brne	.+74     	; 0x3a38 <csp_send_direct+0xce>
    39ee:	80 91 04 02 	lds	r24, 0x0204	; 0x800204 <csp_debug_level_enabled>
    39f2:	88 23       	and	r24, r24
    39f4:	09 f4       	brne	.+2      	; 0x39f8 <csp_send_direct+0x8e>
    39f6:	21 c1       	rjmp	.+578    	; 0x3c3a <csp_send_direct+0x2d0>
    39f8:	bf 92       	push	r11
    39fa:	9f 92       	push	r9
    39fc:	8f 92       	push	r8
    39fe:	af 92       	push	r10
    3a00:	1f 92       	push	r1
    3a02:	8a ef       	ldi	r24, 0xFA	; 250
    3a04:	8f 93       	push	r24
    3a06:	82 e0       	ldi	r24, 0x02	; 2
    3a08:	93 e0       	ldi	r25, 0x03	; 3
    3a0a:	9f 93       	push	r25
    3a0c:	8f 93       	push	r24
    3a0e:	80 91 eb 1e 	lds	r24, 0x1EEB	; 0x801eeb <csp_my_address>
    3a12:	1f 92       	push	r1
    3a14:	8f 93       	push	r24
    3a16:	82 e3       	ldi	r24, 0x32	; 50
    3a18:	99 e0       	ldi	r25, 0x09	; 9
    3a1a:	9f 93       	push	r25
    3a1c:	8f 93       	push	r24
    3a1e:	1f 92       	push	r1
    3a20:	69 de       	rcall	.-814    	; 0x36f4 <do_csp_debug>
    3a22:	ed b7       	in	r30, 0x3d	; 61
    3a24:	fe b7       	in	r31, 0x3e	; 62
    3a26:	3d 96       	adiw	r30, 0x0d	; 13
    3a28:	0f b6       	in	r0, 0x3f	; 63
    3a2a:	f8 94       	cli
    3a2c:	fe bf       	out	0x3e, r31	; 62
    3a2e:	0f be       	out	0x3f, r0	; 63
    3a30:	ed bf       	out	0x3d, r30	; 61
    3a32:	86 ef       	ldi	r24, 0xF6	; 246
    3a34:	9f ef       	ldi	r25, 0xFF	; 255
    3a36:	03 c1       	rjmp	.+518    	; 0x3c3e <csp_send_direct+0x2d4>
    3a38:	80 91 08 02 	lds	r24, 0x0208	; 0x800208 <csp_debug_level_enabled+0x4>
    3a3c:	88 23       	and	r24, r24
    3a3e:	09 f4       	brne	.+2      	; 0x3a42 <csp_send_direct+0xd8>
    3a40:	4b c0       	rjmp	.+150    	; 0x3ad8 <csp_send_direct+0x16e>
    3a42:	89 81       	ldd	r24, Y+1	; 0x01
    3a44:	8f 93       	push	r24
    3a46:	88 81       	ld	r24, Y
    3a48:	8f 93       	push	r24
    3a4a:	fa 01       	movw	r30, r20
    3a4c:	81 85       	ldd	r24, Z+9	; 0x09
    3a4e:	8f 93       	push	r24
    3a50:	80 85       	ldd	r24, Z+8	; 0x08
    3a52:	8f 93       	push	r24
    3a54:	1f 92       	push	r1
    3a56:	6f 93       	push	r22
    3a58:	1f 92       	push	r1
    3a5a:	8b 2d       	mov	r24, r11
    3a5c:	82 95       	swap	r24
    3a5e:	86 95       	lsr	r24
    3a60:	86 95       	lsr	r24
    3a62:	83 70       	andi	r24, 0x03	; 3
    3a64:	8f 93       	push	r24
    3a66:	1f 92       	push	r1
    3a68:	87 2f       	mov	r24, r23
    3a6a:	8f 73       	andi	r24, 0x3F	; 63
    3a6c:	8f 93       	push	r24
    3a6e:	89 2d       	mov	r24, r9
    3a70:	8f 70       	andi	r24, 0x0F	; 15
    3a72:	88 0f       	add	r24, r24
    3a74:	88 0f       	add	r24, r24
    3a76:	97 2f       	mov	r25, r23
    3a78:	92 95       	swap	r25
    3a7a:	96 95       	lsr	r25
    3a7c:	96 95       	lsr	r25
    3a7e:	93 70       	andi	r25, 0x03	; 3
    3a80:	89 2b       	or	r24, r25
    3a82:	1f 92       	push	r1
    3a84:	8f 93       	push	r24
    3a86:	8b 2d       	mov	r24, r11
    3a88:	81 70       	andi	r24, 0x01	; 1
    3a8a:	82 95       	swap	r24
    3a8c:	80 7f       	andi	r24, 0xF0	; 240
    3a8e:	99 2d       	mov	r25, r9
    3a90:	92 95       	swap	r25
    3a92:	9f 70       	andi	r25, 0x0F	; 15
    3a94:	89 2b       	or	r24, r25
    3a96:	1f 92       	push	r1
    3a98:	8f 93       	push	r24
    3a9a:	8b 2d       	mov	r24, r11
    3a9c:	86 95       	lsr	r24
    3a9e:	8f 71       	andi	r24, 0x1F	; 31
    3aa0:	1f 92       	push	r1
    3aa2:	8f 93       	push	r24
    3aa4:	1f 92       	push	r1
    3aa6:	8f ef       	ldi	r24, 0xFF	; 255
    3aa8:	8f 93       	push	r24
    3aaa:	82 e0       	ldi	r24, 0x02	; 2
    3aac:	93 e0       	ldi	r25, 0x03	; 3
    3aae:	9f 93       	push	r25
    3ab0:	8f 93       	push	r24
    3ab2:	80 91 eb 1e 	lds	r24, 0x1EEB	; 0x801eeb <csp_my_address>
    3ab6:	1f 92       	push	r1
    3ab8:	8f 93       	push	r24
    3aba:	86 ee       	ldi	r24, 0xE6	; 230
    3abc:	98 e0       	ldi	r25, 0x08	; 8
    3abe:	9f 93       	push	r25
    3ac0:	8f 93       	push	r24
    3ac2:	84 e0       	ldi	r24, 0x04	; 4
    3ac4:	8f 93       	push	r24
    3ac6:	16 de       	rcall	.-980    	; 0x36f4 <do_csp_debug>
    3ac8:	8d b7       	in	r24, 0x3d	; 61
    3aca:	9e b7       	in	r25, 0x3e	; 62
    3acc:	49 96       	adiw	r24, 0x19	; 25
    3ace:	0f b6       	in	r0, 0x3f	; 63
    3ad0:	f8 94       	cli
    3ad2:	9e bf       	out	0x3e, r25	; 62
    3ad4:	0f be       	out	0x3f, r0	; 63
    3ad6:	8d bf       	out	0x3d, r24	; 61
    3ad8:	f6 01       	movw	r30, r12
    3ada:	a2 86       	std	Z+10, r10	; 0x0a
    3adc:	83 86       	std	Z+11, r8	; 0x0b
    3ade:	94 86       	std	Z+12, r9	; 0x0c
    3ae0:	b5 86       	std	Z+13, r11	; 0x0d
    3ae2:	8b 2d       	mov	r24, r11
    3ae4:	86 95       	lsr	r24
    3ae6:	8f 71       	andi	r24, 0x1F	; 31
    3ae8:	48 2f       	mov	r20, r24
    3aea:	50 e0       	ldi	r21, 0x00	; 0
    3aec:	20 91 eb 1e 	lds	r18, 0x1EEB	; 0x801eeb <csp_my_address>
    3af0:	30 e0       	ldi	r19, 0x00	; 0
    3af2:	42 17       	cp	r20, r18
    3af4:	53 07       	cpc	r21, r19
    3af6:	09 f0       	breq	.+2      	; 0x3afa <csp_send_direct+0x190>
    3af8:	63 c0       	rjmp	.+198    	; 0x3bc0 <csp_send_direct+0x256>
    3afa:	1a 2d       	mov	r17, r10
    3afc:	a3 fe       	sbrs	r10, 3
    3afe:	1e c0       	rjmp	.+60     	; 0x3b3c <csp_send_direct+0x1d2>
    3b00:	90 91 05 02 	lds	r25, 0x0205	; 0x800205 <csp_debug_level_enabled+0x1>
    3b04:	99 23       	and	r25, r25
    3b06:	09 f4       	brne	.+2      	; 0x3b0a <csp_send_direct+0x1a0>
    3b08:	87 c0       	rjmp	.+270    	; 0x3c18 <csp_send_direct+0x2ae>
    3b0a:	91 e0       	ldi	r25, 0x01	; 1
    3b0c:	9f 93       	push	r25
    3b0e:	28 e1       	ldi	r18, 0x18	; 24
    3b10:	2f 93       	push	r18
    3b12:	22 e0       	ldi	r18, 0x02	; 2
    3b14:	33 e0       	ldi	r19, 0x03	; 3
    3b16:	3f 93       	push	r19
    3b18:	2f 93       	push	r18
    3b1a:	1f 92       	push	r1
    3b1c:	8f 93       	push	r24
    3b1e:	2a e7       	ldi	r18, 0x7A	; 122
    3b20:	38 e0       	ldi	r19, 0x08	; 8
    3b22:	3f 93       	push	r19
    3b24:	2f 93       	push	r18
    3b26:	9f 93       	push	r25
    3b28:	e5 dd       	rcall	.-1078   	; 0x36f4 <do_csp_debug>
    3b2a:	8d b7       	in	r24, 0x3d	; 61
    3b2c:	9e b7       	in	r25, 0x3e	; 62
    3b2e:	09 96       	adiw	r24, 0x09	; 9
    3b30:	0f b6       	in	r0, 0x3f	; 63
    3b32:	f8 94       	cli
    3b34:	9e bf       	out	0x3e, r25	; 62
    3b36:	0f be       	out	0x3f, r0	; 63
    3b38:	8d bf       	out	0x3d, r24	; 61
    3b3a:	6e c0       	rjmp	.+220    	; 0x3c18 <csp_send_direct+0x2ae>
    3b3c:	a0 fe       	sbrs	r10, 0
    3b3e:	1e c0       	rjmp	.+60     	; 0x3b7c <csp_send_direct+0x212>
    3b40:	90 91 05 02 	lds	r25, 0x0205	; 0x800205 <csp_debug_level_enabled+0x1>
    3b44:	99 23       	and	r25, r25
    3b46:	c1 f0       	breq	.+48     	; 0x3b78 <csp_send_direct+0x20e>
    3b48:	91 e0       	ldi	r25, 0x01	; 1
    3b4a:	9f 93       	push	r25
    3b4c:	27 e2       	ldi	r18, 0x27	; 39
    3b4e:	2f 93       	push	r18
    3b50:	22 e0       	ldi	r18, 0x02	; 2
    3b52:	33 e0       	ldi	r19, 0x03	; 3
    3b54:	3f 93       	push	r19
    3b56:	2f 93       	push	r18
    3b58:	1f 92       	push	r1
    3b5a:	8f 93       	push	r24
    3b5c:	27 e0       	ldi	r18, 0x07	; 7
    3b5e:	38 e0       	ldi	r19, 0x08	; 8
    3b60:	3f 93       	push	r19
    3b62:	2f 93       	push	r18
    3b64:	9f 93       	push	r25
    3b66:	c6 dd       	rcall	.-1140   	; 0x36f4 <do_csp_debug>
    3b68:	ed b7       	in	r30, 0x3d	; 61
    3b6a:	fe b7       	in	r31, 0x3e	; 62
    3b6c:	39 96       	adiw	r30, 0x09	; 9
    3b6e:	0f b6       	in	r0, 0x3f	; 63
    3b70:	f8 94       	cli
    3b72:	fe bf       	out	0x3e, r31	; 62
    3b74:	0f be       	out	0x3f, r0	; 63
    3b76:	ed bf       	out	0x3d, r30	; 61
    3b78:	1e 7f       	andi	r17, 0xFE	; 254
    3b7a:	a1 2e       	mov	r10, r17
    3b7c:	a2 fe       	sbrs	r10, 2
    3b7e:	20 c0       	rjmp	.+64     	; 0x3bc0 <csp_send_direct+0x256>
    3b80:	80 91 05 02 	lds	r24, 0x0205	; 0x800205 <csp_debug_level_enabled+0x1>
    3b84:	88 23       	and	r24, r24
    3b86:	09 f4       	brne	.+2      	; 0x3b8a <csp_send_direct+0x220>
    3b88:	47 c0       	rjmp	.+142    	; 0x3c18 <csp_send_direct+0x2ae>
    3b8a:	81 e0       	ldi	r24, 0x01	; 1
    3b8c:	8f 93       	push	r24
    3b8e:	90 e4       	ldi	r25, 0x40	; 64
    3b90:	9f 93       	push	r25
    3b92:	22 e0       	ldi	r18, 0x02	; 2
    3b94:	33 e0       	ldi	r19, 0x03	; 3
    3b96:	3f 93       	push	r19
    3b98:	2f 93       	push	r18
    3b9a:	90 91 eb 1e 	lds	r25, 0x1EEB	; 0x801eeb <csp_my_address>
    3b9e:	1f 92       	push	r1
    3ba0:	9f 93       	push	r25
    3ba2:	26 e9       	ldi	r18, 0x96	; 150
    3ba4:	37 e0       	ldi	r19, 0x07	; 7
    3ba6:	3f 93       	push	r19
    3ba8:	2f 93       	push	r18
    3baa:	8f 93       	push	r24
    3bac:	a3 dd       	rcall	.-1210   	; 0x36f4 <do_csp_debug>
    3bae:	8d b7       	in	r24, 0x3d	; 61
    3bb0:	9e b7       	in	r25, 0x3e	; 62
    3bb2:	09 96       	adiw	r24, 0x09	; 9
    3bb4:	0f b6       	in	r0, 0x3f	; 63
    3bb6:	f8 94       	cli
    3bb8:	9e bf       	out	0x3e, r25	; 62
    3bba:	0f be       	out	0x3f, r0	; 63
    3bbc:	8d bf       	out	0x3d, r24	; 61
    3bbe:	2c c0       	rjmp	.+88     	; 0x3c18 <csp_send_direct+0x2ae>
    3bc0:	f6 01       	movw	r30, r12
    3bc2:	a0 84       	ldd	r10, Z+8	; 0x08
    3bc4:	b1 84       	ldd	r11, Z+9	; 0x09
    3bc6:	8e 81       	ldd	r24, Y+6	; 0x06
    3bc8:	9f 81       	ldd	r25, Y+7	; 0x07
    3bca:	00 97       	sbiw	r24, 0x00	; 0
    3bcc:	19 f0       	breq	.+6      	; 0x3bd4 <csp_send_direct+0x26a>
    3bce:	8a 15       	cp	r24, r10
    3bd0:	9b 05       	cpc	r25, r11
    3bd2:	10 f1       	brcs	.+68     	; 0x3c18 <csp_send_direct+0x2ae>
    3bd4:	ec 81       	ldd	r30, Y+4	; 0x04
    3bd6:	fd 81       	ldd	r31, Y+5	; 0x05
    3bd8:	a3 01       	movw	r20, r6
    3bda:	92 01       	movw	r18, r4
    3bdc:	b6 01       	movw	r22, r12
    3bde:	ce 01       	movw	r24, r28
    3be0:	19 95       	eicall
    3be2:	00 97       	sbiw	r24, 0x00	; 0
    3be4:	c9 f4       	brne	.+50     	; 0x3c18 <csp_send_direct+0x2ae>
    3be6:	49 85       	ldd	r20, Y+9	; 0x09
    3be8:	5a 85       	ldd	r21, Y+10	; 0x0a
    3bea:	6b 85       	ldd	r22, Y+11	; 0x0b
    3bec:	7c 85       	ldd	r23, Y+12	; 0x0c
    3bee:	4f 5f       	subi	r20, 0xFF	; 255
    3bf0:	5f 4f       	sbci	r21, 0xFF	; 255
    3bf2:	6f 4f       	sbci	r22, 0xFF	; 255
    3bf4:	7f 4f       	sbci	r23, 0xFF	; 255
    3bf6:	49 87       	std	Y+9, r20	; 0x09
    3bf8:	5a 87       	std	Y+10, r21	; 0x0a
    3bfa:	6b 87       	std	Y+11, r22	; 0x0b
    3bfc:	7c 87       	std	Y+12, r23	; 0x0c
    3bfe:	4d a1       	ldd	r20, Y+37	; 0x25
    3c00:	5e a1       	ldd	r21, Y+38	; 0x26
    3c02:	6f a1       	ldd	r22, Y+39	; 0x27
    3c04:	78 a5       	ldd	r23, Y+40	; 0x28
    3c06:	4a 0d       	add	r20, r10
    3c08:	5b 1d       	adc	r21, r11
    3c0a:	61 1d       	adc	r22, r1
    3c0c:	71 1d       	adc	r23, r1
    3c0e:	4d a3       	std	Y+37, r20	; 0x25
    3c10:	5e a3       	std	Y+38, r21	; 0x26
    3c12:	6f a3       	std	Y+39, r22	; 0x27
    3c14:	78 a7       	std	Y+40, r23	; 0x28
    3c16:	13 c0       	rjmp	.+38     	; 0x3c3e <csp_send_direct+0x2d4>
    3c18:	89 89       	ldd	r24, Y+17	; 0x11
    3c1a:	9a 89       	ldd	r25, Y+18	; 0x12
    3c1c:	ab 89       	ldd	r26, Y+19	; 0x13
    3c1e:	bc 89       	ldd	r27, Y+20	; 0x14
    3c20:	01 96       	adiw	r24, 0x01	; 1
    3c22:	a1 1d       	adc	r26, r1
    3c24:	b1 1d       	adc	r27, r1
    3c26:	89 8b       	std	Y+17, r24	; 0x11
    3c28:	9a 8b       	std	Y+18, r25	; 0x12
    3c2a:	ab 8b       	std	Y+19, r26	; 0x13
    3c2c:	bc 8b       	std	Y+20, r27	; 0x14
    3c2e:	86 ef       	ldi	r24, 0xF6	; 246
    3c30:	9f ef       	ldi	r25, 0xFF	; 255
    3c32:	05 c0       	rjmp	.+10     	; 0x3c3e <csp_send_direct+0x2d4>
    3c34:	86 ef       	ldi	r24, 0xF6	; 246
    3c36:	9f ef       	ldi	r25, 0xFF	; 255
    3c38:	02 c0       	rjmp	.+4      	; 0x3c3e <csp_send_direct+0x2d4>
    3c3a:	86 ef       	ldi	r24, 0xF6	; 246
    3c3c:	9f ef       	ldi	r25, 0xFF	; 255
    3c3e:	df 91       	pop	r29
    3c40:	cf 91       	pop	r28
    3c42:	1f 91       	pop	r17
    3c44:	0f 91       	pop	r16
    3c46:	ff 90       	pop	r15
    3c48:	ef 90       	pop	r14
    3c4a:	df 90       	pop	r13
    3c4c:	cf 90       	pop	r12
    3c4e:	bf 90       	pop	r11
    3c50:	af 90       	pop	r10
    3c52:	9f 90       	pop	r9
    3c54:	8f 90       	pop	r8
    3c56:	7f 90       	pop	r7
    3c58:	6f 90       	pop	r6
    3c5a:	5f 90       	pop	r5
    3c5c:	4f 90       	pop	r4
    3c5e:	08 95       	ret

00003c60 <csp_send>:
    3c60:	8f 92       	push	r8
    3c62:	9f 92       	push	r9
    3c64:	af 92       	push	r10
    3c66:	bf 92       	push	r11
    3c68:	cf 92       	push	r12
    3c6a:	df 92       	push	r13
    3c6c:	ef 92       	push	r14
    3c6e:	ff 92       	push	r15
    3c70:	0f 93       	push	r16
    3c72:	1f 93       	push	r17
    3c74:	cf 93       	push	r28
    3c76:	df 93       	push	r29
    3c78:	ec 01       	movw	r28, r24
    3c7a:	6b 01       	movw	r12, r22
    3c7c:	49 01       	movw	r8, r18
    3c7e:	5a 01       	movw	r10, r20
    3c80:	89 2b       	or	r24, r25
    3c82:	29 f0       	breq	.+10     	; 0x3c8e <csp_send+0x2e>
    3c84:	67 2b       	or	r22, r23
    3c86:	19 f0       	breq	.+6      	; 0x3c8e <csp_send+0x2e>
    3c88:	89 81       	ldd	r24, Y+1	; 0x01
    3c8a:	81 30       	cpi	r24, 0x01	; 1
    3c8c:	09 f1       	breq	.+66     	; 0x3cd0 <csp_send+0x70>
    3c8e:	80 91 04 02 	lds	r24, 0x0204	; 0x800204 <csp_debug_level_enabled>
    3c92:	88 23       	and	r24, r24
    3c94:	b9 f1       	breq	.+110    	; 0x3d04 <csp_send+0xa4>
    3c96:	81 e0       	ldi	r24, 0x01	; 1
    3c98:	8f 93       	push	r24
    3c9a:	80 e6       	ldi	r24, 0x60	; 96
    3c9c:	8f 93       	push	r24
    3c9e:	82 e0       	ldi	r24, 0x02	; 2
    3ca0:	93 e0       	ldi	r25, 0x03	; 3
    3ca2:	9f 93       	push	r25
    3ca4:	8f 93       	push	r24
    3ca6:	80 91 eb 1e 	lds	r24, 0x1EEB	; 0x801eeb <csp_my_address>
    3caa:	1f 92       	push	r1
    3cac:	8f 93       	push	r24
    3cae:	80 e7       	ldi	r24, 0x70	; 112
    3cb0:	97 e0       	ldi	r25, 0x07	; 7
    3cb2:	9f 93       	push	r25
    3cb4:	8f 93       	push	r24
    3cb6:	1f 92       	push	r1
    3cb8:	1d dd       	rcall	.-1478   	; 0x36f4 <do_csp_debug>
    3cba:	8d b7       	in	r24, 0x3d	; 61
    3cbc:	9e b7       	in	r25, 0x3e	; 62
    3cbe:	09 96       	adiw	r24, 0x09	; 9
    3cc0:	0f b6       	in	r0, 0x3f	; 63
    3cc2:	f8 94       	cli
    3cc4:	9e bf       	out	0x3e, r25	; 62
    3cc6:	0f be       	out	0x3f, r0	; 63
    3cc8:	8d bf       	out	0x3d, r24	; 61
    3cca:	80 e0       	ldi	r24, 0x00	; 0
    3ccc:	90 e0       	ldi	r25, 0x00	; 0
    3cce:	1c c0       	rjmp	.+56     	; 0x3d08 <csp_send+0xa8>
    3cd0:	9a 85       	ldd	r25, Y+10	; 0x0a
    3cd2:	92 95       	swap	r25
    3cd4:	9f 70       	andi	r25, 0x0F	; 15
    3cd6:	8b 85       	ldd	r24, Y+11	; 0x0b
    3cd8:	81 70       	andi	r24, 0x01	; 1
    3cda:	82 95       	swap	r24
    3cdc:	80 7f       	andi	r24, 0xF0	; 240
    3cde:	89 2b       	or	r24, r25
    3ce0:	09 d6       	rcall	.+3090   	; 0x48f4 <csp_rtable_find_iface>
    3ce2:	9c 01       	movw	r18, r24
    3ce4:	68 85       	ldd	r22, Y+8	; 0x08
    3ce6:	79 85       	ldd	r23, Y+9	; 0x09
    3ce8:	8a 85       	ldd	r24, Y+10	; 0x0a
    3cea:	9b 85       	ldd	r25, Y+11	; 0x0b
    3cec:	85 01       	movw	r16, r10
    3cee:	74 01       	movw	r14, r8
    3cf0:	a6 01       	movw	r20, r12
    3cf2:	3b de       	rcall	.-906    	; 0x396a <csp_send_direct>
    3cf4:	31 e0       	ldi	r19, 0x01	; 1
    3cf6:	20 e0       	ldi	r18, 0x00	; 0
    3cf8:	89 2b       	or	r24, r25
    3cfa:	09 f0       	breq	.+2      	; 0x3cfe <csp_send+0x9e>
    3cfc:	30 e0       	ldi	r19, 0x00	; 0
    3cfe:	83 2f       	mov	r24, r19
    3d00:	92 2f       	mov	r25, r18
    3d02:	02 c0       	rjmp	.+4      	; 0x3d08 <csp_send+0xa8>
    3d04:	80 e0       	ldi	r24, 0x00	; 0
    3d06:	90 e0       	ldi	r25, 0x00	; 0
    3d08:	df 91       	pop	r29
    3d0a:	cf 91       	pop	r28
    3d0c:	1f 91       	pop	r17
    3d0e:	0f 91       	pop	r16
    3d10:	ff 90       	pop	r15
    3d12:	ef 90       	pop	r14
    3d14:	df 90       	pop	r13
    3d16:	cf 90       	pop	r12
    3d18:	bf 90       	pop	r11
    3d1a:	af 90       	pop	r10
    3d1c:	9f 90       	pop	r9
    3d1e:	8f 90       	pop	r8
    3d20:	08 95       	ret

00003d22 <csp_transaction_persistent>:

int csp_transaction_persistent(csp_conn_t * conn, uint32_t timeout, void * outbuf, int outlen, void * inbuf, int inlen) {
    3d22:	4f 92       	push	r4
    3d24:	5f 92       	push	r5
    3d26:	6f 92       	push	r6
    3d28:	7f 92       	push	r7
    3d2a:	8f 92       	push	r8
    3d2c:	9f 92       	push	r9
    3d2e:	af 92       	push	r10
    3d30:	bf 92       	push	r11
    3d32:	cf 92       	push	r12
    3d34:	df 92       	push	r13
    3d36:	ef 92       	push	r14
    3d38:	ff 92       	push	r15
    3d3a:	0f 93       	push	r16
    3d3c:	1f 93       	push	r17
    3d3e:	cf 93       	push	r28
    3d40:	df 93       	push	r29
    3d42:	3c 01       	movw	r6, r24
    3d44:	4a 01       	movw	r8, r20
    3d46:	5b 01       	movw	r10, r22
    3d48:	29 01       	movw	r4, r18

	int size = (inlen > outlen) ? inlen : outlen;
	csp_packet_t * packet = csp_buffer_get(size);
    3d4a:	80 2f       	mov	r24, r16
    3d4c:	91 2f       	mov	r25, r17
    3d4e:	0c 15       	cp	r16, r12
    3d50:	1d 05       	cpc	r17, r13
    3d52:	14 f4       	brge	.+4      	; 0x3d58 <csp_transaction_persistent+0x36>
    3d54:	8c 2d       	mov	r24, r12
    3d56:	9d 2d       	mov	r25, r13
    3d58:	0e 94 93 15 	call	0x2b26	; 0x2b26 <csp_buffer_get>
    3d5c:	ec 01       	movw	r28, r24
	if (packet == NULL)
    3d5e:	00 97       	sbiw	r24, 0x00	; 0
    3d60:	09 f4       	brne	.+2      	; 0x3d64 <csp_transaction_persistent+0x42>
    3d62:	66 c0       	rjmp	.+204    	; 0x3e30 <csp_transaction_persistent+0x10e>
		return 0;

	/* Copy the request */
	if (outlen > 0 && outbuf != NULL)
    3d64:	10 16       	cp	r1, r16
    3d66:	11 06       	cpc	r1, r17
    3d68:	44 f4       	brge	.+16     	; 0x3d7a <csp_transaction_persistent+0x58>
    3d6a:	41 14       	cp	r4, r1
    3d6c:	51 04       	cpc	r5, r1
    3d6e:	29 f0       	breq	.+10     	; 0x3d7a <csp_transaction_persistent+0x58>
		memcpy(packet->data, outbuf, outlen);
    3d70:	a8 01       	movw	r20, r16
    3d72:	b2 01       	movw	r22, r4
    3d74:	0e 96       	adiw	r24, 0x0e	; 14
    3d76:	0e 94 30 2c 	call	0x5860	; 0x5860 <memcpy>
	packet->length = outlen;
    3d7a:	19 87       	std	Y+9, r17	; 0x09
    3d7c:	08 87       	std	Y+8, r16	; 0x08

	if (!csp_send(conn, packet, timeout)) {
    3d7e:	a5 01       	movw	r20, r10
    3d80:	94 01       	movw	r18, r8
    3d82:	be 01       	movw	r22, r28
    3d84:	c3 01       	movw	r24, r6
    3d86:	6c df       	rcall	.-296    	; 0x3c60 <csp_send>
    3d88:	8c 01       	movw	r16, r24
    3d8a:	89 2b       	or	r24, r25
    3d8c:	21 f4       	brne	.+8      	; 0x3d96 <csp_transaction_persistent+0x74>
		csp_buffer_free(packet);
    3d8e:	ce 01       	movw	r24, r28
    3d90:	0e 94 8c 16 	call	0x2d18	; 0x2d18 <csp_buffer_free>
		return 0;
    3d94:	55 c0       	rjmp	.+170    	; 0x3e40 <csp_transaction_persistent+0x11e>
	}

	/* If no reply is expected, return now */
	if (inlen == 0)
    3d96:	c1 14       	cp	r12, r1
    3d98:	d1 04       	cpc	r13, r1
    3d9a:	09 f4       	brne	.+2      	; 0x3d9e <csp_transaction_persistent+0x7c>
    3d9c:	4c c0       	rjmp	.+152    	; 0x3e36 <csp_transaction_persistent+0x114>
		return 1;

	packet = csp_read(conn, timeout);
    3d9e:	b5 01       	movw	r22, r10
    3da0:	a4 01       	movw	r20, r8
    3da2:	c3 01       	movw	r24, r6
    3da4:	b9 dd       	rcall	.-1166   	; 0x3918 <csp_read>
    3da6:	ec 01       	movw	r28, r24
	if (packet == NULL)
    3da8:	89 2b       	or	r24, r25
    3daa:	09 f4       	brne	.+2      	; 0x3dae <csp_transaction_persistent+0x8c>
    3dac:	47 c0       	rjmp	.+142    	; 0x3e3c <csp_transaction_persistent+0x11a>
		return 0;

	if ((inlen != -1) && ((int)packet->length != inlen)) {
    3dae:	8f ef       	ldi	r24, 0xFF	; 255
    3db0:	c8 16       	cp	r12, r24
    3db2:	d8 06       	cpc	r13, r24
    3db4:	69 f1       	breq	.+90     	; 0x3e10 <csp_transaction_persistent+0xee>
    3db6:	88 85       	ldd	r24, Y+8	; 0x08
    3db8:	99 85       	ldd	r25, Y+9	; 0x09
    3dba:	c8 16       	cp	r12, r24
    3dbc:	d9 06       	cpc	r13, r25
    3dbe:	41 f1       	breq	.+80     	; 0x3e10 <csp_transaction_persistent+0xee>
		csp_log_error("Reply length %u expected %u", packet->length, inlen);
    3dc0:	20 91 04 02 	lds	r18, 0x0204	; 0x800204 <csp_debug_level_enabled>
    3dc4:	22 23       	and	r18, r18
    3dc6:	f1 f0       	breq	.+60     	; 0x3e04 <csp_transaction_persistent+0xe2>
    3dc8:	df 92       	push	r13
    3dca:	cf 92       	push	r12
    3dcc:	9f 93       	push	r25
    3dce:	8f 93       	push	r24
    3dd0:	81 e0       	ldi	r24, 0x01	; 1
    3dd2:	8f 93       	push	r24
    3dd4:	86 e9       	ldi	r24, 0x96	; 150
    3dd6:	8f 93       	push	r24
    3dd8:	82 e0       	ldi	r24, 0x02	; 2
    3dda:	93 e0       	ldi	r25, 0x03	; 3
    3ddc:	9f 93       	push	r25
    3dde:	8f 93       	push	r24
    3de0:	80 91 eb 1e 	lds	r24, 0x1EEB	; 0x801eeb <csp_my_address>
    3de4:	1f 92       	push	r1
    3de6:	8f 93       	push	r24
    3de8:	87 e4       	ldi	r24, 0x47	; 71
    3dea:	97 e0       	ldi	r25, 0x07	; 7
    3dec:	9f 93       	push	r25
    3dee:	8f 93       	push	r24
    3df0:	1f 92       	push	r1
    3df2:	80 dc       	rcall	.-1792   	; 0x36f4 <do_csp_debug>
    3df4:	8d b7       	in	r24, 0x3d	; 61
    3df6:	9e b7       	in	r25, 0x3e	; 62
    3df8:	0d 96       	adiw	r24, 0x0d	; 13
    3dfa:	0f b6       	in	r0, 0x3f	; 63
    3dfc:	f8 94       	cli
    3dfe:	9e bf       	out	0x3e, r25	; 62
    3e00:	0f be       	out	0x3f, r0	; 63
    3e02:	8d bf       	out	0x3d, r24	; 61
		csp_buffer_free(packet);
    3e04:	ce 01       	movw	r24, r28
    3e06:	0e 94 8c 16 	call	0x2d18	; 0x2d18 <csp_buffer_free>
		return 0;
    3e0a:	00 e0       	ldi	r16, 0x00	; 0
    3e0c:	10 e0       	ldi	r17, 0x00	; 0
    3e0e:	18 c0       	rjmp	.+48     	; 0x3e40 <csp_transaction_persistent+0x11e>
	}

	memcpy(inbuf, packet->data, packet->length);
    3e10:	be 01       	movw	r22, r28
    3e12:	62 5f       	subi	r22, 0xF2	; 242
    3e14:	7f 4f       	sbci	r23, 0xFF	; 255
    3e16:	48 85       	ldd	r20, Y+8	; 0x08
    3e18:	59 85       	ldd	r21, Y+9	; 0x09
    3e1a:	c7 01       	movw	r24, r14
    3e1c:	0e 94 30 2c 	call	0x5860	; 0x5860 <memcpy>
	int length = packet->length;
    3e20:	e8 84       	ldd	r14, Y+8	; 0x08
    3e22:	f9 84       	ldd	r15, Y+9	; 0x09
	csp_buffer_free(packet);
    3e24:	ce 01       	movw	r24, r28
    3e26:	0e 94 8c 16 	call	0x2d18	; 0x2d18 <csp_buffer_free>
	return length;
    3e2a:	0e 2d       	mov	r16, r14
    3e2c:	1f 2d       	mov	r17, r15
    3e2e:	08 c0       	rjmp	.+16     	; 0x3e40 <csp_transaction_persistent+0x11e>
int csp_transaction_persistent(csp_conn_t * conn, uint32_t timeout, void * outbuf, int outlen, void * inbuf, int inlen) {

	int size = (inlen > outlen) ? inlen : outlen;
	csp_packet_t * packet = csp_buffer_get(size);
	if (packet == NULL)
		return 0;
    3e30:	00 e0       	ldi	r16, 0x00	; 0
    3e32:	10 e0       	ldi	r17, 0x00	; 0
    3e34:	05 c0       	rjmp	.+10     	; 0x3e40 <csp_transaction_persistent+0x11e>
		return 0;
	}

	/* If no reply is expected, return now */
	if (inlen == 0)
		return 1;
    3e36:	01 e0       	ldi	r16, 0x01	; 1
    3e38:	10 e0       	ldi	r17, 0x00	; 0
    3e3a:	02 c0       	rjmp	.+4      	; 0x3e40 <csp_transaction_persistent+0x11e>

	packet = csp_read(conn, timeout);
	if (packet == NULL)
		return 0;
    3e3c:	00 e0       	ldi	r16, 0x00	; 0
    3e3e:	10 e0       	ldi	r17, 0x00	; 0
	memcpy(inbuf, packet->data, packet->length);
	int length = packet->length;
	csp_buffer_free(packet);
	return length;

}
    3e40:	c8 01       	movw	r24, r16
    3e42:	df 91       	pop	r29
    3e44:	cf 91       	pop	r28
    3e46:	1f 91       	pop	r17
    3e48:	0f 91       	pop	r16
    3e4a:	ff 90       	pop	r15
    3e4c:	ef 90       	pop	r14
    3e4e:	df 90       	pop	r13
    3e50:	cf 90       	pop	r12
    3e52:	bf 90       	pop	r11
    3e54:	af 90       	pop	r10
    3e56:	9f 90       	pop	r9
    3e58:	8f 90       	pop	r8
    3e5a:	7f 90       	pop	r7
    3e5c:	6f 90       	pop	r6
    3e5e:	5f 90       	pop	r5
    3e60:	4f 90       	pop	r4
    3e62:	08 95       	ret

00003e64 <csp_transaction>:

int csp_transaction(uint8_t prio, uint8_t dest, uint8_t port, uint32_t timeout, void * outbuf, int outlen, void * inbuf, int inlen) {
    3e64:	2f 92       	push	r2
    3e66:	3f 92       	push	r3
    3e68:	4f 92       	push	r4
    3e6a:	5f 92       	push	r5
    3e6c:	6f 92       	push	r6
    3e6e:	7f 92       	push	r7
    3e70:	8f 92       	push	r8
    3e72:	9f 92       	push	r9
    3e74:	af 92       	push	r10
    3e76:	bf 92       	push	r11
    3e78:	cf 92       	push	r12
    3e7a:	df 92       	push	r13
    3e7c:	ef 92       	push	r14
    3e7e:	ff 92       	push	r15
    3e80:	0f 93       	push	r16
    3e82:	1f 93       	push	r17
    3e84:	cf 93       	push	r28
    3e86:	df 93       	push	r29
    3e88:	00 d0       	rcall	.+0      	; 0x3e8a <csp_transaction+0x26>
    3e8a:	1f 92       	push	r1
    3e8c:	cd b7       	in	r28, 0x3d	; 61
    3e8e:	de b7       	in	r29, 0x3e	; 62
    3e90:	28 01       	movw	r4, r16
    3e92:	39 01       	movw	r6, r18
    3e94:	fa 82       	std	Y+2, r15	; 0x02
    3e96:	e9 82       	std	Y+1, r14	; 0x01
    3e98:	dc 82       	std	Y+4, r13	; 0x04
    3e9a:	cb 82       	std	Y+3, r12	; 0x03
    3e9c:	15 01       	movw	r2, r10

	csp_conn_t * conn = csp_connect(prio, dest, port, 0, CSP_CONNECTION_SO);
    3e9e:	c1 2c       	mov	r12, r1
    3ea0:	d1 2c       	mov	r13, r1
    3ea2:	76 01       	movw	r14, r12
    3ea4:	00 e0       	ldi	r16, 0x00	; 0
    3ea6:	10 e0       	ldi	r17, 0x00	; 0
    3ea8:	98 01       	movw	r18, r16
    3eaa:	e8 da       	rcall	.-2608   	; 0x347c <csp_connect>
    3eac:	5c 01       	movw	r10, r24
	if (conn == NULL){
    3eae:	00 97       	sbiw	r24, 0x00	; 0
    3eb0:	81 f0       	breq	.+32     	; 0x3ed2 <csp_transaction+0x6e>
		return 0;
	}

	int status = csp_transaction_persistent(conn, timeout, outbuf, outlen, inbuf, inlen);
    3eb2:	64 01       	movw	r12, r8
    3eb4:	71 01       	movw	r14, r2
    3eb6:	0b 81       	ldd	r16, Y+3	; 0x03
    3eb8:	1c 81       	ldd	r17, Y+4	; 0x04
    3eba:	29 81       	ldd	r18, Y+1	; 0x01
    3ebc:	3a 81       	ldd	r19, Y+2	; 0x02
    3ebe:	b3 01       	movw	r22, r6
    3ec0:	a2 01       	movw	r20, r4
    3ec2:	2f df       	rcall	.-418    	; 0x3d22 <csp_transaction_persistent>
    3ec4:	88 2e       	mov	r8, r24
    3ec6:	99 2e       	mov	r9, r25

	csp_close(conn);
    3ec8:	c5 01       	movw	r24, r10
    3eca:	50 da       	rcall	.-2912   	; 0x336c <csp_close>
    3ecc:	88 2d       	mov	r24, r8

	return status;
    3ece:	99 2d       	mov	r25, r9
    3ed0:	02 c0       	rjmp	.+4      	; 0x3ed6 <csp_transaction+0x72>
    3ed2:	80 e0       	ldi	r24, 0x00	; 0

int csp_transaction(uint8_t prio, uint8_t dest, uint8_t port, uint32_t timeout, void * outbuf, int outlen, void * inbuf, int inlen) {

	csp_conn_t * conn = csp_connect(prio, dest, port, 0, CSP_CONNECTION_SO);
	if (conn == NULL){
		return 0;
    3ed4:	90 e0       	ldi	r25, 0x00	; 0
    3ed6:	0f 90       	pop	r0

	csp_close(conn);

	return status;

}
    3ed8:	0f 90       	pop	r0
    3eda:	0f 90       	pop	r0
    3edc:	0f 90       	pop	r0
    3ede:	df 91       	pop	r29
    3ee0:	cf 91       	pop	r28
    3ee2:	1f 91       	pop	r17
    3ee4:	0f 91       	pop	r16
    3ee6:	ff 90       	pop	r15
    3ee8:	ef 90       	pop	r14
    3eea:	df 90       	pop	r13
    3eec:	cf 90       	pop	r12
    3eee:	bf 90       	pop	r11
    3ef0:	af 90       	pop	r10
    3ef2:	9f 90       	pop	r9
    3ef4:	8f 90       	pop	r8
    3ef6:	7f 90       	pop	r7
    3ef8:	6f 90       	pop	r6
    3efa:	5f 90       	pop	r5
    3efc:	4f 90       	pop	r4
    3efe:	3f 90       	pop	r3
    3f00:	2f 90       	pop	r2
    3f02:	08 95       	ret

00003f04 <csp_port_get_socket>:

csp_socket_t * csp_port_get_socket(unsigned int port) {

	csp_socket_t * ret = NULL;

	if (port >= CSP_ANY)
    3f04:	80 32       	cpi	r24, 0x20	; 32
    3f06:	91 05       	cpc	r25, r1
    3f08:	f0 f4       	brcc	.+60     	; 0x3f46 <csp_port_get_socket+0x42>
		return NULL;

	/* Match dport to socket or local "catch all" port number */
	if (ports[port].state == PORT_OPEN)
    3f0a:	fc 01       	movw	r30, r24
    3f0c:	ee 0f       	add	r30, r30
    3f0e:	ff 1f       	adc	r31, r31
    3f10:	e8 0f       	add	r30, r24
    3f12:	f9 1f       	adc	r31, r25
    3f14:	e4 51       	subi	r30, 0x14	; 20
    3f16:	f1 4e       	sbci	r31, 0xE1	; 225
    3f18:	20 81       	ld	r18, Z
    3f1a:	21 30       	cpi	r18, 0x01	; 1
    3f1c:	59 f4       	brne	.+22     	; 0x3f34 <csp_port_get_socket+0x30>
		ret = ports[port].socket;
    3f1e:	fc 01       	movw	r30, r24
    3f20:	ee 0f       	add	r30, r30
    3f22:	ff 1f       	adc	r31, r31
    3f24:	8e 0f       	add	r24, r30
    3f26:	9f 1f       	adc	r25, r31
    3f28:	fc 01       	movw	r30, r24
    3f2a:	e4 51       	subi	r30, 0x14	; 20
    3f2c:	f1 4e       	sbci	r31, 0xE1	; 225
    3f2e:	81 81       	ldd	r24, Z+1	; 0x01
    3f30:	92 81       	ldd	r25, Z+2	; 0x02
    3f32:	08 95       	ret
	else if (ports[CSP_ANY].state == PORT_OPEN)
    3f34:	80 91 4c 1f 	lds	r24, 0x1F4C	; 0x801f4c <ports+0x60>
    3f38:	81 30       	cpi	r24, 0x01	; 1
    3f3a:	41 f4       	brne	.+16     	; 0x3f4c <csp_port_get_socket+0x48>
		ret = ports[CSP_ANY].socket;
    3f3c:	80 91 4d 1f 	lds	r24, 0x1F4D	; 0x801f4d <ports+0x61>
    3f40:	90 91 4e 1f 	lds	r25, 0x1F4E	; 0x801f4e <ports+0x62>
    3f44:	08 95       	ret
csp_socket_t * csp_port_get_socket(unsigned int port) {

	csp_socket_t * ret = NULL;

	if (port >= CSP_ANY)
		return NULL;
    3f46:	80 e0       	ldi	r24, 0x00	; 0
    3f48:	90 e0       	ldi	r25, 0x00	; 0
    3f4a:	08 95       	ret
/* Allocation of ports */
static csp_port_t ports[CSP_MAX_BIND_PORT + 2];

csp_socket_t * csp_port_get_socket(unsigned int port) {

	csp_socket_t * ret = NULL;
    3f4c:	80 e0       	ldi	r24, 0x00	; 0
    3f4e:	90 e0       	ldi	r25, 0x00	; 0
	else if (ports[CSP_ANY].state == PORT_OPEN)
		ret = ports[CSP_ANY].socket;

	return ret;

}
    3f50:	08 95       	ret

00003f52 <csp_port_init>:

int csp_port_init(void) {

	memset(ports, PORT_CLOSED, sizeof(csp_port_t) * (CSP_MAX_BIND_PORT + 2));
    3f52:	83 e6       	ldi	r24, 0x63	; 99
    3f54:	ec ee       	ldi	r30, 0xEC	; 236
    3f56:	fe e1       	ldi	r31, 0x1E	; 30
    3f58:	df 01       	movw	r26, r30
    3f5a:	1d 92       	st	X+, r1
    3f5c:	8a 95       	dec	r24
    3f5e:	e9 f7       	brne	.-6      	; 0x3f5a <csp_port_init+0x8>

	return CSP_ERR_NONE;

}
    3f60:	80 e0       	ldi	r24, 0x00	; 0
    3f62:	90 e0       	ldi	r25, 0x00	; 0
    3f64:	08 95       	ret

00003f66 <csp_qfifo_init>:
int csp_qfifo_init(void) {
	int prio;

	/* Create router fifos for each priority */
	for (prio = 0; prio < CSP_ROUTE_FIFOS; prio++) {
		if (qfifo[prio] == NULL) {
    3f66:	80 91 4f 1f 	lds	r24, 0x1F4F	; 0x801f4f <qfifo>
    3f6a:	90 91 50 1f 	lds	r25, 0x1F50	; 0x801f50 <qfifo+0x1>
    3f6e:	89 2b       	or	r24, r25
    3f70:	61 f4       	brne	.+24     	; 0x3f8a <csp_qfifo_init+0x24>
			qfifo[prio] = csp_queue_create(CSP_FIFO_INPUT, sizeof(csp_qfifo_t));
    3f72:	64 e0       	ldi	r22, 0x04	; 4
    3f74:	70 e0       	ldi	r23, 0x00	; 0
    3f76:	8a e0       	ldi	r24, 0x0A	; 10
    3f78:	90 e0       	ldi	r25, 0x00	; 0
    3f7a:	0e 94 9d 13 	call	0x273a	; 0x273a <csp_queue_create>
    3f7e:	90 93 50 1f 	sts	0x1F50, r25	; 0x801f50 <qfifo+0x1>
    3f82:	80 93 4f 1f 	sts	0x1F4F, r24	; 0x801f4f <qfifo>
			if (!qfifo[prio])
    3f86:	89 2b       	or	r24, r25
    3f88:	19 f0       	breq	.+6      	; 0x3f90 <csp_qfifo_init+0x2a>
	qfifo_events = csp_queue_create(CSP_FIFO_INPUT, sizeof(int));
	if (!qfifo_events)
		return CSP_ERR_NOMEM;
#endif

	return CSP_ERR_NONE;
    3f8a:	80 e0       	ldi	r24, 0x00	; 0
    3f8c:	90 e0       	ldi	r25, 0x00	; 0
    3f8e:	08 95       	ret
	/* Create router fifos for each priority */
	for (prio = 0; prio < CSP_ROUTE_FIFOS; prio++) {
		if (qfifo[prio] == NULL) {
			qfifo[prio] = csp_queue_create(CSP_FIFO_INPUT, sizeof(csp_qfifo_t));
			if (!qfifo[prio])
				return CSP_ERR_NOMEM;
    3f90:	8f ef       	ldi	r24, 0xFF	; 255
    3f92:	9f ef       	ldi	r25, 0xFF	; 255
		return CSP_ERR_NOMEM;
#endif

	return CSP_ERR_NONE;

}
    3f94:	08 95       	ret

00003f96 <csp_qfifo_read>:
	if (!found) {
		csp_log_warn("Spurious wakeup: No packet found");
		return CSP_ERR_TIMEDOUT;
	}
#else
	if (csp_queue_dequeue(qfifo[0], input, FIFO_TIMEOUT) != CSP_QUEUE_OK)
    3f96:	2f ef       	ldi	r18, 0xFF	; 255
    3f98:	3f ef       	ldi	r19, 0xFF	; 255
    3f9a:	a9 01       	movw	r20, r18
    3f9c:	bc 01       	movw	r22, r24
    3f9e:	80 91 4f 1f 	lds	r24, 0x1F4F	; 0x801f4f <qfifo>
    3fa2:	90 91 50 1f 	lds	r25, 0x1F50	; 0x801f50 <qfifo+0x1>
    3fa6:	0e 94 ae 13 	call	0x275c	; 0x275c <csp_queue_dequeue>
    3faa:	01 97       	sbiw	r24, 0x01	; 1
    3fac:	19 f4       	brne	.+6      	; 0x3fb4 <csp_qfifo_read+0x1e>
		return CSP_ERR_TIMEDOUT;
#endif

	return CSP_ERR_NONE;
    3fae:	80 e0       	ldi	r24, 0x00	; 0
    3fb0:	90 e0       	ldi	r25, 0x00	; 0
    3fb2:	08 95       	ret
		csp_log_warn("Spurious wakeup: No packet found");
		return CSP_ERR_TIMEDOUT;
	}
#else
	if (csp_queue_dequeue(qfifo[0], input, FIFO_TIMEOUT) != CSP_QUEUE_OK)
		return CSP_ERR_TIMEDOUT;
    3fb4:	8d ef       	ldi	r24, 0xFD	; 253
    3fb6:	9f ef       	ldi	r25, 0xFF	; 255
#endif

	return CSP_ERR_NONE;

}
    3fb8:	08 95       	ret

00003fba <csp_qfifo_write>:

void csp_qfifo_write(csp_packet_t * packet, csp_iface_t * interface, CSP_BASE_TYPE * pxTaskWoken) {
    3fba:	cf 92       	push	r12
    3fbc:	df 92       	push	r13
    3fbe:	ef 92       	push	r14
    3fc0:	ff 92       	push	r15
    3fc2:	0f 93       	push	r16
    3fc4:	1f 93       	push	r17
    3fc6:	cf 93       	push	r28
    3fc8:	df 93       	push	r29
    3fca:	00 d0       	rcall	.+0      	; 0x3fcc <csp_qfifo_write+0x12>
    3fcc:	1f 92       	push	r1
    3fce:	cd b7       	in	r28, 0x3d	; 61
    3fd0:	de b7       	in	r29, 0x3e	; 62
    3fd2:	7c 01       	movw	r14, r24
    3fd4:	8b 01       	movw	r16, r22
    3fd6:	6a 01       	movw	r12, r20
	int result;

	if (packet == NULL) {
    3fd8:	00 97       	sbiw	r24, 0x00	; 0
    3fda:	e1 f4       	brne	.+56     	; 0x4014 <csp_qfifo_write+0x5a>
		csp_log_warn("csp_new packet called with NULL packet");
    3fdc:	80 91 05 02 	lds	r24, 0x0205	; 0x800205 <csp_debug_level_enabled+0x1>
    3fe0:	88 23       	and	r24, r24
    3fe2:	09 f4       	brne	.+2      	; 0x3fe6 <csp_qfifo_write+0x2c>
    3fe4:	a9 c0       	rjmp	.+338    	; 0x4138 <csp_qfifo_write+0x17e>
    3fe6:	6e dc       	rcall	.-1828   	; 0x38c4 <csp_get_address>
    3fe8:	1f 92       	push	r1
    3fea:	9d e5       	ldi	r25, 0x5D	; 93
    3fec:	9f 93       	push	r25
    3fee:	2e e2       	ldi	r18, 0x2E	; 46
    3ff0:	33 e0       	ldi	r19, 0x03	; 3
    3ff2:	3f 93       	push	r19
    3ff4:	2f 93       	push	r18
    3ff6:	1f 92       	push	r1
    3ff8:	8f 93       	push	r24
    3ffa:	84 e0       	ldi	r24, 0x04	; 4
    3ffc:	9a e0       	ldi	r25, 0x0A	; 10
    3ffe:	9f 93       	push	r25
    4000:	8f 93       	push	r24
    4002:	81 e0       	ldi	r24, 0x01	; 1
    4004:	8f 93       	push	r24
    4006:	76 db       	rcall	.-2324   	; 0x36f4 <do_csp_debug>
    4008:	0f b6       	in	r0, 0x3f	; 63
    400a:	f8 94       	cli
    400c:	de bf       	out	0x3e, r29	; 62
    400e:	0f be       	out	0x3f, r0	; 63
    4010:	cd bf       	out	0x3d, r28	; 61
    4012:	92 c0       	rjmp	.+292    	; 0x4138 <csp_qfifo_write+0x17e>
		return;
	} else if (interface == NULL) {
    4014:	61 15       	cp	r22, r1
    4016:	71 05       	cpc	r23, r1
    4018:	21 f5       	brne	.+72     	; 0x4062 <csp_qfifo_write+0xa8>
		csp_log_warn("csp_new packet called with NULL interface");
    401a:	80 91 05 02 	lds	r24, 0x0205	; 0x800205 <csp_debug_level_enabled+0x1>
    401e:	88 23       	and	r24, r24
    4020:	b1 f0       	breq	.+44     	; 0x404e <csp_qfifo_write+0x94>
    4022:	50 dc       	rcall	.-1888   	; 0x38c4 <csp_get_address>
    4024:	1f 92       	push	r1
    4026:	90 e6       	ldi	r25, 0x60	; 96
    4028:	9f 93       	push	r25
    402a:	2e e2       	ldi	r18, 0x2E	; 46
    402c:	33 e0       	ldi	r19, 0x03	; 3
    402e:	3f 93       	push	r19
    4030:	2f 93       	push	r18
    4032:	1f 92       	push	r1
    4034:	8f 93       	push	r24
    4036:	8d ec       	ldi	r24, 0xCD	; 205
    4038:	99 e0       	ldi	r25, 0x09	; 9
    403a:	9f 93       	push	r25
    403c:	8f 93       	push	r24
    403e:	81 e0       	ldi	r24, 0x01	; 1
    4040:	8f 93       	push	r24
    4042:	58 db       	rcall	.-2384   	; 0x36f4 <do_csp_debug>
    4044:	0f b6       	in	r0, 0x3f	; 63
    4046:	f8 94       	cli
    4048:	de bf       	out	0x3e, r29	; 62
    404a:	0f be       	out	0x3f, r0	; 63
    404c:	cd bf       	out	0x3d, r28	; 61
		if (pxTaskWoken == NULL)
    404e:	cd 28       	or	r12, r13
    4050:	21 f4       	brne	.+8      	; 0x405a <csp_qfifo_write+0xa0>
			csp_buffer_free(packet);
    4052:	c7 01       	movw	r24, r14
    4054:	0e 94 8c 16 	call	0x2d18	; 0x2d18 <csp_buffer_free>
    4058:	6f c0       	rjmp	.+222    	; 0x4138 <csp_qfifo_write+0x17e>
		else
			csp_buffer_free_isr(packet);
    405a:	c7 01       	movw	r24, r14
    405c:	0e 94 54 16 	call	0x2ca8	; 0x2ca8 <csp_buffer_free_isr>
    4060:	6b c0       	rjmp	.+214    	; 0x4138 <csp_qfifo_write+0x17e>
		return;
	}

	csp_qfifo_t queue_element;
	queue_element.interface = interface;
    4062:	7a 83       	std	Y+2, r23	; 0x02
    4064:	69 83       	std	Y+1, r22	; 0x01
	queue_element.packet = packet;
    4066:	9c 83       	std	Y+4, r25	; 0x04
    4068:	8b 83       	std	Y+3, r24	; 0x03
	int fifo = packet->id.pri;
#else
	int fifo = 0;
#endif

	if (pxTaskWoken == NULL)
    406a:	41 15       	cp	r20, r1
    406c:	51 05       	cpc	r21, r1
    406e:	69 f4       	brne	.+26     	; 0x408a <csp_qfifo_write+0xd0>
		result = csp_queue_enqueue(qfifo[fifo], &queue_element, 0);
    4070:	20 e0       	ldi	r18, 0x00	; 0
    4072:	30 e0       	ldi	r19, 0x00	; 0
    4074:	a9 01       	movw	r20, r18
    4076:	be 01       	movw	r22, r28
    4078:	6f 5f       	subi	r22, 0xFF	; 255
    407a:	7f 4f       	sbci	r23, 0xFF	; 255
    407c:	80 91 4f 1f 	lds	r24, 0x1F4F	; 0x801f4f <qfifo>
    4080:	90 91 50 1f 	lds	r25, 0x1F50	; 0x801f50 <qfifo+0x1>
    4084:	0e 94 a0 13 	call	0x2740	; 0x2740 <csp_queue_enqueue>
    4088:	09 c0       	rjmp	.+18     	; 0x409c <csp_qfifo_write+0xe2>
	else
		result = csp_queue_enqueue_isr(qfifo[fifo], &queue_element, pxTaskWoken);
    408a:	be 01       	movw	r22, r28
    408c:	6f 5f       	subi	r22, 0xFF	; 255
    408e:	7f 4f       	sbci	r23, 0xFF	; 255
    4090:	80 91 4f 1f 	lds	r24, 0x1F4F	; 0x801f4f <qfifo>
    4094:	90 91 50 1f 	lds	r25, 0x1F50	; 0x801f50 <qfifo+0x1>
    4098:	0e 94 a8 13 	call	0x2750	; 0x2750 <csp_queue_enqueue_isr>
		else
			csp_queue_enqueue_isr(qfifo_events, &event, pxTaskWoken);
	}
#endif

	if (result != CSP_QUEUE_OK) {
    409c:	01 97       	sbiw	r24, 0x01	; 1
    409e:	81 f1       	breq	.+96     	; 0x4100 <csp_qfifo_write+0x146>
		csp_log_warn("ERROR: Routing input FIFO is FULL. Dropping packet.");
    40a0:	80 91 05 02 	lds	r24, 0x0205	; 0x800205 <csp_debug_level_enabled+0x1>
    40a4:	88 23       	and	r24, r24
    40a6:	b1 f0       	breq	.+44     	; 0x40d4 <csp_qfifo_write+0x11a>
    40a8:	0d dc       	rcall	.-2022   	; 0x38c4 <csp_get_address>
    40aa:	1f 92       	push	r1
    40ac:	93 e8       	ldi	r25, 0x83	; 131
    40ae:	9f 93       	push	r25
    40b0:	2e e2       	ldi	r18, 0x2E	; 46
    40b2:	33 e0       	ldi	r19, 0x03	; 3
    40b4:	3f 93       	push	r19
    40b6:	2f 93       	push	r18
    40b8:	1f 92       	push	r1
    40ba:	8f 93       	push	r24
    40bc:	8c e8       	ldi	r24, 0x8C	; 140
    40be:	99 e0       	ldi	r25, 0x09	; 9
    40c0:	9f 93       	push	r25
    40c2:	8f 93       	push	r24
    40c4:	81 e0       	ldi	r24, 0x01	; 1
    40c6:	8f 93       	push	r24
    40c8:	15 db       	rcall	.-2518   	; 0x36f4 <do_csp_debug>
    40ca:	0f b6       	in	r0, 0x3f	; 63
    40cc:	f8 94       	cli
    40ce:	de bf       	out	0x3e, r29	; 62
    40d0:	0f be       	out	0x3f, r0	; 63
    40d2:	cd bf       	out	0x3d, r28	; 61
		interface->drop++;
    40d4:	f8 01       	movw	r30, r16
    40d6:	81 8d       	ldd	r24, Z+25	; 0x19
    40d8:	92 8d       	ldd	r25, Z+26	; 0x1a
    40da:	a3 8d       	ldd	r26, Z+27	; 0x1b
    40dc:	b4 8d       	ldd	r27, Z+28	; 0x1c
    40de:	01 96       	adiw	r24, 0x01	; 1
    40e0:	a1 1d       	adc	r26, r1
    40e2:	b1 1d       	adc	r27, r1
    40e4:	81 8f       	std	Z+25, r24	; 0x19
    40e6:	92 8f       	std	Z+26, r25	; 0x1a
    40e8:	a3 8f       	std	Z+27, r26	; 0x1b
    40ea:	b4 8f       	std	Z+28, r27	; 0x1c
		if (pxTaskWoken == NULL)
    40ec:	cd 28       	or	r12, r13
    40ee:	21 f4       	brne	.+8      	; 0x40f8 <csp_qfifo_write+0x13e>
			csp_buffer_free(packet);
    40f0:	c7 01       	movw	r24, r14
    40f2:	0e 94 8c 16 	call	0x2d18	; 0x2d18 <csp_buffer_free>
    40f6:	20 c0       	rjmp	.+64     	; 0x4138 <csp_qfifo_write+0x17e>
		else
			csp_buffer_free_isr(packet);
    40f8:	c7 01       	movw	r24, r14
    40fa:	0e 94 54 16 	call	0x2ca8	; 0x2ca8 <csp_buffer_free_isr>
    40fe:	1c c0       	rjmp	.+56     	; 0x4138 <csp_qfifo_write+0x17e>
	} else {
		interface->rx++;
    4100:	f8 01       	movw	r30, r16
    4102:	85 85       	ldd	r24, Z+13	; 0x0d
    4104:	96 85       	ldd	r25, Z+14	; 0x0e
    4106:	a7 85       	ldd	r26, Z+15	; 0x0f
    4108:	b0 89       	ldd	r27, Z+16	; 0x10
    410a:	01 96       	adiw	r24, 0x01	; 1
    410c:	a1 1d       	adc	r26, r1
    410e:	b1 1d       	adc	r27, r1
    4110:	85 87       	std	Z+13, r24	; 0x0d
    4112:	96 87       	std	Z+14, r25	; 0x0e
    4114:	a7 87       	std	Z+15, r26	; 0x0f
    4116:	b0 8b       	std	Z+16, r27	; 0x10
		interface->rxbytes += packet->length;
    4118:	f7 01       	movw	r30, r14
    411a:	20 85       	ldd	r18, Z+8	; 0x08
    411c:	31 85       	ldd	r19, Z+9	; 0x09
    411e:	f8 01       	movw	r30, r16
    4120:	81 a5       	ldd	r24, Z+41	; 0x29
    4122:	92 a5       	ldd	r25, Z+42	; 0x2a
    4124:	a3 a5       	ldd	r26, Z+43	; 0x2b
    4126:	b4 a5       	ldd	r27, Z+44	; 0x2c
    4128:	82 0f       	add	r24, r18
    412a:	93 1f       	adc	r25, r19
    412c:	a1 1d       	adc	r26, r1
    412e:	b1 1d       	adc	r27, r1
    4130:	81 a7       	std	Z+41, r24	; 0x29
    4132:	92 a7       	std	Z+42, r25	; 0x2a
    4134:	a3 a7       	std	Z+43, r26	; 0x2b
    4136:	b4 a7       	std	Z+44, r27	; 0x2c
	}

}
    4138:	0f 90       	pop	r0
    413a:	0f 90       	pop	r0
    413c:	0f 90       	pop	r0
    413e:	0f 90       	pop	r0
    4140:	df 91       	pop	r29
    4142:	cf 91       	pop	r28
    4144:	1f 91       	pop	r17
    4146:	0f 91       	pop	r16
    4148:	ff 90       	pop	r15
    414a:	ef 90       	pop	r14
    414c:	df 90       	pop	r13
    414e:	cf 90       	pop	r12
    4150:	08 95       	ret

00004152 <csp_route_security_check>:
 * @param security_opts either socket_opts or conn_opts
 * @param interface pointer to incoming interface
 * @param packet pointer to packet
 * @return -1 Missing feature, -2 XTEA error, -3 CRC error, -4 HMAC error, 0 = OK.
 */
static int csp_route_security_check(uint32_t security_opts, csp_iface_t * interface, csp_packet_t * packet) {
    4152:	cf 93       	push	r28
    4154:	df 93       	push	r29
		return CSP_ERR_XTEA;
	}
#endif

	/* CRC32 verified packet */
	if (packet->id.flags & CSP_FCRC32) {
    4156:	f9 01       	movw	r30, r18
    4158:	82 85       	ldd	r24, Z+10	; 0x0a
    415a:	80 ff       	sbrs	r24, 0
    415c:	23 c0       	rjmp	.+70     	; 0x41a4 <csp_route_security_check+0x52>
    415e:	e9 01       	movw	r28, r18
		}
	} else if (security_opts & CSP_SO_CRC32REQ) {
		csp_log_warn("Received packet without CRC32. Accepting packet");
#else
		/* Strip CRC32 field and accept the packet */
		csp_log_warn("Received packet with CRC32, but CSP was compiled without CRC32 support. Accepting packet");
    4160:	80 91 05 02 	lds	r24, 0x0205	; 0x800205 <csp_debug_level_enabled+0x1>
    4164:	88 23       	and	r24, r24
    4166:	c9 f0       	breq	.+50     	; 0x419a <csp_route_security_check+0x48>
    4168:	ad db       	rcall	.-2214   	; 0x38c4 <csp_get_address>
    416a:	1f 92       	push	r1
    416c:	94 e8       	ldi	r25, 0x84	; 132
    416e:	9f 93       	push	r25
    4170:	2c e4       	ldi	r18, 0x4C	; 76
    4172:	33 e0       	ldi	r19, 0x03	; 3
    4174:	3f 93       	push	r19
    4176:	2f 93       	push	r18
    4178:	1f 92       	push	r1
    417a:	8f 93       	push	r24
    417c:	81 e6       	ldi	r24, 0x61	; 97
    417e:	9a e0       	ldi	r25, 0x0A	; 10
    4180:	9f 93       	push	r25
    4182:	8f 93       	push	r24
    4184:	81 e0       	ldi	r24, 0x01	; 1
    4186:	8f 93       	push	r24
    4188:	b5 da       	rcall	.-2710   	; 0x36f4 <do_csp_debug>
    418a:	8d b7       	in	r24, 0x3d	; 61
    418c:	9e b7       	in	r25, 0x3e	; 62
    418e:	09 96       	adiw	r24, 0x09	; 9
    4190:	0f b6       	in	r0, 0x3f	; 63
    4192:	f8 94       	cli
    4194:	9e bf       	out	0x3e, r25	; 62
    4196:	0f be       	out	0x3f, r0	; 63
    4198:	8d bf       	out	0x3d, r24	; 61
		packet->length -= sizeof(uint32_t);
    419a:	88 85       	ldd	r24, Y+8	; 0x08
    419c:	99 85       	ldd	r25, Y+9	; 0x09
    419e:	04 97       	sbiw	r24, 0x04	; 4
    41a0:	99 87       	std	Y+9, r25	; 0x09
    41a2:	88 87       	std	Y+8, r24	; 0x08
	}
#endif

	return CSP_ERR_NONE;

}
    41a4:	80 e0       	ldi	r24, 0x00	; 0
    41a6:	90 e0       	ldi	r25, 0x00	; 0
    41a8:	df 91       	pop	r29
    41aa:	cf 91       	pop	r28
    41ac:	08 95       	ret

000041ae <csp_route_work>:

int csp_route_work(uint32_t timeout) {
    41ae:	6f 92       	push	r6
    41b0:	7f 92       	push	r7
    41b2:	8f 92       	push	r8
    41b4:	9f 92       	push	r9
    41b6:	af 92       	push	r10
    41b8:	bf 92       	push	r11
    41ba:	cf 92       	push	r12
    41bc:	df 92       	push	r13
    41be:	ef 92       	push	r14
    41c0:	ff 92       	push	r15
    41c2:	0f 93       	push	r16
    41c4:	1f 93       	push	r17
    41c6:	cf 93       	push	r28
    41c8:	df 93       	push	r29
    41ca:	00 d0       	rcall	.+0      	; 0x41cc <csp_route_work+0x1e>
    41cc:	00 d0       	rcall	.+0      	; 0x41ce <csp_route_work+0x20>
    41ce:	cd b7       	in	r28, 0x3d	; 61
    41d0:	de b7       	in	r29, 0x3e	; 62
	/* Check connection timeouts (currently only for RDP) */
	csp_conn_check_timeouts();
#endif

	/* Get next packet to route */
	if (csp_qfifo_read(&input) != CSP_ERR_NONE)
    41d2:	ce 01       	movw	r24, r28
    41d4:	01 96       	adiw	r24, 0x01	; 1
    41d6:	df de       	rcall	.-578    	; 0x3f96 <csp_qfifo_read>
    41d8:	6c 01       	movw	r12, r24
    41da:	89 2b       	or	r24, r25
    41dc:	09 f0       	breq	.+2      	; 0x41e0 <csp_route_work+0x32>
    41de:	0f c2       	rjmp	.+1054   	; 0x45fe <csp_route_work+0x450>
		return -1;

	packet = input.packet;
    41e0:	eb 81       	ldd	r30, Y+3	; 0x03
    41e2:	fc 81       	ldd	r31, Y+4	; 0x04
    41e4:	fe 83       	std	Y+6, r31	; 0x06
    41e6:	ed 83       	std	Y+5, r30	; 0x05

	csp_log_packet("INP: S %u, D %u, Dp %u, Sp %u, Pr %u, Fl 0x%02X, Sz %"PRIu16" VIA: %s",
    41e8:	80 91 08 02 	lds	r24, 0x0208	; 0x800208 <csp_debug_level_enabled+0x4>
    41ec:	88 23       	and	r24, r24
    41ee:	09 f4       	brne	.+2      	; 0x41f2 <csp_route_work+0x44>
    41f0:	50 c0       	rjmp	.+160    	; 0x4292 <csp_route_work+0xe4>
    41f2:	a9 81       	ldd	r26, Y+1	; 0x01
    41f4:	ba 81       	ldd	r27, Y+2	; 0x02
    41f6:	8c 90       	ld	r8, X
    41f8:	11 96       	adiw	r26, 0x01	; 1
    41fa:	7c 90       	ld	r7, X
    41fc:	a0 84       	ldd	r10, Z+8	; 0x08
    41fe:	91 84       	ldd	r9, Z+9	; 0x09
    4200:	b2 84       	ldd	r11, Z+10	; 0x0a
    4202:	85 85       	ldd	r24, Z+13	; 0x0d
    4204:	e8 2e       	mov	r14, r24
    4206:	e6 94       	lsr	r14
    4208:	e6 94       	lsr	r14
    420a:	e6 94       	lsr	r14
    420c:	e6 94       	lsr	r14
    420e:	e6 94       	lsr	r14
    4210:	e6 94       	lsr	r14
    4212:	93 85       	ldd	r25, Z+11	; 0x0b
    4214:	29 2f       	mov	r18, r25
    4216:	2f 73       	andi	r18, 0x3F	; 63
    4218:	f2 2e       	mov	r15, r18
    421a:	29 2f       	mov	r18, r25
    421c:	22 95       	swap	r18
    421e:	26 95       	lsr	r18
    4220:	26 95       	lsr	r18
    4222:	23 70       	andi	r18, 0x03	; 3
    4224:	94 85       	ldd	r25, Z+12	; 0x0c
    4226:	39 2f       	mov	r19, r25
    4228:	3f 70       	andi	r19, 0x0F	; 15
    422a:	63 2e       	mov	r6, r19
    422c:	66 0c       	add	r6, r6
    422e:	66 0c       	add	r6, r6
    4230:	62 2a       	or	r6, r18
    4232:	92 95       	swap	r25
    4234:	9f 70       	andi	r25, 0x0F	; 15
    4236:	08 2f       	mov	r16, r24
    4238:	01 70       	andi	r16, 0x01	; 1
    423a:	02 95       	swap	r16
    423c:	00 7f       	andi	r16, 0xF0	; 240
    423e:	09 2b       	or	r16, r25
    4240:	86 95       	lsr	r24
    4242:	18 2f       	mov	r17, r24
    4244:	1f 71       	andi	r17, 0x1F	; 31
    4246:	3e db       	rcall	.-2436   	; 0x38c4 <csp_get_address>
    4248:	7f 92       	push	r7
    424a:	8f 92       	push	r8
    424c:	9f 92       	push	r9
    424e:	af 92       	push	r10
    4250:	1f 92       	push	r1
    4252:	bf 92       	push	r11
    4254:	1f 92       	push	r1
    4256:	ef 92       	push	r14
    4258:	1f 92       	push	r1
    425a:	ff 92       	push	r15
    425c:	1f 92       	push	r1
    425e:	6f 92       	push	r6
    4260:	1f 92       	push	r1
    4262:	0f 93       	push	r16
    4264:	1f 92       	push	r1
    4266:	1f 93       	push	r17
    4268:	1f 92       	push	r1
    426a:	9d eb       	ldi	r25, 0xBD	; 189
    426c:	9f 93       	push	r25
    426e:	2c e4       	ldi	r18, 0x4C	; 76
    4270:	33 e0       	ldi	r19, 0x03	; 3
    4272:	3f 93       	push	r19
    4274:	2f 93       	push	r18
    4276:	1f 92       	push	r1
    4278:	8f 93       	push	r24
    427a:	8b e6       	ldi	r24, 0x6B	; 107
    427c:	9c e0       	ldi	r25, 0x0C	; 12
    427e:	9f 93       	push	r25
    4280:	8f 93       	push	r24
    4282:	84 e0       	ldi	r24, 0x04	; 4
    4284:	8f 93       	push	r24
    4286:	36 da       	rcall	.-2964   	; 0x36f4 <do_csp_debug>
    4288:	0f b6       	in	r0, 0x3f	; 63
    428a:	f8 94       	cli
    428c:	de bf       	out	0x3e, r29	; 62
    428e:	0f be       	out	0x3f, r0	; 63
    4290:	cd bf       	out	0x3d, r28	; 61
		return 0;
	}
#endif

	/* If the message is not to me, route the message to the correct interface */
	if ((packet->id.dst != csp_get_address()) && (packet->id.dst != CSP_BROADCAST_ADDR)) {
    4292:	ed 81       	ldd	r30, Y+5	; 0x05
    4294:	fe 81       	ldd	r31, Y+6	; 0x06
    4296:	04 85       	ldd	r16, Z+12	; 0x0c
    4298:	80 2f       	mov	r24, r16
    429a:	82 95       	swap	r24
    429c:	8f 70       	andi	r24, 0x0F	; 15
    429e:	05 85       	ldd	r16, Z+13	; 0x0d
    42a0:	01 70       	andi	r16, 0x01	; 1
    42a2:	02 95       	swap	r16
    42a4:	00 7f       	andi	r16, 0xF0	; 240
    42a6:	08 2b       	or	r16, r24
    42a8:	10 e0       	ldi	r17, 0x00	; 0
    42aa:	0c db       	rcall	.-2536   	; 0x38c4 <csp_get_address>
    42ac:	90 e0       	ldi	r25, 0x00	; 0
    42ae:	08 17       	cp	r16, r24
    42b0:	19 07       	cpc	r17, r25
    42b2:	09 f4       	brne	.+2      	; 0x42b6 <csp_route_work+0x108>
    42b4:	4f c0       	rjmp	.+158    	; 0x4354 <csp_route_work+0x1a6>
    42b6:	ed 81       	ldd	r30, Y+5	; 0x05
    42b8:	fe 81       	ldd	r31, Y+6	; 0x06
    42ba:	84 85       	ldd	r24, Z+12	; 0x0c
    42bc:	98 2f       	mov	r25, r24
    42be:	92 95       	swap	r25
    42c0:	9f 70       	andi	r25, 0x0F	; 15
    42c2:	85 85       	ldd	r24, Z+13	; 0x0d
    42c4:	81 70       	andi	r24, 0x01	; 1
    42c6:	82 95       	swap	r24
    42c8:	80 7f       	andi	r24, 0xF0	; 240
    42ca:	89 2b       	or	r24, r25
    42cc:	8f 31       	cpi	r24, 0x1F	; 31
    42ce:	09 f4       	brne	.+2      	; 0x42d2 <csp_route_work+0x124>

		/* Find the destination interface */
		csp_iface_t * dstif = csp_rtable_find_iface(packet->id.dst);
    42d0:	41 c0       	rjmp	.+130    	; 0x4354 <csp_route_work+0x1a6>
    42d2:	10 d3       	rcall	.+1568   	; 0x48f4 <csp_rtable_find_iface>
    42d4:	fc 01       	movw	r30, r24

		/* If the message resolves to the input interface, don't loop it back out */
		if ((dstif == NULL) || ((dstif == input.interface) && (input.interface->split_horizon_off == 0))) {
    42d6:	00 97       	sbiw	r24, 0x00	; 0
    42d8:	41 f0       	breq	.+16     	; 0x42ea <csp_route_work+0x13c>
    42da:	29 81       	ldd	r18, Y+1	; 0x01
    42dc:	3a 81       	ldd	r19, Y+2	; 0x02
    42de:	82 17       	cp	r24, r18
    42e0:	93 07       	cpc	r25, r19
    42e2:	41 f4       	brne	.+16     	; 0x42f4 <csp_route_work+0x146>
    42e4:	20 85       	ldd	r18, Z+8	; 0x08
    42e6:	21 11       	cpse	r18, r1
    42e8:	05 c0       	rjmp	.+10     	; 0x42f4 <csp_route_work+0x146>
			csp_buffer_free(packet);
    42ea:	8d 81       	ldd	r24, Y+5	; 0x05
    42ec:	9e 81       	ldd	r25, Y+6	; 0x06
    42ee:	0e 94 8c 16 	call	0x2d18	; 0x2d18 <csp_buffer_free>
			return 0;
    42f2:	c3 c1       	rjmp	.+902    	; 0x467a <csp_route_work+0x4cc>
		}

		/* Otherwise, actually send the message */
		if (csp_send_direct(packet->id, packet, dstif, 0) != CSP_ERR_NONE) {
    42f4:	4d 81       	ldd	r20, Y+5	; 0x05
    42f6:	5e 81       	ldd	r21, Y+6	; 0x06
    42f8:	da 01       	movw	r26, r20
    42fa:	1a 96       	adiw	r26, 0x0a	; 10
    42fc:	6d 91       	ld	r22, X+
    42fe:	7d 91       	ld	r23, X+
    4300:	8d 91       	ld	r24, X+
    4302:	9c 91       	ld	r25, X
    4304:	1d 97       	sbiw	r26, 0x0d	; 13
    4306:	e1 2c       	mov	r14, r1
    4308:	f1 2c       	mov	r15, r1
    430a:	87 01       	movw	r16, r14
    430c:	9f 01       	movw	r18, r30
    430e:	2d db       	rcall	.-2470   	; 0x396a <csp_send_direct>
    4310:	00 97       	sbiw	r24, 0x00	; 0
    4312:	09 f4       	brne	.+2      	; 0x4316 <csp_route_work+0x168>
			csp_log_warn("Router failed to send");
    4314:	78 c1       	rjmp	.+752    	; 0x4606 <csp_route_work+0x458>
    4316:	80 91 05 02 	lds	r24, 0x0205	; 0x800205 <csp_debug_level_enabled+0x1>
    431a:	88 23       	and	r24, r24
    431c:	b1 f0       	breq	.+44     	; 0x434a <csp_route_work+0x19c>
    431e:	d2 da       	rcall	.-2652   	; 0x38c4 <csp_get_address>
    4320:	1f 92       	push	r1
    4322:	9c ed       	ldi	r25, 0xDC	; 220
    4324:	9f 93       	push	r25
    4326:	2c e4       	ldi	r18, 0x4C	; 76
    4328:	33 e0       	ldi	r19, 0x03	; 3
    432a:	3f 93       	push	r19
    432c:	2f 93       	push	r18
    432e:	1f 92       	push	r1
    4330:	8f 93       	push	r24
    4332:	88 e4       	ldi	r24, 0x48	; 72
    4334:	9c e0       	ldi	r25, 0x0C	; 12
    4336:	9f 93       	push	r25
    4338:	8f 93       	push	r24
    433a:	81 e0       	ldi	r24, 0x01	; 1
    433c:	8f 93       	push	r24
    433e:	da d9       	rcall	.-3148   	; 0x36f4 <do_csp_debug>
    4340:	0f b6       	in	r0, 0x3f	; 63
    4342:	f8 94       	cli
    4344:	de bf       	out	0x3e, r29	; 62
    4346:	0f be       	out	0x3f, r0	; 63
    4348:	cd bf       	out	0x3d, r28	; 61
			csp_buffer_free(packet);
    434a:	8d 81       	ldd	r24, Y+5	; 0x05
    434c:	9e 81       	ldd	r25, Y+6	; 0x06
    434e:	0e 94 8c 16 	call	0x2d18	; 0x2d18 <csp_buffer_free>
    4352:	93 c1       	rjmp	.+806    	; 0x467a <csp_route_work+0x4cc>
		/* Next message, please */
		return 0;
	}

	/* Discard packets with unsupported options */
	if (csp_route_check_options(input.interface, packet) != CSP_ERR_NONE) {
    4354:	ed 81       	ldd	r30, Y+5	; 0x05
    4356:	fe 81       	ldd	r31, Y+6	; 0x06
    4358:	09 81       	ldd	r16, Y+1	; 0x01
 */
static int csp_route_check_options(csp_iface_t *interface, csp_packet_t *packet)
{
#ifndef CSP_USE_XTEA
	/* Drop XTEA packets */
	if (packet->id.flags & CSP_FXTEA) {
    435a:	1a 81       	ldd	r17, Y+2	; 0x02
    435c:	82 85       	ldd	r24, Z+10	; 0x0a
    435e:	82 ff       	sbrs	r24, 2
		csp_log_error("Received XTEA encrypted packet, but CSP was compiled without XTEA support. Discarding packet");
    4360:	26 c0       	rjmp	.+76     	; 0x43ae <csp_route_work+0x200>
    4362:	80 91 04 02 	lds	r24, 0x0204	; 0x800204 <csp_debug_level_enabled>
    4366:	88 23       	and	r24, r24
    4368:	a9 f0       	breq	.+42     	; 0x4394 <csp_route_work+0x1e6>
    436a:	ac da       	rcall	.-2728   	; 0x38c4 <csp_get_address>
    436c:	1f 92       	push	r1
    436e:	97 e3       	ldi	r25, 0x37	; 55
    4370:	9f 93       	push	r25
    4372:	2c e4       	ldi	r18, 0x4C	; 76
    4374:	33 e0       	ldi	r19, 0x03	; 3
    4376:	3f 93       	push	r19
    4378:	2f 93       	push	r18
    437a:	1f 92       	push	r1
    437c:	8f 93       	push	r24
    437e:	8a e8       	ldi	r24, 0x8A	; 138
    4380:	9b e0       	ldi	r25, 0x0B	; 11
    4382:	9f 93       	push	r25
    4384:	8f 93       	push	r24
    4386:	1f 92       	push	r1
    4388:	b5 d9       	rcall	.-3222   	; 0x36f4 <do_csp_debug>
    438a:	0f b6       	in	r0, 0x3f	; 63
    438c:	f8 94       	cli
    438e:	de bf       	out	0x3e, r29	; 62
    4390:	0f be       	out	0x3f, r0	; 63
    4392:	cd bf       	out	0x3d, r28	; 61
		interface->autherr++;
    4394:	f8 01       	movw	r30, r16
    4396:	85 8d       	ldd	r24, Z+29	; 0x1d
    4398:	96 8d       	ldd	r25, Z+30	; 0x1e
    439a:	a7 8d       	ldd	r26, Z+31	; 0x1f
    439c:	b0 a1       	ldd	r27, Z+32	; 0x20
    439e:	01 96       	adiw	r24, 0x01	; 1
    43a0:	a1 1d       	adc	r26, r1
    43a2:	b1 1d       	adc	r27, r1
    43a4:	85 8f       	std	Z+29, r24	; 0x1d
    43a6:	96 8f       	std	Z+30, r25	; 0x1e
    43a8:	a7 8f       	std	Z+31, r26	; 0x1f
    43aa:	b0 a3       	std	Z+32, r27	; 0x20
	}
#endif

#ifndef CSP_USE_HMAC
	/* Drop HMAC packets */
	if (packet->id.flags & CSP_FHMAC) {
    43ac:	2e c1       	rjmp	.+604    	; 0x460a <csp_route_work+0x45c>
    43ae:	83 ff       	sbrs	r24, 3
		csp_log_error("Received packet with HMAC, but CSP was compiled without HMAC support. Discarding packet");
    43b0:	26 c0       	rjmp	.+76     	; 0x43fe <csp_route_work+0x250>
    43b2:	80 91 04 02 	lds	r24, 0x0204	; 0x800204 <csp_debug_level_enabled>
    43b6:	88 23       	and	r24, r24
    43b8:	a9 f0       	breq	.+42     	; 0x43e4 <csp_route_work+0x236>
    43ba:	84 da       	rcall	.-2808   	; 0x38c4 <csp_get_address>
    43bc:	1f 92       	push	r1
    43be:	90 e4       	ldi	r25, 0x40	; 64
    43c0:	9f 93       	push	r25
    43c2:	2c e4       	ldi	r18, 0x4C	; 76
    43c4:	33 e0       	ldi	r19, 0x03	; 3
    43c6:	3f 93       	push	r19
    43c8:	2f 93       	push	r18
    43ca:	1f 92       	push	r1
    43cc:	8f 93       	push	r24
    43ce:	85 e2       	ldi	r24, 0x25	; 37
    43d0:	9b e0       	ldi	r25, 0x0B	; 11
    43d2:	9f 93       	push	r25
    43d4:	8f 93       	push	r24
    43d6:	1f 92       	push	r1
    43d8:	8d d9       	rcall	.-3302   	; 0x36f4 <do_csp_debug>
    43da:	0f b6       	in	r0, 0x3f	; 63
    43dc:	f8 94       	cli
    43de:	de bf       	out	0x3e, r29	; 62
    43e0:	0f be       	out	0x3f, r0	; 63
    43e2:	cd bf       	out	0x3d, r28	; 61
		interface->autherr++;
    43e4:	f8 01       	movw	r30, r16
    43e6:	85 8d       	ldd	r24, Z+29	; 0x1d
    43e8:	96 8d       	ldd	r25, Z+30	; 0x1e
    43ea:	a7 8d       	ldd	r26, Z+31	; 0x1f
    43ec:	b0 a1       	ldd	r27, Z+32	; 0x20
    43ee:	01 96       	adiw	r24, 0x01	; 1
    43f0:	a1 1d       	adc	r26, r1
    43f2:	b1 1d       	adc	r27, r1
    43f4:	85 8f       	std	Z+29, r24	; 0x1d
    43f6:	96 8f       	std	Z+30, r25	; 0x1e
    43f8:	a7 8f       	std	Z+31, r26	; 0x1f
    43fa:	b0 a3       	std	Z+32, r27	; 0x20
	}
#endif

#ifndef CSP_USE_RDP
	/* Drop RDP packets */
	if (packet->id.flags & CSP_FRDP) {
    43fc:	06 c1       	rjmp	.+524    	; 0x460a <csp_route_work+0x45c>
    43fe:	81 ff       	sbrs	r24, 1
		csp_log_error("Received RDP packet, but CSP was compiled without RDP support. Discarding packet");
    4400:	09 c1       	rjmp	.+530    	; 0x4614 <csp_route_work+0x466>
    4402:	80 91 04 02 	lds	r24, 0x0204	; 0x800204 <csp_debug_level_enabled>
    4406:	88 23       	and	r24, r24
    4408:	a9 f0       	breq	.+42     	; 0x4434 <csp_route_work+0x286>
    440a:	5c da       	rcall	.-2888   	; 0x38c4 <csp_get_address>
    440c:	1f 92       	push	r1
    440e:	99 e4       	ldi	r25, 0x49	; 73
    4410:	9f 93       	push	r25
    4412:	2c e4       	ldi	r18, 0x4C	; 76
    4414:	33 e0       	ldi	r19, 0x03	; 3
    4416:	3f 93       	push	r19
    4418:	2f 93       	push	r18
    441a:	1f 92       	push	r1
    441c:	8f 93       	push	r24
    441e:	87 ec       	ldi	r24, 0xC7	; 199
    4420:	9a e0       	ldi	r25, 0x0A	; 10
    4422:	9f 93       	push	r25
    4424:	8f 93       	push	r24
    4426:	1f 92       	push	r1
    4428:	65 d9       	rcall	.-3382   	; 0x36f4 <do_csp_debug>
    442a:	0f b6       	in	r0, 0x3f	; 63
    442c:	f8 94       	cli
    442e:	de bf       	out	0x3e, r29	; 62
    4430:	0f be       	out	0x3f, r0	; 63
    4432:	cd bf       	out	0x3d, r28	; 61
		interface->rx_error++;
    4434:	f8 01       	movw	r30, r16
    4436:	85 89       	ldd	r24, Z+21	; 0x15
    4438:	96 89       	ldd	r25, Z+22	; 0x16
    443a:	a7 89       	ldd	r26, Z+23	; 0x17
    443c:	b0 8d       	ldd	r27, Z+24	; 0x18
    443e:	01 96       	adiw	r24, 0x01	; 1
    4440:	a1 1d       	adc	r26, r1
    4442:	b1 1d       	adc	r27, r1
    4444:	85 8b       	std	Z+21, r24	; 0x15
    4446:	96 8b       	std	Z+22, r25	; 0x16
    4448:	a7 8b       	std	Z+23, r26	; 0x17
    444a:	b0 8f       	std	Z+24, r27	; 0x18

	/* The message is to me, search for incoming socket */
	socket = csp_port_get_socket(packet->id.dport);

	/* If the socket is connection-less, deliver now */
	if (socket && (socket->opts & CSP_SO_CONN_LESS)) {
    444c:	de c0       	rjmp	.+444    	; 0x460a <csp_route_work+0x45c>
    444e:	d8 01       	movw	r26, r16
    4450:	54 96       	adiw	r26, 0x14	; 20
    4452:	6d 91       	ld	r22, X+
    4454:	7d 91       	ld	r23, X+
    4456:	8d 91       	ld	r24, X+
    4458:	9c 91       	ld	r25, X
    445a:	57 97       	sbiw	r26, 0x17	; 23
    445c:	70 ff       	sbrs	r23, 0
		if (csp_route_security_check(socket->opts, input.interface, packet) < 0) {
    445e:	fc c0       	rjmp	.+504    	; 0x4658 <csp_route_work+0x4aa>
    4460:	2d 81       	ldd	r18, Y+5	; 0x05
    4462:	3e 81       	ldd	r19, Y+6	; 0x06
    4464:	49 81       	ldd	r20, Y+1	; 0x01
    4466:	5a 81       	ldd	r21, Y+2	; 0x02
    4468:	74 de       	rcall	.-792    	; 0x4152 <csp_route_security_check>
    446a:	99 23       	and	r25, r25
    446c:	2c f4       	brge	.+10     	; 0x4478 <csp_route_work+0x2ca>
			csp_buffer_free(packet);
    446e:	8d 81       	ldd	r24, Y+5	; 0x05
    4470:	9e 81       	ldd	r25, Y+6	; 0x06
    4472:	0e 94 8c 16 	call	0x2d18	; 0x2d18 <csp_buffer_free>
			return 0;
    4476:	01 c1       	rjmp	.+514    	; 0x467a <csp_route_work+0x4cc>
		}
		if (csp_queue_enqueue(socket->socket, &packet, 0) != CSP_QUEUE_OK) {
    4478:	20 e0       	ldi	r18, 0x00	; 0
    447a:	30 e0       	ldi	r19, 0x00	; 0
    447c:	a9 01       	movw	r20, r18
    447e:	be 01       	movw	r22, r28
    4480:	6b 5f       	subi	r22, 0xFB	; 251
    4482:	7f 4f       	sbci	r23, 0xFF	; 255
    4484:	f8 01       	movw	r30, r16
    4486:	86 85       	ldd	r24, Z+14	; 0x0e
    4488:	97 85       	ldd	r25, Z+15	; 0x0f
    448a:	0e 94 a0 13 	call	0x2740	; 0x2740 <csp_queue_enqueue>
    448e:	01 97       	sbiw	r24, 0x01	; 1
    4490:	09 f4       	brne	.+2      	; 0x4494 <csp_route_work+0x2e6>
			csp_log_error("Conn-less socket queue full");
    4492:	f3 c0       	rjmp	.+486    	; 0x467a <csp_route_work+0x4cc>
    4494:	80 91 04 02 	lds	r24, 0x0204	; 0x800204 <csp_debug_level_enabled>
    4498:	88 23       	and	r24, r24
    449a:	a9 f0       	breq	.+42     	; 0x44c6 <csp_route_work+0x318>
    449c:	13 da       	rcall	.-3034   	; 0x38c4 <csp_get_address>
    449e:	1f 92       	push	r1
    44a0:	94 ef       	ldi	r25, 0xF4	; 244
    44a2:	9f 93       	push	r25
    44a4:	2c e4       	ldi	r18, 0x4C	; 76
    44a6:	33 e0       	ldi	r19, 0x03	; 3
    44a8:	3f 93       	push	r19
    44aa:	2f 93       	push	r18
    44ac:	1f 92       	push	r1
    44ae:	8f 93       	push	r24
    44b0:	8f e1       	ldi	r24, 0x1F	; 31
    44b2:	9c e0       	ldi	r25, 0x0C	; 12
    44b4:	9f 93       	push	r25
    44b6:	8f 93       	push	r24
    44b8:	1f 92       	push	r1
    44ba:	1c d9       	rcall	.-3528   	; 0x36f4 <do_csp_debug>
    44bc:	0f b6       	in	r0, 0x3f	; 63
    44be:	f8 94       	cli
    44c0:	de bf       	out	0x3e, r29	; 62
    44c2:	0f be       	out	0x3f, r0	; 63
    44c4:	cd bf       	out	0x3d, r28	; 61
			csp_buffer_free(packet);
    44c6:	8d 81       	ldd	r24, Y+5	; 0x05
    44c8:	9e 81       	ldd	r25, Y+6	; 0x06
    44ca:	0e 94 8c 16 	call	0x2d18	; 0x2d18 <csp_buffer_free>
	/* If this is an incoming packet on a new connection */
	if (conn == NULL) {

		/* Reject packet if no matching socket is found */
		if (!socket) {
			csp_buffer_free(packet);
    44ce:	d5 c0       	rjmp	.+426    	; 0x467a <csp_route_work+0x4cc>
    44d0:	8d 81       	ldd	r24, Y+5	; 0x05
    44d2:	9e 81       	ldd	r25, Y+6	; 0x06
    44d4:	0e 94 8c 16 	call	0x2d18	; 0x2d18 <csp_buffer_free>
			return 0;
		}

		/* Run security check on incoming packet */
		if (csp_route_security_check(socket->opts, input.interface, packet) < 0) {
    44d8:	d0 c0       	rjmp	.+416    	; 0x467a <csp_route_work+0x4cc>
    44da:	2d 81       	ldd	r18, Y+5	; 0x05
    44dc:	3e 81       	ldd	r19, Y+6	; 0x06
    44de:	49 81       	ldd	r20, Y+1	; 0x01
    44e0:	5a 81       	ldd	r21, Y+2	; 0x02
    44e2:	d8 01       	movw	r26, r16
    44e4:	54 96       	adiw	r26, 0x14	; 20
    44e6:	6d 91       	ld	r22, X+
    44e8:	7d 91       	ld	r23, X+
    44ea:	8d 91       	ld	r24, X+
    44ec:	9c 91       	ld	r25, X
    44ee:	57 97       	sbiw	r26, 0x17	; 23
    44f0:	30 de       	rcall	.-928    	; 0x4152 <csp_route_security_check>
    44f2:	99 23       	and	r25, r25
			csp_buffer_free(packet);
    44f4:	2c f4       	brge	.+10     	; 0x4500 <csp_route_work+0x352>
    44f6:	8d 81       	ldd	r24, Y+5	; 0x05
    44f8:	9e 81       	ldd	r25, Y+6	; 0x06
    44fa:	0e 94 8c 16 	call	0x2d18	; 0x2d18 <csp_buffer_free>
			return 0;
		}

		/* New incoming connection accepted */
		csp_id_t idout;
		idout.pri   = packet->id.pri;
    44fe:	bd c0       	rjmp	.+378    	; 0x467a <csp_route_work+0x4cc>
    4500:	ed 81       	ldd	r30, Y+5	; 0x05
    4502:	fe 81       	ldd	r31, Y+6	; 0x06
    4504:	85 85       	ldd	r24, Z+13	; 0x0d
    4506:	80 7c       	andi	r24, 0xC0	; 192
		idout.src   = csp_get_address();
    4508:	f8 2e       	mov	r15, r24
    450a:	dc d9       	rcall	.-3144   	; 0x38c4 <csp_get_address>
    450c:	8f 71       	andi	r24, 0x1F	; 31
    450e:	88 0f       	add	r24, r24
    4510:	f8 2a       	or	r15, r24

		idout.dst   = packet->id.src;
    4512:	ed 81       	ldd	r30, Y+5	; 0x05
    4514:	fe 81       	ldd	r31, Y+6	; 0x06
    4516:	85 85       	ldd	r24, Z+13	; 0x0d
    4518:	86 95       	lsr	r24
    451a:	84 fb       	bst	r24, 4
    451c:	99 27       	eor	r25, r25
    451e:	90 f9       	bld	r25, 0
    4520:	f9 2a       	or	r15, r25
		idout.dport = packet->id.sport;
    4522:	53 85       	ldd	r21, Z+11	; 0x0b
    4524:	45 2f       	mov	r20, r21
    4526:	4f 73       	andi	r20, 0x3F	; 63
    4528:	46 95       	lsr	r20
    452a:	46 95       	lsr	r20
    452c:	82 95       	swap	r24
    452e:	80 7f       	andi	r24, 0xF0	; 240
    4530:	48 2b       	or	r20, r24
		idout.sport = packet->id.dport;
    4532:	25 2f       	mov	r18, r21
    4534:	22 95       	swap	r18
    4536:	26 95       	lsr	r18
    4538:	26 95       	lsr	r18
    453a:	23 70       	andi	r18, 0x03	; 3
    453c:	34 85       	ldd	r19, Z+12	; 0x0c
    453e:	3f 70       	andi	r19, 0x0F	; 15
    4540:	33 0f       	add	r19, r19
    4542:	33 0f       	add	r19, r19
    4544:	93 2f       	mov	r25, r19
    4546:	92 2b       	or	r25, r18
    4548:	35 2f       	mov	r19, r21
    454a:	32 95       	swap	r19
    454c:	33 0f       	add	r19, r19
    454e:	33 0f       	add	r19, r19
    4550:	30 7c       	andi	r19, 0xC0	; 192
		idout.flags = packet->id.flags;
    4552:	39 2b       	or	r19, r25

		/* Create connection */
		conn = csp_conn_new(packet->id, idout);
    4554:	22 85       	ldd	r18, Z+10	; 0x0a
    4556:	62 85       	ldd	r22, Z+10	; 0x0a
    4558:	73 85       	ldd	r23, Z+11	; 0x0b
    455a:	84 85       	ldd	r24, Z+12	; 0x0c
    455c:	95 85       	ldd	r25, Z+13	; 0x0d
    455e:	5f 2d       	mov	r21, r15
    4560:	0e 94 88 19 	call	0x3310	; 0x3310 <csp_conn_new>

		if (!conn) {
    4564:	7c 01       	movw	r14, r24
    4566:	89 2b       	or	r24, r25
			csp_log_error("No more connections available");
    4568:	f9 f4       	brne	.+62     	; 0x45a8 <csp_route_work+0x3fa>
    456a:	80 91 04 02 	lds	r24, 0x0204	; 0x800204 <csp_debug_level_enabled>
    456e:	88 23       	and	r24, r24
    4570:	b1 f0       	breq	.+44     	; 0x459e <csp_route_work+0x3f0>
    4572:	a8 d9       	rcall	.-3248   	; 0x38c4 <csp_get_address>
    4574:	91 e0       	ldi	r25, 0x01	; 1
    4576:	9f 93       	push	r25
    4578:	9b e1       	ldi	r25, 0x1B	; 27
    457a:	9f 93       	push	r25
    457c:	2c e4       	ldi	r18, 0x4C	; 76
    457e:	33 e0       	ldi	r19, 0x03	; 3
    4580:	3f 93       	push	r19
    4582:	2f 93       	push	r18
    4584:	1f 92       	push	r1
    4586:	8f 93       	push	r24
    4588:	84 ef       	ldi	r24, 0xF4	; 244
    458a:	9b e0       	ldi	r25, 0x0B	; 11
    458c:	9f 93       	push	r25
    458e:	8f 93       	push	r24
    4590:	1f 92       	push	r1
    4592:	b0 d8       	rcall	.-3744   	; 0x36f4 <do_csp_debug>
    4594:	0f b6       	in	r0, 0x3f	; 63
    4596:	f8 94       	cli
    4598:	de bf       	out	0x3e, r29	; 62
    459a:	0f be       	out	0x3f, r0	; 63
    459c:	cd bf       	out	0x3d, r28	; 61
			csp_buffer_free(packet);
    459e:	8d 81       	ldd	r24, Y+5	; 0x05
    45a0:	9e 81       	ldd	r25, Y+6	; 0x06
    45a2:	0e 94 8c 16 	call	0x2d18	; 0x2d18 <csp_buffer_free>
			return 0;
    45a6:	69 c0       	rjmp	.+210    	; 0x467a <csp_route_work+0x4cc>
		}

		/* Store the socket queue and options */
		conn->socket = socket->socket;
    45a8:	d8 01       	movw	r26, r16
    45aa:	1e 96       	adiw	r26, 0x0e	; 14
    45ac:	8d 91       	ld	r24, X+
    45ae:	9c 91       	ld	r25, X
    45b0:	1f 97       	sbiw	r26, 0x0f	; 15
    45b2:	f7 01       	movw	r30, r14
    45b4:	97 87       	std	Z+15, r25	; 0x0f
    45b6:	86 87       	std	Z+14, r24	; 0x0e
		conn->opts = socket->opts;
    45b8:	54 96       	adiw	r26, 0x14	; 20
    45ba:	8d 91       	ld	r24, X+
    45bc:	9d 91       	ld	r25, X+
    45be:	0d 90       	ld	r0, X+
    45c0:	bc 91       	ld	r27, X
    45c2:	a0 2d       	mov	r26, r0
    45c4:	84 8b       	std	Z+20, r24	; 0x14
    45c6:	95 8b       	std	Z+21, r25	; 0x15
    45c8:	a6 8b       	std	Z+22, r26	; 0x16
    45ca:	b7 8b       	std	Z+23, r27	; 0x17

	/* Packet to existing connection */
	} else {

		/* Run security check on incoming packet */
		if (csp_route_security_check(conn->opts, input.interface, packet) < 0) {
    45cc:	13 c0       	rjmp	.+38     	; 0x45f4 <csp_route_work+0x446>
    45ce:	2d 81       	ldd	r18, Y+5	; 0x05
    45d0:	3e 81       	ldd	r19, Y+6	; 0x06
    45d2:	49 81       	ldd	r20, Y+1	; 0x01
    45d4:	5a 81       	ldd	r21, Y+2	; 0x02
    45d6:	d7 01       	movw	r26, r14
    45d8:	54 96       	adiw	r26, 0x14	; 20
    45da:	6d 91       	ld	r22, X+
    45dc:	7d 91       	ld	r23, X+
    45de:	8d 91       	ld	r24, X+
    45e0:	9c 91       	ld	r25, X
    45e2:	57 97       	sbiw	r26, 0x17	; 23
    45e4:	b6 dd       	rcall	.-1172   	; 0x4152 <csp_route_security_check>
    45e6:	99 23       	and	r25, r25
			csp_buffer_free(packet);
    45e8:	2c f4       	brge	.+10     	; 0x45f4 <csp_route_work+0x446>
    45ea:	8d 81       	ldd	r24, Y+5	; 0x05
    45ec:	9e 81       	ldd	r25, Y+6	; 0x06
    45ee:	0e 94 8c 16 	call	0x2d18	; 0x2d18 <csp_buffer_free>
		return 0;
	}
#endif

	/* Pass packet to UDP module */
	csp_udp_new_packet(conn, packet);
    45f2:	43 c0       	rjmp	.+134    	; 0x467a <csp_route_work+0x4cc>
    45f4:	6d 81       	ldd	r22, Y+5	; 0x05
    45f6:	7e 81       	ldd	r23, Y+6	; 0x06
    45f8:	c7 01       	movw	r24, r14
    45fa:	63 d2       	rcall	.+1222   	; 0x4ac2 <csp_udp_new_packet>
	return 0;
    45fc:	3e c0       	rjmp	.+124    	; 0x467a <csp_route_work+0x4cc>
	csp_conn_check_timeouts();
#endif

	/* Get next packet to route */
	if (csp_qfifo_read(&input) != CSP_ERR_NONE)
		return -1;
    45fe:	cc 24       	eor	r12, r12
    4600:	ca 94       	dec	r12
    4602:	dc 2c       	mov	r13, r12
			csp_log_warn("Router failed to send");
			csp_buffer_free(packet);
		}

		/* Next message, please */
		return 0;
    4604:	3a c0       	rjmp	.+116    	; 0x467a <csp_route_work+0x4cc>
    4606:	6c 01       	movw	r12, r24
	}

	/* Discard packets with unsupported options */
	if (csp_route_check_options(input.interface, packet) != CSP_ERR_NONE) {
		csp_buffer_free(packet);
    4608:	38 c0       	rjmp	.+112    	; 0x467a <csp_route_work+0x4cc>
    460a:	8d 81       	ldd	r24, Y+5	; 0x05
    460c:	9e 81       	ldd	r25, Y+6	; 0x06
    460e:	0e 94 8c 16 	call	0x2d18	; 0x2d18 <csp_buffer_free>
		return 0;
	}

	/* The message is to me, search for incoming socket */
	socket = csp_port_get_socket(packet->id.dport);
    4612:	33 c0       	rjmp	.+102    	; 0x467a <csp_route_work+0x4cc>
    4614:	83 85       	ldd	r24, Z+11	; 0x0b
    4616:	98 2f       	mov	r25, r24
    4618:	92 95       	swap	r25
    461a:	96 95       	lsr	r25
    461c:	96 95       	lsr	r25
    461e:	93 70       	andi	r25, 0x03	; 3
    4620:	84 85       	ldd	r24, Z+12	; 0x0c
    4622:	8f 70       	andi	r24, 0x0F	; 15
    4624:	88 0f       	add	r24, r24
    4626:	88 0f       	add	r24, r24
    4628:	89 2b       	or	r24, r25
    462a:	90 e0       	ldi	r25, 0x00	; 0
    462c:	6b dc       	rcall	.-1834   	; 0x3f04 <csp_port_get_socket>
    462e:	8c 01       	movw	r16, r24

	/* If the socket is connection-less, deliver now */
	if (socket && (socket->opts & CSP_SO_CONN_LESS)) {
    4630:	89 2b       	or	r24, r25
    4632:	09 f0       	breq	.+2      	; 0x4636 <csp_route_work+0x488>
    4634:	0c cf       	rjmp	.-488    	; 0x444e <csp_route_work+0x2a0>
		}
		return 0;
	}

	/* Search for an existing connection */
	conn = csp_conn_find(packet->id.ext, CSP_ID_CONN_MASK);
    4636:	ed 81       	ldd	r30, Y+5	; 0x05
    4638:	fe 81       	ldd	r31, Y+6	; 0x06
    463a:	62 85       	ldd	r22, Z+10	; 0x0a
    463c:	73 85       	ldd	r23, Z+11	; 0x0b
    463e:	84 85       	ldd	r24, Z+12	; 0x0c
    4640:	95 85       	ldd	r25, Z+13	; 0x0d
    4642:	20 e0       	ldi	r18, 0x00	; 0
    4644:	3f ef       	ldi	r19, 0xFF	; 255
    4646:	4f ef       	ldi	r20, 0xFF	; 255
    4648:	5f e3       	ldi	r21, 0x3F	; 63
    464a:	0e 94 7f 18 	call	0x30fe	; 0x30fe <csp_conn_find>
    464e:	7c 01       	movw	r14, r24

	/* If this is an incoming packet on a new connection */
	if (conn == NULL) {
    4650:	89 2b       	or	r24, r25
    4652:	09 f0       	breq	.+2      	; 0x4656 <csp_route_work+0x4a8>
    4654:	bc cf       	rjmp	.-136    	; 0x45ce <csp_route_work+0x420>
    4656:	3c cf       	rjmp	.-392    	; 0x44d0 <csp_route_work+0x322>
		}
		return 0;
	}

	/* Search for an existing connection */
	conn = csp_conn_find(packet->id.ext, CSP_ID_CONN_MASK);
    4658:	ed 81       	ldd	r30, Y+5	; 0x05
    465a:	fe 81       	ldd	r31, Y+6	; 0x06
    465c:	62 85       	ldd	r22, Z+10	; 0x0a
    465e:	73 85       	ldd	r23, Z+11	; 0x0b
    4660:	84 85       	ldd	r24, Z+12	; 0x0c
    4662:	95 85       	ldd	r25, Z+13	; 0x0d
    4664:	20 e0       	ldi	r18, 0x00	; 0
    4666:	3f ef       	ldi	r19, 0xFF	; 255
    4668:	4f ef       	ldi	r20, 0xFF	; 255
    466a:	5f e3       	ldi	r21, 0x3F	; 63
    466c:	0e 94 7f 18 	call	0x30fe	; 0x30fe <csp_conn_find>
    4670:	7c 01       	movw	r14, r24

	/* If this is an incoming packet on a new connection */
	if (conn == NULL) {
    4672:	89 2b       	or	r24, r25
    4674:	09 f0       	breq	.+2      	; 0x4678 <csp_route_work+0x4ca>
    4676:	ab cf       	rjmp	.-170    	; 0x45ce <csp_route_work+0x420>
    4678:	30 cf       	rjmp	.-416    	; 0x44da <csp_route_work+0x32c>
#endif

	/* Pass packet to UDP module */
	csp_udp_new_packet(conn, packet);
	return 0;
}
    467a:	c6 01       	movw	r24, r12
    467c:	26 96       	adiw	r28, 0x06	; 6
    467e:	0f b6       	in	r0, 0x3f	; 63
    4680:	f8 94       	cli
    4682:	de bf       	out	0x3e, r29	; 62
    4684:	0f be       	out	0x3f, r0	; 63
    4686:	cd bf       	out	0x3d, r28	; 61
    4688:	df 91       	pop	r29
    468a:	cf 91       	pop	r28
    468c:	1f 91       	pop	r17
    468e:	0f 91       	pop	r16
    4690:	ff 90       	pop	r15
    4692:	ef 90       	pop	r14
    4694:	df 90       	pop	r13
    4696:	cf 90       	pop	r12
    4698:	bf 90       	pop	r11
    469a:	af 90       	pop	r10
    469c:	9f 90       	pop	r9
    469e:	8f 90       	pop	r8
    46a0:	7f 90       	pop	r7
    46a2:	6f 90       	pop	r6
    46a4:	08 95       	ret

000046a6 <csp_task_router>:

CSP_DEFINE_TASK(csp_task_router) {

	/* Here there be routing */
	while (1) {
		csp_route_work(FIFO_TIMEOUT);
    46a6:	6f ef       	ldi	r22, 0xFF	; 255
    46a8:	7f ef       	ldi	r23, 0xFF	; 255
    46aa:	cb 01       	movw	r24, r22
    46ac:	80 dd       	rcall	.-1280   	; 0x41ae <csp_route_work>
    46ae:	fb cf       	rjmp	.-10     	; 0x46a6 <csp_task_router>

000046b0 <csp_route_start_task>:
	}

}

int csp_route_start_task(unsigned int task_stack_size, unsigned int priority) {
    46b0:	ef 92       	push	r14
    46b2:	ff 92       	push	r15
    46b4:	0f 93       	push	r16
    46b6:	1f 93       	push	r17

	static csp_thread_handle_t handle_router;
	int ret = csp_thread_create(csp_task_router, "RTE", task_stack_size, NULL, priority, &handle_router);
    46b8:	0f 2e       	mov	r0, r31
    46ba:	f1 e5       	ldi	r31, 0x51	; 81
    46bc:	ef 2e       	mov	r14, r31
    46be:	ff e1       	ldi	r31, 0x1F	; 31
    46c0:	ff 2e       	mov	r15, r31
    46c2:	f0 2d       	mov	r31, r0
    46c4:	8b 01       	movw	r16, r22
    46c6:	20 e0       	ldi	r18, 0x00	; 0
    46c8:	30 e0       	ldi	r19, 0x00	; 0
    46ca:	ac 01       	movw	r20, r24
    46cc:	68 e5       	ldi	r22, 0x58	; 88
    46ce:	73 e0       	ldi	r23, 0x03	; 3
    46d0:	83 e5       	ldi	r24, 0x53	; 83
    46d2:	93 e2       	ldi	r25, 0x23	; 35
    46d4:	0e 94 b9 14 	call	0x2972	; 0x2972 <csp_thread_create>

	if (ret != 0) {
    46d8:	89 2b       	or	r24, r25
    46da:	09 f1       	breq	.+66     	; 0x471e <csp_route_start_task+0x6e>
		csp_log_error("Failed to start router task");
    46dc:	80 91 04 02 	lds	r24, 0x0204	; 0x800204 <csp_debug_level_enabled>
    46e0:	88 23       	and	r24, r24
    46e2:	01 f1       	breq	.+64     	; 0x4724 <csp_route_start_task+0x74>
    46e4:	ef d8       	rcall	.-3618   	; 0x38c4 <csp_get_address>
    46e6:	91 e0       	ldi	r25, 0x01	; 1
    46e8:	9f 93       	push	r25
    46ea:	9b e4       	ldi	r25, 0x4B	; 75
    46ec:	9f 93       	push	r25
    46ee:	2c e4       	ldi	r18, 0x4C	; 76
    46f0:	33 e0       	ldi	r19, 0x03	; 3
    46f2:	3f 93       	push	r19
    46f4:	2f 93       	push	r18
    46f6:	1f 92       	push	r1
    46f8:	8f 93       	push	r24
    46fa:	88 e3       	ldi	r24, 0x38	; 56
    46fc:	9a e0       	ldi	r25, 0x0A	; 10
    46fe:	9f 93       	push	r25
    4700:	8f 93       	push	r24
    4702:	1f 92       	push	r1
    4704:	0e 94 7a 1b 	call	0x36f4	; 0x36f4 <do_csp_debug>
    4708:	8d b7       	in	r24, 0x3d	; 61
    470a:	9e b7       	in	r25, 0x3e	; 62
    470c:	09 96       	adiw	r24, 0x09	; 9
    470e:	0f b6       	in	r0, 0x3f	; 63
    4710:	f8 94       	cli
    4712:	9e bf       	out	0x3e, r25	; 62
    4714:	0f be       	out	0x3f, r0	; 63
    4716:	8d bf       	out	0x3d, r24	; 61
		return CSP_ERR_NOMEM;
    4718:	8f ef       	ldi	r24, 0xFF	; 255
    471a:	9f ef       	ldi	r25, 0xFF	; 255
    471c:	05 c0       	rjmp	.+10     	; 0x4728 <csp_route_start_task+0x78>
	}

	return CSP_ERR_NONE;
    471e:	80 e0       	ldi	r24, 0x00	; 0
    4720:	90 e0       	ldi	r25, 0x00	; 0
    4722:	02 c0       	rjmp	.+4      	; 0x4728 <csp_route_start_task+0x78>
	static csp_thread_handle_t handle_router;
	int ret = csp_thread_create(csp_task_router, "RTE", task_stack_size, NULL, priority, &handle_router);

	if (ret != 0) {
		csp_log_error("Failed to start router task");
		return CSP_ERR_NOMEM;
    4724:	8f ef       	ldi	r24, 0xFF	; 255
    4726:	9f ef       	ldi	r25, 0xFF	; 255
	}

	return CSP_ERR_NONE;

}
    4728:	1f 91       	pop	r17
    472a:	0f 91       	pop	r16
    472c:	ff 90       	pop	r15
    472e:	ef 90       	pop	r14
    4730:	08 95       	ret

00004732 <csp_i2c_tx>:
#include <csp/interfaces/csp_if_i2c.h>
#include <csp/drivers/i2c.h>

static int csp_i2c_handle = 0;

int csp_i2c_tx(csp_iface_t * interface, csp_packet_t * packet, uint32_t timeout) {
    4732:	cf 92       	push	r12
    4734:	df 92       	push	r13
    4736:	ef 92       	push	r14
    4738:	ff 92       	push	r15
    473a:	cf 93       	push	r28
    473c:	df 93       	push	r29
    473e:	eb 01       	movw	r28, r22
    4740:	69 01       	movw	r12, r18
    4742:	7a 01       	movw	r14, r20

	/* Cast the CSP packet buffer into an i2c frame */
	i2c_frame_t * frame = (i2c_frame_t *) packet;

	/* Insert destination node into the i2c destination field */
	if (csp_rtable_find_mac(packet->id.dst) == CSP_NODE_MAC) {
    4744:	9c 85       	ldd	r25, Y+12	; 0x0c
    4746:	92 95       	swap	r25
    4748:	9f 70       	andi	r25, 0x0F	; 15
    474a:	8d 85       	ldd	r24, Y+13	; 0x0d
    474c:	81 70       	andi	r24, 0x01	; 1
    474e:	82 95       	swap	r24
    4750:	80 7f       	andi	r24, 0xF0	; 240
    4752:	89 2b       	or	r24, r25
    4754:	ef d0       	rcall	.+478    	; 0x4934 <csp_rtable_find_mac>
    4756:	8f 3f       	cpi	r24, 0xFF	; 255
    4758:	59 f4       	brne	.+22     	; 0x4770 <csp_i2c_tx+0x3e>
		frame->dest = packet->id.dst;
    475a:	8c 85       	ldd	r24, Y+12	; 0x0c
    475c:	98 2f       	mov	r25, r24
    475e:	92 95       	swap	r25
    4760:	9f 70       	andi	r25, 0x0F	; 15
    4762:	8d 85       	ldd	r24, Y+13	; 0x0d
    4764:	81 70       	andi	r24, 0x01	; 1
    4766:	82 95       	swap	r24
    4768:	80 7f       	andi	r24, 0xF0	; 240
    476a:	89 2b       	or	r24, r25
    476c:	8e 83       	std	Y+6, r24	; 0x06
    476e:	0a c0       	rjmp	.+20     	; 0x4784 <csp_i2c_tx+0x52>
	} else {
		frame->dest = csp_rtable_find_mac(packet->id.dst);
    4770:	9c 85       	ldd	r25, Y+12	; 0x0c
    4772:	92 95       	swap	r25
    4774:	9f 70       	andi	r25, 0x0F	; 15
    4776:	8d 85       	ldd	r24, Y+13	; 0x0d
    4778:	81 70       	andi	r24, 0x01	; 1
    477a:	82 95       	swap	r24
    477c:	80 7f       	andi	r24, 0xF0	; 240
    477e:	89 2b       	or	r24, r25
    4780:	d9 d0       	rcall	.+434    	; 0x4934 <csp_rtable_find_mac>
    4782:	8e 83       	std	Y+6, r24	; 0x06
	}

	/* Save the outgoing id in the buffer */
	packet->id.ext = csp_hton32(packet->id.ext);
    4784:	6a 85       	ldd	r22, Y+10	; 0x0a
    4786:	7b 85       	ldd	r23, Y+11	; 0x0b
    4788:	8c 85       	ldd	r24, Y+12	; 0x0c
    478a:	9d 85       	ldd	r25, Y+13	; 0x0d
    478c:	08 d8       	rcall	.-4080   	; 0x379e <csp_hton32>
    478e:	6a 87       	std	Y+10, r22	; 0x0a
    4790:	7b 87       	std	Y+11, r23	; 0x0b
    4792:	8c 87       	std	Y+12, r24	; 0x0c
    4794:	9d 87       	std	Y+13, r25	; 0x0d

	/* Add the CSP header to the I2C length field */
	frame->len += sizeof(packet->id);
    4796:	88 85       	ldd	r24, Y+8	; 0x08
    4798:	99 85       	ldd	r25, Y+9	; 0x09
    479a:	04 96       	adiw	r24, 0x04	; 4
    479c:	99 87       	std	Y+9, r25	; 0x09
    479e:	88 87       	std	Y+8, r24	; 0x08
	frame->len_rx = 0;
    47a0:	1f 82       	std	Y+7, r1	; 0x07

	/* Some I2C drivers support X number of retries
	 * CSP don't care about this. If it doesn't work the first
	 * time, don'y use time on it.
	 */
	frame->retries = 0;
    47a2:	19 82       	std	Y+1, r1	; 0x01

	/* enqueue the frame */
	if (i2c_send(csp_i2c_handle, frame, timeout) != E_NO_ERR)
    47a4:	a6 01       	movw	r20, r12
    47a6:	be 01       	movw	r22, r28
    47a8:	80 91 55 1f 	lds	r24, 0x1F55	; 0x801f55 <csp_i2c_handle>
    47ac:	90 91 56 1f 	lds	r25, 0x1F56	; 0x801f56 <csp_i2c_handle+0x1>
    47b0:	02 d3       	rcall	.+1540   	; 0x4db6 <i2c_send>
    47b2:	01 96       	adiw	r24, 0x01	; 1
    47b4:	19 f4       	brne	.+6      	; 0x47bc <csp_i2c_tx+0x8a>
		return CSP_ERR_DRIVER;

	return CSP_ERR_NONE;
    47b6:	80 e0       	ldi	r24, 0x00	; 0
    47b8:	90 e0       	ldi	r25, 0x00	; 0
    47ba:	02 c0       	rjmp	.+4      	; 0x47c0 <csp_i2c_tx+0x8e>
	 */
	frame->retries = 0;

	/* enqueue the frame */
	if (i2c_send(csp_i2c_handle, frame, timeout) != E_NO_ERR)
		return CSP_ERR_DRIVER;
    47bc:	85 ef       	ldi	r24, 0xF5	; 245
    47be:	9f ef       	ldi	r25, 0xFF	; 255

	return CSP_ERR_NONE;

}
    47c0:	df 91       	pop	r29
    47c2:	cf 91       	pop	r28
    47c4:	ff 90       	pop	r15
    47c6:	ef 90       	pop	r14
    47c8:	df 90       	pop	r13
    47ca:	cf 90       	pop	r12
    47cc:	08 95       	ret

000047ce <csp_i2c_rx>:
 * When a frame is received, cast it to a csp_packet
 * and send it directly to the CSP new packet function.
 * Context: ISR only
 * @param frame
 */
void csp_i2c_rx(i2c_frame_t * frame, void * pxTaskWoken) {
    47ce:	0f 93       	push	r16
    47d0:	1f 93       	push	r17
    47d2:	cf 93       	push	r28
    47d4:	df 93       	push	r29
	
	static csp_packet_t * packet;

	/* Validate input */
	if (frame == NULL)
    47d6:	00 97       	sbiw	r24, 0x00	; 0
    47d8:	89 f1       	breq	.+98     	; 0x483c <csp_i2c_rx+0x6e>
    47da:	8b 01       	movw	r16, r22
    47dc:	ec 01       	movw	r28, r24
		return;

	if ((frame->len < 4) || (frame->len > I2C_MTU)) {
    47de:	88 85       	ldd	r24, Y+8	; 0x08
    47e0:	99 85       	ldd	r25, Y+9	; 0x09
    47e2:	04 97       	sbiw	r24, 0x04	; 4
    47e4:	8d 3f       	cpi	r24, 0xFD	; 253
    47e6:	91 05       	cpc	r25, r1
    47e8:	88 f0       	brcs	.+34     	; 0x480c <csp_i2c_rx+0x3e>
		csp_if_i2c.frame++;
    47ea:	eb e0       	ldi	r30, 0x0B	; 11
    47ec:	f2 e0       	ldi	r31, 0x02	; 2
    47ee:	81 a1       	ldd	r24, Z+33	; 0x21
    47f0:	92 a1       	ldd	r25, Z+34	; 0x22
    47f2:	a3 a1       	ldd	r26, Z+35	; 0x23
    47f4:	b4 a1       	ldd	r27, Z+36	; 0x24
    47f6:	01 96       	adiw	r24, 0x01	; 1
    47f8:	a1 1d       	adc	r26, r1
    47fa:	b1 1d       	adc	r27, r1
    47fc:	81 a3       	std	Z+33, r24	; 0x21
    47fe:	92 a3       	std	Z+34, r25	; 0x22
    4800:	a3 a3       	std	Z+35, r26	; 0x23
    4802:	b4 a3       	std	Z+36, r27	; 0x24
		csp_buffer_free_isr(frame);
    4804:	ce 01       	movw	r24, r28
    4806:	0e 94 54 16 	call	0x2ca8	; 0x2ca8 <csp_buffer_free_isr>
		return;
    480a:	18 c0       	rjmp	.+48     	; 0x483c <csp_i2c_rx+0x6e>
	}

	/* Strip the CSP header off the length field before converting to CSP packet */
	frame->len -= sizeof(csp_id_t);
    480c:	99 87       	std	Y+9, r25	; 0x09
    480e:	88 87       	std	Y+8, r24	; 0x08

	/* Convert the packet from network to host order */
	packet = (csp_packet_t *) frame;
    4810:	d0 93 54 1f 	sts	0x1F54, r29	; 0x801f54 <packet.2416+0x1>
    4814:	c0 93 53 1f 	sts	0x1F53, r28	; 0x801f53 <packet.2416>
	packet->id.ext = csp_ntoh32(packet->id.ext);
    4818:	6a 85       	ldd	r22, Y+10	; 0x0a
    481a:	7b 85       	ldd	r23, Y+11	; 0x0b
    481c:	8c 85       	ldd	r24, Y+12	; 0x0c
    481e:	9d 85       	ldd	r25, Y+13	; 0x0d
    4820:	0e 94 04 1c 	call	0x3808	; 0x3808 <csp_ntoh32>
    4824:	6a 87       	std	Y+10, r22	; 0x0a
    4826:	7b 87       	std	Y+11, r23	; 0x0b
    4828:	8c 87       	std	Y+12, r24	; 0x0c
    482a:	9d 87       	std	Y+13, r25	; 0x0d

	/* Receive the packet in CSP */
	csp_new_packet(packet, &csp_if_i2c, pxTaskWoken);
    482c:	a8 01       	movw	r20, r16
    482e:	6b e0       	ldi	r22, 0x0B	; 11
    4830:	72 e0       	ldi	r23, 0x02	; 2
    4832:	80 91 53 1f 	lds	r24, 0x1F53	; 0x801f53 <packet.2416>
    4836:	90 91 54 1f 	lds	r25, 0x1F54	; 0x801f54 <packet.2416+0x1>
    483a:	bf db       	rcall	.-2178   	; 0x3fba <csp_qfifo_write>

}
    483c:	df 91       	pop	r29
    483e:	cf 91       	pop	r28
    4840:	1f 91       	pop	r17
    4842:	0f 91       	pop	r16
    4844:	08 95       	ret

00004846 <csp_i2c_init>:

int csp_i2c_init(uint8_t addr, int handle, int speed) {
    4846:	cf 92       	push	r12
    4848:	df 92       	push	r13
    484a:	ef 92       	push	r14
    484c:	ff 92       	push	r15
    484e:	0f 93       	push	r16
    4850:	1f 93       	push	r17
    4852:	e8 2f       	mov	r30, r24
    4854:	cb 01       	movw	r24, r22
    4856:	9a 01       	movw	r18, r20

	/* Create i2c_handle */
	csp_i2c_handle = handle;
    4858:	70 93 56 1f 	sts	0x1F56, r23	; 0x801f56 <csp_i2c_handle+0x1>
    485c:	60 93 55 1f 	sts	0x1F55, r22	; 0x801f55 <csp_i2c_handle>
	if (i2c_init(csp_i2c_handle, I2C_MASTER, addr, speed, 10, 10, csp_i2c_rx) != E_NO_ERR)
    4860:	0f 2e       	mov	r0, r31
    4862:	f7 ee       	ldi	r31, 0xE7	; 231
    4864:	cf 2e       	mov	r12, r31
    4866:	f3 e2       	ldi	r31, 0x23	; 35
    4868:	df 2e       	mov	r13, r31
    486a:	f0 2d       	mov	r31, r0
    486c:	0f 2e       	mov	r0, r31
    486e:	fa e0       	ldi	r31, 0x0A	; 10
    4870:	ef 2e       	mov	r14, r31
    4872:	f1 2c       	mov	r15, r1
    4874:	f0 2d       	mov	r31, r0
    4876:	0a e0       	ldi	r16, 0x0A	; 10
    4878:	10 e0       	ldi	r17, 0x00	; 0
    487a:	4e 2f       	mov	r20, r30
    487c:	60 e0       	ldi	r22, 0x00	; 0
    487e:	70 e0       	ldi	r23, 0x00	; 0
    4880:	15 d2       	rcall	.+1066   	; 0x4cac <i2c_init>
    4882:	01 96       	adiw	r24, 0x01	; 1
    4884:	39 f4       	brne	.+14     	; 0x4894 <csp_i2c_init+0x4e>
		return CSP_ERR_DRIVER;

	/* Register interface */
	csp_iflist_add(&csp_if_i2c);
    4886:	8b e0       	ldi	r24, 0x0B	; 11
    4888:	92 e0       	ldi	r25, 0x02	; 2
    488a:	0e 94 39 1c 	call	0x3872	; 0x3872 <csp_iflist_add>

	return CSP_ERR_NONE;
    488e:	80 e0       	ldi	r24, 0x00	; 0
    4890:	90 e0       	ldi	r25, 0x00	; 0
    4892:	02 c0       	rjmp	.+4      	; 0x4898 <csp_i2c_init+0x52>
int csp_i2c_init(uint8_t addr, int handle, int speed) {

	/* Create i2c_handle */
	csp_i2c_handle = handle;
	if (i2c_init(csp_i2c_handle, I2C_MASTER, addr, speed, 10, 10, csp_i2c_rx) != E_NO_ERR)
		return CSP_ERR_DRIVER;
    4894:	85 ef       	ldi	r24, 0xF5	; 245
    4896:	9f ef       	ldi	r25, 0xFF	; 255
	/* Register interface */
	csp_iflist_add(&csp_if_i2c);

	return CSP_ERR_NONE;

}
    4898:	1f 91       	pop	r17
    489a:	0f 91       	pop	r16
    489c:	ff 90       	pop	r15
    489e:	ef 90       	pop	r14
    48a0:	df 90       	pop	r13
    48a2:	cf 90       	pop	r12
    48a4:	08 95       	ret

000048a6 <csp_lo_tx>:
 * Loopback interface transmit function
 * @param packet Packet to transmit
 * @param timeout Timout in ms
 * @return 1 if packet was successfully transmitted, 0 on error
 */
int csp_lo_tx(csp_iface_t * interface, csp_packet_t * packet, uint32_t timeout) {
    48a6:	0f 93       	push	r16
    48a8:	1f 93       	push	r17
    48aa:	cf 93       	push	r28
    48ac:	df 93       	push	r29
    48ae:	8b 01       	movw	r16, r22

	/* Drop packet silently if not destined for us. This allows
	 * blackhole routing addresses by setting their nexthop to
	 * the loopback interface.
	 */
	if (packet->id.dst != csp_get_address()) {
    48b0:	fb 01       	movw	r30, r22
    48b2:	c4 85       	ldd	r28, Z+12	; 0x0c
    48b4:	8c 2f       	mov	r24, r28
    48b6:	82 95       	swap	r24
    48b8:	8f 70       	andi	r24, 0x0F	; 15
    48ba:	c5 85       	ldd	r28, Z+13	; 0x0d
    48bc:	c1 70       	andi	r28, 0x01	; 1
    48be:	c2 95       	swap	r28
    48c0:	c0 7f       	andi	r28, 0xF0	; 240
    48c2:	c8 2b       	or	r28, r24
    48c4:	d0 e0       	ldi	r29, 0x00	; 0
    48c6:	0e 94 62 1c 	call	0x38c4	; 0x38c4 <csp_get_address>
    48ca:	90 e0       	ldi	r25, 0x00	; 0
    48cc:	c8 17       	cp	r28, r24
    48ce:	d9 07       	cpc	r29, r25
    48d0:	21 f0       	breq	.+8      	; 0x48da <csp_lo_tx+0x34>
		/* Consume and drop packet */
		csp_buffer_free(packet);
    48d2:	c8 01       	movw	r24, r16
    48d4:	0e 94 8c 16 	call	0x2d18	; 0x2d18 <csp_buffer_free>
		return CSP_ERR_NONE;
    48d8:	06 c0       	rjmp	.+12     	; 0x48e6 <csp_lo_tx+0x40>
	}

	/* Send back into CSP, notice calling from task so last argument must be NULL! */
	csp_qfifo_write(packet, &csp_if_lo, NULL);
    48da:	40 e0       	ldi	r20, 0x00	; 0
    48dc:	50 e0       	ldi	r21, 0x00	; 0
    48de:	6e e3       	ldi	r22, 0x3E	; 62
    48e0:	72 e0       	ldi	r23, 0x02	; 2
    48e2:	c8 01       	movw	r24, r16
    48e4:	6a db       	rcall	.-2348   	; 0x3fba <csp_qfifo_write>

	return CSP_ERR_NONE;

}
    48e6:	80 e0       	ldi	r24, 0x00	; 0
    48e8:	90 e0       	ldi	r25, 0x00	; 0
    48ea:	df 91       	pop	r29
    48ec:	cf 91       	pop	r28
    48ee:	1f 91       	pop	r17
    48f0:	0f 91       	pop	r16
    48f2:	08 95       	ret

000048f4 <csp_rtable_find_iface>:
void csp_route_table_load(uint8_t route_table_in[CSP_ROUTE_TABLE_SIZE]) {
	memcpy(routes, route_table_in, sizeof(routes[0]) * CSP_ROUTE_COUNT);
}

void csp_route_table_save(uint8_t route_table_out[CSP_ROUTE_TABLE_SIZE]) {
	memcpy(route_table_out, routes, sizeof(routes[0]) * CSP_ROUTE_COUNT);
    48f4:	90 e0       	ldi	r25, 0x00	; 0
    48f6:	fc 01       	movw	r30, r24
    48f8:	ee 0f       	add	r30, r30
    48fa:	ff 1f       	adc	r31, r31
    48fc:	e8 0f       	add	r30, r24
    48fe:	f9 1f       	adc	r31, r25
    4900:	e9 5a       	subi	r30, 0xA9	; 169
    4902:	f0 4e       	sbci	r31, 0xE0	; 224
    4904:	20 81       	ld	r18, Z
    4906:	31 81       	ldd	r19, Z+1	; 0x01
    4908:	23 2b       	or	r18, r19
    490a:	49 f0       	breq	.+18     	; 0x491e <csp_rtable_find_iface+0x2a>
    490c:	fc 01       	movw	r30, r24
    490e:	ee 0f       	add	r30, r30
    4910:	ff 1f       	adc	r31, r31
    4912:	8e 0f       	add	r24, r30
    4914:	9f 1f       	adc	r25, r31
    4916:	fc 01       	movw	r30, r24
    4918:	e9 5a       	subi	r30, 0xA9	; 169
    491a:	f0 4e       	sbci	r31, 0xE0	; 224
    491c:	08 c0       	rjmp	.+16     	; 0x492e <csp_rtable_find_iface+0x3a>
    491e:	80 91 b7 1f 	lds	r24, 0x1FB7	; 0x801fb7 <routes+0x60>
    4922:	90 91 b8 1f 	lds	r25, 0x1FB8	; 0x801fb8 <routes+0x61>
    4926:	00 97       	sbiw	r24, 0x00	; 0
    4928:	21 f0       	breq	.+8      	; 0x4932 <csp_rtable_find_iface+0x3e>
    492a:	e7 eb       	ldi	r30, 0xB7	; 183
    492c:	ff e1       	ldi	r31, 0x1F	; 31
    492e:	80 81       	ld	r24, Z
    4930:	91 81       	ldd	r25, Z+1	; 0x01
    4932:	08 95       	ret

00004934 <csp_rtable_find_mac>:
    4934:	90 e0       	ldi	r25, 0x00	; 0
    4936:	fc 01       	movw	r30, r24
    4938:	ee 0f       	add	r30, r30
    493a:	ff 1f       	adc	r31, r31
    493c:	e8 0f       	add	r30, r24
    493e:	f9 1f       	adc	r31, r25
    4940:	e9 5a       	subi	r30, 0xA9	; 169
    4942:	f0 4e       	sbci	r31, 0xE0	; 224
    4944:	20 81       	ld	r18, Z
    4946:	31 81       	ldd	r19, Z+1	; 0x01
    4948:	23 2b       	or	r18, r19
    494a:	49 f0       	breq	.+18     	; 0x495e <csp_rtable_find_mac+0x2a>
    494c:	fc 01       	movw	r30, r24
    494e:	ee 0f       	add	r30, r30
    4950:	ff 1f       	adc	r31, r31
    4952:	8e 0f       	add	r24, r30
    4954:	9f 1f       	adc	r25, r31
    4956:	fc 01       	movw	r30, r24
    4958:	e9 5a       	subi	r30, 0xA9	; 169
    495a:	f0 4e       	sbci	r31, 0xE0	; 224
    495c:	08 c0       	rjmp	.+16     	; 0x496e <csp_rtable_find_mac+0x3a>
    495e:	80 91 b7 1f 	lds	r24, 0x1FB7	; 0x801fb7 <routes+0x60>
    4962:	90 91 b8 1f 	lds	r25, 0x1FB8	; 0x801fb8 <routes+0x61>
    4966:	89 2b       	or	r24, r25
    4968:	21 f0       	breq	.+8      	; 0x4972 <csp_rtable_find_mac+0x3e>
    496a:	e7 eb       	ldi	r30, 0xB7	; 183
    496c:	ff e1       	ldi	r31, 0x1F	; 31
    496e:	82 81       	ldd	r24, Z+2	; 0x02
    4970:	08 95       	ret
    4972:	8f ef       	ldi	r24, 0xFF	; 255
    4974:	08 95       	ret

00004976 <csp_rtable_set>:
}

int csp_rtable_set(uint8_t node, uint8_t mask, csp_iface_t *ifc, uint8_t mac) {
    4976:	0f 93       	push	r16
    4978:	1f 93       	push	r17
    497a:	cf 93       	push	r28
    497c:	df 93       	push	r29

	/* Don't add nothing */
	if (ifc == NULL)
    497e:	41 15       	cp	r20, r1
    4980:	51 05       	cpc	r21, r1
    4982:	d1 f1       	breq	.+116    	; 0x49f8 <csp_rtable_set+0x82>
    4984:	d2 2f       	mov	r29, r18
    4986:	8a 01       	movw	r16, r20
    4988:	c8 2f       	mov	r28, r24
	 * NOTE: For future implementations, interfaces should call
	 * csp_route_add_if in its csp_if_<name>_init function, instead
	 * of registering at first route_set, in order to make the interface
	 * available to network based (CMP) route configuration.
	 */
	csp_iflist_add(ifc);
    498a:	ca 01       	movw	r24, r20
    498c:	0e 94 39 1c 	call	0x3872	; 0x3872 <csp_iflist_add>

	/* Set route */
	if (node <= CSP_DEFAULT_ROUTE) {
    4990:	c1 32       	cpi	r28, 0x21	; 33
    4992:	78 f4       	brcc	.+30     	; 0x49b2 <csp_rtable_set+0x3c>
		routes[node].interface = ifc;
    4994:	8c 2f       	mov	r24, r28
    4996:	90 e0       	ldi	r25, 0x00	; 0
    4998:	fc 01       	movw	r30, r24
    499a:	ee 0f       	add	r30, r30
    499c:	ff 1f       	adc	r31, r31
    499e:	e8 0f       	add	r30, r24
    49a0:	f9 1f       	adc	r31, r25
    49a2:	e9 5a       	subi	r30, 0xA9	; 169
    49a4:	f0 4e       	sbci	r31, 0xE0	; 224
    49a6:	11 83       	std	Z+1, r17	; 0x01
    49a8:	00 83       	st	Z, r16
		routes[node].mac = mac;
    49aa:	d2 83       	std	Z+2, r29	; 0x02
	} else {
		csp_log_error("Failed to set route: invalid node id %u", node);
		return CSP_ERR_INVAL;
	}

	return CSP_ERR_NONE;
    49ac:	80 e0       	ldi	r24, 0x00	; 0
    49ae:	90 e0       	ldi	r25, 0x00	; 0
    49b0:	28 c0       	rjmp	.+80     	; 0x4a02 <csp_rtable_set+0x8c>
	/* Set route */
	if (node <= CSP_DEFAULT_ROUTE) {
		routes[node].interface = ifc;
		routes[node].mac = mac;
	} else {
		csp_log_error("Failed to set route: invalid node id %u", node);
    49b2:	80 91 04 02 	lds	r24, 0x0204	; 0x800204 <csp_debug_level_enabled>
    49b6:	88 23       	and	r24, r24
    49b8:	11 f1       	breq	.+68     	; 0x49fe <csp_rtable_set+0x88>
    49ba:	0e 94 62 1c 	call	0x38c4	; 0x38c4 <csp_get_address>
    49be:	1f 92       	push	r1
    49c0:	cf 93       	push	r28
    49c2:	1f 92       	push	r1
    49c4:	95 e6       	ldi	r25, 0x65	; 101
    49c6:	9f 93       	push	r25
    49c8:	2e e7       	ldi	r18, 0x7E	; 126
    49ca:	33 e0       	ldi	r19, 0x03	; 3
    49cc:	3f 93       	push	r19
    49ce:	2f 93       	push	r18
    49d0:	1f 92       	push	r1
    49d2:	8f 93       	push	r24
    49d4:	83 ef       	ldi	r24, 0xF3	; 243
    49d6:	9c e0       	ldi	r25, 0x0C	; 12
    49d8:	9f 93       	push	r25
    49da:	8f 93       	push	r24
    49dc:	1f 92       	push	r1
    49de:	0e 94 7a 1b 	call	0x36f4	; 0x36f4 <do_csp_debug>
    49e2:	8d b7       	in	r24, 0x3d	; 61
    49e4:	9e b7       	in	r25, 0x3e	; 62
    49e6:	0b 96       	adiw	r24, 0x0b	; 11
    49e8:	0f b6       	in	r0, 0x3f	; 63
    49ea:	f8 94       	cli
    49ec:	9e bf       	out	0x3e, r25	; 62
    49ee:	0f be       	out	0x3f, r0	; 63
    49f0:	8d bf       	out	0x3d, r24	; 61
		return CSP_ERR_INVAL;
    49f2:	8e ef       	ldi	r24, 0xFE	; 254
    49f4:	9f ef       	ldi	r25, 0xFF	; 255
    49f6:	05 c0       	rjmp	.+10     	; 0x4a02 <csp_rtable_set+0x8c>

int csp_rtable_set(uint8_t node, uint8_t mask, csp_iface_t *ifc, uint8_t mac) {

	/* Don't add nothing */
	if (ifc == NULL)
		return CSP_ERR_INVAL;
    49f8:	8e ef       	ldi	r24, 0xFE	; 254
    49fa:	9f ef       	ldi	r25, 0xFF	; 255
    49fc:	02 c0       	rjmp	.+4      	; 0x4a02 <csp_rtable_set+0x8c>
	if (node <= CSP_DEFAULT_ROUTE) {
		routes[node].interface = ifc;
		routes[node].mac = mac;
	} else {
		csp_log_error("Failed to set route: invalid node id %u", node);
		return CSP_ERR_INVAL;
    49fe:	8e ef       	ldi	r24, 0xFE	; 254
    4a00:	9f ef       	ldi	r25, 0xFF	; 255
	}

	return CSP_ERR_NONE;

}
    4a02:	df 91       	pop	r29
    4a04:	cf 91       	pop	r28
    4a06:	1f 91       	pop	r17
    4a08:	0f 91       	pop	r16
    4a0a:	08 95       	ret

00004a0c <csp_rtable_print>:

#ifdef CSP_DEBUG
void csp_rtable_print(void) {
    4a0c:	ef 92       	push	r14
    4a0e:	ff 92       	push	r15
    4a10:	0f 93       	push	r16
    4a12:	1f 93       	push	r17
    4a14:	cf 93       	push	r28
    4a16:	df 93       	push	r29
	int i;
	printf("Node  Interface  Address\r\n");
    4a18:	88 ed       	ldi	r24, 0xD8	; 216
    4a1a:	9c e0       	ldi	r25, 0x0C	; 12
    4a1c:	9f 93       	push	r25
    4a1e:	8f 93       	push	r24
    4a20:	7c d7       	rcall	.+3832   	; 0x591a <printf_P>
    4a22:	07 e5       	ldi	r16, 0x57	; 87
    4a24:	1f e1       	ldi	r17, 0x1F	; 31
    4a26:	0f 90       	pop	r0
    4a28:	0f 90       	pop	r0
	for (i = 0; i < CSP_DEFAULT_ROUTE; i++)
    4a2a:	c0 e0       	ldi	r28, 0x00	; 0
    4a2c:	d0 e0       	ldi	r29, 0x00	; 0
		if (routes[i].interface != NULL)
			printf("%4u  %-9s  %u\r\n", i,
    4a2e:	0f 2e       	mov	r0, r31
    4a30:	f8 ec       	ldi	r31, 0xC8	; 200
    4a32:	ef 2e       	mov	r14, r31
    4a34:	fc e0       	ldi	r31, 0x0C	; 12
    4a36:	ff 2e       	mov	r15, r31
    4a38:	f0 2d       	mov	r31, r0
#ifdef CSP_DEBUG
void csp_rtable_print(void) {
	int i;
	printf("Node  Interface  Address\r\n");
	for (i = 0; i < CSP_DEFAULT_ROUTE; i++)
		if (routes[i].interface != NULL)
    4a3a:	d8 01       	movw	r26, r16
    4a3c:	ed 91       	ld	r30, X+
    4a3e:	fc 91       	ld	r31, X
    4a40:	11 97       	sbiw	r26, 0x01	; 1
    4a42:	30 97       	sbiw	r30, 0x00	; 0
    4a44:	d1 f0       	breq	.+52     	; 0x4a7a <csp_rtable_print+0x6e>
			printf("%4u  %-9s  %u\r\n", i,
    4a46:	12 96       	adiw	r26, 0x02	; 2
    4a48:	8c 91       	ld	r24, X
    4a4a:	8f 3f       	cpi	r24, 0xFF	; 255
    4a4c:	11 f0       	breq	.+4      	; 0x4a52 <csp_rtable_print+0x46>
    4a4e:	90 e0       	ldi	r25, 0x00	; 0
    4a50:	01 c0       	rjmp	.+2      	; 0x4a54 <csp_rtable_print+0x48>
    4a52:	ce 01       	movw	r24, r28
    4a54:	9f 93       	push	r25
    4a56:	8f 93       	push	r24
    4a58:	81 81       	ldd	r24, Z+1	; 0x01
    4a5a:	8f 93       	push	r24
    4a5c:	80 81       	ld	r24, Z
    4a5e:	8f 93       	push	r24
    4a60:	df 93       	push	r29
    4a62:	cf 93       	push	r28
    4a64:	ff 92       	push	r15
    4a66:	ef 92       	push	r14
    4a68:	58 d7       	rcall	.+3760   	; 0x591a <printf_P>
    4a6a:	ad b7       	in	r26, 0x3d	; 61
    4a6c:	be b7       	in	r27, 0x3e	; 62
    4a6e:	18 96       	adiw	r26, 0x08	; 8
    4a70:	0f b6       	in	r0, 0x3f	; 63
    4a72:	f8 94       	cli
    4a74:	be bf       	out	0x3e, r27	; 62
    4a76:	0f be       	out	0x3f, r0	; 63
    4a78:	ad bf       	out	0x3d, r26	; 61

#ifdef CSP_DEBUG
void csp_rtable_print(void) {
	int i;
	printf("Node  Interface  Address\r\n");
	for (i = 0; i < CSP_DEFAULT_ROUTE; i++)
    4a7a:	21 96       	adiw	r28, 0x01	; 1
    4a7c:	0d 5f       	subi	r16, 0xFD	; 253
    4a7e:	1f 4f       	sbci	r17, 0xFF	; 255
    4a80:	c0 32       	cpi	r28, 0x20	; 32
    4a82:	d1 05       	cpc	r29, r1
    4a84:	d1 f6       	brne	.-76     	; 0x4a3a <csp_rtable_print+0x2e>
		if (routes[i].interface != NULL)
			printf("%4u  %-9s  %u\r\n", i,
				routes[i].interface->name,
				routes[i].mac == CSP_NODE_MAC ? i : routes[i].mac);
	printf("   *  %-9s  %u\r\n", routes[CSP_DEFAULT_ROUTE].interface->name, routes[CSP_DEFAULT_ROUTE].mac);
    4a86:	80 91 b9 1f 	lds	r24, 0x1FB9	; 0x801fb9 <routes+0x62>
    4a8a:	1f 92       	push	r1
    4a8c:	8f 93       	push	r24
    4a8e:	e0 91 b7 1f 	lds	r30, 0x1FB7	; 0x801fb7 <routes+0x60>
    4a92:	f0 91 b8 1f 	lds	r31, 0x1FB8	; 0x801fb8 <routes+0x61>
    4a96:	81 81       	ldd	r24, Z+1	; 0x01
    4a98:	8f 93       	push	r24
    4a9a:	80 81       	ld	r24, Z
    4a9c:	8f 93       	push	r24
    4a9e:	87 eb       	ldi	r24, 0xB7	; 183
    4aa0:	9c e0       	ldi	r25, 0x0C	; 12
    4aa2:	9f 93       	push	r25
    4aa4:	8f 93       	push	r24
    4aa6:	39 d7       	rcall	.+3698   	; 0x591a <printf_P>

}
    4aa8:	0f 90       	pop	r0
    4aaa:	0f 90       	pop	r0
    4aac:	0f 90       	pop	r0
    4aae:	0f 90       	pop	r0
    4ab0:	0f 90       	pop	r0
    4ab2:	0f 90       	pop	r0
    4ab4:	df 91       	pop	r29
    4ab6:	cf 91       	pop	r28
    4ab8:	1f 91       	pop	r17
    4aba:	0f 91       	pop	r16
    4abc:	ff 90       	pop	r15
    4abe:	ef 90       	pop	r14
    4ac0:	08 95       	ret

00004ac2 <csp_udp_new_packet>:
#include <csp/csp.h>
#include <csp/arch/csp_queue.h>
#include "../csp_port.h"
#include "../csp_conn.h"

void csp_udp_new_packet(csp_conn_t * conn, csp_packet_t * packet) {
    4ac2:	0f 93       	push	r16
    4ac4:	1f 93       	push	r17
    4ac6:	cf 93       	push	r28
    4ac8:	df 93       	push	r29
    4aca:	1f 92       	push	r1
    4acc:	1f 92       	push	r1
    4ace:	cd b7       	in	r28, 0x3d	; 61
    4ad0:	de b7       	in	r29, 0x3e	; 62
    4ad2:	9a 83       	std	Y+2, r25	; 0x02
    4ad4:	89 83       	std	Y+1, r24	; 0x01
    4ad6:	8b 01       	movw	r16, r22

	/* Enqueue */
	if (csp_conn_enqueue_packet(conn, packet) < 0) {
    4ad8:	0e 94 82 17 	call	0x2f04	; 0x2f04 <csp_conn_enqueue_packet>
    4adc:	99 23       	and	r25, r25
    4ade:	fc f4       	brge	.+62     	; 0x4b1e <csp_udp_new_packet+0x5c>
		csp_log_error("Connection buffer queue full!");
    4ae0:	80 91 04 02 	lds	r24, 0x0204	; 0x800204 <csp_debug_level_enabled>
    4ae4:	88 23       	and	r24, r24
    4ae6:	b9 f0       	breq	.+46     	; 0x4b16 <csp_udp_new_packet+0x54>
    4ae8:	0e 94 62 1c 	call	0x38c4	; 0x38c4 <csp_get_address>
    4aec:	1f 92       	push	r1
    4aee:	9e e1       	ldi	r25, 0x1E	; 30
    4af0:	9f 93       	push	r25
    4af2:	2e ea       	ldi	r18, 0xAE	; 174
    4af4:	33 e0       	ldi	r19, 0x03	; 3
    4af6:	3f 93       	push	r19
    4af8:	2f 93       	push	r18
    4afa:	1f 92       	push	r1
    4afc:	8f 93       	push	r24
    4afe:	8a e5       	ldi	r24, 0x5A	; 90
    4b00:	9d e0       	ldi	r25, 0x0D	; 13
    4b02:	9f 93       	push	r25
    4b04:	8f 93       	push	r24
    4b06:	1f 92       	push	r1
    4b08:	0e 94 7a 1b 	call	0x36f4	; 0x36f4 <do_csp_debug>
    4b0c:	0f b6       	in	r0, 0x3f	; 63
    4b0e:	f8 94       	cli
    4b10:	de bf       	out	0x3e, r29	; 62
    4b12:	0f be       	out	0x3f, r0	; 63
    4b14:	cd bf       	out	0x3d, r28	; 61
		csp_buffer_free(packet);
    4b16:	c8 01       	movw	r24, r16
    4b18:	0e 94 8c 16 	call	0x2d18	; 0x2d18 <csp_buffer_free>
		return;
    4b1c:	35 c0       	rjmp	.+106    	; 0x4b88 <csp_udp_new_packet+0xc6>
	}

	/* Try to queue up the new connection pointer */
	if (conn->socket != NULL) {
    4b1e:	e9 81       	ldd	r30, Y+1	; 0x01
    4b20:	fa 81       	ldd	r31, Y+2	; 0x02
    4b22:	86 85       	ldd	r24, Z+14	; 0x0e
    4b24:	97 85       	ldd	r25, Z+15	; 0x0f
    4b26:	00 97       	sbiw	r24, 0x00	; 0
    4b28:	79 f1       	breq	.+94     	; 0x4b88 <csp_udp_new_packet+0xc6>
		if (csp_queue_enqueue(conn->socket, &conn, 0) != CSP_QUEUE_OK) {
    4b2a:	20 e0       	ldi	r18, 0x00	; 0
    4b2c:	30 e0       	ldi	r19, 0x00	; 0
    4b2e:	a9 01       	movw	r20, r18
    4b30:	be 01       	movw	r22, r28
    4b32:	6f 5f       	subi	r22, 0xFF	; 255
    4b34:	7f 4f       	sbci	r23, 0xFF	; 255
    4b36:	0e 94 a0 13 	call	0x2740	; 0x2740 <csp_queue_enqueue>
    4b3a:	01 97       	sbiw	r24, 0x01	; 1
    4b3c:	09 f1       	breq	.+66     	; 0x4b80 <csp_udp_new_packet+0xbe>
			csp_log_warn("Warning socket connection queue full");
    4b3e:	80 91 05 02 	lds	r24, 0x0205	; 0x800205 <csp_debug_level_enabled+0x1>
    4b42:	88 23       	and	r24, r24
    4b44:	c1 f0       	breq	.+48     	; 0x4b76 <csp_udp_new_packet+0xb4>
    4b46:	0e 94 62 1c 	call	0x38c4	; 0x38c4 <csp_get_address>
    4b4a:	1f 92       	push	r1
    4b4c:	96 e2       	ldi	r25, 0x26	; 38
    4b4e:	9f 93       	push	r25
    4b50:	2e ea       	ldi	r18, 0xAE	; 174
    4b52:	33 e0       	ldi	r19, 0x03	; 3
    4b54:	3f 93       	push	r19
    4b56:	2f 93       	push	r18
    4b58:	1f 92       	push	r1
    4b5a:	8f 93       	push	r24
    4b5c:	88 e2       	ldi	r24, 0x28	; 40
    4b5e:	9d e0       	ldi	r25, 0x0D	; 13
    4b60:	9f 93       	push	r25
    4b62:	8f 93       	push	r24
    4b64:	81 e0       	ldi	r24, 0x01	; 1
    4b66:	8f 93       	push	r24
    4b68:	0e 94 7a 1b 	call	0x36f4	; 0x36f4 <do_csp_debug>
    4b6c:	0f b6       	in	r0, 0x3f	; 63
    4b6e:	f8 94       	cli
    4b70:	de bf       	out	0x3e, r29	; 62
    4b72:	0f be       	out	0x3f, r0	; 63
    4b74:	cd bf       	out	0x3d, r28	; 61
			csp_close(conn);
    4b76:	89 81       	ldd	r24, Y+1	; 0x01
    4b78:	9a 81       	ldd	r25, Y+2	; 0x02
    4b7a:	0e 94 b6 19 	call	0x336c	; 0x336c <csp_close>
			return;
    4b7e:	04 c0       	rjmp	.+8      	; 0x4b88 <csp_udp_new_packet+0xc6>
		}

		/* Ensure that this connection will not be posted to this socket again */
		conn->socket = NULL;
    4b80:	e9 81       	ldd	r30, Y+1	; 0x01
    4b82:	fa 81       	ldd	r31, Y+2	; 0x02
    4b84:	17 86       	std	Z+15, r1	; 0x0f
    4b86:	16 86       	std	Z+14, r1	; 0x0e
	}

}
    4b88:	0f 90       	pop	r0
    4b8a:	0f 90       	pop	r0
    4b8c:	df 91       	pop	r29
    4b8e:	cf 91       	pop	r28
    4b90:	1f 91       	pop	r17
    4b92:	0f 91       	pop	r16
    4b94:	08 95       	ret

00004b96 <__portable_avr_delay_cycles>:
 *
 * @{
 */
__always_optimize
static inline void __portable_avr_delay_cycles(unsigned long n)
{
    4b96:	04 c0       	rjmp	.+8      	; 0x4ba0 <__portable_avr_delay_cycles+0xa>
	while (n) {
		barrier();
		n--;
    4b98:	61 50       	subi	r22, 0x01	; 1
    4b9a:	71 09       	sbc	r23, r1
    4b9c:	81 09       	sbc	r24, r1
    4b9e:	91 09       	sbc	r25, r1
 * @{
 */
__always_optimize
static inline void __portable_avr_delay_cycles(unsigned long n)
{
	while (n) {
    4ba0:	61 15       	cp	r22, r1
    4ba2:	71 05       	cpc	r23, r1
    4ba4:	81 05       	cpc	r24, r1
    4ba6:	91 05       	cpc	r25, r1
    4ba8:	b9 f7       	brne	.-18     	; 0x4b98 <__portable_avr_delay_cycles+0x2>
    4baa:	08 95       	ret

00004bac <led_blinky>:
 */
__always_inline static void arch_ioport_toggle_pin_level(ioport_pin_t pin)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);

	base->PINCRL = arch_ioport_pin_to_mask(pin);
    4bac:	c0 e8       	ldi	r28, 0x80	; 128
    4bae:	c3 b9       	out	0x03, r28	; 3
TaskHandle_t I2C_task;

void led_blinky(void *pvParameters) {
    while (1) {
        ioport_toggle_pin_level(MY_LED);
        delay_ms(2000);
    4bb0:	66 e1       	ldi	r22, 0x16	; 22
    4bb2:	76 e1       	ldi	r23, 0x16	; 22
    4bb4:	85 e0       	ldi	r24, 0x05	; 5
    4bb6:	90 e0       	ldi	r25, 0x00	; 0
    4bb8:	ee df       	rcall	.-36     	; 0x4b96 <__portable_avr_delay_cycles>
    4bba:	f9 cf       	rjmp	.-14     	; 0x4bae <led_blinky+0x2>

00004bbc <csp_twoway_client>:
    }
}

void csp_twoway_client(void *pvParameters) {
    4bbc:	cf 93       	push	r28
    4bbe:	df 93       	push	r29
    4bc0:	cd b7       	in	r28, 0x3d	; 61
    4bc2:	de b7       	in	r29, 0x3e	; 62
    4bc4:	c9 56       	subi	r28, 0x69	; 105
    4bc6:	d1 09       	sbc	r29, r1
    4bc8:	0f b6       	in	r0, 0x3f	; 63
    4bca:	f8 94       	cli
    4bcc:	de bf       	out	0x3e, r29	; 62
    4bce:	0f be       	out	0x3f, r0	; 63
    4bd0:	cd bf       	out	0x3d, r28	; 61
    int ret;
    char incoming[100] = "";
    4bd2:	1a 82       	std	Y+2, r1	; 0x02
    4bd4:	19 82       	std	Y+1, r1	; 0x01
    4bd6:	fe 01       	movw	r30, r28
    4bd8:	33 96       	adiw	r30, 0x03	; 3
    4bda:	82 e6       	ldi	r24, 0x62	; 98
    4bdc:	df 01       	movw	r26, r30
    4bde:	1d 92       	st	X+, r1
    4be0:	8a 95       	dec	r24
    4be2:	e9 f7       	brne	.-6      	; 0x4bde <csp_twoway_client+0x22>
    char outgoing_data[] = "hello_twoway";
    char outgoing_ping[] = "Ping";
    4be4:	85 e0       	ldi	r24, 0x05	; 5
    4be6:	e8 eb       	ldi	r30, 0xB8	; 184
    4be8:	f3 e0       	ldi	r31, 0x03	; 3
    4bea:	de 01       	movw	r26, r28
    4bec:	ab 59       	subi	r26, 0x9B	; 155
    4bee:	bf 4f       	sbci	r27, 0xFF	; 255
    4bf0:	01 90       	ld	r0, Z+
    4bf2:	0d 92       	st	X+, r0
    4bf4:	8a 95       	dec	r24
    4bf6:	e1 f7       	brne	.-8      	; 0x4bf0 <csp_twoway_client+0x34>
            @param inbuf pointer to incoming data buffer
            @param inlen length of expected reply, -1 for unknown size (note inbuf MUST be large enough)
            @return Return 1 or reply size if successful, 0 if error or incoming length does not match or -1 if timeout was reached
        */
        ret = csp_transaction(OBC_CSP_PRIO, EPS_ADDR, EPS_CONN_PORT_PING, OBC_CSP_TRANSACTION_TIMEOUT, outgoing_ping,
                              strlen(outgoing_ping), incoming, -1);
    4bf8:	3e 01       	movw	r6, r28
    4bfa:	b5 e6       	ldi	r27, 0x65	; 101
    4bfc:	6b 0e       	add	r6, r27
    4bfe:	71 1c       	adc	r7, r1
            @param outlen length of request to send
            @param inbuf pointer to incoming data buffer
            @param inlen length of expected reply, -1 for unknown size (note inbuf MUST be large enough)
            @return Return 1 or reply size if successful, 0 if error or incoming length does not match or -1 if timeout was reached
        */
        ret = csp_transaction(OBC_CSP_PRIO, EPS_ADDR, EPS_CONN_PORT_PING, OBC_CSP_TRANSACTION_TIMEOUT, outgoing_ping,
    4c00:	ce 01       	movw	r24, r28
    4c02:	01 96       	adiw	r24, 0x01	; 1
    4c04:	2c 01       	movw	r4, r24
                              strlen(outgoing_ping), incoming, -1);

        if (ret != -1 && ret != 0) {
            printf("Ping -- Success\r\n");
    4c06:	0f 2e       	mov	r0, r31
    4c08:	f2 ec       	ldi	r31, 0xC2	; 194
    4c0a:	2f 2e       	mov	r2, r31
    4c0c:	fd e0       	ldi	r31, 0x0D	; 13
    4c0e:	3f 2e       	mov	r3, r31
    4c10:	f0 2d       	mov	r31, r0
            @param inbuf pointer to incoming data buffer
            @param inlen length of expected reply, -1 for unknown size (note inbuf MUST be large enough)
            @return Return 1 or reply size if successful, 0 if error or incoming length does not match or -1 if timeout was reached
        */
        ret = csp_transaction(OBC_CSP_PRIO, EPS_ADDR, EPS_CONN_PORT_PING, OBC_CSP_TRANSACTION_TIMEOUT, outgoing_ping,
                              strlen(outgoing_ping), incoming, -1);
    4c12:	f3 01       	movw	r30, r6
    4c14:	01 90       	ld	r0, Z+
    4c16:	00 20       	and	r0, r0
    4c18:	e9 f7       	brne	.-6      	; 0x4c14 <csp_twoway_client+0x58>
    4c1a:	31 97       	sbiw	r30, 0x01	; 1
    4c1c:	6f 01       	movw	r12, r30
    4c1e:	c6 18       	sub	r12, r6
    4c20:	d7 08       	sbc	r13, r7
            @param outlen length of request to send
            @param inbuf pointer to incoming data buffer
            @param inlen length of expected reply, -1 for unknown size (note inbuf MUST be large enough)
            @return Return 1 or reply size if successful, 0 if error or incoming length does not match or -1 if timeout was reached
        */
        ret = csp_transaction(OBC_CSP_PRIO, EPS_ADDR, EPS_CONN_PORT_PING, OBC_CSP_TRANSACTION_TIMEOUT, outgoing_ping,
    4c22:	88 24       	eor	r8, r8
    4c24:	8a 94       	dec	r8
    4c26:	98 2c       	mov	r9, r8
    4c28:	52 01       	movw	r10, r4
    4c2a:	73 01       	movw	r14, r6
    4c2c:	08 ee       	ldi	r16, 0xE8	; 232
    4c2e:	13 e0       	ldi	r17, 0x03	; 3
    4c30:	20 e0       	ldi	r18, 0x00	; 0
    4c32:	30 e0       	ldi	r19, 0x00	; 0
    4c34:	41 e0       	ldi	r20, 0x01	; 1
    4c36:	62 e0       	ldi	r22, 0x02	; 2
    4c38:	85 e0       	ldi	r24, 0x05	; 5
    4c3a:	14 d9       	rcall	.-3544   	; 0x3e64 <csp_transaction>
    4c3c:	6c 01       	movw	r12, r24
                              strlen(outgoing_ping), incoming, -1);

        if (ret != -1 && ret != 0) {
    4c3e:	01 96       	adiw	r24, 0x01	; 1
    4c40:	02 97       	sbiw	r24, 0x02	; 2
    4c42:	90 f0       	brcs	.+36     	; 0x4c68 <csp_twoway_client+0xac>
            printf("Ping -- Success\r\n");
    4c44:	3f 92       	push	r3
    4c46:	2f 92       	push	r2
    4c48:	68 d6       	rcall	.+3280   	; 0x591a <printf_P>
            printf("Reply: %s, Length: %d\r\n\r\n", incoming, ret);
    4c4a:	df 92       	push	r13
    4c4c:	cf 92       	push	r12
    4c4e:	5f 92       	push	r5
    4c50:	4f 92       	push	r4
    4c52:	a8 ea       	ldi	r26, 0xA8	; 168
    4c54:	bd e0       	ldi	r27, 0x0D	; 13
    4c56:	bf 93       	push	r27
    4c58:	af 93       	push	r26
    4c5a:	5f d6       	rcall	.+3262   	; 0x591a <printf_P>
    4c5c:	0f b6       	in	r0, 0x3f	; 63
    4c5e:	f8 94       	cli
    4c60:	de bf       	out	0x3e, r29	; 62
    4c62:	0f be       	out	0x3f, r0	; 63
    4c64:	cd bf       	out	0x3d, r28	; 61
    4c66:	12 c0       	rjmp	.+36     	; 0x4c8c <csp_twoway_client+0xd0>
        }
        else if (ret == -1) {
    4c68:	cd 20       	and	r12, r13
    4c6a:	c0 94       	com	r12
    4c6c:	41 f4       	brne	.+16     	; 0x4c7e <csp_twoway_client+0xc2>
            printf("Ping -- Timeout\r\n");
    4c6e:	a6 e9       	ldi	r26, 0x96	; 150
    4c70:	bd e0       	ldi	r27, 0x0D	; 13
    4c72:	bf 93       	push	r27
    4c74:	af 93       	push	r26
    4c76:	51 d6       	rcall	.+3234   	; 0x591a <printf_P>
    4c78:	0f 90       	pop	r0
    4c7a:	0f 90       	pop	r0
    4c7c:	07 c0       	rjmp	.+14     	; 0x4c8c <csp_twoway_client+0xd0>
        }
        else {
            printf("Ping -- Failed\r\n");
    4c7e:	85 e8       	ldi	r24, 0x85	; 133
    4c80:	9d e0       	ldi	r25, 0x0D	; 13
    4c82:	9f 93       	push	r25
    4c84:	8f 93       	push	r24
    4c86:	49 d6       	rcall	.+3218   	; 0x591a <printf_P>
    4c88:	0f 90       	pop	r0
    4c8a:	0f 90       	pop	r0

        //ret = csp_transaction(4, SUBSYS_ADDR, SUBSYS_DATA_PORT, 1000, outgoing_data, strlen(outgoing_data), incoming, -1);
        //if (ret != -1 || ret != 0) printf("Data -- Success\r\nReply: %s\r\n", incoming);
        //else if (ret == -1) printf("Data -- Timeout\r\n");
        //else printf("Data -- Failed\r\n");
        vTaskDelay(10000);
    4c8c:	60 e1       	ldi	r22, 0x10	; 16
    4c8e:	77 e2       	ldi	r23, 0x27	; 39
    4c90:	80 e0       	ldi	r24, 0x00	; 0
    4c92:	90 e0       	ldi	r25, 0x00	; 0
    4c94:	0e 94 6a 11 	call	0x22d4	; 0x22d4 <vTaskDelay>
    }
    4c98:	bc cf       	rjmp	.-136    	; 0x4c12 <csp_twoway_client+0x56>

00004c9a <send_start>:
        xQueueSendToBack(tx_queue, &frame , timeout);
    }

    printf("\n qaft is %d", uxQueueMessagesWaiting(tx_queue));
    return 0;
}
    4c9a:	ec eb       	ldi	r30, 0xBC	; 188
    4c9c:	f0 e0       	ldi	r31, 0x00	; 0
    4c9e:	80 81       	ld	r24, Z
    4ca0:	8f 7e       	andi	r24, 0xEF	; 239
    4ca2:	80 83       	st	Z, r24
    4ca4:	80 81       	ld	r24, Z
    4ca6:	80 6a       	ori	r24, 0xA0	; 160
    4ca8:	80 83       	st	Z, r24
    4caa:	08 95       	ret

00004cac <i2c_init>:
    4cac:	8f 92       	push	r8
    4cae:	9f 92       	push	r9
    4cb0:	af 92       	push	r10
    4cb2:	bf 92       	push	r11
    4cb4:	cf 92       	push	r12
    4cb6:	df 92       	push	r13
    4cb8:	ef 92       	push	r14
    4cba:	0f 93       	push	r16
    4cbc:	1f 93       	push	r17
    4cbe:	cf 93       	push	r28
    4cc0:	62 30       	cpi	r22, 0x02	; 2
    4cc2:	71 05       	cpc	r23, r1
    4cc4:	08 f0       	brcs	.+2      	; 0x4cc8 <i2c_init+0x1c>
    4cc6:	64 c0       	rjmp	.+200    	; 0x4d90 <i2c_init+0xe4>
    4cc8:	80 2f       	mov	r24, r16
    4cca:	59 01       	movw	r10, r18
    4ccc:	c4 2f       	mov	r28, r20
    4cce:	4b 01       	movw	r8, r22
    4cd0:	67 2b       	or	r22, r23
    4cd2:	59 f4       	brne	.+22     	; 0x4cea <i2c_init+0x3e>
    4cd4:	40 e0       	ldi	r20, 0x00	; 0
    4cd6:	62 e0       	ldi	r22, 0x02	; 2
    4cd8:	0e 94 ba 0b 	call	0x1774	; 0x1774 <xQueueGenericCreate>
    4cdc:	90 93 cd 1f 	sts	0x1FCD, r25	; 0x801fcd <tx_queue+0x1>
    4ce0:	80 93 cc 1f 	sts	0x1FCC, r24	; 0x801fcc <tx_queue>
    4ce4:	89 2b       	or	r24, r25
    4ce6:	09 f4       	brne	.+2      	; 0x4cea <i2c_init+0x3e>
    4ce8:	56 c0       	rjmp	.+172    	; 0x4d96 <i2c_init+0xea>
    4cea:	c1 14       	cp	r12, r1
    4cec:	d1 04       	cpc	r13, r1
    4cee:	29 f0       	breq	.+10     	; 0x4cfa <i2c_init+0x4e>
    4cf0:	d0 92 c9 1f 	sts	0x1FC9, r13	; 0x801fc9 <rx_callback+0x1>
    4cf4:	c0 92 c8 1f 	sts	0x1FC8, r12	; 0x801fc8 <rx_callback>
    4cf8:	0c c0       	rjmp	.+24     	; 0x4d12 <i2c_init+0x66>
    4cfa:	40 e0       	ldi	r20, 0x00	; 0
    4cfc:	62 e0       	ldi	r22, 0x02	; 2
    4cfe:	8e 2d       	mov	r24, r14
    4d00:	0e 94 ba 0b 	call	0x1774	; 0x1774 <xQueueGenericCreate>
    4d04:	90 93 cb 1f 	sts	0x1FCB, r25	; 0x801fcb <rx_queue+0x1>
    4d08:	80 93 ca 1f 	sts	0x1FCA, r24	; 0x801fca <rx_queue>
    4d0c:	89 2b       	or	r24, r25
    4d0e:	09 f4       	brne	.+2      	; 0x4d12 <i2c_init+0x66>
    4d10:	45 c0       	rjmp	.+138    	; 0x4d9c <i2c_init+0xf0>
    4d12:	90 92 c3 1f 	sts	0x1FC3, r9	; 0x801fc3 <device_mode+0x1>
    4d16:	80 92 c2 1f 	sts	0x1FC2, r8	; 0x801fc2 <device_mode>
    4d1a:	b0 92 c1 1f 	sts	0x1FC1, r11	; 0x801fc1 <i2c_speed+0x1>
    4d1e:	a0 92 c0 1f 	sts	0x1FC0, r10	; 0x801fc0 <i2c_speed>
    4d22:	c0 93 bf 1f 	sts	0x1FBF, r28	; 0x801fbf <i2c_addr>
    4d26:	0c eb       	ldi	r16, 0xBC	; 188
    4d28:	10 e0       	ldi	r17, 0x00	; 0
    4d2a:	f8 01       	movw	r30, r16
    4d2c:	10 82       	st	Z, r1
    4d2e:	c0 91 b9 00 	lds	r28, 0x00B9	; 0x8000b9 <__TEXT_REGION_LENGTH__+0x7000b9>
    4d32:	20 91 c0 1f 	lds	r18, 0x1FC0	; 0x801fc0 <i2c_speed>
    4d36:	30 91 c1 1f 	lds	r19, 0x1FC1	; 0x801fc1 <i2c_speed+0x1>
    4d3a:	a0 ed       	ldi	r26, 0xD0	; 208
    4d3c:	b7 e0       	ldi	r27, 0x07	; 7
    4d3e:	18 d5       	rcall	.+2608   	; 0x5770 <__umulhisi3>
    4d40:	9b 01       	movw	r18, r22
    4d42:	ac 01       	movw	r20, r24
    4d44:	60 e0       	ldi	r22, 0x00	; 0
    4d46:	74 e2       	ldi	r23, 0x24	; 36
    4d48:	84 ef       	ldi	r24, 0xF4	; 244
    4d4a:	90 e0       	ldi	r25, 0x00	; 0
    4d4c:	e7 d4       	rcall	.+2510   	; 0x571c <__udivmodsi4>
    4d4e:	ca 01       	movw	r24, r20
    4d50:	b9 01       	movw	r22, r18
    4d52:	68 50       	subi	r22, 0x08	; 8
    4d54:	71 09       	sbc	r23, r1
    4d56:	81 09       	sbc	r24, r1
    4d58:	91 09       	sbc	r25, r1
    4d5a:	c3 70       	andi	r28, 0x03	; 3
    4d5c:	cc 0f       	add	r28, r28
    4d5e:	21 e0       	ldi	r18, 0x01	; 1
    4d60:	30 e0       	ldi	r19, 0x00	; 0
    4d62:	02 c0       	rjmp	.+4      	; 0x4d68 <i2c_init+0xbc>
    4d64:	22 0f       	add	r18, r18
    4d66:	33 1f       	adc	r19, r19
    4d68:	ca 95       	dec	r28
    4d6a:	e2 f7       	brpl	.-8      	; 0x4d64 <i2c_init+0xb8>
    4d6c:	03 2e       	mov	r0, r19
    4d6e:	00 0c       	add	r0, r0
    4d70:	44 0b       	sbc	r20, r20
    4d72:	55 0b       	sbc	r21, r21
    4d74:	d3 d4       	rcall	.+2470   	; 0x571c <__udivmodsi4>
    4d76:	20 93 b8 00 	sts	0x00B8, r18	; 0x8000b8 <__TEXT_REGION_LENGTH__+0x7000b8>
    4d7a:	80 91 bf 1f 	lds	r24, 0x1FBF	; 0x801fbf <i2c_addr>
    4d7e:	88 0f       	add	r24, r24
    4d80:	80 93 ba 00 	sts	0x00BA, r24	; 0x8000ba <__TEXT_REGION_LENGTH__+0x7000ba>
    4d84:	85 e4       	ldi	r24, 0x45	; 69
    4d86:	f8 01       	movw	r30, r16
    4d88:	80 83       	st	Z, r24
    4d8a:	8f ef       	ldi	r24, 0xFF	; 255
    4d8c:	9f ef       	ldi	r25, 0xFF	; 255
    4d8e:	08 c0       	rjmp	.+16     	; 0x4da0 <i2c_init+0xf4>
    4d90:	89 ef       	ldi	r24, 0xF9	; 249
    4d92:	9f ef       	ldi	r25, 0xFF	; 255
    4d94:	05 c0       	rjmp	.+10     	; 0x4da0 <i2c_init+0xf4>
    4d96:	8e ee       	ldi	r24, 0xEE	; 238
    4d98:	9f ef       	ldi	r25, 0xFF	; 255
    4d9a:	02 c0       	rjmp	.+4      	; 0x4da0 <i2c_init+0xf4>
    4d9c:	8e ee       	ldi	r24, 0xEE	; 238
    4d9e:	9f ef       	ldi	r25, 0xFF	; 255
    4da0:	cf 91       	pop	r28
    4da2:	1f 91       	pop	r17
    4da4:	0f 91       	pop	r16
    4da6:	ef 90       	pop	r14
    4da8:	df 90       	pop	r13
    4daa:	cf 90       	pop	r12
    4dac:	bf 90       	pop	r11
    4dae:	af 90       	pop	r10
    4db0:	9f 90       	pop	r9
    4db2:	8f 90       	pop	r8
    4db4:	08 95       	ret

00004db6 <i2c_send>:
    4db6:	0f 93       	push	r16
    4db8:	cf 93       	push	r28
    4dba:	df 93       	push	r29
    4dbc:	1f 92       	push	r1
    4dbe:	1f 92       	push	r1
    4dc0:	cd b7       	in	r28, 0x3d	; 61
    4dc2:	de b7       	in	r29, 0x3e	; 62
    4dc4:	fb 01       	movw	r30, r22
    4dc6:	7a 83       	std	Y+2, r23	; 0x02
    4dc8:	69 83       	std	Y+1, r22	; 0x01
    4dca:	80 85       	ldd	r24, Z+8	; 0x08
    4dcc:	91 85       	ldd	r25, Z+9	; 0x09
    4dce:	01 97       	sbiw	r24, 0x01	; 1
    4dd0:	8f 3f       	cpi	r24, 0xFF	; 255
    4dd2:	91 05       	cpc	r25, r1
    4dd4:	11 f0       	breq	.+4      	; 0x4dda <i2c_send+0x24>
    4dd6:	08 f0       	brcs	.+2      	; 0x4dda <i2c_send+0x24>
    4dd8:	40 c0       	rjmp	.+128    	; 0x4e5a <i2c_send+0xa4>
    4dda:	80 91 c2 1f 	lds	r24, 0x1FC2	; 0x801fc2 <device_mode>
    4dde:	90 91 c3 1f 	lds	r25, 0x1FC3	; 0x801fc3 <device_mode+0x1>
    4de2:	01 97       	sbiw	r24, 0x01	; 1
    4de4:	51 f4       	brne	.+20     	; 0x4dfa <i2c_send+0x44>
    4de6:	80 e0       	ldi	r24, 0x00	; 0
    4de8:	9e e0       	ldi	r25, 0x0E	; 14
    4dea:	9f 93       	push	r25
    4dec:	8f 93       	push	r24
    4dee:	95 d5       	rcall	.+2858   	; 0x591a <printf_P>
    4df0:	0f 90       	pop	r0
    4df2:	0f 90       	pop	r0
    4df4:	89 ef       	ldi	r24, 0xF9	; 249
    4df6:	9f ef       	ldi	r25, 0xFF	; 255
    4df8:	32 c0       	rjmp	.+100    	; 0x4e5e <i2c_send+0xa8>
    4dfa:	00 e0       	ldi	r16, 0x00	; 0
    4dfc:	20 e0       	ldi	r18, 0x00	; 0
    4dfe:	30 e0       	ldi	r19, 0x00	; 0
    4e00:	a9 01       	movw	r20, r18
    4e02:	be 01       	movw	r22, r28
    4e04:	6f 5f       	subi	r22, 0xFF	; 255
    4e06:	7f 4f       	sbci	r23, 0xFF	; 255
    4e08:	80 91 cc 1f 	lds	r24, 0x1FCC	; 0x801fcc <tx_queue>
    4e0c:	90 91 cd 1f 	lds	r25, 0x1FCD	; 0x801fcd <tx_queue+0x1>
    4e10:	0e 94 e8 0b 	call	0x17d0	; 0x17d0 <xQueueGenericSend>
    4e14:	81 30       	cpi	r24, 0x01	; 1
    4e16:	51 f0       	breq	.+20     	; 0x4e2c <i2c_send+0x76>
    4e18:	8e ee       	ldi	r24, 0xEE	; 238
    4e1a:	9d e0       	ldi	r25, 0x0D	; 13
    4e1c:	9f 93       	push	r25
    4e1e:	8f 93       	push	r24
    4e20:	7c d5       	rcall	.+2808   	; 0x591a <printf_P>
    4e22:	0f 90       	pop	r0
    4e24:	0f 90       	pop	r0
    4e26:	8f ee       	ldi	r24, 0xEF	; 239
    4e28:	9f ef       	ldi	r25, 0xFF	; 255
    4e2a:	19 c0       	rjmp	.+50     	; 0x4e5e <i2c_send+0xa8>
    4e2c:	0f b6       	in	r0, 0x3f	; 63
    4e2e:	f8 94       	cli
    4e30:	0f 92       	push	r0
    4e32:	80 91 bd 1f 	lds	r24, 0x1FBD	; 0x801fbd <i2c_busy>
    4e36:	90 91 be 1f 	lds	r25, 0x1FBE	; 0x801fbe <i2c_busy+0x1>
    4e3a:	89 2b       	or	r24, r25
    4e3c:	49 f4       	brne	.+18     	; 0x4e50 <i2c_send+0x9a>
    4e3e:	0e 94 0c 10 	call	0x2018	; 0x2018 <xTaskGetTickCount>
    4e42:	2b df       	rcall	.-426    	; 0x4c9a <send_start>
    4e44:	81 e0       	ldi	r24, 0x01	; 1
    4e46:	90 e0       	ldi	r25, 0x00	; 0
    4e48:	90 93 be 1f 	sts	0x1FBE, r25	; 0x801fbe <i2c_busy+0x1>
    4e4c:	80 93 bd 1f 	sts	0x1FBD, r24	; 0x801fbd <i2c_busy>
    4e50:	0f 90       	pop	r0
    4e52:	0f be       	out	0x3f, r0	; 63
    4e54:	8f ef       	ldi	r24, 0xFF	; 255
    4e56:	9f ef       	ldi	r25, 0xFF	; 255
    4e58:	02 c0       	rjmp	.+4      	; 0x4e5e <i2c_send+0xa8>
    4e5a:	8a ef       	ldi	r24, 0xFA	; 250
    4e5c:	9f ef       	ldi	r25, 0xFF	; 255
    4e5e:	0f 90       	pop	r0
    4e60:	0f 90       	pop	r0
    4e62:	df 91       	pop	r29
    4e64:	cf 91       	pop	r28
    4e66:	0f 91       	pop	r16
    4e68:	08 95       	ret

00004e6a <__vector_39>:


void TWI_vect(void) __attribute__((signal));
void TWI_vect(void) {
    4e6a:	1f 92       	push	r1
    4e6c:	0f 92       	push	r0
    4e6e:	0f b6       	in	r0, 0x3f	; 63
    4e70:	0f 92       	push	r0
    4e72:	11 24       	eor	r1, r1
    4e74:	0b b6       	in	r0, 0x3b	; 59
    4e76:	0f 92       	push	r0
    4e78:	0f 93       	push	r16
    4e7a:	1f 93       	push	r17
    4e7c:	2f 93       	push	r18
    4e7e:	3f 93       	push	r19
    4e80:	4f 93       	push	r20
    4e82:	5f 93       	push	r21
    4e84:	6f 93       	push	r22
    4e86:	7f 93       	push	r23
    4e88:	8f 93       	push	r24
    4e8a:	9f 93       	push	r25
    4e8c:	af 93       	push	r26
    4e8e:	bf 93       	push	r27
    4e90:	cf 93       	push	r28
    4e92:	ef 93       	push	r30
    4e94:	ff 93       	push	r31
    static uint8_t status;
    static signed portBASE_TYPE xTaskWoken;
    static uint8_t flag;
    static uint8_t flag2;
    status = TWSR & 0xF8;
    4e96:	80 91 b9 00 	lds	r24, 0x00B9	; 0x8000b9 <__TEXT_REGION_LENGTH__+0x7000b9>
    xTaskWoken = pdFALSE;
    4e9a:	10 92 bc 1f 	sts	0x1FBC, r1	; 0x801fbc <xTaskWoken.3115>
    flag = 0;
    4e9e:	10 92 bb 1f 	sts	0x1FBB, r1	; 0x801fbb <flag.3116>

    last_tx = 0;

    switch (status) {
    4ea2:	e8 2f       	mov	r30, r24
    4ea4:	e8 7f       	andi	r30, 0xF8	; 248
    4ea6:	8e 2f       	mov	r24, r30
    4ea8:	90 e0       	ldi	r25, 0x00	; 0
    4eaa:	fc 01       	movw	r30, r24
    4eac:	38 97       	sbiw	r30, 0x08	; 8
    4eae:	e1 3c       	cpi	r30, 0xC1	; 193
    4eb0:	f1 05       	cpc	r31, r1
    4eb2:	08 f0       	brcs	.+2      	; 0x4eb6 <__vector_39+0x4c>
    4eb4:	0f c2       	rjmp	.+1054   	; 0x52d4 <__vector_39+0x46a>
    4eb6:	88 27       	eor	r24, r24
    4eb8:	ef 57       	subi	r30, 0x7F	; 127
    4eba:	ff 4f       	sbci	r31, 0xFF	; 255
    4ebc:	8f 4f       	sbci	r24, 0xFF	; 255
    4ebe:	50 c4       	rjmp	.+2208   	; 0x5760 <__tablejump2__>
    case TW_ST_ARB_LOST_SLA_ACK:			// 0xB0 Arbitration lost in SLA+RW, SLA+R received, ACK returned
    case TW_ST_DATA_ACK:					// 0xB8 Data transmitted, ACK received

        //printf("\nSlave Transmit -- ACK received");

        if (tx_frame == NULL) {
    4ec0:	80 91 ce 1f 	lds	r24, 0x1FCE	; 0x801fce <tx_frame>
    4ec4:	90 91 cf 1f 	lds	r25, 0x1FCF	; 0x801fcf <tx_frame+0x1>
    4ec8:	89 2b       	or	r24, r25
    4eca:	b1 f4       	brne	.+44     	; 0x4ef8 <__vector_39+0x8e>
            if (xQueueReceiveFromISR(tx_queue, &tx_frame, &xTaskWoken) == pdFALSE) {
    4ecc:	4c eb       	ldi	r20, 0xBC	; 188
    4ece:	5f e1       	ldi	r21, 0x1F	; 31
    4ed0:	6e ec       	ldi	r22, 0xCE	; 206
    4ed2:	7f e1       	ldi	r23, 0x1F	; 31
    4ed4:	80 91 cc 1f 	lds	r24, 0x1FCC	; 0x801fcc <tx_queue>
    4ed8:	90 91 cd 1f 	lds	r25, 0x1FCD	; 0x801fcd <tx_queue+0x1>
    4edc:	0e 94 9c 0d 	call	0x1b38	; 0x1b38 <xQueueReceiveFromISR>
    4ee0:	81 11       	cpse	r24, r1
    4ee2:	06 c0       	rjmp	.+12     	; 0x4ef0 <__vector_39+0x86>
                TWCR |= _BV(TWSTO);
    4ee4:	ec eb       	ldi	r30, 0xBC	; 188
    4ee6:	f0 e0       	ldi	r31, 0x00	; 0
    4ee8:	80 81       	ld	r24, Z
    4eea:	80 61       	ori	r24, 0x10	; 16
    4eec:	80 83       	st	Z, r24
                break;
    4eee:	4a c2       	rjmp	.+1172   	; 0x5384 <__vector_39+0x51a>
            }

            /* Reset counter */
            tx_cnt = 0;
    4ef0:	10 92 c7 1f 	sts	0x1FC7, r1	; 0x801fc7 <tx_cnt+0x1>
    4ef4:	10 92 c6 1f 	sts	0x1FC6, r1	; 0x801fc6 <tx_cnt>

        }

        /* Send next byte */
        if (tx_cnt < tx_frame->len) {
    4ef8:	e0 91 ce 1f 	lds	r30, 0x1FCE	; 0x801fce <tx_frame>
    4efc:	f0 91 cf 1f 	lds	r31, 0x1FCF	; 0x801fcf <tx_frame+0x1>
    4f00:	80 91 c6 1f 	lds	r24, 0x1FC6	; 0x801fc6 <tx_cnt>
    4f04:	90 91 c7 1f 	lds	r25, 0x1FC7	; 0x801fc7 <tx_cnt+0x1>
    4f08:	20 85       	ldd	r18, Z+8	; 0x08
    4f0a:	31 85       	ldd	r19, Z+9	; 0x09
    4f0c:	82 17       	cp	r24, r18
    4f0e:	93 07       	cpc	r25, r19
    4f10:	88 f4       	brcc	.+34     	; 0x4f34 <__vector_39+0xca>
            TWDR = tx_frame->data[tx_cnt++];
    4f12:	80 91 c6 1f 	lds	r24, 0x1FC6	; 0x801fc6 <tx_cnt>
    4f16:	90 91 c7 1f 	lds	r25, 0x1FC7	; 0x801fc7 <tx_cnt+0x1>
    4f1a:	9c 01       	movw	r18, r24
    4f1c:	2f 5f       	subi	r18, 0xFF	; 255
    4f1e:	3f 4f       	sbci	r19, 0xFF	; 255
    4f20:	30 93 c7 1f 	sts	0x1FC7, r19	; 0x801fc7 <tx_cnt+0x1>
    4f24:	20 93 c6 1f 	sts	0x1FC6, r18	; 0x801fc6 <tx_cnt>
    4f28:	e8 0f       	add	r30, r24
    4f2a:	f9 1f       	adc	r31, r25
    4f2c:	82 85       	ldd	r24, Z+10	; 0x0a
    4f2e:	80 93 bb 00 	sts	0x00BB, r24	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7000bb>
    4f32:	07 c0       	rjmp	.+14     	; 0x4f42 <__vector_39+0xd8>

        }
        else {
            printf("Error: i2c too long \r\n");
    4f34:	87 ed       	ldi	r24, 0xD7	; 215
    4f36:	9d e0       	ldi	r25, 0x0D	; 13
    4f38:	9f 93       	push	r25
    4f3a:	8f 93       	push	r24
    4f3c:	ee d4       	rcall	.+2524   	; 0x591a <printf_P>
    4f3e:	0f 90       	pop	r0
    4f40:	0f 90       	pop	r0
        }

        flag2 = _BV(TWEA);
    4f42:	80 e4       	ldi	r24, 0x40	; 64
    4f44:	80 93 ba 1f 	sts	0x1FBA, r24	; 0x801fba <flag2.3117>
        break;
    4f48:	1d c2       	rjmp	.+1082   	; 0x5384 <__vector_39+0x51a>

    case TW_ST_DATA_NACK:				// 0xC0 Data transmitted, NACK received
    case TW_ST_LAST_DATA:				// 0xC8 Last data byte transmitted, ACK received
        //printf("\nSlave Transmit -- NACK/ACK received");

        csp_buffer_free_isr(tx_frame);
    4f4a:	80 91 ce 1f 	lds	r24, 0x1FCE	; 0x801fce <tx_frame>
    4f4e:	90 91 cf 1f 	lds	r25, 0x1FCF	; 0x801fcf <tx_frame+0x1>
    4f52:	0e 94 54 16 	call	0x2ca8	; 0x2ca8 <csp_buffer_free_isr>
        tx_frame = NULL;
    4f56:	10 92 cf 1f 	sts	0x1FCF, r1	; 0x801fcf <tx_frame+0x1>
    4f5a:	10 92 ce 1f 	sts	0x1FCE, r1	; 0x801fce <tx_frame>
        flag2 = _BV(TWEA);
    4f5e:	80 e4       	ldi	r24, 0x40	; 64
    4f60:	80 93 ba 1f 	sts	0x1FBA, r24	; 0x801fba <flag2.3117>

        break;
    4f64:	0f c2       	rjmp	.+1054   	; 0x5384 <__vector_39+0x51a>

    /* Beginning of new RX Frame */
    case TW_SR_SLA_ACK: 					// 0x60 SLA+W received, ACK returned
    case TW_SR_ARB_LOST_SLA_ACK:			// 0x68 Arbitration lost (in master mode) and addressed as slave, ACK returned
        //printf("\nSlave Receive -- ACK received");
        i2c_busy = 1;
    4f66:	81 e0       	ldi	r24, 0x01	; 1
    4f68:	90 e0       	ldi	r25, 0x00	; 0
    4f6a:	90 93 be 1f 	sts	0x1FBE, r25	; 0x801fbe <i2c_busy+0x1>
    4f6e:	80 93 bd 1f 	sts	0x1FBD, r24	; 0x801fbd <i2c_busy>
        flag2 = _BV(TWEA);
    4f72:	80 e4       	ldi	r24, 0x40	; 64
    4f74:	80 93 ba 1f 	sts	0x1FBA, r24	; 0x801fba <flag2.3117>

        break;
    4f78:	05 c2       	rjmp	.+1034   	; 0x5384 <__vector_39+0x51a>
    /* DATA received */
    case TW_SR_DATA_ACK: 					// 0x80 Data received, ACK returned
    case TW_SR_DATA_NACK: 					// 0x88 Data received, NACK returned
        //printf("\nSlave Received -- ACK return");

        i2c_busy = 1;
    4f7a:	81 e0       	ldi	r24, 0x01	; 1
    4f7c:	90 e0       	ldi	r25, 0x00	; 0
    4f7e:	90 93 be 1f 	sts	0x1FBE, r25	; 0x801fbe <i2c_busy+0x1>
    4f82:	80 93 bd 1f 	sts	0x1FBD, r24	; 0x801fbd <i2c_busy>

        /* Get buffer */
        if (rx_frame == NULL) {
    4f86:	e0 91 d0 1f 	lds	r30, 0x1FD0	; 0x801fd0 <rx_frame>
    4f8a:	f0 91 d1 1f 	lds	r31, 0x1FD1	; 0x801fd1 <rx_frame+0x1>
    4f8e:	30 97       	sbiw	r30, 0x00	; 0
    4f90:	a9 f4       	brne	.+42     	; 0x4fbc <__vector_39+0x152>
            rx_frame = csp_buffer_get_isr(I2C_MTU);
    4f92:	80 e0       	ldi	r24, 0x00	; 0
    4f94:	91 e0       	ldi	r25, 0x01	; 1
    4f96:	0e 94 58 15 	call	0x2ab0	; 0x2ab0 <csp_buffer_get_isr>
    4f9a:	fc 01       	movw	r30, r24
    4f9c:	90 93 d1 1f 	sts	0x1FD1, r25	; 0x801fd1 <rx_frame+0x1>
    4fa0:	80 93 d0 1f 	sts	0x1FD0, r24	; 0x801fd0 <rx_frame>

            //printf("\nSlave Receive -- Getting buffer");

            if (rx_frame == NULL) {
    4fa4:	89 2b       	or	r24, r25
    4fa6:	09 f4       	brne	.+2      	; 0x4faa <__vector_39+0x140>
    4fa8:	ed c1       	rjmp	.+986    	; 0x5384 <__vector_39+0x51a>
                //printf("\nSlave Receive -- no buffer found\r\n");
                break;
            }

            rx_frame->len_rx = 0;
    4faa:	17 82       	std	Z+7, r1	; 0x07
            rx_frame->len = 0;
    4fac:	11 86       	std	Z+9, r1	; 0x09
    4fae:	10 86       	std	Z+8, r1	; 0x08
            rx_frame->dest = i2c_addr;
    4fb0:	80 91 bf 1f 	lds	r24, 0x1FBF	; 0x801fbf <i2c_addr>
    4fb4:	86 83       	std	Z+6, r24	; 0x06
        }

        /* Store data */
        if (rx_frame->len < I2C_MTU) {
    4fb6:	80 e0       	ldi	r24, 0x00	; 0
    4fb8:	90 e0       	ldi	r25, 0x00	; 0
    4fba:	06 c0       	rjmp	.+12     	; 0x4fc8 <__vector_39+0x15e>
    4fbc:	80 85       	ldd	r24, Z+8	; 0x08
    4fbe:	91 85       	ldd	r25, Z+9	; 0x09
    4fc0:	8f 3f       	cpi	r24, 0xFF	; 255
    4fc2:	91 05       	cpc	r25, r1
    4fc4:	09 f0       	breq	.+2      	; 0x4fc8 <__vector_39+0x15e>
    4fc6:	50 f4       	brcc	.+20     	; 0x4fdc <__vector_39+0x172>
            rx_frame->data[rx_frame->len++] = TWDR;
    4fc8:	9c 01       	movw	r18, r24
    4fca:	2f 5f       	subi	r18, 0xFF	; 255
    4fcc:	3f 4f       	sbci	r19, 0xFF	; 255
    4fce:	31 87       	std	Z+9, r19	; 0x09
    4fd0:	20 87       	std	Z+8, r18	; 0x08
    4fd2:	20 91 bb 00 	lds	r18, 0x00BB	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7000bb>
    4fd6:	e8 0f       	add	r30, r24
    4fd8:	f9 1f       	adc	r31, r25
    4fda:	22 87       	std	Z+10, r18	; 0x0a
        }

        flag2 = _BV(TWEA);
    4fdc:	80 e4       	ldi	r24, 0x40	; 64
    4fde:	80 93 ba 1f 	sts	0x1FBA, r24	; 0x801fba <flag2.3117>

        break;
    4fe2:	d0 c1       	rjmp	.+928    	; 0x5384 <__vector_39+0x51a>

    /* End of frame */
    case TW_SR_STOP: 						// 0xA0 Stop condition received or repeated start
        //printf("\nSlave Receive -- Stop");
        i2c_busy = 0;
    4fe4:	10 92 be 1f 	sts	0x1FBE, r1	; 0x801fbe <i2c_busy+0x1>
    4fe8:	10 92 bd 1f 	sts	0x1FBD, r1	; 0x801fbd <i2c_busy>

        /* Break if no RX frame */
        if (rx_frame == NULL) {
    4fec:	80 91 d0 1f 	lds	r24, 0x1FD0	; 0x801fd0 <rx_frame>
    4ff0:	90 91 d1 1f 	lds	r25, 0x1FD1	; 0x801fd1 <rx_frame+0x1>
    4ff4:	00 97       	sbiw	r24, 0x00	; 0
    4ff6:	21 f4       	brne	.+8      	; 0x5000 <__vector_39+0x196>
            flag2 = _BV(TWEA);
    4ff8:	80 e4       	ldi	r24, 0x40	; 64
    4ffa:	80 93 ba 1f 	sts	0x1FBA, r24	; 0x801fba <flag2.3117>
            break;
    4ffe:	c2 c1       	rjmp	.+900    	; 0x5384 <__vector_39+0x51a>
        }

        /* Deliver frame */
        if (rx_callback != NULL) {
    5000:	e0 91 c8 1f 	lds	r30, 0x1FC8	; 0x801fc8 <rx_callback>
    5004:	f0 91 c9 1f 	lds	r31, 0x1FC9	; 0x801fc9 <rx_callback+0x1>
    5008:	30 97       	sbiw	r30, 0x00	; 0
    500a:	21 f0       	breq	.+8      	; 0x5014 <__vector_39+0x1aa>
            //for(int i = 0 ; i<3; i++)
            //receive_frame.data[i]=rx_frame->data[i];
            (*rx_callback)(rx_frame, &xTaskWoken);
    500c:	6c eb       	ldi	r22, 0xBC	; 188
    500e:	7f e1       	ldi	r23, 0x1F	; 31
    5010:	19 95       	eicall
    5012:	13 c0       	rjmp	.+38     	; 0x503a <__vector_39+0x1d0>

        }
        else {
            //printf("\nSlave Receive -- Queue");

            if (xQueueSendFromISR(rx_queue, &rx_frame, (signed portBASE_TYPE *) &xTaskWoken) != pdTRUE) {
    5014:	20 e0       	ldi	r18, 0x00	; 0
    5016:	4c eb       	ldi	r20, 0xBC	; 188
    5018:	5f e1       	ldi	r21, 0x1F	; 31
    501a:	60 ed       	ldi	r22, 0xD0	; 208
    501c:	7f e1       	ldi	r23, 0x1F	; 31
    501e:	80 91 ca 1f 	lds	r24, 0x1FCA	; 0x801fca <rx_queue>
    5022:	90 91 cb 1f 	lds	r25, 0x1FCB	; 0x801fcb <rx_queue+0x1>
    5026:	0e 94 9f 0c 	call	0x193e	; 0x193e <xQueueGenericSendFromISR>
    502a:	81 30       	cpi	r24, 0x01	; 1
    502c:	31 f0       	breq	.+12     	; 0x503a <__vector_39+0x1d0>
                csp_buffer_free_isr(rx_frame);
    502e:	80 91 d0 1f 	lds	r24, 0x1FD0	; 0x801fd0 <rx_frame>
    5032:	90 91 d1 1f 	lds	r25, 0x1FD1	; 0x801fd1 <rx_frame+0x1>
    5036:	0e 94 54 16 	call	0x2ca8	; 0x2ca8 <csp_buffer_free_isr>

            //printf("\n q has %d", uxQueueMessagesWaitingFromISR(rx_queue));
        }

        /* Prepare reply or next frame */
        if (device_mode == I2C_SLAVE) {
    503a:	80 91 c2 1f 	lds	r24, 0x1FC2	; 0x801fc2 <device_mode>
    503e:	90 91 c3 1f 	lds	r25, 0x1FC3	; 0x801fc3 <device_mode+0x1>
    5042:	01 97       	sbiw	r24, 0x01	; 1
    5044:	29 f5       	brne	.+74     	; 0x5090 <__vector_39+0x226>
            //printf("\nSlave");

            if (tx_frame != NULL) {
    5046:	80 91 ce 1f 	lds	r24, 0x1FCE	; 0x801fce <tx_frame>
    504a:	90 91 cf 1f 	lds	r25, 0x1FCF	; 0x801fcf <tx_frame+0x1>
    504e:	00 97       	sbiw	r24, 0x00	; 0
    5050:	31 f0       	breq	.+12     	; 0x505e <__vector_39+0x1f4>
                //printf("\ntxnotempty");
                csp_buffer_free_isr(tx_frame);
    5052:	0e 94 54 16 	call	0x2ca8	; 0x2ca8 <csp_buffer_free_isr>
                tx_frame = NULL;
    5056:	10 92 cf 1f 	sts	0x1FCF, r1	; 0x801fcf <tx_frame+0x1>
    505a:	10 92 ce 1f 	sts	0x1FCE, r1	; 0x801fce <tx_frame>
            }

            if (rx_frame->len == 0) {
    505e:	e0 91 d0 1f 	lds	r30, 0x1FD0	; 0x801fd0 <rx_frame>
    5062:	f0 91 d1 1f 	lds	r31, 0x1FD1	; 0x801fd1 <rx_frame+0x1>
    5066:	80 85       	ldd	r24, Z+8	; 0x08
    5068:	91 85       	ldd	r25, Z+9	; 0x09
    506a:	89 2b       	or	r24, r25
    506c:	41 f4       	brne	.+16     	; 0x507e <__vector_39+0x214>
                //printf("\nrxlennot0");
                csp_buffer_free_isr(rx_frame);
    506e:	cf 01       	movw	r24, r30
    5070:	0e 94 54 16 	call	0x2ca8	; 0x2ca8 <csp_buffer_free_isr>
                rx_frame = NULL;
    5074:	10 92 d1 1f 	sts	0x1FD1, r1	; 0x801fd1 <rx_frame+0x1>
    5078:	10 92 d0 1f 	sts	0x1FD0, r1	; 0x801fd0 <rx_frame>
    507c:	04 c0       	rjmp	.+8      	; 0x5086 <__vector_39+0x21c>
            }
            else {
                //printf("\ntxisrx");
                tx_frame = rx_frame;
    507e:	f0 93 cf 1f 	sts	0x1FCF, r31	; 0x801fcf <tx_frame+0x1>
    5082:	e0 93 ce 1f 	sts	0x1FCE, r30	; 0x801fce <tx_frame>
            }

            tx_cnt = 0;
    5086:	10 92 c7 1f 	sts	0x1FC7, r1	; 0x801fc7 <tx_cnt+0x1>
    508a:	10 92 c6 1f 	sts	0x1FC6, r1	; 0x801fc6 <tx_cnt>
    508e:	19 c0       	rjmp	.+50     	; 0x50c2 <__vector_39+0x258>
        }
        else {
            /* Try new transmission */
            if (uxQueueMessagesWaitingFromISR(tx_queue) > 0 || tx_frame != NULL) {
    5090:	80 91 cc 1f 	lds	r24, 0x1FCC	; 0x801fcc <tx_queue>
    5094:	90 91 cd 1f 	lds	r25, 0x1FCD	; 0x801fcd <tx_queue+0x1>
    5098:	0e 94 d9 0d 	call	0x1bb2	; 0x1bb2 <uxQueueMessagesWaitingFromISR>
    509c:	81 11       	cpse	r24, r1
    509e:	06 c0       	rjmp	.+12     	; 0x50ac <__vector_39+0x242>
    50a0:	80 91 ce 1f 	lds	r24, 0x1FCE	; 0x801fce <tx_frame>
    50a4:	90 91 cf 1f 	lds	r25, 0x1FCF	; 0x801fcf <tx_frame+0x1>
    50a8:	89 2b       	or	r24, r25
    50aa:	59 f0       	breq	.+22     	; 0x50c2 <__vector_39+0x258>
                //printf("\nnewtrans");
                flag |= _BV(TWSTA);
    50ac:	80 91 bb 1f 	lds	r24, 0x1FBB	; 0x801fbb <flag.3116>
    50b0:	80 62       	ori	r24, 0x20	; 32
    50b2:	80 93 bb 1f 	sts	0x1FBB, r24	; 0x801fbb <flag.3116>
                i2c_busy = 1;
    50b6:	81 e0       	ldi	r24, 0x01	; 1
    50b8:	90 e0       	ldi	r25, 0x00	; 0
    50ba:	90 93 be 1f 	sts	0x1FBE, r25	; 0x801fbe <i2c_busy+0x1>
    50be:	80 93 bd 1f 	sts	0x1FBD, r24	; 0x801fbd <i2c_busy>
            }

        }

        if (i2cflag == 0) {
    50c2:	80 91 d2 1f 	lds	r24, 0x1FD2	; 0x801fd2 <i2cflag>
    50c6:	90 91 d3 1f 	lds	r25, 0x1FD3	; 0x801fd3 <i2cflag+0x1>
    50ca:	89 2b       	or	r24, r25
    50cc:	71 f4       	brne	.+28     	; 0x50ea <__vector_39+0x280>
            //printf("\nwake");
            //printf("--- I2C interrupt done ---\r\n\r\n");

            xTaskWoken = xTaskResumeFromISR(I2C_task);
    50ce:	80 91 26 20 	lds	r24, 0x2026	; 0x802026 <I2C_task>
    50d2:	90 91 27 20 	lds	r25, 0x2027	; 0x802027 <I2C_task+0x1>
    50d6:	0e 94 86 0f 	call	0x1f0c	; 0x1f0c <xTaskResumeFromISR>
    50da:	80 93 bc 1f 	sts	0x1FBC, r24	; 0x801fbc <xTaskWoken.3115>
            i2cflag = 1;
    50de:	81 e0       	ldi	r24, 0x01	; 1
    50e0:	90 e0       	ldi	r25, 0x00	; 0
    50e2:	90 93 d3 1f 	sts	0x1FD3, r25	; 0x801fd3 <i2cflag+0x1>
    50e6:	80 93 d2 1f 	sts	0x1FD2, r24	; 0x801fd2 <i2cflag>
        }

        rx_frame = NULL;
    50ea:	10 92 d1 1f 	sts	0x1FD1, r1	; 0x801fd1 <rx_frame+0x1>
    50ee:	10 92 d0 1f 	sts	0x1FD0, r1	; 0x801fd0 <rx_frame>
        flag2 = _BV(TWEA);
    50f2:	80 e4       	ldi	r24, 0x40	; 64
    50f4:	80 93 ba 1f 	sts	0x1FBA, r24	; 0x801fba <flag2.3117>

        break;
    50f8:	45 c1       	rjmp	.+650    	; 0x5384 <__vector_39+0x51a>
    /* Frame START has been signalled */
    case TW_START: 							// 0x08 START has been transmitted
    case TW_REP_START: 				// 0x10 Repeated START has been transmitted
        //printf("\nMaster Transmit -- Start");

        i2c_busy = 1;
    50fa:	81 e0       	ldi	r24, 0x01	; 1
    50fc:	90 e0       	ldi	r25, 0x00	; 0
    50fe:	90 93 be 1f 	sts	0x1FBE, r25	; 0x801fbe <i2c_busy+0x1>
    5102:	80 93 bd 1f 	sts	0x1FBD, r24	; 0x801fbd <i2c_busy>

        /* First check if the previous frame was completed */
        if (tx_frame == NULL) {
    5106:	80 91 ce 1f 	lds	r24, 0x1FCE	; 0x801fce <tx_frame>
    510a:	90 91 cf 1f 	lds	r25, 0x1FCF	; 0x801fcf <tx_frame+0x1>
    510e:	89 2b       	or	r24, r25
    5110:	b1 f4       	brne	.+44     	; 0x513e <__vector_39+0x2d4>

            /* Receive next frame for transmission */
            if (xQueueReceiveFromISR(tx_queue, &tx_frame,
    5112:	4c eb       	ldi	r20, 0xBC	; 188
    5114:	5f e1       	ldi	r21, 0x1F	; 31
    5116:	6e ec       	ldi	r22, 0xCE	; 206
    5118:	7f e1       	ldi	r23, 0x1F	; 31
    511a:	80 91 cc 1f 	lds	r24, 0x1FCC	; 0x801fcc <tx_queue>
    511e:	90 91 cd 1f 	lds	r25, 0x1FCD	; 0x801fcd <tx_queue+0x1>
    5122:	0e 94 9c 0d 	call	0x1b38	; 0x1b38 <xQueueReceiveFromISR>
    5126:	81 11       	cpse	r24, r1
    5128:	06 c0       	rjmp	.+12     	; 0x5136 <__vector_39+0x2cc>
                                     &xTaskWoken) == pdFALSE) {

                TWCR |= _BV(TWSTO);
    512a:	ec eb       	ldi	r30, 0xBC	; 188
    512c:	f0 e0       	ldi	r31, 0x00	; 0
    512e:	80 81       	ld	r24, Z
    5130:	80 61       	ori	r24, 0x10	; 16
    5132:	80 83       	st	Z, r24
                break;
    5134:	27 c1       	rjmp	.+590    	; 0x5384 <__vector_39+0x51a>
            }

            /* Reset counter */
            tx_cnt = 0;
    5136:	10 92 c7 1f 	sts	0x1FC7, r1	; 0x801fc7 <tx_cnt+0x1>
    513a:	10 92 c6 1f 	sts	0x1FC6, r1	; 0x801fc6 <tx_cnt>

        }

        /* Send destination addr */
        TWDR = tx_frame->dest << 1;
    513e:	e0 91 ce 1f 	lds	r30, 0x1FCE	; 0x801fce <tx_frame>
    5142:	f0 91 cf 1f 	lds	r31, 0x1FCF	; 0x801fcf <tx_frame+0x1>
    5146:	86 81       	ldd	r24, Z+6	; 0x06
    5148:	88 0f       	add	r24, r24
    514a:	80 93 bb 00 	sts	0x00BB, r24	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7000bb>
        flag2 = _BV(TWEA);
    514e:	80 e4       	ldi	r24, 0x40	; 64
    5150:	80 93 ba 1f 	sts	0x1FBA, r24	; 0x801fba <flag2.3117>

        break;
    5154:	17 c1       	rjmp	.+558    	; 0x5384 <__vector_39+0x51a>
    /* Data ACK */
    case TW_MT_SLA_ACK: 		// 0x18 SLA+W has been transmitted, ACK received
    case TW_MT_DATA_ACK: // 0x28 Data byte has been transmitted,  ACK received
        //printf("\nMaster Transmit -- ACK received");

        i2c_busy = 1;
    5156:	81 e0       	ldi	r24, 0x01	; 1
    5158:	90 e0       	ldi	r25, 0x00	; 0
    515a:	90 93 be 1f 	sts	0x1FBE, r25	; 0x801fbe <i2c_busy+0x1>
    515e:	80 93 bd 1f 	sts	0x1FBD, r24	; 0x801fbd <i2c_busy>

        /* If there is data left in the tx_frame */
        if (tx_frame != NULL && tx_cnt < tx_frame->len) {
    5162:	80 91 ce 1f 	lds	r24, 0x1FCE	; 0x801fce <tx_frame>
    5166:	90 91 cf 1f 	lds	r25, 0x1FCF	; 0x801fcf <tx_frame+0x1>
    516a:	00 97       	sbiw	r24, 0x00	; 0
    516c:	61 f1       	breq	.+88     	; 0x51c6 <__vector_39+0x35c>
    516e:	20 91 c6 1f 	lds	r18, 0x1FC6	; 0x801fc6 <tx_cnt>
    5172:	30 91 c7 1f 	lds	r19, 0x1FC7	; 0x801fc7 <tx_cnt+0x1>
    5176:	fc 01       	movw	r30, r24
    5178:	40 85       	ldd	r20, Z+8	; 0x08
    517a:	51 85       	ldd	r21, Z+9	; 0x09
    517c:	24 17       	cp	r18, r20
    517e:	35 07       	cpc	r19, r21
    5180:	e0 f4       	brcc	.+56     	; 0x51ba <__vector_39+0x350>
            TWDR = *(tx_frame->data + tx_cnt);
    5182:	20 91 c6 1f 	lds	r18, 0x1FC6	; 0x801fc6 <tx_cnt>
    5186:	30 91 c7 1f 	lds	r19, 0x1FC7	; 0x801fc7 <tx_cnt+0x1>
    518a:	e2 0f       	add	r30, r18
    518c:	f3 1f       	adc	r31, r19
    518e:	82 85       	ldd	r24, Z+10	; 0x0a
    5190:	80 93 bb 00 	sts	0x00BB, r24	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7000bb>
            tx_cnt++;
    5194:	80 91 c6 1f 	lds	r24, 0x1FC6	; 0x801fc6 <tx_cnt>
    5198:	90 91 c7 1f 	lds	r25, 0x1FC7	; 0x801fc7 <tx_cnt+0x1>
    519c:	01 96       	adiw	r24, 0x01	; 1
    519e:	90 93 c7 1f 	sts	0x1FC7, r25	; 0x801fc7 <tx_cnt+0x1>
    51a2:	80 93 c6 1f 	sts	0x1FC6, r24	; 0x801fc6 <tx_cnt>
            flag2 = _BV(TWEA);
    51a6:	80 e4       	ldi	r24, 0x40	; 64
    51a8:	80 93 ba 1f 	sts	0x1FBA, r24	; 0x801fba <flag2.3117>

            break;
    51ac:	eb c0       	rjmp	.+470    	; 0x5384 <__vector_39+0x51a>
    case TW_MT_DATA_NACK: 				// 0x30 Data transmitted, NACK returned

        //printf("\nMaster Transmit -- NACK return");

        /* Clear TX frame */
        if (tx_frame != NULL) {
    51ae:	80 91 ce 1f 	lds	r24, 0x1FCE	; 0x801fce <tx_frame>
    51b2:	90 91 cf 1f 	lds	r25, 0x1FCF	; 0x801fcf <tx_frame+0x1>
    51b6:	00 97       	sbiw	r24, 0x00	; 0
    51b8:	31 f0       	breq	.+12     	; 0x51c6 <__vector_39+0x35c>
            //printf("\nMaster Transmit -- NACK returned, clear tx frame");

            csp_buffer_free_isr(tx_frame);
    51ba:	0e 94 54 16 	call	0x2ca8	; 0x2ca8 <csp_buffer_free_isr>

            tx_frame = NULL;
    51be:	10 92 cf 1f 	sts	0x1FCF, r1	; 0x801fcf <tx_frame+0x1>
    51c2:	10 92 ce 1f 	sts	0x1FCE, r1	; 0x801fce <tx_frame>
        }

        /* Try new transmission */
        if (uxQueueMessagesWaitingFromISR(tx_queue) > 0) {
    51c6:	80 91 cc 1f 	lds	r24, 0x1FCC	; 0x801fcc <tx_queue>
    51ca:	90 91 cd 1f 	lds	r25, 0x1FCD	; 0x801fcd <tx_queue+0x1>
    51ce:	0e 94 d9 0d 	call	0x1bb2	; 0x1bb2 <uxQueueMessagesWaitingFromISR>
    51d2:	88 23       	and	r24, r24
    51d4:	61 f0       	breq	.+24     	; 0x51ee <__vector_39+0x384>

            /* Set START condition */
            flag |= _BV(TWSTA);
            flag |= _BV(TWSTO);
    51d6:	80 91 bb 1f 	lds	r24, 0x1FBB	; 0x801fbb <flag.3116>
    51da:	80 63       	ori	r24, 0x30	; 48
    51dc:	80 93 bb 1f 	sts	0x1FBB, r24	; 0x801fbb <flag.3116>
            i2c_busy = 1;
    51e0:	81 e0       	ldi	r24, 0x01	; 1
    51e2:	90 e0       	ldi	r25, 0x00	; 0
    51e4:	90 93 be 1f 	sts	0x1FBE, r25	; 0x801fbe <i2c_busy+0x1>
    51e8:	80 93 bd 1f 	sts	0x1FBD, r24	; 0x801fbd <i2c_busy>
    51ec:	09 c0       	rjmp	.+18     	; 0x5200 <__vector_39+0x396>
        }
        else {
            /* Set STOP condition */
            flag |= _BV(TWSTO);
    51ee:	80 91 bb 1f 	lds	r24, 0x1FBB	; 0x801fbb <flag.3116>
    51f2:	80 61       	ori	r24, 0x10	; 16
    51f4:	80 93 bb 1f 	sts	0x1FBB, r24	; 0x801fbb <flag.3116>
            i2c_busy = 0;
    51f8:	10 92 be 1f 	sts	0x1FBE, r1	; 0x801fbe <i2c_busy+0x1>
    51fc:	10 92 bd 1f 	sts	0x1FBD, r1	; 0x801fbd <i2c_busy>
        }

        flag2 = _BV(TWEA);
    5200:	80 e4       	ldi	r24, 0x40	; 64
    5202:	80 93 ba 1f 	sts	0x1FBA, r24	; 0x801fba <flag2.3117>

        break;
    5206:	be c0       	rjmp	.+380    	; 0x5384 <__vector_39+0x51a>

    case TW_MT_ARB_LOST: 		// 0x38 Arbitration lost, return to slave mode.
        //printf("\nf");


        tx_cnt = 0;
    5208:	10 92 c7 1f 	sts	0x1FC7, r1	; 0x801fc7 <tx_cnt+0x1>
    520c:	10 92 c6 1f 	sts	0x1FC6, r1	; 0x801fc6 <tx_cnt>
        flag |= _BV(TWSTA);
    5210:	80 e2       	ldi	r24, 0x20	; 32
    5212:	80 93 bb 1f 	sts	0x1FBB, r24	; 0x801fbb <flag.3116>
        i2c_busy = 1;
    5216:	81 e0       	ldi	r24, 0x01	; 1
    5218:	90 e0       	ldi	r25, 0x00	; 0
    521a:	90 93 be 1f 	sts	0x1FBE, r25	; 0x801fbe <i2c_busy+0x1>
    521e:	80 93 bd 1f 	sts	0x1FBD, r24	; 0x801fbd <i2c_busy>
        flag2 = _BV(TWEA);
    5222:	80 e4       	ldi	r24, 0x40	; 64
    5224:	80 93 ba 1f 	sts	0x1FBA, r24	; 0x801fba <flag2.3117>

        break;
    5228:	ad c0       	rjmp	.+346    	; 0x5384 <__vector_39+0x51a>


    case TW_MR_SLA_ACK:					// 0x40 SLA+R transmitted, ACK received
        //printf("\nslark");

        i2c_busy = 1;
    522a:	81 e0       	ldi	r24, 0x01	; 1
    522c:	90 e0       	ldi	r25, 0x00	; 0
    522e:	90 93 be 1f 	sts	0x1FBE, r25	; 0x801fbe <i2c_busy+0x1>
    5232:	80 93 bd 1f 	sts	0x1FBD, r24	; 0x801fbd <i2c_busy>
        flag &= ~((1 << TWSTA) | (1 << TWSTO));
        flag2 = _BV(TWEA);
    5236:	80 e4       	ldi	r24, 0x40	; 64
    5238:	80 93 ba 1f 	sts	0x1FBA, r24	; 0x801fba <flag2.3117>

        break;
    523c:	a3 c0       	rjmp	.+326    	; 0x5384 <__vector_39+0x51a>

    case TW_MR_DATA_ACK:					// 0x50 Data received, ACK returned
        //printf("\ndark");

        i2c_busy = 1;
    523e:	81 e0       	ldi	r24, 0x01	; 1
    5240:	90 e0       	ldi	r25, 0x00	; 0
    5242:	90 93 be 1f 	sts	0x1FBE, r25	; 0x801fbe <i2c_busy+0x1>
    5246:	80 93 bd 1f 	sts	0x1FBD, r24	; 0x801fbd <i2c_busy>


        if (rx_frame != NULL && rx_cnt < rx_frame->len) {
    524a:	e0 91 d0 1f 	lds	r30, 0x1FD0	; 0x801fd0 <rx_frame>
    524e:	f0 91 d1 1f 	lds	r31, 0x1FD1	; 0x801fd1 <rx_frame+0x1>
    5252:	30 97       	sbiw	r30, 0x00	; 0
    5254:	f9 f0       	breq	.+62     	; 0x5294 <__vector_39+0x42a>
    5256:	80 91 c4 1f 	lds	r24, 0x1FC4	; 0x801fc4 <rx_cnt>
    525a:	90 91 c5 1f 	lds	r25, 0x1FC5	; 0x801fc5 <rx_cnt+0x1>
    525e:	20 85       	ldd	r18, Z+8	; 0x08
    5260:	31 85       	ldd	r19, Z+9	; 0x09
    5262:	82 17       	cp	r24, r18
    5264:	93 07       	cpc	r25, r19
    5266:	b0 f4       	brcc	.+44     	; 0x5294 <__vector_39+0x42a>
            *(rx_frame->data + rx_cnt) = TWDR;
    5268:	80 91 c4 1f 	lds	r24, 0x1FC4	; 0x801fc4 <rx_cnt>
    526c:	90 91 c5 1f 	lds	r25, 0x1FC5	; 0x801fc5 <rx_cnt+0x1>
    5270:	20 91 bb 00 	lds	r18, 0x00BB	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7000bb>
    5274:	e8 0f       	add	r30, r24
    5276:	f9 1f       	adc	r31, r25
    5278:	22 87       	std	Z+10, r18	; 0x0a
            rx_cnt++;
    527a:	80 91 c4 1f 	lds	r24, 0x1FC4	; 0x801fc4 <rx_cnt>
    527e:	90 91 c5 1f 	lds	r25, 0x1FC5	; 0x801fc5 <rx_cnt+0x1>
    5282:	01 96       	adiw	r24, 0x01	; 1
    5284:	90 93 c5 1f 	sts	0x1FC5, r25	; 0x801fc5 <rx_cnt+0x1>
    5288:	80 93 c4 1f 	sts	0x1FC4, r24	; 0x801fc4 <rx_cnt>
            flag2 = _BV(TWEA);
    528c:	80 e4       	ldi	r24, 0x40	; 64
    528e:	80 93 ba 1f 	sts	0x1FBA, r24	; 0x801fba <flag2.3117>

            break;
    5292:	78 c0       	rjmp	.+240    	; 0x5384 <__vector_39+0x51a>
//		}


    case TW_MR_SLA_NACK:				// 0x48 SLA+R transmitted, NACK received
        //printf("\nslnak");
        flag |= _BV(TWSTA);
    5294:	80 e2       	ldi	r24, 0x20	; 32
    5296:	80 93 bb 1f 	sts	0x1FBB, r24	; 0x801fbb <flag.3116>
        flag2 = _BV(TWEA);
    529a:	80 e4       	ldi	r24, 0x40	; 64
    529c:	80 93 ba 1f 	sts	0x1FBA, r24	; 0x801fba <flag2.3117>

        break;
    52a0:	71 c0       	rjmp	.+226    	; 0x5384 <__vector_39+0x51a>
    case TW_MR_DATA_NACK:					// 0x58 Data received, NACK returned

//		/* Clear TX frame */
        //printf("\ndatnak");

        if (rx_frame != NULL) {
    52a2:	80 91 d0 1f 	lds	r24, 0x1FD0	; 0x801fd0 <rx_frame>
    52a6:	90 91 d1 1f 	lds	r25, 0x1FD1	; 0x801fd1 <rx_frame+0x1>
    52aa:	89 2b       	or	r24, r25
    52ac:	41 f0       	breq	.+16     	; 0x52be <__vector_39+0x454>
//			for(int i=0; i<rx_cnt; i++){
//				receive_frame.data[i]= rx_frame->data[i];
//			}
            //printf("\ntried");
            rx_frame = NULL;
    52ae:	10 92 d1 1f 	sts	0x1FD1, r1	; 0x801fd1 <rx_frame+0x1>
    52b2:	10 92 d0 1f 	sts	0x1FD0, r1	; 0x801fd0 <rx_frame>
            rx_cnt = 0;
    52b6:	10 92 c5 1f 	sts	0x1FC5, r1	; 0x801fc5 <rx_cnt+0x1>
    52ba:	10 92 c4 1f 	sts	0x1FC4, r1	; 0x801fc4 <rx_cnt>
        }

        /* Set STOP condition */
        flag |= _BV(TWSTO);
    52be:	80 e1       	ldi	r24, 0x10	; 16
    52c0:	80 93 bb 1f 	sts	0x1FBB, r24	; 0x801fbb <flag.3116>
        i2c_busy = 0;
    52c4:	10 92 be 1f 	sts	0x1FBE, r1	; 0x801fbe <i2c_busy+0x1>
    52c8:	10 92 bd 1f 	sts	0x1FBD, r1	; 0x801fbd <i2c_busy>
        flag2 = _BV(TWEA);
    52cc:	80 e4       	ldi	r24, 0x40	; 64
    52ce:	80 93 ba 1f 	sts	0x1FBA, r24	; 0x801fba <flag2.3117>

        break;
    52d2:	58 c0       	rjmp	.+176    	; 0x5384 <__vector_39+0x51a>
        TWI ERROR EVENTS
    */
    case TW_BUS_ERROR: 								// 0x00 Bus error

    default:
        printf("\nh");
    52d4:	84 ed       	ldi	r24, 0xD4	; 212
    52d6:	9d e0       	ldi	r25, 0x0D	; 13
    52d8:	9f 93       	push	r25
    52da:	8f 93       	push	r24
    52dc:	1e d3       	rcall	.+1596   	; 0x591a <printf_P>

        if (tx_frame != NULL) {
    52de:	80 91 ce 1f 	lds	r24, 0x1FCE	; 0x801fce <tx_frame>
    52e2:	90 91 cf 1f 	lds	r25, 0x1FCF	; 0x801fcf <tx_frame+0x1>
    52e6:	0f 90       	pop	r0
    52e8:	0f 90       	pop	r0
    52ea:	00 97       	sbiw	r24, 0x00	; 0
    52ec:	31 f0       	breq	.+12     	; 0x52fa <__vector_39+0x490>
            //printf("\ntried");

            csp_buffer_free_isr(tx_frame);
    52ee:	0e 94 54 16 	call	0x2ca8	; 0x2ca8 <csp_buffer_free_isr>
            tx_frame = NULL;
    52f2:	10 92 cf 1f 	sts	0x1FCF, r1	; 0x801fcf <tx_frame+0x1>
    52f6:	10 92 ce 1f 	sts	0x1FCE, r1	; 0x801fce <tx_frame>
        }

        if (rx_frame != NULL) {
    52fa:	80 91 d0 1f 	lds	r24, 0x1FD0	; 0x801fd0 <rx_frame>
    52fe:	90 91 d1 1f 	lds	r25, 0x1FD1	; 0x801fd1 <rx_frame+0x1>
    5302:	00 97       	sbiw	r24, 0x00	; 0
    5304:	31 f0       	breq	.+12     	; 0x5312 <__vector_39+0x4a8>
            //printf("\ntried");

            csp_buffer_free_isr(rx_frame);
    5306:	0e 94 54 16 	call	0x2ca8	; 0x2ca8 <csp_buffer_free_isr>
            rx_frame = NULL;
    530a:	10 92 d1 1f 	sts	0x1FD1, r1	; 0x801fd1 <rx_frame+0x1>
    530e:	10 92 d0 1f 	sts	0x1FD0, r1	; 0x801fd0 <rx_frame>
        }

        TWCR = 0; // Reset TWI hardware
    5312:	0c eb       	ldi	r16, 0xBC	; 188
    5314:	10 e0       	ldi	r17, 0x00	; 0
    5316:	f8 01       	movw	r30, r16
    5318:	10 82       	st	Z, r1
        TWBR = BITRATE(i2c_speed); // Set bit rate register
    531a:	c0 91 b9 00 	lds	r28, 0x00B9	; 0x8000b9 <__TEXT_REGION_LENGTH__+0x7000b9>
    531e:	20 91 c0 1f 	lds	r18, 0x1FC0	; 0x801fc0 <i2c_speed>
    5322:	30 91 c1 1f 	lds	r19, 0x1FC1	; 0x801fc1 <i2c_speed+0x1>
    5326:	a0 ed       	ldi	r26, 0xD0	; 208
    5328:	b7 e0       	ldi	r27, 0x07	; 7
    532a:	22 d2       	rcall	.+1092   	; 0x5770 <__umulhisi3>
    532c:	9b 01       	movw	r18, r22
    532e:	ac 01       	movw	r20, r24
    5330:	60 e0       	ldi	r22, 0x00	; 0
    5332:	74 e2       	ldi	r23, 0x24	; 36
    5334:	84 ef       	ldi	r24, 0xF4	; 244
    5336:	90 e0       	ldi	r25, 0x00	; 0
    5338:	f1 d1       	rcall	.+994    	; 0x571c <__udivmodsi4>
    533a:	ca 01       	movw	r24, r20
    533c:	b9 01       	movw	r22, r18
    533e:	68 50       	subi	r22, 0x08	; 8
    5340:	71 09       	sbc	r23, r1
    5342:	81 09       	sbc	r24, r1
    5344:	91 09       	sbc	r25, r1
    5346:	c3 70       	andi	r28, 0x03	; 3
    5348:	cc 0f       	add	r28, r28
    534a:	21 e0       	ldi	r18, 0x01	; 1
    534c:	30 e0       	ldi	r19, 0x00	; 0
    534e:	02 c0       	rjmp	.+4      	; 0x5354 <__vector_39+0x4ea>
    5350:	22 0f       	add	r18, r18
    5352:	33 1f       	adc	r19, r19
    5354:	ca 95       	dec	r28
    5356:	e2 f7       	brpl	.-8      	; 0x5350 <__vector_39+0x4e6>
    5358:	03 2e       	mov	r0, r19
    535a:	00 0c       	add	r0, r0
    535c:	44 0b       	sbc	r20, r20
    535e:	55 0b       	sbc	r21, r21
    5360:	dd d1       	rcall	.+954    	; 0x571c <__udivmodsi4>
    5362:	20 93 b8 00 	sts	0x00B8, r18	; 0x8000b8 <__TEXT_REGION_LENGTH__+0x7000b8>
        TWAR = i2c_addr << 1; // Set slave address in the two wire address register
    5366:	80 91 bf 1f 	lds	r24, 0x1FBF	; 0x801fbf <i2c_addr>
    536a:	88 0f       	add	r24, r24
    536c:	80 93 ba 00 	sts	0x00BA, r24	; 0x8000ba <__TEXT_REGION_LENGTH__+0x7000ba>
        TWCR = _BV(TWEA) | _BV(TWEN) | _BV(TWIE); // Enable acknowledge, twi and interrupts
    5370:	85 e4       	ldi	r24, 0x45	; 69
    5372:	f8 01       	movw	r30, r16
    5374:	80 83       	st	Z, r24
        flag2 = _BV(TWEA);
    5376:	80 e4       	ldi	r24, 0x40	; 64
    5378:	80 93 ba 1f 	sts	0x1FBA, r24	; 0x801fba <flag2.3117>
        i2c_busy = 0;
    537c:	10 92 be 1f 	sts	0x1FBE, r1	; 0x801fbe <i2c_busy+0x1>
    5380:	10 92 bd 1f 	sts	0x1FBD, r1	; 0x801fbd <i2c_busy>
        break;
    }



    TWCR = flag | _BV(TWEN) | _BV(TWIE) | _BV(TWINT);
    5384:	80 91 bb 1f 	lds	r24, 0x1FBB	; 0x801fbb <flag.3116>
    5388:	85 68       	ori	r24, 0x85	; 133
    538a:	ec eb       	ldi	r30, 0xBC	; 188
    538c:	f0 e0       	ldi	r31, 0x00	; 0
    538e:	80 83       	st	Z, r24
    TWCR |= flag2;
    5390:	90 81       	ld	r25, Z
    5392:	80 91 ba 1f 	lds	r24, 0x1FBA	; 0x801fba <flag2.3117>
    5396:	89 2b       	or	r24, r25
    5398:	80 83       	st	Z, r24

    if (xTaskWoken == pdTRUE) {
    539a:	80 91 bc 1f 	lds	r24, 0x1FBC	; 0x801fbc <xTaskWoken.3115>
    539e:	81 30       	cpi	r24, 0x01	; 1
    53a0:	11 f4       	brne	.+4      	; 0x53a6 <__vector_39+0x53c>
        taskYIELD();
    53a2:	0e 94 fb 09 	call	0x13f6	; 0x13f6 <vPortYield>
    }
}
    53a6:	ff 91       	pop	r31
    53a8:	ef 91       	pop	r30
    53aa:	cf 91       	pop	r28
    53ac:	bf 91       	pop	r27
    53ae:	af 91       	pop	r26
    53b0:	9f 91       	pop	r25
    53b2:	8f 91       	pop	r24
    53b4:	7f 91       	pop	r23
    53b6:	6f 91       	pop	r22
    53b8:	5f 91       	pop	r21
    53ba:	4f 91       	pop	r20
    53bc:	3f 91       	pop	r19
    53be:	2f 91       	pop	r18
    53c0:	1f 91       	pop	r17
    53c2:	0f 91       	pop	r16
    53c4:	0f 90       	pop	r0
    53c6:	0b be       	out	0x3b, r0	; 59
    53c8:	0f 90       	pop	r0
    53ca:	0f be       	out	0x3f, r0	; 63
    53cc:	0f 90       	pop	r0
    53ce:	1f 90       	pop	r1
    53d0:	18 95       	reti

000053d2 <uart_putchar>:
 * Send character c down the UART Tx, wait until tx holding register
 * is empty.
 */
int
uart_putchar(char c, FILE *stream)
{
    53d2:	cf 93       	push	r28
    53d4:	c8 2f       	mov	r28, r24

  if (c == '\a')
    53d6:	87 30       	cpi	r24, 0x07	; 7
    53d8:	61 f4       	brne	.+24     	; 0x53f2 <uart_putchar+0x20>
    {
      fputs("*ring*\n", stderr);
    53da:	20 91 2c 20 	lds	r18, 0x202C	; 0x80202c <__iob+0x4>
    53de:	30 91 2d 20 	lds	r19, 0x202D	; 0x80202d <__iob+0x5>
    53e2:	47 e0       	ldi	r20, 0x07	; 7
    53e4:	50 e0       	ldi	r21, 0x00	; 0
    53e6:	61 e0       	ldi	r22, 0x01	; 1
    53e8:	70 e0       	ldi	r23, 0x00	; 0
    53ea:	8d eb       	ldi	r24, 0xBD	; 189
    53ec:	93 e0       	ldi	r25, 0x03	; 3
    53ee:	53 d2       	rcall	.+1190   	; 0x5896 <fwrite>
      return 0;
    53f0:	0b c0       	rjmp	.+22     	; 0x5408 <uart_putchar+0x36>
    }

  if (c == '\n')
    53f2:	8a 30       	cpi	r24, 0x0A	; 10
    53f4:	11 f4       	brne	.+4      	; 0x53fa <uart_putchar+0x28>
    uart_putchar('\r', stream);
    53f6:	8d e0       	ldi	r24, 0x0D	; 13
    53f8:	ec df       	rcall	.-40     	; 0x53d2 <uart_putchar>
  loop_until_bit_is_set(UCSR0A, UDRE0);
    53fa:	e0 ec       	ldi	r30, 0xC0	; 192
    53fc:	f0 e0       	ldi	r31, 0x00	; 0
    53fe:	80 81       	ld	r24, Z
    5400:	85 ff       	sbrs	r24, 5
    5402:	fd cf       	rjmp	.-6      	; 0x53fe <uart_putchar+0x2c>
  UDR0 = c;
    5404:	c0 93 c6 00 	sts	0x00C6, r28	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7000c6>

  return 0;
}
    5408:	80 e0       	ldi	r24, 0x00	; 0
    540a:	90 e0       	ldi	r25, 0x00	; 0
    540c:	cf 91       	pop	r28
    540e:	08 95       	ret

00005410 <uart_getchar>:
 * Successive calls to uart_getchar() will be satisfied from the
 * internal buffer until that buffer is emptied again.
 */
int
uart_getchar(FILE *stream)
{
    5410:	6f 92       	push	r6
    5412:	7f 92       	push	r7
    5414:	8f 92       	push	r8
    5416:	9f 92       	push	r9
    5418:	af 92       	push	r10
    541a:	bf 92       	push	r11
    541c:	cf 92       	push	r12
    541e:	df 92       	push	r13
    5420:	ef 92       	push	r14
    5422:	ff 92       	push	r15
    5424:	0f 93       	push	r16
    5426:	1f 93       	push	r17
    5428:	cf 93       	push	r28
    542a:	df 93       	push	r29
  uint8_t c;
  char *cp, *cp2;
  static char b[RX_BUFSIZE];
  static char *rxp;

  if (rxp == 0)
    542c:	20 91 24 20 	lds	r18, 0x2024	; 0x802024 <rxp.2118>
    5430:	30 91 25 20 	lds	r19, 0x2025	; 0x802025 <rxp.2118+0x1>
    5434:	23 2b       	or	r18, r19
    5436:	09 f0       	breq	.+2      	; 0x543a <uart_getchar+0x2a>
    5438:	cc c0       	rjmp	.+408    	; 0x55d2 <uart_getchar+0x1c2>
    543a:	8c 01       	movw	r16, r24
    543c:	0f 2e       	mov	r0, r31
    543e:	f4 ed       	ldi	r31, 0xD4	; 212
    5440:	8f 2e       	mov	r8, r31
    5442:	ff e1       	ldi	r31, 0x1F	; 31
    5444:	9f 2e       	mov	r9, r31
    5446:	f0 2d       	mov	r31, r0
    for (cp = b;;)
      {
	loop_until_bit_is_set(UCSR0A, RXC0);
    5448:	c0 ec       	ldi	r28, 0xC0	; 192
    544a:	d0 e0       	ldi	r29, 0x00	; 0
	if (UCSR0A & _BV(FE0))
	  return _FDEV_EOF;
	if (UCSR0A & _BV(DOR0))
	  return _FDEV_ERR;
	c = UDR0;
    544c:	0f 2e       	mov	r0, r31
    544e:	f6 ec       	ldi	r31, 0xC6	; 198
    5450:	cf 2e       	mov	r12, r31
    5452:	d1 2c       	mov	r13, r1
    5454:	f0 2d       	mov	r31, r0
    5456:	54 01       	movw	r10, r8
    5458:	0f 2e       	mov	r0, r31
    545a:	f3 ed       	ldi	r31, 0xD3	; 211
    545c:	6f 2e       	mov	r6, r31
    545e:	ff e1       	ldi	r31, 0x1F	; 31
    5460:	7f 2e       	mov	r7, r31
    5462:	f0 2d       	mov	r31, r0
  static char *rxp;

  if (rxp == 0)
    for (cp = b;;)
      {
	loop_until_bit_is_set(UCSR0A, RXC0);
    5464:	88 81       	ld	r24, Y
    5466:	88 23       	and	r24, r24
    5468:	ec f7       	brge	.-6      	; 0x5464 <uart_getchar+0x54>
	if (UCSR0A & _BV(FE0))
    546a:	88 81       	ld	r24, Y
    546c:	84 fd       	sbrc	r24, 4
    546e:	c4 c0       	rjmp	.+392    	; 0x55f8 <uart_getchar+0x1e8>
	  return _FDEV_EOF;
	if (UCSR0A & _BV(DOR0))
    5470:	88 81       	ld	r24, Y
    5472:	83 fd       	sbrc	r24, 3
    5474:	c4 c0       	rjmp	.+392    	; 0x55fe <uart_getchar+0x1ee>
	  return _FDEV_ERR;
	c = UDR0;
    5476:	f6 01       	movw	r30, r12
    5478:	80 81       	ld	r24, Z
	/* behaviour similar to Unix stty ICRNL */
	if (c == '\r')
    547a:	8d 30       	cpi	r24, 0x0D	; 13
    547c:	11 f0       	breq	.+4      	; 0x5482 <uart_getchar+0x72>
	  c = '\n';
	if (c == '\n')
    547e:	8a 30       	cpi	r24, 0x0A	; 10
    5480:	61 f4       	brne	.+24     	; 0x549a <uart_getchar+0x8a>
	  {
	    *cp = c;
    5482:	8a e0       	ldi	r24, 0x0A	; 10
    5484:	f4 01       	movw	r30, r8
    5486:	80 83       	st	Z, r24
	    uart_putchar(c, stream);
    5488:	b8 01       	movw	r22, r16
    548a:	a3 df       	rcall	.-186    	; 0x53d2 <uart_putchar>
	    rxp = b;
    548c:	84 ed       	ldi	r24, 0xD4	; 212
    548e:	9f e1       	ldi	r25, 0x1F	; 31
    5490:	90 93 25 20 	sts	0x2025, r25	; 0x802025 <rxp.2118+0x1>
    5494:	80 93 24 20 	sts	0x2024, r24	; 0x802024 <rxp.2118>
	    break;
    5498:	9c c0       	rjmp	.+312    	; 0x55d2 <uart_getchar+0x1c2>
	  }
	else if (c == '\t')
    549a:	89 30       	cpi	r24, 0x09	; 9
    549c:	39 f0       	breq	.+14     	; 0x54ac <uart_getchar+0x9c>
	  c = ' ';

	if ((c >= (uint8_t)' ' && c <= (uint8_t)'\x7e') ||
    549e:	90 ee       	ldi	r25, 0xE0	; 224
    54a0:	98 0f       	add	r25, r24
    54a2:	9f 35       	cpi	r25, 0x5F	; 95
    54a4:	20 f0       	brcs	.+8      	; 0x54ae <uart_getchar+0x9e>
    54a6:	80 3a       	cpi	r24, 0xA0	; 160
    54a8:	a8 f0       	brcs	.+42     	; 0x54d4 <uart_getchar+0xc4>
    54aa:	01 c0       	rjmp	.+2      	; 0x54ae <uart_getchar+0x9e>
	    uart_putchar(c, stream);
	    rxp = b;
	    break;
	  }
	else if (c == '\t')
	  c = ' ';
    54ac:	80 e2       	ldi	r24, 0x20	; 32

	if ((c >= (uint8_t)' ' && c <= (uint8_t)'\x7e') ||
	    c >= (uint8_t)'\xa0')
	  {
	    if (cp == b + RX_BUFSIZE - 1)
    54ae:	f3 e2       	ldi	r31, 0x23	; 35
    54b0:	8f 16       	cp	r8, r31
    54b2:	f0 e2       	ldi	r31, 0x20	; 32
    54b4:	9f 06       	cpc	r9, r31
    54b6:	21 f4       	brne	.+8      	; 0x54c0 <uart_getchar+0xb0>
	      uart_putchar('\a', stream);
    54b8:	b8 01       	movw	r22, r16
    54ba:	87 e0       	ldi	r24, 0x07	; 7
    54bc:	8a df       	rcall	.-236    	; 0x53d2 <uart_putchar>
    54be:	d2 cf       	rjmp	.-92     	; 0x5464 <uart_getchar+0x54>
	    else
	      {
		*cp++ = c;
    54c0:	74 01       	movw	r14, r8
    54c2:	9f ef       	ldi	r25, 0xFF	; 255
    54c4:	e9 1a       	sub	r14, r25
    54c6:	f9 0a       	sbc	r15, r25
    54c8:	f4 01       	movw	r30, r8
		uart_putchar(c, stream);
    54ca:	80 83       	st	Z, r24
    54cc:	b8 01       	movw	r22, r16
    54ce:	81 df       	rcall	.-254    	; 0x53d2 <uart_putchar>
	  {
	    if (cp == b + RX_BUFSIZE - 1)
	      uart_putchar('\a', stream);
	    else
	      {
		*cp++ = c;
    54d0:	47 01       	movw	r8, r14
    54d2:	c8 cf       	rjmp	.-112    	; 0x5464 <uart_getchar+0x54>
		uart_putchar(c, stream);
	      }
	    continue;
	  }

	switch (c)
    54d4:	82 31       	cpi	r24, 0x12	; 18
    54d6:	b9 f1       	breq	.+110    	; 0x5546 <uart_getchar+0x136>
    54d8:	30 f4       	brcc	.+12     	; 0x54e6 <uart_getchar+0xd6>
    54da:	83 30       	cpi	r24, 0x03	; 3
    54dc:	09 f4       	brne	.+2      	; 0x54e0 <uart_getchar+0xd0>
    54de:	92 c0       	rjmp	.+292    	; 0x5604 <uart_getchar+0x1f4>
    54e0:	88 30       	cpi	r24, 0x08	; 8
    54e2:	e9 f0       	breq	.+58     	; 0x551e <uart_getchar+0x10e>
    54e4:	bf cf       	rjmp	.-130    	; 0x5464 <uart_getchar+0x54>
    54e6:	87 31       	cpi	r24, 0x17	; 23
    54e8:	29 f0       	breq	.+10     	; 0x54f4 <uart_getchar+0xe4>
    54ea:	8f 37       	cpi	r24, 0x7F	; 127
    54ec:	c1 f0       	breq	.+48     	; 0x551e <uart_getchar+0x10e>
    54ee:	85 31       	cpi	r24, 0x15	; 21
    54f0:	79 f0       	breq	.+30     	; 0x5510 <uart_getchar+0x100>
    54f2:	b8 cf       	rjmp	.-144    	; 0x5464 <uart_getchar+0x54>
		cp--;
	      }
	    break;

	  case 'w' & 0x1f:
	    while (cp > b && cp[-1] != ' ')
    54f4:	f4 ed       	ldi	r31, 0xD4	; 212
    54f6:	8f 16       	cp	r8, r31
    54f8:	ff e1       	ldi	r31, 0x1F	; 31
    54fa:	9f 06       	cpc	r9, r31
    54fc:	09 f0       	breq	.+2      	; 0x5500 <uart_getchar+0xf0>
    54fe:	08 f4       	brcc	.+2      	; 0x5502 <uart_getchar+0xf2>
    5500:	b1 cf       	rjmp	.-158    	; 0x5464 <uart_getchar+0x54>
    5502:	f4 01       	movw	r30, r8
    5504:	31 97       	sbiw	r30, 0x01	; 1
    5506:	80 81       	ld	r24, Z
    5508:	80 32       	cpi	r24, 0x20	; 32
    550a:	09 f0       	breq	.+2      	; 0x550e <uart_getchar+0xfe>
    550c:	4a c0       	rjmp	.+148    	; 0x55a2 <uart_getchar+0x192>
    550e:	aa cf       	rjmp	.-172    	; 0x5464 <uart_getchar+0x54>
	    for (cp2 = b; cp2 < cp; cp2++)
	      uart_putchar(*cp2, stream);
	    break;

	  case 'u' & 0x1f:
	    while (cp > b)
    5510:	84 ed       	ldi	r24, 0xD4	; 212
    5512:	88 16       	cp	r8, r24
    5514:	8f e1       	ldi	r24, 0x1F	; 31
    5516:	98 06       	cpc	r9, r24
    5518:	09 f0       	breq	.+2      	; 0x551c <uart_getchar+0x10c>
    551a:	70 f5       	brcc	.+92     	; 0x5578 <uart_getchar+0x168>
    551c:	a3 cf       	rjmp	.-186    	; 0x5464 <uart_getchar+0x54>
	  case 'c' & 0x1f:
	    return -1;

	  case '\b':
	  case '\x7f':
	    if (cp > b)
    551e:	94 ed       	ldi	r25, 0xD4	; 212
    5520:	89 16       	cp	r8, r25
    5522:	9f e1       	ldi	r25, 0x1F	; 31
    5524:	99 06       	cpc	r9, r25
    5526:	09 f0       	breq	.+2      	; 0x552a <uart_getchar+0x11a>
    5528:	08 f4       	brcc	.+2      	; 0x552c <uart_getchar+0x11c>
	      {
		uart_putchar('\b', stream);
    552a:	9c cf       	rjmp	.-200    	; 0x5464 <uart_getchar+0x54>
    552c:	b8 01       	movw	r22, r16
    552e:	88 e0       	ldi	r24, 0x08	; 8
		uart_putchar(' ', stream);
    5530:	50 df       	rcall	.-352    	; 0x53d2 <uart_putchar>
    5532:	b8 01       	movw	r22, r16
    5534:	80 e2       	ldi	r24, 0x20	; 32
		uart_putchar('\b', stream);
    5536:	4d df       	rcall	.-358    	; 0x53d2 <uart_putchar>
    5538:	b8 01       	movw	r22, r16
    553a:	88 e0       	ldi	r24, 0x08	; 8
    553c:	4a df       	rcall	.-364    	; 0x53d2 <uart_putchar>
		cp--;
    553e:	e1 e0       	ldi	r30, 0x01	; 1
    5540:	8e 1a       	sub	r8, r30
    5542:	91 08       	sbc	r9, r1
	      }
	    break;

	  case 'r' & 0x1f:
	    uart_putchar('\r', stream);
    5544:	8f cf       	rjmp	.-226    	; 0x5464 <uart_getchar+0x54>
    5546:	b8 01       	movw	r22, r16
    5548:	8d e0       	ldi	r24, 0x0D	; 13
    554a:	43 df       	rcall	.-378    	; 0x53d2 <uart_putchar>
	    for (cp2 = b; cp2 < cp; cp2++)
    554c:	f4 ed       	ldi	r31, 0xD4	; 212
    554e:	8f 16       	cp	r8, r31
    5550:	ff e1       	ldi	r31, 0x1F	; 31
    5552:	9f 06       	cpc	r9, r31
    5554:	09 f0       	breq	.+2      	; 0x5558 <uart_getchar+0x148>
    5556:	08 f4       	brcc	.+2      	; 0x555a <uart_getchar+0x14a>
    5558:	85 cf       	rjmp	.-246    	; 0x5464 <uart_getchar+0x54>
    555a:	0f 2e       	mov	r0, r31
    555c:	f4 ed       	ldi	r31, 0xD4	; 212
    555e:	ef 2e       	mov	r14, r31
    5560:	ff e1       	ldi	r31, 0x1F	; 31
    5562:	ff 2e       	mov	r15, r31
	      uart_putchar(*cp2, stream);
    5564:	f0 2d       	mov	r31, r0
    5566:	b8 01       	movw	r22, r16
    5568:	f7 01       	movw	r30, r14
    556a:	81 91       	ld	r24, Z+
    556c:	7f 01       	movw	r14, r30
	      }
	    break;

	  case 'r' & 0x1f:
	    uart_putchar('\r', stream);
	    for (cp2 = b; cp2 < cp; cp2++)
    556e:	31 df       	rcall	.-414    	; 0x53d2 <uart_putchar>
    5570:	8e 14       	cp	r8, r14
    5572:	9f 04       	cpc	r9, r15
	    break;

	  case 'u' & 0x1f:
	    while (cp > b)
	      {
		uart_putchar('\b', stream);
    5574:	c1 f7       	brne	.-16     	; 0x5566 <uart_getchar+0x156>
    5576:	76 cf       	rjmp	.-276    	; 0x5464 <uart_getchar+0x54>
    5578:	b8 01       	movw	r22, r16
		uart_putchar(' ', stream);
    557a:	88 e0       	ldi	r24, 0x08	; 8
    557c:	2a df       	rcall	.-428    	; 0x53d2 <uart_putchar>
    557e:	b8 01       	movw	r22, r16
    5580:	80 e2       	ldi	r24, 0x20	; 32
		uart_putchar('\b', stream);
    5582:	27 df       	rcall	.-434    	; 0x53d2 <uart_putchar>
    5584:	b8 01       	movw	r22, r16
    5586:	88 e0       	ldi	r24, 0x08	; 8
    5588:	24 df       	rcall	.-440    	; 0x53d2 <uart_putchar>
		cp--;
    558a:	f1 e0       	ldi	r31, 0x01	; 1
    558c:	8f 1a       	sub	r8, r31
    558e:	91 08       	sbc	r9, r1
	    for (cp2 = b; cp2 < cp; cp2++)
	      uart_putchar(*cp2, stream);
	    break;

	  case 'u' & 0x1f:
	    while (cp > b)
    5590:	84 ed       	ldi	r24, 0xD4	; 212
    5592:	88 16       	cp	r8, r24
    5594:	8f e1       	ldi	r24, 0x1F	; 31
    5596:	98 06       	cpc	r9, r24
    5598:	79 f7       	brne	.-34     	; 0x5578 <uart_getchar+0x168>
    559a:	f3 01       	movw	r30, r6
    559c:	31 96       	adiw	r30, 0x01	; 1
    559e:	4f 01       	movw	r8, r30
    55a0:	61 cf       	rjmp	.-318    	; 0x5464 <uart_getchar+0x54>
    55a2:	74 01       	movw	r14, r8
	    break;

	  case 'w' & 0x1f:
	    while (cp > b && cp[-1] != ' ')
	      {
		uart_putchar('\b', stream);
    55a4:	f1 e0       	ldi	r31, 0x01	; 1
    55a6:	ef 1a       	sub	r14, r31
    55a8:	f1 08       	sbc	r15, r1
    55aa:	b8 01       	movw	r22, r16
		uart_putchar(' ', stream);
    55ac:	88 e0       	ldi	r24, 0x08	; 8
    55ae:	11 df       	rcall	.-478    	; 0x53d2 <uart_putchar>
    55b0:	b8 01       	movw	r22, r16
    55b2:	80 e2       	ldi	r24, 0x20	; 32
		uart_putchar('\b', stream);
    55b4:	0e df       	rcall	.-484    	; 0x53d2 <uart_putchar>
    55b6:	b8 01       	movw	r22, r16
    55b8:	88 e0       	ldi	r24, 0x08	; 8
    55ba:	0b df       	rcall	.-490    	; 0x53d2 <uart_putchar>
		cp--;
    55bc:	47 01       	movw	r8, r14
		cp--;
	      }
	    break;

	  case 'w' & 0x1f:
	    while (cp > b && cp[-1] != ' ')
    55be:	ea 14       	cp	r14, r10
    55c0:	fb 04       	cpc	r15, r11
    55c2:	09 f4       	brne	.+2      	; 0x55c6 <uart_getchar+0x1b6>
    55c4:	4f cf       	rjmp	.-354    	; 0x5464 <uart_getchar+0x54>
    55c6:	f7 01       	movw	r30, r14
    55c8:	82 91       	ld	r24, -Z
    55ca:	7f 01       	movw	r14, r30
    55cc:	80 32       	cpi	r24, 0x20	; 32
    55ce:	69 f7       	brne	.-38     	; 0x55aa <uart_getchar+0x19a>
    55d0:	49 cf       	rjmp	.-366    	; 0x5464 <uart_getchar+0x54>
	      }
	    break;
	  }
      }

  c = *rxp++;
    55d2:	e0 91 24 20 	lds	r30, 0x2024	; 0x802024 <rxp.2118>
    55d6:	f0 91 25 20 	lds	r31, 0x2025	; 0x802025 <rxp.2118+0x1>
    55da:	cf 01       	movw	r24, r30
    55dc:	01 96       	adiw	r24, 0x01	; 1
    55de:	90 93 25 20 	sts	0x2025, r25	; 0x802025 <rxp.2118+0x1>
    55e2:	80 93 24 20 	sts	0x2024, r24	; 0x802024 <rxp.2118>
    55e6:	80 81       	ld	r24, Z
  if (c == '\n')
    55e8:	8a 30       	cpi	r24, 0x0A	; 10
    55ea:	21 f4       	brne	.+8      	; 0x55f4 <uart_getchar+0x1e4>
    rxp = 0;
    55ec:	10 92 25 20 	sts	0x2025, r1	; 0x802025 <rxp.2118+0x1>
    55f0:	10 92 24 20 	sts	0x2024, r1	; 0x802024 <rxp.2118>

  return c;
    55f4:	90 e0       	ldi	r25, 0x00	; 0
    55f6:	08 c0       	rjmp	.+16     	; 0x5608 <uart_getchar+0x1f8>
  if (rxp == 0)
    for (cp = b;;)
      {
	loop_until_bit_is_set(UCSR0A, RXC0);
	if (UCSR0A & _BV(FE0))
	  return _FDEV_EOF;
    55f8:	8e ef       	ldi	r24, 0xFE	; 254
    55fa:	9f ef       	ldi	r25, 0xFF	; 255
    55fc:	05 c0       	rjmp	.+10     	; 0x5608 <uart_getchar+0x1f8>
	if (UCSR0A & _BV(DOR0))
	  return _FDEV_ERR;
    55fe:	8f ef       	ldi	r24, 0xFF	; 255
    5600:	9f ef       	ldi	r25, 0xFF	; 255
    5602:	02 c0       	rjmp	.+4      	; 0x5608 <uart_getchar+0x1f8>
	  }

	switch (c)
	  {
	  case 'c' & 0x1f:
	    return -1;
    5604:	8f ef       	ldi	r24, 0xFF	; 255
    5606:	9f ef       	ldi	r25, 0xFF	; 255
  c = *rxp++;
  if (c == '\n')
    rxp = 0;

  return c;
}
    5608:	df 91       	pop	r29
    560a:	cf 91       	pop	r28
    560c:	1f 91       	pop	r17
    560e:	0f 91       	pop	r16
    5610:	ff 90       	pop	r15
    5612:	ef 90       	pop	r14
    5614:	df 90       	pop	r13
    5616:	cf 90       	pop	r12
    5618:	bf 90       	pop	r11
    561a:	af 90       	pop	r10
    561c:	9f 90       	pop	r9
    561e:	8f 90       	pop	r8
    5620:	7f 90       	pop	r7
    5622:	6f 90       	pop	r6
    5624:	08 95       	ret

00005626 <uart_init>:
{
#if F_CPU < 2000000UL && defined(U2X)
  UCSRA = _BV(U2X);             /* improve baud rate error by using 2x clk */
  UBRRL = (F_CPU / (8UL * UART_BAUD)) - 1;
#else
	UBRR0H = (uint8_t) (MYUBRR >> 8);
    5626:	10 92 c5 00 	sts	0x00C5, r1	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7000c5>
	UBRR0L = (uint8_t) MYUBRR;
    562a:	80 e1       	ldi	r24, 0x10	; 16
    562c:	80 93 c4 00 	sts	0x00C4, r24	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7000c4>
#endif
	UCSR0B = (1 << RXEN0) | (1 << TXEN0); /* tx/rx enable */
    5630:	88 e1       	ldi	r24, 0x18	; 24
    5632:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7000c1>
	UCSR0C = (3 << UCSZ00);
    5636:	86 e0       	ldi	r24, 0x06	; 6
    5638:	80 93 c2 00 	sts	0x00C2, r24	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7000c2>
	stdout = stdin = &usart0_str;
    563c:	e8 e2       	ldi	r30, 0x28	; 40
    563e:	f0 e2       	ldi	r31, 0x20	; 32
    5640:	81 e7       	ldi	r24, 0x71	; 113
    5642:	92 e0       	ldi	r25, 0x02	; 2
    5644:	91 83       	std	Z+1, r25	; 0x01
    5646:	80 83       	st	Z, r24
    5648:	93 83       	std	Z+3, r25	; 0x03
    564a:	82 83       	std	Z+2, r24	; 0x02
    564c:	08 95       	ret

0000564e <main>:
extern TaskHandle_t I2C_task;

int main(void) {
    /* Initialization Mode */
    // Initialize board
    board_init();
    564e:	52 d0       	rcall	.+164    	; 0x56f4 <board_init>

    // Initialize UART
    // Baud Rate: 57600
    uart_init();
    5650:	ea df       	rcall	.-44     	; 0x5626 <uart_init>
    5652:	89 e6       	ldi	r24, 0x69	; 105
    printf("----------- EPS: Initialization Mode -----------\r\n");
    5654:	9e e0       	ldi	r25, 0x0E	; 14
    5656:	9f 93       	push	r25
    5658:	8f 93       	push	r24
    565a:	5f d1       	rcall	.+702    	; 0x591a <printf_P>
    565c:	6c e2       	ldi	r22, 0x2C	; 44
    ioport_init();

    // Initialize CSP
    // 300 bytes per buffer --> I2C MTU = 256 bytes
    // Buffer = MTU + 2 Sync flag + 2 Length field
    csp_buffer_init(2, 300);
    565e:	71 e0       	ldi	r23, 0x01	; 1
    5660:	82 e0       	ldi	r24, 0x02	; 2
    5662:	90 e0       	ldi	r25, 0x00	; 0
    5664:	0e 94 cd 14 	call	0x299a	; 0x299a <csp_buffer_init>
    5668:	81 e0       	ldi	r24, 0x01	; 1
    csp_init(OBC_ADDR);
    566a:	0e 94 65 1c 	call	0x38ca	; 0x38ca <csp_init>
    566e:	40 e9       	ldi	r20, 0x90	; 144
    csp_i2c_init(OBC_ADDR, 0, 400);
    5670:	51 e0       	ldi	r21, 0x01	; 1
    5672:	60 e0       	ldi	r22, 0x00	; 0
    5674:	70 e0       	ldi	r23, 0x00	; 0
    5676:	81 e0       	ldi	r24, 0x01	; 1
    5678:	e6 d8       	rcall	.-3636   	; 0x4846 <csp_i2c_init>
    567a:	2f ef       	ldi	r18, 0xFF	; 255
    csp_route_set(EPS_ADDR, &csp_if_i2c, CSP_NODE_MAC);
    567c:	4b e0       	ldi	r20, 0x0B	; 11
    567e:	52 e0       	ldi	r21, 0x02	; 2
    5680:	65 e0       	ldi	r22, 0x05	; 5
    5682:	82 e0       	ldi	r24, 0x02	; 2
    5684:	78 d9       	rcall	.-3344   	; 0x4976 <csp_rtable_set>
    5686:	61 e0       	ldi	r22, 0x01	; 1
    csp_route_start_task(500, 1);
    5688:	70 e0       	ldi	r23, 0x00	; 0
    568a:	84 ef       	ldi	r24, 0xF4	; 244
    568c:	91 e0       	ldi	r25, 0x01	; 1
    568e:	10 d8       	rcall	.-4064   	; 0x46b0 <csp_route_start_task>
    5690:	bd d9       	rcall	.-3206   	; 0x4a0c <csp_rtable_print>
    csp_rtable_print();	// For debugging purposes
    5692:	86 e6       	ldi	r24, 0x66	; 102
    printf("\r\n");
    5694:	9e e0       	ldi	r25, 0x0E	; 14
    5696:	9f 93       	push	r25
    5698:	8f 93       	push	r24
    569a:	3f d1       	rcall	.+638    	; 0x591a <printf_P>
    569c:	e1 2c       	mov	r14, r1
    569e:	f1 2c       	mov	r15, r1

    // Create FreeRTOS tasks
    // Placeholder blinky task
    extern void led_blinky(void *pvParameters);
    xTaskCreate(led_blinky, "Task to blink led pin 13", 100, NULL, OBC_NORM_PRIO, NULL);
    56a0:	01 e0       	ldi	r16, 0x01	; 1
    56a2:	20 e0       	ldi	r18, 0x00	; 0
    56a4:	30 e0       	ldi	r19, 0x00	; 0
    56a6:	44 e6       	ldi	r20, 0x64	; 100
    56a8:	50 e0       	ldi	r21, 0x00	; 0
    56aa:	65 ec       	ldi	r22, 0xC5	; 197
    56ac:	73 e0       	ldi	r23, 0x03	; 3
    56ae:	86 ed       	ldi	r24, 0xD6	; 214
    56b0:	95 e2       	ldi	r25, 0x25	; 37
    56b2:	0e 94 79 0e 	call	0x1cf2	; 0x1cf2 <xTaskCreate>
    56b6:	0f 2e       	mov	r0, r31
    56b8:	f6 e2       	ldi	r31, 0x26	; 38

    // Task for the csp server to be loaded
    extern void csp_twoway_client(void *pvParameters);
    xTaskCreate(csp_twoway_client, "Task for CSP server", 250, NULL, OBC_CSP_PRIO, &I2C_task);
    56ba:	ef 2e       	mov	r14, r31
    56bc:	f0 e2       	ldi	r31, 0x20	; 32
    56be:	ff 2e       	mov	r15, r31
    56c0:	f0 2d       	mov	r31, r0
    56c2:	05 e0       	ldi	r16, 0x05	; 5
    56c4:	20 e0       	ldi	r18, 0x00	; 0
    56c6:	30 e0       	ldi	r19, 0x00	; 0
    56c8:	4a ef       	ldi	r20, 0xFA	; 250
    56ca:	50 e0       	ldi	r21, 0x00	; 0
    56cc:	6e ed       	ldi	r22, 0xDE	; 222
    56ce:	73 e0       	ldi	r23, 0x03	; 3
    56d0:	8e ed       	ldi	r24, 0xDE	; 222
    56d2:	95 e2       	ldi	r25, 0x25	; 37
    56d4:	0e 94 79 0e 	call	0x1cf2	; 0x1cf2 <xTaskCreate>
    56d8:	89 e3       	ldi	r24, 0x39	; 57

    /*-----------------------------------------------------------------------------*/


    /* Autonomous Mode */
    printf("----------- EPS: Autonomous Mode -----------");
    56da:	9e e0       	ldi	r25, 0x0E	; 14
    56dc:	9f 93       	push	r25
    56de:	8f 93       	push	r24
    56e0:	1c d1       	rcall	.+568    	; 0x591a <printf_P>
    56e2:	0e 94 d5 0f 	call	0x1faa	; 0x1faa <vTaskStartScheduler>
    // Start Scheduler
    vTaskStartScheduler();
    56e6:	0f 90       	pop	r0
    56e8:	0f 90       	pop	r0
    56ea:	0f 90       	pop	r0
    56ec:	0f 90       	pop	r0
    56ee:	0f 90       	pop	r0
    56f0:	0f 90       	pop	r0
    56f2:	ff cf       	rjmp	.-2      	; 0x56f2 <main+0xa4>

000056f4 <board_init>:
#include <compiler.h>
#include <conf_board.h>


void board_init(void)
{
    56f4:	08 95       	ret

000056f6 <__divmodhi4>:
    56f6:	97 fb       	bst	r25, 7
    56f8:	07 2e       	mov	r0, r23
    56fa:	16 f4       	brtc	.+4      	; 0x5700 <__divmodhi4+0xa>
    56fc:	00 94       	com	r0
    56fe:	06 d0       	rcall	.+12     	; 0x570c <__divmodhi4_neg1>
    5700:	77 fd       	sbrc	r23, 7
    5702:	08 d0       	rcall	.+16     	; 0x5714 <__divmodhi4_neg2>
    5704:	44 d0       	rcall	.+136    	; 0x578e <__udivmodhi4>
    5706:	07 fc       	sbrc	r0, 7
    5708:	05 d0       	rcall	.+10     	; 0x5714 <__divmodhi4_neg2>
    570a:	3e f4       	brtc	.+14     	; 0x571a <__divmodhi4_exit>

0000570c <__divmodhi4_neg1>:
    570c:	90 95       	com	r25
    570e:	81 95       	neg	r24
    5710:	9f 4f       	sbci	r25, 0xFF	; 255
    5712:	08 95       	ret

00005714 <__divmodhi4_neg2>:
    5714:	70 95       	com	r23
    5716:	61 95       	neg	r22
    5718:	7f 4f       	sbci	r23, 0xFF	; 255

0000571a <__divmodhi4_exit>:
    571a:	08 95       	ret

0000571c <__udivmodsi4>:
    571c:	a1 e2       	ldi	r26, 0x21	; 33
    571e:	1a 2e       	mov	r1, r26
    5720:	aa 1b       	sub	r26, r26
    5722:	bb 1b       	sub	r27, r27
    5724:	fd 01       	movw	r30, r26
    5726:	0d c0       	rjmp	.+26     	; 0x5742 <__udivmodsi4_ep>

00005728 <__udivmodsi4_loop>:
    5728:	aa 1f       	adc	r26, r26
    572a:	bb 1f       	adc	r27, r27
    572c:	ee 1f       	adc	r30, r30
    572e:	ff 1f       	adc	r31, r31
    5730:	a2 17       	cp	r26, r18
    5732:	b3 07       	cpc	r27, r19
    5734:	e4 07       	cpc	r30, r20
    5736:	f5 07       	cpc	r31, r21
    5738:	20 f0       	brcs	.+8      	; 0x5742 <__udivmodsi4_ep>
    573a:	a2 1b       	sub	r26, r18
    573c:	b3 0b       	sbc	r27, r19
    573e:	e4 0b       	sbc	r30, r20
    5740:	f5 0b       	sbc	r31, r21

00005742 <__udivmodsi4_ep>:
    5742:	66 1f       	adc	r22, r22
    5744:	77 1f       	adc	r23, r23
    5746:	88 1f       	adc	r24, r24
    5748:	99 1f       	adc	r25, r25
    574a:	1a 94       	dec	r1
    574c:	69 f7       	brne	.-38     	; 0x5728 <__udivmodsi4_loop>
    574e:	60 95       	com	r22
    5750:	70 95       	com	r23
    5752:	80 95       	com	r24
    5754:	90 95       	com	r25
    5756:	9b 01       	movw	r18, r22
    5758:	ac 01       	movw	r20, r24
    575a:	bd 01       	movw	r22, r26
    575c:	cf 01       	movw	r24, r30
    575e:	08 95       	ret

00005760 <__tablejump2__>:
    5760:	ee 0f       	add	r30, r30
    5762:	ff 1f       	adc	r31, r31
    5764:	88 1f       	adc	r24, r24
    5766:	8b bf       	out	0x3b, r24	; 59
    5768:	07 90       	elpm	r0, Z+
    576a:	f6 91       	elpm	r31, Z
    576c:	e0 2d       	mov	r30, r0
    576e:	19 94       	eijmp

00005770 <__umulhisi3>:
    5770:	a2 9f       	mul	r26, r18
    5772:	b0 01       	movw	r22, r0
    5774:	b3 9f       	mul	r27, r19
    5776:	c0 01       	movw	r24, r0
    5778:	a3 9f       	mul	r26, r19
    577a:	70 0d       	add	r23, r0
    577c:	81 1d       	adc	r24, r1
    577e:	11 24       	eor	r1, r1
    5780:	91 1d       	adc	r25, r1
    5782:	b2 9f       	mul	r27, r18
    5784:	70 0d       	add	r23, r0
    5786:	81 1d       	adc	r24, r1
    5788:	11 24       	eor	r1, r1
    578a:	91 1d       	adc	r25, r1
    578c:	08 95       	ret

0000578e <__udivmodhi4>:
    578e:	aa 1b       	sub	r26, r26
    5790:	bb 1b       	sub	r27, r27
    5792:	51 e1       	ldi	r21, 0x11	; 17
    5794:	07 c0       	rjmp	.+14     	; 0x57a4 <__udivmodhi4_ep>

00005796 <__udivmodhi4_loop>:
    5796:	aa 1f       	adc	r26, r26
    5798:	bb 1f       	adc	r27, r27
    579a:	a6 17       	cp	r26, r22
    579c:	b7 07       	cpc	r27, r23
    579e:	10 f0       	brcs	.+4      	; 0x57a4 <__udivmodhi4_ep>
    57a0:	a6 1b       	sub	r26, r22
    57a2:	b7 0b       	sbc	r27, r23

000057a4 <__udivmodhi4_ep>:
    57a4:	88 1f       	adc	r24, r24
    57a6:	99 1f       	adc	r25, r25
    57a8:	5a 95       	dec	r21
    57aa:	a9 f7       	brne	.-22     	; 0x5796 <__udivmodhi4_loop>
    57ac:	80 95       	com	r24
    57ae:	90 95       	com	r25
    57b0:	bc 01       	movw	r22, r24
    57b2:	cd 01       	movw	r24, r26
    57b4:	08 95       	ret

000057b6 <do_rand>:
    57b6:	8f 92       	push	r8
    57b8:	9f 92       	push	r9
    57ba:	af 92       	push	r10
    57bc:	bf 92       	push	r11
    57be:	cf 92       	push	r12
    57c0:	df 92       	push	r13
    57c2:	ef 92       	push	r14
    57c4:	ff 92       	push	r15
    57c6:	cf 93       	push	r28
    57c8:	df 93       	push	r29
    57ca:	ec 01       	movw	r28, r24
    57cc:	68 81       	ld	r22, Y
    57ce:	79 81       	ldd	r23, Y+1	; 0x01
    57d0:	8a 81       	ldd	r24, Y+2	; 0x02
    57d2:	9b 81       	ldd	r25, Y+3	; 0x03
    57d4:	61 15       	cp	r22, r1
    57d6:	71 05       	cpc	r23, r1
    57d8:	81 05       	cpc	r24, r1
    57da:	91 05       	cpc	r25, r1
    57dc:	21 f4       	brne	.+8      	; 0x57e6 <do_rand+0x30>
    57de:	64 e2       	ldi	r22, 0x24	; 36
    57e0:	79 ed       	ldi	r23, 0xD9	; 217
    57e2:	8b e5       	ldi	r24, 0x5B	; 91
    57e4:	97 e0       	ldi	r25, 0x07	; 7
    57e6:	2d e1       	ldi	r18, 0x1D	; 29
    57e8:	33 ef       	ldi	r19, 0xF3	; 243
    57ea:	41 e0       	ldi	r20, 0x01	; 1
    57ec:	50 e0       	ldi	r21, 0x00	; 0
    57ee:	6c d3       	rcall	.+1752   	; 0x5ec8 <__divmodsi4>
    57f0:	49 01       	movw	r8, r18
    57f2:	5a 01       	movw	r10, r20
    57f4:	9b 01       	movw	r18, r22
    57f6:	ac 01       	movw	r20, r24
    57f8:	a7 ea       	ldi	r26, 0xA7	; 167
    57fa:	b1 e4       	ldi	r27, 0x41	; 65
    57fc:	81 d3       	rcall	.+1794   	; 0x5f00 <__muluhisi3>
    57fe:	6b 01       	movw	r12, r22
    5800:	7c 01       	movw	r14, r24
    5802:	ac ee       	ldi	r26, 0xEC	; 236
    5804:	b4 ef       	ldi	r27, 0xF4	; 244
    5806:	a5 01       	movw	r20, r10
    5808:	94 01       	movw	r18, r8
    580a:	86 d3       	rcall	.+1804   	; 0x5f18 <__mulohisi3>
    580c:	dc 01       	movw	r26, r24
    580e:	cb 01       	movw	r24, r22
    5810:	8c 0d       	add	r24, r12
    5812:	9d 1d       	adc	r25, r13
    5814:	ae 1d       	adc	r26, r14
    5816:	bf 1d       	adc	r27, r15
    5818:	b7 ff       	sbrs	r27, 7
    581a:	03 c0       	rjmp	.+6      	; 0x5822 <do_rand+0x6c>
    581c:	01 97       	sbiw	r24, 0x01	; 1
    581e:	a1 09       	sbc	r26, r1
    5820:	b0 48       	sbci	r27, 0x80	; 128
    5822:	88 83       	st	Y, r24
    5824:	99 83       	std	Y+1, r25	; 0x01
    5826:	aa 83       	std	Y+2, r26	; 0x02
    5828:	bb 83       	std	Y+3, r27	; 0x03
    582a:	9f 77       	andi	r25, 0x7F	; 127
    582c:	df 91       	pop	r29
    582e:	cf 91       	pop	r28
    5830:	ff 90       	pop	r15
    5832:	ef 90       	pop	r14
    5834:	df 90       	pop	r13
    5836:	cf 90       	pop	r12
    5838:	bf 90       	pop	r11
    583a:	af 90       	pop	r10
    583c:	9f 90       	pop	r9
    583e:	8f 90       	pop	r8
    5840:	08 95       	ret

00005842 <rand_r>:
    5842:	b9 cf       	rjmp	.-142    	; 0x57b6 <do_rand>

00005844 <rand>:
    5844:	80 e0       	ldi	r24, 0x00	; 0
    5846:	92 e0       	ldi	r25, 0x02	; 2
    5848:	b6 cf       	rjmp	.-148    	; 0x57b6 <do_rand>

0000584a <srand>:
    584a:	a0 e0       	ldi	r26, 0x00	; 0
    584c:	b0 e0       	ldi	r27, 0x00	; 0
    584e:	80 93 00 02 	sts	0x0200, r24	; 0x800200 <__DATA_REGION_ORIGIN__>
    5852:	90 93 01 02 	sts	0x0201, r25	; 0x800201 <__DATA_REGION_ORIGIN__+0x1>
    5856:	a0 93 02 02 	sts	0x0202, r26	; 0x800202 <__DATA_REGION_ORIGIN__+0x2>
    585a:	b0 93 03 02 	sts	0x0203, r27	; 0x800203 <__DATA_REGION_ORIGIN__+0x3>
    585e:	08 95       	ret

00005860 <memcpy>:
    5860:	fb 01       	movw	r30, r22
    5862:	dc 01       	movw	r26, r24
    5864:	02 c0       	rjmp	.+4      	; 0x586a <memcpy+0xa>
    5866:	01 90       	ld	r0, Z+
    5868:	0d 92       	st	X+, r0
    586a:	41 50       	subi	r20, 0x01	; 1
    586c:	50 40       	sbci	r21, 0x00	; 0
    586e:	d8 f7       	brcc	.-10     	; 0x5866 <memcpy+0x6>
    5870:	08 95       	ret

00005872 <memset>:
    5872:	dc 01       	movw	r26, r24
    5874:	01 c0       	rjmp	.+2      	; 0x5878 <memset+0x6>
    5876:	6d 93       	st	X+, r22
    5878:	41 50       	subi	r20, 0x01	; 1
    587a:	50 40       	sbci	r21, 0x00	; 0
    587c:	e0 f7       	brcc	.-8      	; 0x5876 <memset+0x4>
    587e:	08 95       	ret

00005880 <strnlen>:
    5880:	fc 01       	movw	r30, r24
    5882:	61 50       	subi	r22, 0x01	; 1
    5884:	70 40       	sbci	r23, 0x00	; 0
    5886:	01 90       	ld	r0, Z+
    5888:	01 10       	cpse	r0, r1
    588a:	d8 f7       	brcc	.-10     	; 0x5882 <strnlen+0x2>
    588c:	80 95       	com	r24
    588e:	90 95       	com	r25
    5890:	8e 0f       	add	r24, r30
    5892:	9f 1f       	adc	r25, r31
    5894:	08 95       	ret

00005896 <fwrite>:
    5896:	8f 92       	push	r8
    5898:	9f 92       	push	r9
    589a:	af 92       	push	r10
    589c:	bf 92       	push	r11
    589e:	cf 92       	push	r12
    58a0:	df 92       	push	r13
    58a2:	ef 92       	push	r14
    58a4:	ff 92       	push	r15
    58a6:	0f 93       	push	r16
    58a8:	1f 93       	push	r17
    58aa:	cf 93       	push	r28
    58ac:	df 93       	push	r29
    58ae:	5b 01       	movw	r10, r22
    58b0:	4a 01       	movw	r8, r20
    58b2:	79 01       	movw	r14, r18
    58b4:	d9 01       	movw	r26, r18
    58b6:	13 96       	adiw	r26, 0x03	; 3
    58b8:	2c 91       	ld	r18, X
    58ba:	21 ff       	sbrs	r18, 1
    58bc:	1d c0       	rjmp	.+58     	; 0x58f8 <fwrite+0x62>
    58be:	c0 e0       	ldi	r28, 0x00	; 0
    58c0:	d0 e0       	ldi	r29, 0x00	; 0
    58c2:	c8 15       	cp	r28, r8
    58c4:	d9 05       	cpc	r29, r9
    58c6:	d9 f0       	breq	.+54     	; 0x58fe <fwrite+0x68>
    58c8:	8c 01       	movw	r16, r24
    58ca:	6c 01       	movw	r12, r24
    58cc:	ca 0c       	add	r12, r10
    58ce:	db 1c       	adc	r13, r11
    58d0:	c8 01       	movw	r24, r16
    58d2:	0c 15       	cp	r16, r12
    58d4:	1d 05       	cpc	r17, r13
    58d6:	71 f0       	breq	.+28     	; 0x58f4 <fwrite+0x5e>
    58d8:	0f 5f       	subi	r16, 0xFF	; 255
    58da:	1f 4f       	sbci	r17, 0xFF	; 255
    58dc:	d7 01       	movw	r26, r14
    58de:	18 96       	adiw	r26, 0x08	; 8
    58e0:	ed 91       	ld	r30, X+
    58e2:	fc 91       	ld	r31, X
    58e4:	19 97       	sbiw	r26, 0x09	; 9
    58e6:	b7 01       	movw	r22, r14
    58e8:	dc 01       	movw	r26, r24
    58ea:	8c 91       	ld	r24, X
    58ec:	19 95       	eicall
    58ee:	89 2b       	or	r24, r25
    58f0:	79 f3       	breq	.-34     	; 0x58d0 <fwrite+0x3a>
    58f2:	05 c0       	rjmp	.+10     	; 0x58fe <fwrite+0x68>
    58f4:	21 96       	adiw	r28, 0x01	; 1
    58f6:	e5 cf       	rjmp	.-54     	; 0x58c2 <fwrite+0x2c>
    58f8:	80 e0       	ldi	r24, 0x00	; 0
    58fa:	90 e0       	ldi	r25, 0x00	; 0
    58fc:	01 c0       	rjmp	.+2      	; 0x5900 <fwrite+0x6a>
    58fe:	ce 01       	movw	r24, r28
    5900:	df 91       	pop	r29
    5902:	cf 91       	pop	r28
    5904:	1f 91       	pop	r17
    5906:	0f 91       	pop	r16
    5908:	ff 90       	pop	r15
    590a:	ef 90       	pop	r14
    590c:	df 90       	pop	r13
    590e:	cf 90       	pop	r12
    5910:	bf 90       	pop	r11
    5912:	af 90       	pop	r10
    5914:	9f 90       	pop	r9
    5916:	8f 90       	pop	r8
    5918:	08 95       	ret

0000591a <printf_P>:
    591a:	0f 93       	push	r16
    591c:	1f 93       	push	r17
    591e:	cf 93       	push	r28
    5920:	df 93       	push	r29
    5922:	cd b7       	in	r28, 0x3d	; 61
    5924:	de b7       	in	r29, 0x3e	; 62
    5926:	ae 01       	movw	r20, r28
    5928:	48 5f       	subi	r20, 0xF8	; 248
    592a:	5f 4f       	sbci	r21, 0xFF	; 255
    592c:	da 01       	movw	r26, r20
    592e:	6d 91       	ld	r22, X+
    5930:	7d 91       	ld	r23, X+
    5932:	ad 01       	movw	r20, r26
    5934:	08 e2       	ldi	r16, 0x28	; 40
    5936:	10 e2       	ldi	r17, 0x20	; 32
    5938:	f8 01       	movw	r30, r16
    593a:	82 81       	ldd	r24, Z+2	; 0x02
    593c:	93 81       	ldd	r25, Z+3	; 0x03
    593e:	dc 01       	movw	r26, r24
    5940:	13 96       	adiw	r26, 0x03	; 3
    5942:	2c 91       	ld	r18, X
    5944:	13 97       	sbiw	r26, 0x03	; 3
    5946:	28 60       	ori	r18, 0x08	; 8
    5948:	13 96       	adiw	r26, 0x03	; 3
    594a:	2c 93       	st	X, r18
    594c:	1b d0       	rcall	.+54     	; 0x5984 <vfprintf>
    594e:	d8 01       	movw	r26, r16
    5950:	12 96       	adiw	r26, 0x02	; 2
    5952:	ed 91       	ld	r30, X+
    5954:	fc 91       	ld	r31, X
    5956:	13 97       	sbiw	r26, 0x03	; 3
    5958:	23 81       	ldd	r18, Z+3	; 0x03
    595a:	27 7f       	andi	r18, 0xF7	; 247
    595c:	23 83       	std	Z+3, r18	; 0x03
    595e:	df 91       	pop	r29
    5960:	cf 91       	pop	r28
    5962:	1f 91       	pop	r17
    5964:	0f 91       	pop	r16
    5966:	08 95       	ret

00005968 <vfprintf_P>:
    5968:	cf 93       	push	r28
    596a:	df 93       	push	r29
    596c:	ec 01       	movw	r28, r24
    596e:	8b 81       	ldd	r24, Y+3	; 0x03
    5970:	88 60       	ori	r24, 0x08	; 8
    5972:	8b 83       	std	Y+3, r24	; 0x03
    5974:	ce 01       	movw	r24, r28
    5976:	06 d0       	rcall	.+12     	; 0x5984 <vfprintf>
    5978:	2b 81       	ldd	r18, Y+3	; 0x03
    597a:	27 7f       	andi	r18, 0xF7	; 247
    597c:	2b 83       	std	Y+3, r18	; 0x03
    597e:	df 91       	pop	r29
    5980:	cf 91       	pop	r28
    5982:	08 95       	ret

00005984 <vfprintf>:
    5984:	2f 92       	push	r2
    5986:	3f 92       	push	r3
    5988:	4f 92       	push	r4
    598a:	5f 92       	push	r5
    598c:	6f 92       	push	r6
    598e:	7f 92       	push	r7
    5990:	8f 92       	push	r8
    5992:	9f 92       	push	r9
    5994:	af 92       	push	r10
    5996:	bf 92       	push	r11
    5998:	cf 92       	push	r12
    599a:	df 92       	push	r13
    599c:	ef 92       	push	r14
    599e:	ff 92       	push	r15
    59a0:	0f 93       	push	r16
    59a2:	1f 93       	push	r17
    59a4:	cf 93       	push	r28
    59a6:	df 93       	push	r29
    59a8:	cd b7       	in	r28, 0x3d	; 61
    59aa:	de b7       	in	r29, 0x3e	; 62
    59ac:	2b 97       	sbiw	r28, 0x0b	; 11
    59ae:	0f b6       	in	r0, 0x3f	; 63
    59b0:	f8 94       	cli
    59b2:	de bf       	out	0x3e, r29	; 62
    59b4:	0f be       	out	0x3f, r0	; 63
    59b6:	cd bf       	out	0x3d, r28	; 61
    59b8:	6c 01       	movw	r12, r24
    59ba:	7b 01       	movw	r14, r22
    59bc:	8a 01       	movw	r16, r20
    59be:	fc 01       	movw	r30, r24
    59c0:	17 82       	std	Z+7, r1	; 0x07
    59c2:	16 82       	std	Z+6, r1	; 0x06
    59c4:	83 81       	ldd	r24, Z+3	; 0x03
    59c6:	81 ff       	sbrs	r24, 1
    59c8:	bf c1       	rjmp	.+894    	; 0x5d48 <vfprintf+0x3c4>
    59ca:	ce 01       	movw	r24, r28
    59cc:	01 96       	adiw	r24, 0x01	; 1
    59ce:	3c 01       	movw	r6, r24
    59d0:	f6 01       	movw	r30, r12
    59d2:	93 81       	ldd	r25, Z+3	; 0x03
    59d4:	f7 01       	movw	r30, r14
    59d6:	93 fd       	sbrc	r25, 3
    59d8:	85 91       	lpm	r24, Z+
    59da:	93 ff       	sbrs	r25, 3
    59dc:	81 91       	ld	r24, Z+
    59de:	7f 01       	movw	r14, r30
    59e0:	88 23       	and	r24, r24
    59e2:	09 f4       	brne	.+2      	; 0x59e6 <vfprintf+0x62>
    59e4:	ad c1       	rjmp	.+858    	; 0x5d40 <vfprintf+0x3bc>
    59e6:	85 32       	cpi	r24, 0x25	; 37
    59e8:	39 f4       	brne	.+14     	; 0x59f8 <vfprintf+0x74>
    59ea:	93 fd       	sbrc	r25, 3
    59ec:	85 91       	lpm	r24, Z+
    59ee:	93 ff       	sbrs	r25, 3
    59f0:	81 91       	ld	r24, Z+
    59f2:	7f 01       	movw	r14, r30
    59f4:	85 32       	cpi	r24, 0x25	; 37
    59f6:	21 f4       	brne	.+8      	; 0x5a00 <vfprintf+0x7c>
    59f8:	b6 01       	movw	r22, r12
    59fa:	90 e0       	ldi	r25, 0x00	; 0
    59fc:	cb d1       	rcall	.+918    	; 0x5d94 <fputc>
    59fe:	e8 cf       	rjmp	.-48     	; 0x59d0 <vfprintf+0x4c>
    5a00:	91 2c       	mov	r9, r1
    5a02:	21 2c       	mov	r2, r1
    5a04:	31 2c       	mov	r3, r1
    5a06:	ff e1       	ldi	r31, 0x1F	; 31
    5a08:	f3 15       	cp	r31, r3
    5a0a:	d8 f0       	brcs	.+54     	; 0x5a42 <vfprintf+0xbe>
    5a0c:	8b 32       	cpi	r24, 0x2B	; 43
    5a0e:	79 f0       	breq	.+30     	; 0x5a2e <vfprintf+0xaa>
    5a10:	38 f4       	brcc	.+14     	; 0x5a20 <vfprintf+0x9c>
    5a12:	80 32       	cpi	r24, 0x20	; 32
    5a14:	79 f0       	breq	.+30     	; 0x5a34 <vfprintf+0xb0>
    5a16:	83 32       	cpi	r24, 0x23	; 35
    5a18:	a1 f4       	brne	.+40     	; 0x5a42 <vfprintf+0xbe>
    5a1a:	23 2d       	mov	r18, r3
    5a1c:	20 61       	ori	r18, 0x10	; 16
    5a1e:	1d c0       	rjmp	.+58     	; 0x5a5a <vfprintf+0xd6>
    5a20:	8d 32       	cpi	r24, 0x2D	; 45
    5a22:	61 f0       	breq	.+24     	; 0x5a3c <vfprintf+0xb8>
    5a24:	80 33       	cpi	r24, 0x30	; 48
    5a26:	69 f4       	brne	.+26     	; 0x5a42 <vfprintf+0xbe>
    5a28:	23 2d       	mov	r18, r3
    5a2a:	21 60       	ori	r18, 0x01	; 1
    5a2c:	16 c0       	rjmp	.+44     	; 0x5a5a <vfprintf+0xd6>
    5a2e:	83 2d       	mov	r24, r3
    5a30:	82 60       	ori	r24, 0x02	; 2
    5a32:	38 2e       	mov	r3, r24
    5a34:	e3 2d       	mov	r30, r3
    5a36:	e4 60       	ori	r30, 0x04	; 4
    5a38:	3e 2e       	mov	r3, r30
    5a3a:	2a c0       	rjmp	.+84     	; 0x5a90 <vfprintf+0x10c>
    5a3c:	f3 2d       	mov	r31, r3
    5a3e:	f8 60       	ori	r31, 0x08	; 8
    5a40:	1d c0       	rjmp	.+58     	; 0x5a7c <vfprintf+0xf8>
    5a42:	37 fc       	sbrc	r3, 7
    5a44:	2d c0       	rjmp	.+90     	; 0x5aa0 <vfprintf+0x11c>
    5a46:	20 ed       	ldi	r18, 0xD0	; 208
    5a48:	28 0f       	add	r18, r24
    5a4a:	2a 30       	cpi	r18, 0x0A	; 10
    5a4c:	40 f0       	brcs	.+16     	; 0x5a5e <vfprintf+0xda>
    5a4e:	8e 32       	cpi	r24, 0x2E	; 46
    5a50:	b9 f4       	brne	.+46     	; 0x5a80 <vfprintf+0xfc>
    5a52:	36 fc       	sbrc	r3, 6
    5a54:	75 c1       	rjmp	.+746    	; 0x5d40 <vfprintf+0x3bc>
    5a56:	23 2d       	mov	r18, r3
    5a58:	20 64       	ori	r18, 0x40	; 64
    5a5a:	32 2e       	mov	r3, r18
    5a5c:	19 c0       	rjmp	.+50     	; 0x5a90 <vfprintf+0x10c>
    5a5e:	36 fe       	sbrs	r3, 6
    5a60:	06 c0       	rjmp	.+12     	; 0x5a6e <vfprintf+0xea>
    5a62:	8a e0       	ldi	r24, 0x0A	; 10
    5a64:	98 9e       	mul	r9, r24
    5a66:	20 0d       	add	r18, r0
    5a68:	11 24       	eor	r1, r1
    5a6a:	92 2e       	mov	r9, r18
    5a6c:	11 c0       	rjmp	.+34     	; 0x5a90 <vfprintf+0x10c>
    5a6e:	ea e0       	ldi	r30, 0x0A	; 10
    5a70:	2e 9e       	mul	r2, r30
    5a72:	20 0d       	add	r18, r0
    5a74:	11 24       	eor	r1, r1
    5a76:	22 2e       	mov	r2, r18
    5a78:	f3 2d       	mov	r31, r3
    5a7a:	f0 62       	ori	r31, 0x20	; 32
    5a7c:	3f 2e       	mov	r3, r31
    5a7e:	08 c0       	rjmp	.+16     	; 0x5a90 <vfprintf+0x10c>
    5a80:	8c 36       	cpi	r24, 0x6C	; 108
    5a82:	21 f4       	brne	.+8      	; 0x5a8c <vfprintf+0x108>
    5a84:	83 2d       	mov	r24, r3
    5a86:	80 68       	ori	r24, 0x80	; 128
    5a88:	38 2e       	mov	r3, r24
    5a8a:	02 c0       	rjmp	.+4      	; 0x5a90 <vfprintf+0x10c>
    5a8c:	88 36       	cpi	r24, 0x68	; 104
    5a8e:	41 f4       	brne	.+16     	; 0x5aa0 <vfprintf+0x11c>
    5a90:	f7 01       	movw	r30, r14
    5a92:	93 fd       	sbrc	r25, 3
    5a94:	85 91       	lpm	r24, Z+
    5a96:	93 ff       	sbrs	r25, 3
    5a98:	81 91       	ld	r24, Z+
    5a9a:	7f 01       	movw	r14, r30
    5a9c:	81 11       	cpse	r24, r1
    5a9e:	b3 cf       	rjmp	.-154    	; 0x5a06 <vfprintf+0x82>
    5aa0:	98 2f       	mov	r25, r24
    5aa2:	9f 7d       	andi	r25, 0xDF	; 223
    5aa4:	95 54       	subi	r25, 0x45	; 69
    5aa6:	93 30       	cpi	r25, 0x03	; 3
    5aa8:	28 f4       	brcc	.+10     	; 0x5ab4 <vfprintf+0x130>
    5aaa:	0c 5f       	subi	r16, 0xFC	; 252
    5aac:	1f 4f       	sbci	r17, 0xFF	; 255
    5aae:	9f e3       	ldi	r25, 0x3F	; 63
    5ab0:	99 83       	std	Y+1, r25	; 0x01
    5ab2:	0d c0       	rjmp	.+26     	; 0x5ace <vfprintf+0x14a>
    5ab4:	83 36       	cpi	r24, 0x63	; 99
    5ab6:	31 f0       	breq	.+12     	; 0x5ac4 <vfprintf+0x140>
    5ab8:	83 37       	cpi	r24, 0x73	; 115
    5aba:	71 f0       	breq	.+28     	; 0x5ad8 <vfprintf+0x154>
    5abc:	83 35       	cpi	r24, 0x53	; 83
    5abe:	09 f0       	breq	.+2      	; 0x5ac2 <vfprintf+0x13e>
    5ac0:	55 c0       	rjmp	.+170    	; 0x5b6c <vfprintf+0x1e8>
    5ac2:	20 c0       	rjmp	.+64     	; 0x5b04 <vfprintf+0x180>
    5ac4:	f8 01       	movw	r30, r16
    5ac6:	80 81       	ld	r24, Z
    5ac8:	89 83       	std	Y+1, r24	; 0x01
    5aca:	0e 5f       	subi	r16, 0xFE	; 254
    5acc:	1f 4f       	sbci	r17, 0xFF	; 255
    5ace:	88 24       	eor	r8, r8
    5ad0:	83 94       	inc	r8
    5ad2:	91 2c       	mov	r9, r1
    5ad4:	53 01       	movw	r10, r6
    5ad6:	12 c0       	rjmp	.+36     	; 0x5afc <vfprintf+0x178>
    5ad8:	28 01       	movw	r4, r16
    5ada:	f2 e0       	ldi	r31, 0x02	; 2
    5adc:	4f 0e       	add	r4, r31
    5ade:	51 1c       	adc	r5, r1
    5ae0:	f8 01       	movw	r30, r16
    5ae2:	a0 80       	ld	r10, Z
    5ae4:	b1 80       	ldd	r11, Z+1	; 0x01
    5ae6:	36 fe       	sbrs	r3, 6
    5ae8:	03 c0       	rjmp	.+6      	; 0x5af0 <vfprintf+0x16c>
    5aea:	69 2d       	mov	r22, r9
    5aec:	70 e0       	ldi	r23, 0x00	; 0
    5aee:	02 c0       	rjmp	.+4      	; 0x5af4 <vfprintf+0x170>
    5af0:	6f ef       	ldi	r22, 0xFF	; 255
    5af2:	7f ef       	ldi	r23, 0xFF	; 255
    5af4:	c5 01       	movw	r24, r10
    5af6:	c4 de       	rcall	.-632    	; 0x5880 <strnlen>
    5af8:	4c 01       	movw	r8, r24
    5afa:	82 01       	movw	r16, r4
    5afc:	f3 2d       	mov	r31, r3
    5afe:	ff 77       	andi	r31, 0x7F	; 127
    5b00:	3f 2e       	mov	r3, r31
    5b02:	15 c0       	rjmp	.+42     	; 0x5b2e <vfprintf+0x1aa>
    5b04:	28 01       	movw	r4, r16
    5b06:	22 e0       	ldi	r18, 0x02	; 2
    5b08:	42 0e       	add	r4, r18
    5b0a:	51 1c       	adc	r5, r1
    5b0c:	f8 01       	movw	r30, r16
    5b0e:	a0 80       	ld	r10, Z
    5b10:	b1 80       	ldd	r11, Z+1	; 0x01
    5b12:	36 fe       	sbrs	r3, 6
    5b14:	03 c0       	rjmp	.+6      	; 0x5b1c <vfprintf+0x198>
    5b16:	69 2d       	mov	r22, r9
    5b18:	70 e0       	ldi	r23, 0x00	; 0
    5b1a:	02 c0       	rjmp	.+4      	; 0x5b20 <vfprintf+0x19c>
    5b1c:	6f ef       	ldi	r22, 0xFF	; 255
    5b1e:	7f ef       	ldi	r23, 0xFF	; 255
    5b20:	c5 01       	movw	r24, r10
    5b22:	2d d1       	rcall	.+602    	; 0x5d7e <strnlen_P>
    5b24:	4c 01       	movw	r8, r24
    5b26:	f3 2d       	mov	r31, r3
    5b28:	f0 68       	ori	r31, 0x80	; 128
    5b2a:	3f 2e       	mov	r3, r31
    5b2c:	82 01       	movw	r16, r4
    5b2e:	33 fc       	sbrc	r3, 3
    5b30:	19 c0       	rjmp	.+50     	; 0x5b64 <vfprintf+0x1e0>
    5b32:	82 2d       	mov	r24, r2
    5b34:	90 e0       	ldi	r25, 0x00	; 0
    5b36:	88 16       	cp	r8, r24
    5b38:	99 06       	cpc	r9, r25
    5b3a:	a0 f4       	brcc	.+40     	; 0x5b64 <vfprintf+0x1e0>
    5b3c:	b6 01       	movw	r22, r12
    5b3e:	80 e2       	ldi	r24, 0x20	; 32
    5b40:	90 e0       	ldi	r25, 0x00	; 0
    5b42:	28 d1       	rcall	.+592    	; 0x5d94 <fputc>
    5b44:	2a 94       	dec	r2
    5b46:	f5 cf       	rjmp	.-22     	; 0x5b32 <vfprintf+0x1ae>
    5b48:	f5 01       	movw	r30, r10
    5b4a:	37 fc       	sbrc	r3, 7
    5b4c:	85 91       	lpm	r24, Z+
    5b4e:	37 fe       	sbrs	r3, 7
    5b50:	81 91       	ld	r24, Z+
    5b52:	5f 01       	movw	r10, r30
    5b54:	b6 01       	movw	r22, r12
    5b56:	90 e0       	ldi	r25, 0x00	; 0
    5b58:	1d d1       	rcall	.+570    	; 0x5d94 <fputc>
    5b5a:	21 10       	cpse	r2, r1
    5b5c:	2a 94       	dec	r2
    5b5e:	21 e0       	ldi	r18, 0x01	; 1
    5b60:	82 1a       	sub	r8, r18
    5b62:	91 08       	sbc	r9, r1
    5b64:	81 14       	cp	r8, r1
    5b66:	91 04       	cpc	r9, r1
    5b68:	79 f7       	brne	.-34     	; 0x5b48 <vfprintf+0x1c4>
    5b6a:	e1 c0       	rjmp	.+450    	; 0x5d2e <vfprintf+0x3aa>
    5b6c:	84 36       	cpi	r24, 0x64	; 100
    5b6e:	11 f0       	breq	.+4      	; 0x5b74 <vfprintf+0x1f0>
    5b70:	89 36       	cpi	r24, 0x69	; 105
    5b72:	39 f5       	brne	.+78     	; 0x5bc2 <vfprintf+0x23e>
    5b74:	f8 01       	movw	r30, r16
    5b76:	37 fe       	sbrs	r3, 7
    5b78:	07 c0       	rjmp	.+14     	; 0x5b88 <vfprintf+0x204>
    5b7a:	60 81       	ld	r22, Z
    5b7c:	71 81       	ldd	r23, Z+1	; 0x01
    5b7e:	82 81       	ldd	r24, Z+2	; 0x02
    5b80:	93 81       	ldd	r25, Z+3	; 0x03
    5b82:	0c 5f       	subi	r16, 0xFC	; 252
    5b84:	1f 4f       	sbci	r17, 0xFF	; 255
    5b86:	08 c0       	rjmp	.+16     	; 0x5b98 <vfprintf+0x214>
    5b88:	60 81       	ld	r22, Z
    5b8a:	71 81       	ldd	r23, Z+1	; 0x01
    5b8c:	07 2e       	mov	r0, r23
    5b8e:	00 0c       	add	r0, r0
    5b90:	88 0b       	sbc	r24, r24
    5b92:	99 0b       	sbc	r25, r25
    5b94:	0e 5f       	subi	r16, 0xFE	; 254
    5b96:	1f 4f       	sbci	r17, 0xFF	; 255
    5b98:	f3 2d       	mov	r31, r3
    5b9a:	ff 76       	andi	r31, 0x6F	; 111
    5b9c:	3f 2e       	mov	r3, r31
    5b9e:	97 ff       	sbrs	r25, 7
    5ba0:	09 c0       	rjmp	.+18     	; 0x5bb4 <vfprintf+0x230>
    5ba2:	90 95       	com	r25
    5ba4:	80 95       	com	r24
    5ba6:	70 95       	com	r23
    5ba8:	61 95       	neg	r22
    5baa:	7f 4f       	sbci	r23, 0xFF	; 255
    5bac:	8f 4f       	sbci	r24, 0xFF	; 255
    5bae:	9f 4f       	sbci	r25, 0xFF	; 255
    5bb0:	f0 68       	ori	r31, 0x80	; 128
    5bb2:	3f 2e       	mov	r3, r31
    5bb4:	2a e0       	ldi	r18, 0x0A	; 10
    5bb6:	30 e0       	ldi	r19, 0x00	; 0
    5bb8:	a3 01       	movw	r20, r6
    5bba:	28 d1       	rcall	.+592    	; 0x5e0c <__ultoa_invert>
    5bbc:	88 2e       	mov	r8, r24
    5bbe:	86 18       	sub	r8, r6
    5bc0:	44 c0       	rjmp	.+136    	; 0x5c4a <vfprintf+0x2c6>
    5bc2:	85 37       	cpi	r24, 0x75	; 117
    5bc4:	31 f4       	brne	.+12     	; 0x5bd2 <vfprintf+0x24e>
    5bc6:	23 2d       	mov	r18, r3
    5bc8:	2f 7e       	andi	r18, 0xEF	; 239
    5bca:	b2 2e       	mov	r11, r18
    5bcc:	2a e0       	ldi	r18, 0x0A	; 10
    5bce:	30 e0       	ldi	r19, 0x00	; 0
    5bd0:	25 c0       	rjmp	.+74     	; 0x5c1c <vfprintf+0x298>
    5bd2:	93 2d       	mov	r25, r3
    5bd4:	99 7f       	andi	r25, 0xF9	; 249
    5bd6:	b9 2e       	mov	r11, r25
    5bd8:	8f 36       	cpi	r24, 0x6F	; 111
    5bda:	c1 f0       	breq	.+48     	; 0x5c0c <vfprintf+0x288>
    5bdc:	18 f4       	brcc	.+6      	; 0x5be4 <vfprintf+0x260>
    5bde:	88 35       	cpi	r24, 0x58	; 88
    5be0:	79 f0       	breq	.+30     	; 0x5c00 <vfprintf+0x27c>
    5be2:	ae c0       	rjmp	.+348    	; 0x5d40 <vfprintf+0x3bc>
    5be4:	80 37       	cpi	r24, 0x70	; 112
    5be6:	19 f0       	breq	.+6      	; 0x5bee <vfprintf+0x26a>
    5be8:	88 37       	cpi	r24, 0x78	; 120
    5bea:	21 f0       	breq	.+8      	; 0x5bf4 <vfprintf+0x270>
    5bec:	a9 c0       	rjmp	.+338    	; 0x5d40 <vfprintf+0x3bc>
    5bee:	e9 2f       	mov	r30, r25
    5bf0:	e0 61       	ori	r30, 0x10	; 16
    5bf2:	be 2e       	mov	r11, r30
    5bf4:	b4 fe       	sbrs	r11, 4
    5bf6:	0d c0       	rjmp	.+26     	; 0x5c12 <vfprintf+0x28e>
    5bf8:	fb 2d       	mov	r31, r11
    5bfa:	f4 60       	ori	r31, 0x04	; 4
    5bfc:	bf 2e       	mov	r11, r31
    5bfe:	09 c0       	rjmp	.+18     	; 0x5c12 <vfprintf+0x28e>
    5c00:	34 fe       	sbrs	r3, 4
    5c02:	0a c0       	rjmp	.+20     	; 0x5c18 <vfprintf+0x294>
    5c04:	29 2f       	mov	r18, r25
    5c06:	26 60       	ori	r18, 0x06	; 6
    5c08:	b2 2e       	mov	r11, r18
    5c0a:	06 c0       	rjmp	.+12     	; 0x5c18 <vfprintf+0x294>
    5c0c:	28 e0       	ldi	r18, 0x08	; 8
    5c0e:	30 e0       	ldi	r19, 0x00	; 0
    5c10:	05 c0       	rjmp	.+10     	; 0x5c1c <vfprintf+0x298>
    5c12:	20 e1       	ldi	r18, 0x10	; 16
    5c14:	30 e0       	ldi	r19, 0x00	; 0
    5c16:	02 c0       	rjmp	.+4      	; 0x5c1c <vfprintf+0x298>
    5c18:	20 e1       	ldi	r18, 0x10	; 16
    5c1a:	32 e0       	ldi	r19, 0x02	; 2
    5c1c:	f8 01       	movw	r30, r16
    5c1e:	b7 fe       	sbrs	r11, 7
    5c20:	07 c0       	rjmp	.+14     	; 0x5c30 <vfprintf+0x2ac>
    5c22:	60 81       	ld	r22, Z
    5c24:	71 81       	ldd	r23, Z+1	; 0x01
    5c26:	82 81       	ldd	r24, Z+2	; 0x02
    5c28:	93 81       	ldd	r25, Z+3	; 0x03
    5c2a:	0c 5f       	subi	r16, 0xFC	; 252
    5c2c:	1f 4f       	sbci	r17, 0xFF	; 255
    5c2e:	06 c0       	rjmp	.+12     	; 0x5c3c <vfprintf+0x2b8>
    5c30:	60 81       	ld	r22, Z
    5c32:	71 81       	ldd	r23, Z+1	; 0x01
    5c34:	80 e0       	ldi	r24, 0x00	; 0
    5c36:	90 e0       	ldi	r25, 0x00	; 0
    5c38:	0e 5f       	subi	r16, 0xFE	; 254
    5c3a:	1f 4f       	sbci	r17, 0xFF	; 255
    5c3c:	a3 01       	movw	r20, r6
    5c3e:	e6 d0       	rcall	.+460    	; 0x5e0c <__ultoa_invert>
    5c40:	88 2e       	mov	r8, r24
    5c42:	86 18       	sub	r8, r6
    5c44:	fb 2d       	mov	r31, r11
    5c46:	ff 77       	andi	r31, 0x7F	; 127
    5c48:	3f 2e       	mov	r3, r31
    5c4a:	36 fe       	sbrs	r3, 6
    5c4c:	0d c0       	rjmp	.+26     	; 0x5c68 <vfprintf+0x2e4>
    5c4e:	23 2d       	mov	r18, r3
    5c50:	2e 7f       	andi	r18, 0xFE	; 254
    5c52:	a2 2e       	mov	r10, r18
    5c54:	89 14       	cp	r8, r9
    5c56:	58 f4       	brcc	.+22     	; 0x5c6e <vfprintf+0x2ea>
    5c58:	34 fe       	sbrs	r3, 4
    5c5a:	0b c0       	rjmp	.+22     	; 0x5c72 <vfprintf+0x2ee>
    5c5c:	32 fc       	sbrc	r3, 2
    5c5e:	09 c0       	rjmp	.+18     	; 0x5c72 <vfprintf+0x2ee>
    5c60:	83 2d       	mov	r24, r3
    5c62:	8e 7e       	andi	r24, 0xEE	; 238
    5c64:	a8 2e       	mov	r10, r24
    5c66:	05 c0       	rjmp	.+10     	; 0x5c72 <vfprintf+0x2ee>
    5c68:	b8 2c       	mov	r11, r8
    5c6a:	a3 2c       	mov	r10, r3
    5c6c:	03 c0       	rjmp	.+6      	; 0x5c74 <vfprintf+0x2f0>
    5c6e:	b8 2c       	mov	r11, r8
    5c70:	01 c0       	rjmp	.+2      	; 0x5c74 <vfprintf+0x2f0>
    5c72:	b9 2c       	mov	r11, r9
    5c74:	a4 fe       	sbrs	r10, 4
    5c76:	0f c0       	rjmp	.+30     	; 0x5c96 <vfprintf+0x312>
    5c78:	fe 01       	movw	r30, r28
    5c7a:	e8 0d       	add	r30, r8
    5c7c:	f1 1d       	adc	r31, r1
    5c7e:	80 81       	ld	r24, Z
    5c80:	80 33       	cpi	r24, 0x30	; 48
    5c82:	21 f4       	brne	.+8      	; 0x5c8c <vfprintf+0x308>
    5c84:	9a 2d       	mov	r25, r10
    5c86:	99 7e       	andi	r25, 0xE9	; 233
    5c88:	a9 2e       	mov	r10, r25
    5c8a:	09 c0       	rjmp	.+18     	; 0x5c9e <vfprintf+0x31a>
    5c8c:	a2 fe       	sbrs	r10, 2
    5c8e:	06 c0       	rjmp	.+12     	; 0x5c9c <vfprintf+0x318>
    5c90:	b3 94       	inc	r11
    5c92:	b3 94       	inc	r11
    5c94:	04 c0       	rjmp	.+8      	; 0x5c9e <vfprintf+0x31a>
    5c96:	8a 2d       	mov	r24, r10
    5c98:	86 78       	andi	r24, 0x86	; 134
    5c9a:	09 f0       	breq	.+2      	; 0x5c9e <vfprintf+0x31a>
    5c9c:	b3 94       	inc	r11
    5c9e:	a3 fc       	sbrc	r10, 3
    5ca0:	10 c0       	rjmp	.+32     	; 0x5cc2 <vfprintf+0x33e>
    5ca2:	a0 fe       	sbrs	r10, 0
    5ca4:	06 c0       	rjmp	.+12     	; 0x5cb2 <vfprintf+0x32e>
    5ca6:	b2 14       	cp	r11, r2
    5ca8:	80 f4       	brcc	.+32     	; 0x5cca <vfprintf+0x346>
    5caa:	28 0c       	add	r2, r8
    5cac:	92 2c       	mov	r9, r2
    5cae:	9b 18       	sub	r9, r11
    5cb0:	0d c0       	rjmp	.+26     	; 0x5ccc <vfprintf+0x348>
    5cb2:	b2 14       	cp	r11, r2
    5cb4:	58 f4       	brcc	.+22     	; 0x5ccc <vfprintf+0x348>
    5cb6:	b6 01       	movw	r22, r12
    5cb8:	80 e2       	ldi	r24, 0x20	; 32
    5cba:	90 e0       	ldi	r25, 0x00	; 0
    5cbc:	6b d0       	rcall	.+214    	; 0x5d94 <fputc>
    5cbe:	b3 94       	inc	r11
    5cc0:	f8 cf       	rjmp	.-16     	; 0x5cb2 <vfprintf+0x32e>
    5cc2:	b2 14       	cp	r11, r2
    5cc4:	18 f4       	brcc	.+6      	; 0x5ccc <vfprintf+0x348>
    5cc6:	2b 18       	sub	r2, r11
    5cc8:	02 c0       	rjmp	.+4      	; 0x5cce <vfprintf+0x34a>
    5cca:	98 2c       	mov	r9, r8
    5ccc:	21 2c       	mov	r2, r1
    5cce:	a4 fe       	sbrs	r10, 4
    5cd0:	0f c0       	rjmp	.+30     	; 0x5cf0 <vfprintf+0x36c>
    5cd2:	b6 01       	movw	r22, r12
    5cd4:	80 e3       	ldi	r24, 0x30	; 48
    5cd6:	90 e0       	ldi	r25, 0x00	; 0
    5cd8:	5d d0       	rcall	.+186    	; 0x5d94 <fputc>
    5cda:	a2 fe       	sbrs	r10, 2
    5cdc:	16 c0       	rjmp	.+44     	; 0x5d0a <vfprintf+0x386>
    5cde:	a1 fc       	sbrc	r10, 1
    5ce0:	03 c0       	rjmp	.+6      	; 0x5ce8 <vfprintf+0x364>
    5ce2:	88 e7       	ldi	r24, 0x78	; 120
    5ce4:	90 e0       	ldi	r25, 0x00	; 0
    5ce6:	02 c0       	rjmp	.+4      	; 0x5cec <vfprintf+0x368>
    5ce8:	88 e5       	ldi	r24, 0x58	; 88
    5cea:	90 e0       	ldi	r25, 0x00	; 0
    5cec:	b6 01       	movw	r22, r12
    5cee:	0c c0       	rjmp	.+24     	; 0x5d08 <vfprintf+0x384>
    5cf0:	8a 2d       	mov	r24, r10
    5cf2:	86 78       	andi	r24, 0x86	; 134
    5cf4:	51 f0       	breq	.+20     	; 0x5d0a <vfprintf+0x386>
    5cf6:	a1 fe       	sbrs	r10, 1
    5cf8:	02 c0       	rjmp	.+4      	; 0x5cfe <vfprintf+0x37a>
    5cfa:	8b e2       	ldi	r24, 0x2B	; 43
    5cfc:	01 c0       	rjmp	.+2      	; 0x5d00 <vfprintf+0x37c>
    5cfe:	80 e2       	ldi	r24, 0x20	; 32
    5d00:	a7 fc       	sbrc	r10, 7
    5d02:	8d e2       	ldi	r24, 0x2D	; 45
    5d04:	b6 01       	movw	r22, r12
    5d06:	90 e0       	ldi	r25, 0x00	; 0
    5d08:	45 d0       	rcall	.+138    	; 0x5d94 <fputc>
    5d0a:	89 14       	cp	r8, r9
    5d0c:	30 f4       	brcc	.+12     	; 0x5d1a <vfprintf+0x396>
    5d0e:	b6 01       	movw	r22, r12
    5d10:	80 e3       	ldi	r24, 0x30	; 48
    5d12:	90 e0       	ldi	r25, 0x00	; 0
    5d14:	3f d0       	rcall	.+126    	; 0x5d94 <fputc>
    5d16:	9a 94       	dec	r9
    5d18:	f8 cf       	rjmp	.-16     	; 0x5d0a <vfprintf+0x386>
    5d1a:	8a 94       	dec	r8
    5d1c:	f3 01       	movw	r30, r6
    5d1e:	e8 0d       	add	r30, r8
    5d20:	f1 1d       	adc	r31, r1
    5d22:	80 81       	ld	r24, Z
    5d24:	b6 01       	movw	r22, r12
    5d26:	90 e0       	ldi	r25, 0x00	; 0
    5d28:	35 d0       	rcall	.+106    	; 0x5d94 <fputc>
    5d2a:	81 10       	cpse	r8, r1
    5d2c:	f6 cf       	rjmp	.-20     	; 0x5d1a <vfprintf+0x396>
    5d2e:	22 20       	and	r2, r2
    5d30:	09 f4       	brne	.+2      	; 0x5d34 <vfprintf+0x3b0>
    5d32:	4e ce       	rjmp	.-868    	; 0x59d0 <vfprintf+0x4c>
    5d34:	b6 01       	movw	r22, r12
    5d36:	80 e2       	ldi	r24, 0x20	; 32
    5d38:	90 e0       	ldi	r25, 0x00	; 0
    5d3a:	2c d0       	rcall	.+88     	; 0x5d94 <fputc>
    5d3c:	2a 94       	dec	r2
    5d3e:	f7 cf       	rjmp	.-18     	; 0x5d2e <vfprintf+0x3aa>
    5d40:	f6 01       	movw	r30, r12
    5d42:	86 81       	ldd	r24, Z+6	; 0x06
    5d44:	97 81       	ldd	r25, Z+7	; 0x07
    5d46:	02 c0       	rjmp	.+4      	; 0x5d4c <vfprintf+0x3c8>
    5d48:	8f ef       	ldi	r24, 0xFF	; 255
    5d4a:	9f ef       	ldi	r25, 0xFF	; 255
    5d4c:	2b 96       	adiw	r28, 0x0b	; 11
    5d4e:	0f b6       	in	r0, 0x3f	; 63
    5d50:	f8 94       	cli
    5d52:	de bf       	out	0x3e, r29	; 62
    5d54:	0f be       	out	0x3f, r0	; 63
    5d56:	cd bf       	out	0x3d, r28	; 61
    5d58:	df 91       	pop	r29
    5d5a:	cf 91       	pop	r28
    5d5c:	1f 91       	pop	r17
    5d5e:	0f 91       	pop	r16
    5d60:	ff 90       	pop	r15
    5d62:	ef 90       	pop	r14
    5d64:	df 90       	pop	r13
    5d66:	cf 90       	pop	r12
    5d68:	bf 90       	pop	r11
    5d6a:	af 90       	pop	r10
    5d6c:	9f 90       	pop	r9
    5d6e:	8f 90       	pop	r8
    5d70:	7f 90       	pop	r7
    5d72:	6f 90       	pop	r6
    5d74:	5f 90       	pop	r5
    5d76:	4f 90       	pop	r4
    5d78:	3f 90       	pop	r3
    5d7a:	2f 90       	pop	r2
    5d7c:	08 95       	ret

00005d7e <strnlen_P>:
    5d7e:	fc 01       	movw	r30, r24
    5d80:	05 90       	lpm	r0, Z+
    5d82:	61 50       	subi	r22, 0x01	; 1
    5d84:	70 40       	sbci	r23, 0x00	; 0
    5d86:	01 10       	cpse	r0, r1
    5d88:	d8 f7       	brcc	.-10     	; 0x5d80 <strnlen_P+0x2>
    5d8a:	80 95       	com	r24
    5d8c:	90 95       	com	r25
    5d8e:	8e 0f       	add	r24, r30
    5d90:	9f 1f       	adc	r25, r31
    5d92:	08 95       	ret

00005d94 <fputc>:
    5d94:	0f 93       	push	r16
    5d96:	1f 93       	push	r17
    5d98:	cf 93       	push	r28
    5d9a:	df 93       	push	r29
    5d9c:	fb 01       	movw	r30, r22
    5d9e:	23 81       	ldd	r18, Z+3	; 0x03
    5da0:	21 fd       	sbrc	r18, 1
    5da2:	03 c0       	rjmp	.+6      	; 0x5daa <fputc+0x16>
    5da4:	8f ef       	ldi	r24, 0xFF	; 255
    5da6:	9f ef       	ldi	r25, 0xFF	; 255
    5da8:	2c c0       	rjmp	.+88     	; 0x5e02 <fputc+0x6e>
    5daa:	22 ff       	sbrs	r18, 2
    5dac:	16 c0       	rjmp	.+44     	; 0x5dda <fputc+0x46>
    5dae:	46 81       	ldd	r20, Z+6	; 0x06
    5db0:	57 81       	ldd	r21, Z+7	; 0x07
    5db2:	24 81       	ldd	r18, Z+4	; 0x04
    5db4:	35 81       	ldd	r19, Z+5	; 0x05
    5db6:	42 17       	cp	r20, r18
    5db8:	53 07       	cpc	r21, r19
    5dba:	44 f4       	brge	.+16     	; 0x5dcc <fputc+0x38>
    5dbc:	a0 81       	ld	r26, Z
    5dbe:	b1 81       	ldd	r27, Z+1	; 0x01
    5dc0:	9d 01       	movw	r18, r26
    5dc2:	2f 5f       	subi	r18, 0xFF	; 255
    5dc4:	3f 4f       	sbci	r19, 0xFF	; 255
    5dc6:	31 83       	std	Z+1, r19	; 0x01
    5dc8:	20 83       	st	Z, r18
    5dca:	8c 93       	st	X, r24
    5dcc:	26 81       	ldd	r18, Z+6	; 0x06
    5dce:	37 81       	ldd	r19, Z+7	; 0x07
    5dd0:	2f 5f       	subi	r18, 0xFF	; 255
    5dd2:	3f 4f       	sbci	r19, 0xFF	; 255
    5dd4:	37 83       	std	Z+7, r19	; 0x07
    5dd6:	26 83       	std	Z+6, r18	; 0x06
    5dd8:	14 c0       	rjmp	.+40     	; 0x5e02 <fputc+0x6e>
    5dda:	8b 01       	movw	r16, r22
    5ddc:	ec 01       	movw	r28, r24
    5dde:	fb 01       	movw	r30, r22
    5de0:	00 84       	ldd	r0, Z+8	; 0x08
    5de2:	f1 85       	ldd	r31, Z+9	; 0x09
    5de4:	e0 2d       	mov	r30, r0
    5de6:	19 95       	eicall
    5de8:	89 2b       	or	r24, r25
    5dea:	e1 f6       	brne	.-72     	; 0x5da4 <fputc+0x10>
    5dec:	d8 01       	movw	r26, r16
    5dee:	16 96       	adiw	r26, 0x06	; 6
    5df0:	8d 91       	ld	r24, X+
    5df2:	9c 91       	ld	r25, X
    5df4:	17 97       	sbiw	r26, 0x07	; 7
    5df6:	01 96       	adiw	r24, 0x01	; 1
    5df8:	17 96       	adiw	r26, 0x07	; 7
    5dfa:	9c 93       	st	X, r25
    5dfc:	8e 93       	st	-X, r24
    5dfe:	16 97       	sbiw	r26, 0x06	; 6
    5e00:	ce 01       	movw	r24, r28
    5e02:	df 91       	pop	r29
    5e04:	cf 91       	pop	r28
    5e06:	1f 91       	pop	r17
    5e08:	0f 91       	pop	r16
    5e0a:	08 95       	ret

00005e0c <__ultoa_invert>:
    5e0c:	fa 01       	movw	r30, r20
    5e0e:	aa 27       	eor	r26, r26
    5e10:	28 30       	cpi	r18, 0x08	; 8
    5e12:	51 f1       	breq	.+84     	; 0x5e68 <__ultoa_invert+0x5c>
    5e14:	20 31       	cpi	r18, 0x10	; 16
    5e16:	81 f1       	breq	.+96     	; 0x5e78 <__ultoa_invert+0x6c>
    5e18:	e8 94       	clt
    5e1a:	6f 93       	push	r22
    5e1c:	6e 7f       	andi	r22, 0xFE	; 254
    5e1e:	6e 5f       	subi	r22, 0xFE	; 254
    5e20:	7f 4f       	sbci	r23, 0xFF	; 255
    5e22:	8f 4f       	sbci	r24, 0xFF	; 255
    5e24:	9f 4f       	sbci	r25, 0xFF	; 255
    5e26:	af 4f       	sbci	r26, 0xFF	; 255
    5e28:	b1 e0       	ldi	r27, 0x01	; 1
    5e2a:	3e d0       	rcall	.+124    	; 0x5ea8 <__ultoa_invert+0x9c>
    5e2c:	b4 e0       	ldi	r27, 0x04	; 4
    5e2e:	3c d0       	rcall	.+120    	; 0x5ea8 <__ultoa_invert+0x9c>
    5e30:	67 0f       	add	r22, r23
    5e32:	78 1f       	adc	r23, r24
    5e34:	89 1f       	adc	r24, r25
    5e36:	9a 1f       	adc	r25, r26
    5e38:	a1 1d       	adc	r26, r1
    5e3a:	68 0f       	add	r22, r24
    5e3c:	79 1f       	adc	r23, r25
    5e3e:	8a 1f       	adc	r24, r26
    5e40:	91 1d       	adc	r25, r1
    5e42:	a1 1d       	adc	r26, r1
    5e44:	6a 0f       	add	r22, r26
    5e46:	71 1d       	adc	r23, r1
    5e48:	81 1d       	adc	r24, r1
    5e4a:	91 1d       	adc	r25, r1
    5e4c:	a1 1d       	adc	r26, r1
    5e4e:	20 d0       	rcall	.+64     	; 0x5e90 <__ultoa_invert+0x84>
    5e50:	09 f4       	brne	.+2      	; 0x5e54 <__ultoa_invert+0x48>
    5e52:	68 94       	set
    5e54:	3f 91       	pop	r19
    5e56:	2a e0       	ldi	r18, 0x0A	; 10
    5e58:	26 9f       	mul	r18, r22
    5e5a:	11 24       	eor	r1, r1
    5e5c:	30 19       	sub	r19, r0
    5e5e:	30 5d       	subi	r19, 0xD0	; 208
    5e60:	31 93       	st	Z+, r19
    5e62:	de f6       	brtc	.-74     	; 0x5e1a <__ultoa_invert+0xe>
    5e64:	cf 01       	movw	r24, r30
    5e66:	08 95       	ret
    5e68:	46 2f       	mov	r20, r22
    5e6a:	47 70       	andi	r20, 0x07	; 7
    5e6c:	40 5d       	subi	r20, 0xD0	; 208
    5e6e:	41 93       	st	Z+, r20
    5e70:	b3 e0       	ldi	r27, 0x03	; 3
    5e72:	0f d0       	rcall	.+30     	; 0x5e92 <__ultoa_invert+0x86>
    5e74:	c9 f7       	brne	.-14     	; 0x5e68 <__ultoa_invert+0x5c>
    5e76:	f6 cf       	rjmp	.-20     	; 0x5e64 <__ultoa_invert+0x58>
    5e78:	46 2f       	mov	r20, r22
    5e7a:	4f 70       	andi	r20, 0x0F	; 15
    5e7c:	40 5d       	subi	r20, 0xD0	; 208
    5e7e:	4a 33       	cpi	r20, 0x3A	; 58
    5e80:	18 f0       	brcs	.+6      	; 0x5e88 <__ultoa_invert+0x7c>
    5e82:	49 5d       	subi	r20, 0xD9	; 217
    5e84:	31 fd       	sbrc	r19, 1
    5e86:	40 52       	subi	r20, 0x20	; 32
    5e88:	41 93       	st	Z+, r20
    5e8a:	02 d0       	rcall	.+4      	; 0x5e90 <__ultoa_invert+0x84>
    5e8c:	a9 f7       	brne	.-22     	; 0x5e78 <__ultoa_invert+0x6c>
    5e8e:	ea cf       	rjmp	.-44     	; 0x5e64 <__ultoa_invert+0x58>
    5e90:	b4 e0       	ldi	r27, 0x04	; 4
    5e92:	a6 95       	lsr	r26
    5e94:	97 95       	ror	r25
    5e96:	87 95       	ror	r24
    5e98:	77 95       	ror	r23
    5e9a:	67 95       	ror	r22
    5e9c:	ba 95       	dec	r27
    5e9e:	c9 f7       	brne	.-14     	; 0x5e92 <__ultoa_invert+0x86>
    5ea0:	00 97       	sbiw	r24, 0x00	; 0
    5ea2:	61 05       	cpc	r22, r1
    5ea4:	71 05       	cpc	r23, r1
    5ea6:	08 95       	ret
    5ea8:	9b 01       	movw	r18, r22
    5eaa:	ac 01       	movw	r20, r24
    5eac:	0a 2e       	mov	r0, r26
    5eae:	06 94       	lsr	r0
    5eb0:	57 95       	ror	r21
    5eb2:	47 95       	ror	r20
    5eb4:	37 95       	ror	r19
    5eb6:	27 95       	ror	r18
    5eb8:	ba 95       	dec	r27
    5eba:	c9 f7       	brne	.-14     	; 0x5eae <__ultoa_invert+0xa2>
    5ebc:	62 0f       	add	r22, r18
    5ebe:	73 1f       	adc	r23, r19
    5ec0:	84 1f       	adc	r24, r20
    5ec2:	95 1f       	adc	r25, r21
    5ec4:	a0 1d       	adc	r26, r0
    5ec6:	08 95       	ret

00005ec8 <__divmodsi4>:
    5ec8:	05 2e       	mov	r0, r21
    5eca:	97 fb       	bst	r25, 7
    5ecc:	16 f4       	brtc	.+4      	; 0x5ed2 <__divmodsi4+0xa>
    5ece:	00 94       	com	r0
    5ed0:	0f d0       	rcall	.+30     	; 0x5ef0 <__negsi2>
    5ed2:	57 fd       	sbrc	r21, 7
    5ed4:	05 d0       	rcall	.+10     	; 0x5ee0 <__divmodsi4_neg2>
    5ed6:	22 dc       	rcall	.-1980   	; 0x571c <__udivmodsi4>
    5ed8:	07 fc       	sbrc	r0, 7
    5eda:	02 d0       	rcall	.+4      	; 0x5ee0 <__divmodsi4_neg2>
    5edc:	46 f4       	brtc	.+16     	; 0x5eee <__divmodsi4_exit>
    5ede:	08 c0       	rjmp	.+16     	; 0x5ef0 <__negsi2>

00005ee0 <__divmodsi4_neg2>:
    5ee0:	50 95       	com	r21
    5ee2:	40 95       	com	r20
    5ee4:	30 95       	com	r19
    5ee6:	21 95       	neg	r18
    5ee8:	3f 4f       	sbci	r19, 0xFF	; 255
    5eea:	4f 4f       	sbci	r20, 0xFF	; 255
    5eec:	5f 4f       	sbci	r21, 0xFF	; 255

00005eee <__divmodsi4_exit>:
    5eee:	08 95       	ret

00005ef0 <__negsi2>:
    5ef0:	90 95       	com	r25
    5ef2:	80 95       	com	r24
    5ef4:	70 95       	com	r23
    5ef6:	61 95       	neg	r22
    5ef8:	7f 4f       	sbci	r23, 0xFF	; 255
    5efa:	8f 4f       	sbci	r24, 0xFF	; 255
    5efc:	9f 4f       	sbci	r25, 0xFF	; 255
    5efe:	08 95       	ret

00005f00 <__muluhisi3>:
    5f00:	37 dc       	rcall	.-1938   	; 0x5770 <__umulhisi3>
    5f02:	a5 9f       	mul	r26, r21
    5f04:	90 0d       	add	r25, r0
    5f06:	b4 9f       	mul	r27, r20
    5f08:	90 0d       	add	r25, r0
    5f0a:	a4 9f       	mul	r26, r20
    5f0c:	80 0d       	add	r24, r0
    5f0e:	91 1d       	adc	r25, r1
    5f10:	11 24       	eor	r1, r1
    5f12:	08 95       	ret

00005f14 <__mulshisi3>:
    5f14:	b7 ff       	sbrs	r27, 7
    5f16:	f4 cf       	rjmp	.-24     	; 0x5f00 <__muluhisi3>

00005f18 <__mulohisi3>:
    5f18:	f3 df       	rcall	.-26     	; 0x5f00 <__muluhisi3>
    5f1a:	82 1b       	sub	r24, r18
    5f1c:	93 0b       	sbc	r25, r19
    5f1e:	08 95       	ret

00005f20 <_exit>:
    5f20:	f8 94       	cli

00005f22 <__stop_program>:
    5f22:	ff cf       	rjmp	.-2      	; 0x5f22 <__stop_program>
